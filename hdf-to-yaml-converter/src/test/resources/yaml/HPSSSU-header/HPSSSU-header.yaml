---
connector:
  detection:
    criteria:
    # SSSU should exist and be in Path
    - type: osCommand
      commandLine: sssu help
      errorMessage: SSSU Does not appear to be installed on this system
      expectedResult: SSSU for HP
      executeLocally: true
    # SSSU Should be able to connect and list systems
    - type: osCommand
      commandLine: "sssu \"SELECT Manager %{HOSTNAME} username=%{USERNAME} password=%{PASSWORD}\" \"LS SYSTEM\""
      errorMessage: Unable to connect using SSSU
      expectedResult: Systems available on this Manager
      executeLocally: true
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          computes:
          # Process the sssu command throug an AWK script
          - type: awk
            script: "${file::embeddedFile-2}"
            keep: ^MSHW
            separators: ;
        source(2):
          # Enclosure Source 2 = Copy of Source 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Keep only Enclosures
            # MS_HW_Enclosure;ID;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_ENCLOSURE$
      mapping:
        # The discovery table
        # MS_HW_Enclosure;ID;
        source: "${source::monitors.enclosure.discovery.sources.source(2)}"
        attributes:
          id: $2
          __display_id: $2
          type: DiskSystem
          model: EVA System
          vendor: HP
          name: "${awk::sprintf(\"Enclosure: %s (%s %s)\", $2, \"HP\", \"EVA System\")}"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          computes:
          # Process the sssu command throug an AWK script
          - type: awk
            script: "${file::embeddedFile-2}"
            keep: ^MSHW
            separators: ;
      mapping:
        # The value table (taken from enclosure.discovery, since we don't actually want to collect anything.
        source: "${source::monitors.enclosure.discovery.sources.source(2)}"
        deviceId: $2
  blade:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Keep only DiskControllers
            # MSHW_BLADE;Enclosure;DeviceID;Name;Status;Status Information;Model Number;Serial Number;WWN;Location
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_BLADE$
      mapping:
        # The discovery table
        # MSHW_BLADE;Enclosure;DeviceID;Name;Status;Status Information;Model Number;Serial Number;WWN;Location
        source: "${source::monitors.blade.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          model: $7
          serial_number: $8
          blade_name: $4
          info: "${awk::join(\" \", $10, $9, \"Type: SAN Controller\")}"
          hw.parent.type: DiskSystem
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s (%s - %s)\", $4, $4, $7)}"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep only DiskControllers
            # MSHW_BLADE;Enclosure;Location;Name;Status;Status Information;Model Number;Serial Number;WWN;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_BLADE$
            # Now translate  into OK/Warning/Alarm
            # MSHW_BLADE;Enclosure;Location;Name;Status;Status Information;Model Number;Serial Number;WWN;
          - type: translate
            column: 5
            translationTable: "${translation::opStatusTT}"
            # Now translate Status information
            # MSHW_BLADE;Enclosure;Location;Name;Status;Status Information;Model Number;Serial Number;WWN;
          - type: translate
            column: 6
            translationTable: "${translation::opStatusInfoTT}"
      mapping:
        # The value table
        source: "${source::monitors.blade.collect.sources.source(1)}"
        deviceId: $3
        metrics:
          hw.status{hw.type="blade"}: $5
        legacyTextParameters:
          StatusInformation: $6
  fan:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Keep only Fans
            # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;Speed;DeviceID;InstallStatus;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_FAN$
            # Exclude fans not installed
            # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;Speed;DeviceID;InstallStatus;SystemName;
          - type: excludeMatchingLines
            column: 7
            valueList: "no"
          - type: translate
            column: 4
            translationTable: "${translation::opStatusTT}"
          - type: excludeMatchingLines
            column: 4
            valueList: MISSING
      mapping:
        # The discovery table
        # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;Speed;DeviceID;InstallStatus;SystemName;
        source: "${source::monitors.fan.discovery.sources.source(1)}"
        attributes:
          id: $6
          __display_id: $6
          hw.parent.type: blade
          hw.parent.id: $2
          name: $6
        conditionalCollection:
          hw.fan.speed: $5
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep only DiskControllers
            # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;Speed;DeviceID;InstallStatus;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_FAN$
            # duplicate for status information
            # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;statusinfo;Speed;DeviceID;InstallStatus;SystemName;
          - type: duplicateColumn
            column: 4
            # Now translate  status information
            # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;statusinfo;Speed;DeviceID;InstallStatus;SystemName;
          - type: translate
            column: 5
            translationTable: "${translation::opStatusInfoTT}"
          - type: translate
            column: 4
            translationTable: "${translation::opStatusTT}"
      mapping:
        # The value table
        # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;Speed;DeviceID;InstallStatus;SystemName;
        source: "${source::monitors.fan.collect.sources.source(1)}"
        deviceId: $7
        metrics:
          hw.status{hw.type="fan"}: $4
          hw.fan.speed: $6
        legacyTextParameters:
          StatusInformation: $5
  battery:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Keep only Batterys
            # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_Battery$
            # Exclude Batterys not installed
            # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
          - type: excludeMatchingLines
            column: 4
            valueList: "not installed,not_installed,not present,not_present,notinstalled,notpresent,Not Present"
      mapping:
        # The discovery table
        # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
        source: "${source::monitors.battery.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $3
          type: $6
          hw.parent.type: blade
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s (%s)\", $3, $6)}"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep only DiskControllers
            # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_Battery$
            # Now translate  into OK/Warning/Alarm
            # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
          - type: translate
            column: 4
            translationTable: "${translation::opStatusTT}"
            # Now translate Status information
            # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
          - type: translate
            column: 5
            translationTable: "${translation::opStatusInfoTT}"
      mapping:
        # The value table
        # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
        source: "${source::monitors.battery.collect.sources.source(1)}"
        deviceId: $3
        metrics:
          hw.status{hw.type="battery"}: $4
        legacyTextParameters:
          StatusInformation: $5
  logical_disk:
    discovery:
      sources:
        source(1):
          computes:
            # Awk it and keep only LogicalDisks
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: awk
            script: "${file::embeddedFile-2}"
            keep: ^MSHW_LOGICALDISK
            separators: ;
            # Exclude Snapshots
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: excludeMatchingLines
            column: 10
            valueList: "Demand-allocated Snapshot,Fully-allocated Snapshot,SnapClone"
            # Convert Size from Gbytes to bytes
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: multiply
            column: 8
            value: 1073741824
        source(2):
          # Get the Enclosure Discovery for the Primordial Array
          # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Keep only the Primordials
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_LOGICALDISK$
        source(3):
          # Union the main logical disk discovery with the Primordials
          # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          type: tableUnion
          tables:
          - "${source::monitors.logical_disk.discovery.sources.source(1)}"
          - "${source::monitors.logical_disk.discovery.sources.source(2)}"
      mapping:
        # The discovery table
        # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
        source: "${source::monitors.logical_disk.discovery.sources.source(3)}"
        attributes:
          id: $4
          __display_id: $5
          type: $3
          __use_for_capacity_report: $11
          info: $10
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s (%s)\", $5, bytes2HumanFormatBase2($8))}"
        metrics:
          hw.logical_disk.limit: $8
        conditionalCollection:
          hw.logical_disk.usage{state="free"}: $9
          hw.status{hw.type="logical_disk"}: $6
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          computes:
            # Awk it and keep only LogicalDisks
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: awk
            script: "${file::embeddedFile-2}"
            keep: ^MSHW_LOGICALDISK
            separators: ;
            # Now translate  into OK/Warning/Alarm
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: translate
            column: 6
            translationTable: "${translation::opStatusTT}"
            # Now translate Status information
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: translate
            column: 7
            translationTable: "${translation::opStatusInfoTT}"
            # Convert Unallocated Space from Gbytes to bytes
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: multiply
            column: 9
            value: 1073741824
        source(2):
          # Get the Enclosure Discovery for the Primordial Array
          # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep only the Primordials
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_LOGICALDISK$
        source(3):
          # Union the main logical disk discovery with the Primordials
          # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          type: tableUnion
          tables:
          - "${source::monitors.logical_disk.collect.sources.source(1)}"
          - "${source::monitors.logical_disk.collect.sources.source(2)}"
      mapping:
        # The value table
        # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
        source: "${source::monitors.logical_disk.collect.sources.source(3)}"
        deviceId: $4
        metrics:
          hw.status{hw.type="logical_disk"}: $6
          hw.logical_disk.usage{state="free"}: $9
          hw.logical_disk.usage{state="used"}: collectAllocatedSpace()
        legacyTextParameters:
          StatusInformation: $7
  memory:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Keep only Memorys
            # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_MEMORY$
          # exclude not installed
          - type: excludeMatchingLines
            column: 5
            valueList: "not installed,not_installed,not present,not_present,notinstalled,notpresent,Not Present"
      mapping:
        # The discovery table
        # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;SystemName;
        source: "${source::monitors.memory.discovery.sources.source(1)}"
        attributes:
          id: $4
          type: $3
          hw.parent.type: blade
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s (%s)\", $4, $3)}"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep only DiskControllers
            # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_MEMORY$
            # Duplicate Status Column
            # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;StatusInfo;SystemName;
          - type: duplicateColumn
            column: 5
            # Now translate  into OK/Warning/Alarm
            # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;StatusInfo;SystemName;
          - type: translate
            column: 5
            translationTable: "${translation::opStatusTT}"
            # Translate Status info
            # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;StatusInfo;SystemName;
          - type: translate
            column: 6
            translationTable: "${translation::cacheStatusInfoTT}"
      mapping:
        # The value table
        # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;SystemName;
        source: "${source::monitors.memory.collect.sources.source(1)}"
        deviceId: $4
        metrics:
          hw.status{hw.type="memory"}: $5
        legacyTextParameters:
          StatusInformation: $6
  network:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Keep only NetworkCards
            # MSHW_NETWORKCARD;Enclosure;NcType(hostport);Name;WWN;Status;Speed Mbit;LinkStatus;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_NETWORKCARD$
          # exclude not installed
          - type: excludeMatchingLines
            column: 6
            valueList: "not installed,not_installed,not present,not_present,notinstalled,notpresent,Not Present"
      mapping:
        # The discovery table
        # MSHW_NETWORKCARD;Enclosure;NcType(hostport);Name;WWN;Status;Speed Mbit;LinkStatus;SystemName;
        source: "${source::monitors.network.discovery.sources.source(1)}"
        attributes:
          id: $4
          __display_id: $4
          physical_address: $5
          physical_address_type: WWN
          hw.parent.type: blade
          hw.parent.id: $2
          name: $4
        conditionalCollection:
          hw.network.bandwidth.limit: megaBit2Bit($7)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep only DiskControllers
            # MSHW_NETWORKCARD;Enclosure;NcType(hostport);Name;WWN;Status;Speed Mbit;LinkStatus;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_NetworkCard$
            # Now translate  into OK/Warning/Alarm
            # MSHW_NETWORKCARD;Enclosure;NcType(hostport);Name;WWN;Status;Speed Mbit;LinkStatus;SystemName;
          - type: translate
            column: 6
            translationTable: "${translation::opStatusTT}"
            # Now translate  into OK/Warning/Alarm
            # MSHW_NETWORKCARD;Enclosure;NcType(hostport);Name;WWN;Status;Speed Mbit;LinkStatus;SystemName;
          - type: translate
            column: 8
            translationTable: "${translation::linkStatusTT}"
      mapping:
        # The value table
        # MSHW_NETWORKCARD;Enclosure;NcType(hostport);Name;WWN;Status;Speed Mbit;LinkStatus; SystemName;
        source: "${source::monitors.network.collect.sources.source(1)}"
        deviceId: $4
        metrics:
          hw.network.bandwidth.limit: megaBit2Bit($7)
          hw.network.up: legacyLinkStatus($8)
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Keep only PhysicalDisks
            # MSHW_DISK;Shelf;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_DISK$
            # Convert Size from Gbytes to bytes
            # MSHW_DISK;Shelf;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
          - type: multiply
            column: 9
            value: 1000000000
        source(2):
          # Source(2) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Keep only PhysicalDisks
            # MSHW_DISK_TO_BLADE_TABLE;Enclosure;Shelf;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_DISK_TO_BLADE_TABLE$
        source(3):
          # Table joint of (1) and (2)
          # as disks can ony be allocated to shelves where we need Enclosure
          # MSHW_DISK;Shelf;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;Location;MSHW_DISK_TO_BLADE_TABLE;Enclosure;Shelf;
          type: tableJoin
          leftTable: "${source::monitors.physical_disk.discovery.sources.source(1)}"
          rightTable: "${source::monitors.physical_disk.discovery.sources.source(2)}"
          leftKeyColumn: 2
          rightKeyColumn: 3
          defaultRightLine: ;;;
          computes:
          # exclude not installed
          - type: excludeMatchingLines
            column: 5
            valueList: "not installed,not_installed,not present,not_present,notinstalled,notpresent,Not Present"
      mapping:
        # The discovery table\n    1         2         3     4     5           6                 7              8         9            10         11     12    13              14        15            16             17     18        19       \t\t\t\t\t\t\t20      21\nMSHW_DISK;Shelf;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;Location;MSHW_DISK_TO_BLADE_TABLE;Enclosure;Shelf;
        source: "${source::monitors.physical_disk.discovery.sources.source(3)}"
        attributes:
          id: $3
          __display_id: $7
          vendor: $11
          model: $12
          serial_number: $15
          firmware_version: $13
          info: "${awk::join(\" \", $18, $14, $16)}"
          hw.parent.type: blade
          hw.parent.id: $20
          name: "${awk::sprintf(\"%s (%s - %s)\", $7, $11, bytes2HumanFormatBase10($9))}"
        metrics:
          hw.physical_disk.size: $9
        conditionalCollection:
          hw.status{hw.type="physical_disk", state="predicted_failure"}: boolean($10)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep only DiskControllers
            # MSHW_DISK;Enclosure;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_DISK$
            # Now translate  into OK/Warning/Alarm
            # MSHW_DISK;Enclosure;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
          - type: translate
            column: 5
            translationTable: "${translation::opStatusTT}"
            # Now translate Status information
            # MSHW_DISK;Enclosure;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
          - type: translate
            column: 6
            translationTable: "${translation::opStatusInfoTT}"
            # Now translate  into OK/Warning/Alarm
            # MSHW_DISK;Enclosure;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
          - type: translate
            column: 10
            translationTable: "${translation::predictedFailureTT}"
      mapping:
        # The value table
        #     1         2         3     4     5        #  6        #        7        #     8         9        #   10         11     12    13        #     14        15        #   16        ;
        # MSHW_DISK;Enclosure;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
        source: "${source::monitors.physical_disk.collect.sources.source(1)}"
        deviceId: $3
        metrics:
          hw.status{hw.type="physical_disk"}: $5
          hw.status{hw.type="physical_disk", state="predicted_failure"}: boolean($10)
        legacyTextParameters:
          StatusInformation: $6
  power_supply:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Keep only PowerSupplys
            # MSHW_PSU; Enclosure ;Name - (Controller Name - PSU Name);   Status       ;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PSU$
            # Exclude PowerSupplys not installed
            # MSHW_PSU; Enclosure ;Name - (Controller Name - PSU Name);   Status       ;SystemName;
          - type: excludeMatchingLines
            column: 4
            valueList: "not installed,not_installed,not present,not_present,notinstalled,notpresent,Not Present"
      mapping:
        # The discovery table
        # MSHW_PSU; Enclosure ;Name - (Controller Name - PSU Name);   Status       ;SystemName;
        source: "${source::monitors.power_supply.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $3
          hw.parent.type: blade
          hw.parent.id: $2
          name: $3
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep only DiskControllers
            # MSHW_PSU; Enclosure ;Name - (Controller Name - PSU Name);   Status       ;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PSU$
            # Now translate  into OK/Warning/Alarm
            # MSHW_PSU; Enclosure ;Name - (Controller Name - PSU Name);   Status       ;SystemName;
          - type: translate
            column: 4
            translationTable: "${translation::opStatusTT}"
      mapping:
        # The value table
        # MSHW_PSU; Enclosure ;Name - (Controller Name - PSU Name);   Status       ;SystemName;
        source: "${source::monitors.power_supply.collect.sources.source(1)}"
        deviceId: $3
        metrics:
          hw.status{hw.type="power_supply"}: $4
  temperature:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Keep only Temperatures
            # MSHW_TEMP;Enclosure;Name;Temperature;Status;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_TEMP$
      mapping:
        # The discovery table
        # MSHW_TEMP;Enclosure;Name;Temperature;Status;SystemName;
        source: "${source::monitors.temperature.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $3
          hw.parent.type: blade
          hw.parent.id: $2
          name: $3
        conditionalCollection:
          hw.status{hw.type="temperature"}: $5
          hw.temperature: $4
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep only DiskControllers
            # MSHW_TEMP;Enclosure;Name;Temperature;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_TEMP$
            # Now translate  into OK/Warning/Alarm
            # MSHW_TEMP;Enclosure;Name;Temperature;Status;
          - type: translate
            column: 5
            translationTable: "${translation::opStatusTT}"
      mapping:
        # The value table
        # MSHW_TEMP;Enclosure;Name;Temperature;Status;
        source: "${source::monitors.temperature.collect.sources.source(1)}"
        deviceId: $3
        metrics:
          hw.status{hw.type="temperature"}: $5
          hw.temperature: $4
  other_device:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Keep only Temperatures
            # MSWH_OTHERDEVICE;Enclosure;Type;Name;OpState;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHERDEVICE$
          # Exclude not installed
          - type: excludeMatchingLines
            column: 5
            valueList: "not installed,not_installed,not present,not_present,notinstalled,notpresent,Not Present"
      mapping:
        # The discovery table
        # MSWH_OTHERDEVICE;Enclosure;Type;Name;OpState;SystemName;
        source: "${source::monitors.other_device.discovery.sources.source(1)}"
        attributes:
          device_type: $3
          id: $4
          __display_id: $4
          hw.parent.type: blade
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s: %s\", $3, $4)}"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          # MSWH_OTHERDEVICE;Enclosure;Type;Name;OpState;SystemName;
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep only Other Devices
            # MSWH_OTHERDEVICE;Enclosure;Type;Name;OpState;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHERDEVICE$
            # Now translate  into OK/Warning/Alarm
            # MSWH_OTHERDEVICE;Enclosure;Type;Name;OpState;opState;SystemName;
          - type: duplicateColumn
            column: 5
            # Now translate  into OK/Warning/Alarm
            # MSWH_OTHERDEVICE;Enclosure;Type;Name;status;OpState;SystemName;
          - type: translate
            column: 5
            translationTable: "${translation::opStatusTT}"
      mapping:
        # The value table
        # MSWH_OTHERDEVICE;Enclosure;Type;Name;status;OpState;SystemName;
        source: "${source::monitors.other_device.collect.sources.source(1)}"
        deviceId: $4
        metrics:
          hw.status{hw.type="other_device"}: $5
        legacyTextParameters:
          StatusInformation: $6
translations:
  linkStatusTT:
    fabric_login: ok
    bad: degraded
    good: ok
    link_up: ok
    link_down: degraded
  opStatusInfoTT:
    sc_locked: SC Locked
    emu_unknown: Environmental Monitoring Unit Unknow Error
    notinstalled: Not installed
    DiskenclosureWarn: Not Present
    contains_ilf_disk: 'Contains '
    initialized_ok: ""
    emu_critical: Environmental Monitoring Unit Critical
    initialized_unknown: ""
    non_member_attention: Non Member Error
    uninitialized_attention: Uninitialized
    uninitialized_ok: Unintialized
    emu_ok: ""
    emu_information: ""
    member_ok: ""
    not present: Not Present
    suspended_ok: Suspended
    not_redundant_attention: Not Redundant
    not_available: Not Available
    member_failed: Member Failed
    not installed: Not installed
    initialized_attention: Initialization Error
    not_redundant_failed: Not Redundant
    restoring_ok: Restoring
    restoring_failed: Restoring Failed
    asynch_member_add_in_progress: ok
    emu_non_critical: Environmental Monitoring Unit Warning
    notpresent: Not Present
    diskgroup_degraded: Diskgroup Degraded
    emu_not_available: Environmental Monitoring Unit Not Available
    management_module_installed: ok
    suspended_attention: Suspended Error
    unknown: Unknown
    restoring_attention: Restoring Error
    emu_unrecoverable: Environmental Monitoring Unit Unrecoverable Error
    managed_by_other_agent: Managed by Other Agent
    unsupported: Unsupported
    member_attention: Member Error
    initialized_failed: Initialization Failed
    suspended_failed: Suspended Failed
    non_member_failed: Non Member Failed
    not_redundant_ok: ""
    management_module_not_installed: Management Module Not Installed
    non_member_ok: ""
    emu_unsupported: Environmental Monitoring Unit Unsupported
    not_present: Not Present
    uninitialized_failed: Uninitialized
    firmware_upgrade: Firmware Upgrade
    not_installed: Not installed
    asynch_member_remove_in_progress: ok
  cacheStatusInfoTT:
    no_mirror: No Mirror
    Default: ""
  predictedFailureTT:
    "no": "false"
    "yes": "true"
  opStatusTT:
    Not Present: MISSING
    normal: ok
    not present: MISSING
    notpresent: MISSING
    bad: failed
    notinstalled: MISSING
    no_mirror: degraded
    failed: failed
    DiskenclosureWarn: degraded
    good: ok
    Default: UNKNOWN
    not installed: MISSING
    attention: degraded
    not_present: MISSING
    not_installed: MISSING
