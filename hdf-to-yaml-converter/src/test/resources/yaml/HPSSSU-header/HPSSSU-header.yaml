---
connector:
  detection:
    criteria:
    # SSSU should exist and be in Path
    - type: osCommand
      commandLine: sssu help
      errorMessage: SSSU Does not appear to be installed on this system
      expectedResult: SSSU for HP
      executeLocally: true
    # SSSU Should be able to connect and list systems
    - type: osCommand
      commandLine: "sssu \"SELECT Manager %{HOSTNAME} username=%{USERNAME} password=%{PASSWORD}\" \"LS SYSTEM\""
      errorMessage: Unable to connect using SSSU
      expectedResult: Systems available on this Manager
      executeLocally: true
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          computes:
          # Process the sssu command throug an AWK script
          - type: awk
            script: $file("embeddedFile-2")$
            keep: ^MSHW
            separators: ;
        source(2):
          # Enclosure Source 2 = Copy of Source 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only Enclosures
            # MS_HW_Enclosure;ID;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_ENCLOSURE$
      mapping:
        # The discovery table
        # MS_HW_Enclosure;ID;
        source: $monitors.enclosure.discovery.sources.source(2)$
        attributes:
          id: $column(2)
          __display_id: $column(2)
          type: DiskSystem
          model: EVA System
          vendor: HP
          name: "sprintf(\"Enclosure: %s (%s %s)\", $column(2), \"HP\", \"EVA System\")"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          computes:
          # Process the sssu command throug an AWK script
          - type: awk
            script: $file("embeddedFile-2")$
            keep: ^MSHW
            separators: ;
      mapping:
        # The value table (taken from enclosure.discovery, since we don't actually want to collect anything.
        source: $monitors.enclosure.discovery.sources.source(2)$
        deviceId: $column(2)
  blade:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only DiskControllers
            # MSHW_BLADE;Enclosure;DeviceID;Name;Status;Status Information;Model Number;Serial Number;WWN;Location
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_BLADE$
      mapping:
        # The discovery table
        # MSHW_BLADE;Enclosure;DeviceID;Name;Status;Status Information;Model Number;Serial Number;WWN;Location
        source: $monitors.blade.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(4)
          model: $column(7)
          serial_number: $column(8)
          blade_name: $column(4)
          info: "join($column(10), $column(9), \"Type: SAN Controller\", \" \")"
          hw.parent.type: DiskSystem
          hw.parent.id: $column(2)
          name: "sprintf(\"%s (%s - %s)\", $column(4), $column(4), $column(7))"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only DiskControllers
            # MSHW_BLADE;Enclosure;Location;Name;Status;Status Information;Model Number;Serial Number;WWN;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_BLADE$
            # Now translate  into OK/Warning/Alarm
            # MSHW_BLADE;Enclosure;Location;Name;Status;Status Information;Model Number;Serial Number;WWN;
          - type: translate
            column: 5
            translationTable: opStatusTT
            # Now translate Status information
            # MSHW_BLADE;Enclosure;Location;Name;Status;Status Information;Model Number;Serial Number;WWN;
          - type: translate
            column: 6
            translationTable: opStatusInfoTT
      mapping:
        # The value table
        source: $monitors.blade.collect.sources.source(1)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="blade"}: $column(5)
        legacyTextParameters:
          StatusInformation: $column(6)
  fan:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only Fans
            # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;Speed;DeviceID;InstallStatus;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_FAN$
            # Exclude fans not installed
            # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;Speed;DeviceID;InstallStatus;SystemName;
          - type: excludeMatchingLines
            column: 7
            valueList: "no"
          - type: translate
            column: 4
            translationTable: opStatusTT
          - type: excludeMatchingLines
            column: 4
            valueList: MISSING
      mapping:
        # The discovery table
        # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;Speed;DeviceID;InstallStatus;SystemName;
        source: $monitors.fan.discovery.sources.source(1)$
        attributes:
          id: $column(6)
          __display_id: $column(6)
          hw.parent.type: blade
          hw.parent.id: $column(2)
          name: $column(6)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only DiskControllers
            # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;Speed;DeviceID;InstallStatus;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_FAN$
            # duplicate for status information
            # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;statusinfo;Speed;DeviceID;InstallStatus;SystemName;
          - type: duplicateColumn
            column: 4
            # Now translate  status information
            # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;statusinfo;Speed;DeviceID;InstallStatus;SystemName;
          - type: translate
            column: 5
            translationTable: opStatusInfoTT
          - type: translate
            column: 4
            translationTable: opStatusTT
      mapping:
        # The value table
        # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;Speed;DeviceID;InstallStatus;SystemName;
        source: $monitors.fan.collect.sources.source(1)$
        deviceId: $column(7)
        metrics:
          hw.status{hw.type="fan"}: $column(4)
          hw.fan.speed: $column(6)
        legacyTextParameters:
          StatusInformation: $column(5)
  battery:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only Batterys
            # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_Battery$
            # Exclude Batterys not installed
            # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
          - type: excludeMatchingLines
            column: 4
            valueList: "not installed,not_installed,not present,not_present,notinstalled,notpresent,Not Present"
      mapping:
        # The discovery table
        # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
        source: $monitors.battery.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(3)
          type: $column(6)
          hw.parent.type: blade
          hw.parent.id: $column(2)
          name: "sprintf(\"%s (%s)\", $column(3), $column(6))"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only DiskControllers
            # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_Battery$
            # Now translate  into OK/Warning/Alarm
            # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
          - type: translate
            column: 4
            translationTable: opStatusTT
            # Now translate Status information
            # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
          - type: translate
            column: 5
            translationTable: opStatusInfoTT
      mapping:
        # The value table
        # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
        source: $monitors.battery.collect.sources.source(1)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="battery"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(5)
  logical_disk:
    discovery:
      sources:
        source(1):
          computes:
            # Awk it and keep only LogicalDisks
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: awk
            script: $file("embeddedFile-2")$
            keep: ^MSHW_LOGICALDISK
            separators: ;
            # Exclude Snapshots
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: excludeMatchingLines
            column: 10
            valueList: "Demand-allocated Snapshot,Fully-allocated Snapshot,SnapClone"
            # Convert Size from Gbytes to bytes
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: multiply
            column: 8
            value: 1073741824
        source(2):
          # Get the Enclosure Discovery for the Primordial Array
          # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only the Primordials
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_LOGICALDISK$
        source(3):
          # Union the main logical disk discovery with the Primordials
          # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          type: tableUnion
          tables:
          - $monitors.logical_disk.discovery.sources.source(1)$
          - $monitors.logical_disk.discovery.sources.source(2)$
      mapping:
        # The discovery table
        # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
        source: $monitors.logical_disk.discovery.sources.source(3)$
        attributes:
          id: $column(4)
          __display_id: $column(5)
          type: $column(3)
          __use_for_capacity_report: $column(11)
          info: $column(10)
          hw.parent.type: enclosure
          hw.parent.id: $column(2)
          name: "sprintf(\"%s (%by2hf.s)\", $column(5), $column(8))"
        metrics:
          hw.logical_disk.limit: $column(8)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          computes:
            # Awk it and keep only LogicalDisks
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: awk
            script: $file("embeddedFile-2")$
            keep: ^MSHW_LOGICALDISK
            separators: ;
            # Now translate  into OK/Warning/Alarm
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: translate
            column: 6
            translationTable: opStatusTT
            # Now translate Status information
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: translate
            column: 7
            translationTable: opStatusInfoTT
            # Convert Unallocated Space from Gbytes to bytes
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: multiply
            column: 9
            value: 1073741824
        source(2):
          # Get the Enclosure Discovery for the Primordial Array
          # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only the Primordials
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_LOGICALDISK$
        source(3):
          # Union the main logical disk discovery with the Primordials
          # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          type: tableUnion
          tables:
          - $monitors.logical_disk.collect.sources.source(1)$
          - $monitors.logical_disk.collect.sources.source(2)$
      mapping:
        # The value table
        # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
        source: $monitors.logical_disk.collect.sources.source(3)$
        deviceId: $column(4)
        metrics:
          hw.status{hw.type="logical_disk"}: $column(6)
          hw.logical_disk.usage{state="free"}: $column(9)
          hw.logical_disk.usage{state="used"}: collectAllocatedSpace()
        legacyTextParameters:
          StatusInformation: $column(7)
  memory:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only Memorys
            # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_MEMORY$
          # exclude not installed
          - type: excludeMatchingLines
            column: 5
            valueList: "not installed,not_installed,not present,not_present,notinstalled,notpresent,Not Present"
      mapping:
        # The discovery table
        # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;SystemName;
        source: $monitors.memory.discovery.sources.source(1)$
        attributes:
          id: $column(4)
          type: $column(3)
          hw.parent.type: blade
          hw.parent.id: $column(2)
          name: "sprintf(\"%s (%s)\", $column(4), $column(3))"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only DiskControllers
            # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_MEMORY$
            # Duplicate Status Column
            # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;StatusInfo;SystemName;
          - type: duplicateColumn
            column: 5
            # Now translate  into OK/Warning/Alarm
            # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;StatusInfo;SystemName;
          - type: translate
            column: 5
            translationTable: opStatusTT
            # Translate Status info
            # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;StatusInfo;SystemName;
          - type: translate
            column: 6
            translationTable: cacheStatusInfoTT
      mapping:
        # The value table
        # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;SystemName;
        source: $monitors.memory.collect.sources.source(1)$
        deviceId: $column(4)
        metrics:
          hw.status{hw.type="memory"}: $column(5)
        legacyTextParameters:
          StatusInformation: $column(6)
  network:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only NetworkCards
            # MSHW_NETWORKCARD;Enclosure;NcType(hostport);Name;WWN;Status;Speed Mbit;LinkStatus;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_NETWORKCARD$
          # exclude not installed
          - type: excludeMatchingLines
            column: 6
            valueList: "not installed,not_installed,not present,not_present,notinstalled,notpresent,Not Present"
      mapping:
        # The discovery table
        # MSHW_NETWORKCARD;Enclosure;NcType(hostport);Name;WWN;Status;Speed Mbit;LinkStatus;SystemName;
        source: $monitors.network.discovery.sources.source(1)$
        attributes:
          id: $column(4)
          __display_id: $column(4)
          physical_address: $column(5)
          physical_address_type: WWN
          hw.parent.type: blade
          hw.parent.id: $column(2)
          name: $column(4)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only DiskControllers
            # MSHW_NETWORKCARD;Enclosure;NcType(hostport);Name;WWN;Status;Speed Mbit;LinkStatus;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_NetworkCard$
            # Now translate  into OK/Warning/Alarm
            # MSHW_NETWORKCARD;Enclosure;NcType(hostport);Name;WWN;Status;Speed Mbit;LinkStatus;SystemName;
          - type: translate
            column: 6
            translationTable: opStatusTT
            # Now translate  into OK/Warning/Alarm
            # MSHW_NETWORKCARD;Enclosure;NcType(hostport);Name;WWN;Status;Speed Mbit;LinkStatus;SystemName;
          - type: translate
            column: 8
            translationTable: linkStatusTT
      mapping:
        # The value table
        # MSHW_NETWORKCARD;Enclosure;NcType(hostport);Name;WWN;Status;Speed Mbit;LinkStatus; SystemName;
        source: $monitors.network.collect.sources.source(1)$
        deviceId: $column(4)
        metrics:
          hw.network.bandwidth.limit: megaBit2Bit($column(7))
          hw.network.up: legacyLinkStatus($column(8))
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only PhysicalDisks
            # MSHW_DISK;Shelf;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_DISK$
            # Convert Size from Gbytes to bytes
            # MSHW_DISK;Shelf;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
          - type: multiply
            column: 9
            value: 1000000000
        source(2):
          # Source(2) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only PhysicalDisks
            # MSHW_DISK_TO_BLADE_TABLE;Enclosure;Shelf;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_DISK_TO_BLADE_TABLE$
        source(3):
          # Table joint of (1) and (2)
          # as disks can ony be allocated to shelves where we need Enclosure
          # MSHW_DISK;Shelf;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;Location;MSHW_DISK_TO_BLADE_TABLE;Enclosure;Shelf;
          type: tableJoin
          leftTable: $monitors.physical_disk.discovery.sources.source(1)$
          rightTable: $monitors.physical_disk.discovery.sources.source(2)$
          leftKeyColumn: 2
          rightKeyColumn: 3
          defaultRightLine: ;;;
          computes:
          # exclude not installed
          - type: excludeMatchingLines
            column: 5
            valueList: "not installed,not_installed,not present,not_present,notinstalled,notpresent,Not Present"
      mapping:
        # The discovery table\n    1         2         3     4     5           6                 7              8         9            10         11     12    13              14        15            16             17     18        19       \t\t\t\t\t\t\t20      21\nMSHW_DISK;Shelf;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;Location;MSHW_DISK_TO_BLADE_TABLE;Enclosure;Shelf;
        source: $monitors.physical_disk.discovery.sources.source(3)$
        attributes:
          id: $column(3)
          __display_id: $column(7)
          vendor: $column(11)
          model: $column(12)
          serial_number: $column(15)
          firmware_version: $column(13)
          info: "join($column(18), $column(14), $column(16), \" \")"
          hw.parent.type: blade
          hw.parent.id: $column(20)
          name: "sprintf(\"%s (%s - %by10hf.s)\", $column(7), $column(11), $column(9))"
        metrics:
          hw.physical_disk.size: $column(9)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only DiskControllers
            # MSHW_DISK;Enclosure;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_DISK$
            # Now translate  into OK/Warning/Alarm
            # MSHW_DISK;Enclosure;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
          - type: translate
            column: 5
            translationTable: opStatusTT
            # Now translate Status information
            # MSHW_DISK;Enclosure;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
          - type: translate
            column: 6
            translationTable: opStatusInfoTT
            # Now translate  into OK/Warning/Alarm
            # MSHW_DISK;Enclosure;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
          - type: translate
            column: 10
            translationTable: predictedFailureTT
      mapping:
        # The value table
        #     1         2         3     4     5        #  6        #        7        #     8         9        #   10         11     12    13        #     14        15        #   16        ;
        # MSHW_DISK;Enclosure;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
        source: $monitors.physical_disk.collect.sources.source(1)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="physical_disk"}: $column(5)
          hw.status{hw.type="physical_disk", state="predicted_failure"}: boolean($column(10))
        legacyTextParameters:
          StatusInformation: $column(6)
  power_supply:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only PowerSupplys
            # MSHW_PSU; Enclosure ;Name - (Controller Name - PSU Name);   Status       ;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PSU$
            # Exclude PowerSupplys not installed
            # MSHW_PSU; Enclosure ;Name - (Controller Name - PSU Name);   Status       ;SystemName;
          - type: excludeMatchingLines
            column: 4
            valueList: "not installed,not_installed,not present,not_present,notinstalled,notpresent,Not Present"
      mapping:
        # The discovery table
        # MSHW_PSU; Enclosure ;Name - (Controller Name - PSU Name);   Status       ;SystemName;
        source: $monitors.power_supply.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(3)
          hw.parent.type: blade
          hw.parent.id: $column(2)
          name: $column(3)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only DiskControllers
            # MSHW_PSU; Enclosure ;Name - (Controller Name - PSU Name);   Status       ;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PSU$
            # Now translate  into OK/Warning/Alarm
            # MSHW_PSU; Enclosure ;Name - (Controller Name - PSU Name);   Status       ;SystemName;
          - type: translate
            column: 4
            translationTable: opStatusTT
      mapping:
        # The value table
        # MSHW_PSU; Enclosure ;Name - (Controller Name - PSU Name);   Status       ;SystemName;
        source: $monitors.power_supply.collect.sources.source(1)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="power_supply"}: $column(4)
  temperature:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only Temperatures
            # MSHW_TEMP;Enclosure;Name;Temperature;Status;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_TEMP$
      mapping:
        # The discovery table
        # MSHW_TEMP;Enclosure;Name;Temperature;Status;SystemName;
        source: $monitors.temperature.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(3)
          hw.parent.type: blade
          hw.parent.id: $column(2)
          name: $column(3)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only DiskControllers
            # MSHW_TEMP;Enclosure;Name;Temperature;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_TEMP$
            # Now translate  into OK/Warning/Alarm
            # MSHW_TEMP;Enclosure;Name;Temperature;Status;
          - type: translate
            column: 5
            translationTable: opStatusTT
      mapping:
        # The value table
        # MSHW_TEMP;Enclosure;Name;Temperature;Status;
        source: $monitors.temperature.collect.sources.source(1)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="temperature"}: $column(5)
          hw.temperature: $column(4)
  other_device:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only Temperatures
            # MSWH_OTHERDEVICE;Enclosure;Type;Name;OpState;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHERDEVICE$
          # Exclude not installed
          - type: excludeMatchingLines
            column: 5
            valueList: "not installed,not_installed,not present,not_present,notinstalled,notpresent,Not Present"
      mapping:
        # The discovery table
        # MSWH_OTHERDEVICE;Enclosure;Type;Name;OpState;SystemName;
        source: $monitors.other_device.discovery.sources.source(1)$
        attributes:
          device_type: $column(3)
          id: $column(4)
          __display_id: $column(4)
          hw.parent.type: blade
          hw.parent.id: $column(2)
          name: "sprintf(\"%s: %s\", $column(3), $column(4))"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          # MSWH_OTHERDEVICE;Enclosure;Type;Name;OpState;SystemName;
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only Other Devices
            # MSWH_OTHERDEVICE;Enclosure;Type;Name;OpState;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHERDEVICE$
            # Now translate  into OK/Warning/Alarm
            # MSWH_OTHERDEVICE;Enclosure;Type;Name;OpState;opState;SystemName;
          - type: duplicateColumn
            column: 5
            # Now translate  into OK/Warning/Alarm
            # MSWH_OTHERDEVICE;Enclosure;Type;Name;status;OpState;SystemName;
          - type: translate
            column: 5
            translationTable: opStatusTT
      mapping:
        # The value table
        # MSWH_OTHERDEVICE;Enclosure;Type;Name;status;OpState;SystemName;
        source: $monitors.other_device.collect.sources.source(1)$
        deviceId: $column(4)
        metrics:
          hw.status{hw.type="other_device"}: $column(5)
        legacyTextParameters:
          StatusInformation: $column(6)
translations:
  linkStatusTT:
    fabric_login: ok
    bad: degraded
    good: ok
    link_up: ok
    link_down: degraded
  opStatusInfoTT:
    sc_locked: SC Locked
    emu_unknown: Environmental Monitoring Unit Unknow Error
    notinstalled: Not installed
    DiskenclosureWarn: Not Present
    contains_ilf_disk: 'Contains '
    initialized_ok: ""
    emu_critical: Environmental Monitoring Unit Critical
    initialized_unknown: ""
    non_member_attention: Non Member Error
    uninitialized_attention: Uninitialized
    uninitialized_ok: Unintialized
    emu_ok: ""
    emu_information: ""
    member_ok: ""
    not present: Not Present
    suspended_ok: Suspended
    not_redundant_attention: Not Redundant
    not_available: Not Available
    member_failed: Member Failed
    not installed: Not installed
    initialized_attention: Initialization Error
    not_redundant_failed: Not Redundant
    restoring_ok: Restoring
    restoring_failed: Restoring Failed
    asynch_member_add_in_progress: ok
    emu_non_critical: Environmental Monitoring Unit Warning
    notpresent: Not Present
    diskgroup_degraded: Diskgroup Degraded
    emu_not_available: Environmental Monitoring Unit Not Available
    management_module_installed: ok
    suspended_attention: Suspended Error
    unknown: Unknown
    restoring_attention: Restoring Error
    emu_unrecoverable: Environmental Monitoring Unit Unrecoverable Error
    managed_by_other_agent: Managed by Other Agent
    unsupported: Unsupported
    member_attention: Member Error
    initialized_failed: Initialization Failed
    suspended_failed: Suspended Failed
    non_member_failed: Non Member Failed
    not_redundant_ok: ""
    management_module_not_installed: Management Module Not Installed
    non_member_ok: ""
    emu_unsupported: Environmental Monitoring Unit Unsupported
    not_present: Not Present
    uninitialized_failed: Uninitialized
    firmware_upgrade: Firmware Upgrade
    not_installed: Not installed
    asynch_member_remove_in_progress: ok
  cacheStatusInfoTT:
    no_mirror: No Mirror
    Default: ""
  predictedFailureTT:
    "no": "false"
    "yes": "true"
  opStatusTT:
    Not Present: MISSING
    normal: ok
    not present: MISSING
    notpresent: MISSING
    bad: failed
    notinstalled: MISSING
    no_mirror: degraded
    failed: failed
    DiskenclosureWarn: degraded
    good: ok
    Default: UNKNOWN
    not installed: MISSING
    attention: degraded
    not_present: MISSING
    not_installed: MISSING
