---
translations:
  DiskStatusTranslationTable:
    default: UNKNOWN
    "3": ok
    "4": degraded
    "5": failed
    "6": failed
  RAIDLevelCodeTranslationTable:
    "2": 10
    default: ""
    "3": 50
  PhysicalDiskSMARTTranslationTable:
    default: "false"
    "5": "true"
    "6": "true"
  DiskStatusInformationTranslationTable:
    default: Unknown Status
    "3": ""
    "4": Degraded
    "5": Critical
    "6": Non-recoverable
connector:
  displayName: Adaptec IOManager
  platforms: Fujitsu-Siemens PRIMERGY
  reliesOn: Adaptec IOManager
  version: 1.0
  information: This connector provides disk monitoring through the Adaptec IO Manager SNMP sub-agent which supports a few AAC-based Adaptec RAID controllers.
  detection:
    connectionTypes:
    - remote
    appliesTo:
    - NT
    - Linux
    criteria:
    - type: snmpGetNext
      oid: 1.3.6.1.4.1.795.12.2.3.1.1
monitors:
  disk_controller:
    discovery:
      sources:
        source(1):
          # Source(1) = ctlrTable SNMP table
          # deviceID;ctrlDescription
          type: snmpTable
          oid: 1.3.6.1.4.1.795.12.2.3.1.1
          selectColumns: "ID,2"
          computes:
          # Give a best look to the description field
          - type: extract
            column: 2
            subColumn: 1
            subSeparators: ' -'
          - type: rightConcat
            column: 2
            value: ' HostRAID'
        source(2):
          # Source(2) = associationTable
          # associationType;oid1;oid2
          type: snmpTable
          oid: 1.3.6.1.4.1.795.12.2.12.1.1
          selectColumns: "2,3,4"
          computes:
            # Filter: keep only "Shortcut: Physical Organization"
            # associationType;oid1;oid2
          - type: keepOnlyMatchingLines
            column: 1
            regExp: "Shortcut: Physical Organization"
            # Extract the controller device ID from oid1
            # associationType;controllerID;oid2
          - type: replace
            column: 2
            existingValue: 1.3.6.1.4.1.795.12.2.3.1.1.1.
            newValue: ""
        source(3):
          # Source(3) = Table Joint of Source(1) and Source(2)
          # We'll only keep disk controllers that have really disks attached to them
          # deviceID;ctrlDescription;associationType;controllerID;oid2
          type: tableJoin
          leftTable: $monitors.disk_controller.discovery.sources.source(1)$
          rightTable: $monitors.disk_controller.discovery.sources.source(2)$
          leftKeyColumn: 1
          rightKeyColumn: 2
      mapping:
        # InstanceTable = Source(1)
        source: $monitors.disk_controller.discovery.sources.source(3)$
        attributes:
          id: $column(1)
          controller_number: $column(1)
          model: $column(2)
          vendor: Adaptec
          hw.parent.type: enclosure
          name: "sprintf(\"Disk Controller: %s (%s %s)\", $column(1), \"Adaptec\", $column(2))"
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = deviceTable SNMP table
          # ID;devType;Model;SizeKB
          type: snmpTable
          oid: 1.3.6.1.4.1.795.12.2.2.1.1
          selectColumns: "ID,2,3,6"
          computes:
          # Keep only device type = 1 (disk)
          - type: keepOnlyMatchingLines
            column: 2
            valueList: 3
            # Convert sizeKB to bytes
            # ID;devType;Model;SizeBytes
          - type: multiply
            column: 4
            value: 1024
            # Retrieve the vendor from the model string
            # ID;devType;Vendor;SizeBytes
          - type: extract
            column: 3
            subColumn: 1
            subSeparators: " \t"
        source(2):
          # Source(2) = associationTable
          # associationType;oid1;oid2
          type: snmpTable
          oid: 1.3.6.1.4.1.795.12.2.12.1.1
          selectColumns: "2,3,4"
          computes:
            # Filter: keep only "Shortcut: Physical Organization"
            # associationType;oid1;oid2
          - type: keepOnlyMatchingLines
            column: 1
            regExp: "Shortcut: Physical Organization"
            # Extract the controller device ID from oid1
            # associationType;controllerID;oid2
          - type: replace
            column: 2
            existingValue: 1.3.6.1.4.1.795.12.2.3.1.1.1.
            newValue: ""
            # Extract the physical disk device ID from oid2
            # associationType;controllerID;physicalDiskID
          - type: replace
            column: 3
            existingValue: 1.3.6.1.4.1.795.12.2.2.1.1.1.
            newValue: ""
        source(3):
          # Source(3) = Table Joint of Source(1) with Source(2)
          # ID;devType;Vendor;SizeBytes;associationType;controllerID;physicalDiskID
          type: tableJoin
          leftTable: $monitors.physical_disk.discovery.sources.source(1)$
          rightTable: $monitors.physical_disk.discovery.sources.source(2)$
          leftKeyColumn: 1
          rightKeyColumn: 3
      mapping:
        # Instance Table = Source(3)
        source: $monitors.physical_disk.discovery.sources.source(3)$
        attributes:
          id: $column(1)
          vendor: $column(3)
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $column(6))"
          name: "sprintf(\"%s (%s)\", $column(1), $column(4))"
        metrics:
          hw.physical_disk.size: $column(4)
    collect:
      # Collect type is: multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = deviceTable SNMP table
          # ID;devType
          type: snmpTable
          oid: 1.3.6.1.4.1.795.12.2.2.1.1
          selectColumns: "ID,2"
          computes:
          # Keep only device type = 1 (disk)
          - type: keepOnlyMatchingLines
            column: 2
            valueList: 3
            # Add the OID to the device ID, to make it match in the association table
            # diskOID;devType
          - type: leftConcat
            column: 1
            value: 1.3.6.1.4.1.795.12.2.2.1.1.1.
        source(2):
          # Source(2) = associationTable
          # associationType;oid1;oid2
          type: snmpTable
          oid: 1.3.6.1.4.1.795.12.2.12.1.1
          selectColumns: "2,3,4"
          computes:
            # Filter: keep only "Operational State"
            # associationType;diskOID;stateOID
          - type: keepOnlyMatchingLines
            column: 1
            regExp: Operational State
        source(3):
          # Source(3) = Table Joint between source(1) and source(2)
          # diskOID;devType;associationType;diskOID;stateOID
          type: tableJoin
          leftTable: $monitors.physical_disk.collect.sources.source(1)$
          rightTable: $monitors.physical_disk.collect.sources.source(2)$
          leftKeyColumn: 1
          rightKeyColumn: 2
        source(4):
          # Source(4) = the operationalStateTable
          # stateID;operationalCurrentErrorStatus;operationalPredictedFailureStatus
          type: snmpTable
          oid: 1.3.6.1.4.1.795.12.2.16.1.1
          selectColumns: "ID,10,11"
          computes:
            # Convert the state ID into a stateOID
            # stateOID;operationalCurrentErrorStatus;operationalPredictedFailureStatus
          - type: leftConcat
            column: 1
            value: 1.3.6.1.4.1.795.12.2.16.1.1.1.
        source(5):
          # Source(5) = table joint between source(3) and source(4)
          # diskOID;devType;associationType;diskOID;stateOID;stateOID;operationalCurrentErrorStatus;operationalPredictedFailureStatus
          type: tableJoin
          leftTable: $monitors.physical_disk.collect.sources.source(3)$
          rightTable: $monitors.physical_disk.collect.sources.source(4)$
          leftKeyColumn: 5
          rightKeyColumn: 1
          computes:
            # Duplicate the operationalCurrentErrorStatus
            # diskOID;devType;associationType;diskOID;stateOID;stateOID;operationalCurrentErrorStatus;operationalCurrentErrorStatus;operationalPredictedFailureStatus
          - type: duplicateColumn
            column: 7
            # Translate the first status value into a PATROL Status
            # diskOID;devType;associationType;diskOID;stateOID;stateOID;patrolStatus;operationalCurrentErrorStatus;operationalPredictedFailureStatus
          - type: translate
            column: 7
            translationTable: DiskStatusTranslationTable
            # Translate the second status value into a more readable information
            # diskOID;devType;associationType;diskOID;stateOID;stateOID;patrolStatus;statusInformation;operationalPredictedFailureStatus
          - type: translate
            column: 8
            translationTable: DiskStatusInformationTranslationTable
            # Translate the original SMARTStatus into a true/false value that says if a failure is predicted
            # diskOID;devType;associationType;diskOID;stateOID;stateOID;patrolStatus;statusInformation;PredictedFailure
          - type: translate
            column: 9
            translationTable: PhysicalDiskSMARTTranslationTable
            # Convert the diskOID back to deviceID
            # diskID;devType;associationType;diskOID;stateOID;stateOID;patrolStatus;statusInformation;operationalPredictedFailureStatus
          - type: replace
            column: 1
            existingValue: 1.3.6.1.4.1.795.12.2.2.1.1.1.
            newValue: ""
      mapping:
        # The collect table = Source(1)
        source: $monitors.physical_disk.collect.sources.source(5)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="physical_disk"}: $column(7)
          hw.status{hw.type="physical_disk", state="predicted_failure"}: boolean($column(9))
        legacyTextParameters:
          StatusInformation: $column(8)
  logical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = volumeSetTable SNMP table
          # ID;SizeMB
          type: snmpTable
          oid: 1.3.6.1.4.1.795.12.2.8.1.1
          selectColumns: "ID,3"
          computes:
            # Statically add a field to say this is a RAID0 volume
            # ID;SizeMB;RAIDLevel
          - type: rightConcat
            column: 2
            value: ;0
            # Convert the ID into a diskOID
            # diskOID;SizeMB;RAIDLevel
          - type: leftConcat
            column: 1
            value: 1.3.6.1.4.1.795.12.2.8.1.1.1.
            # Convert sizeMB to bytes
            # diskOID;SizeBytes;RAIDLevel
          - type: multiply
            column: 2
            value: 1048576
        source(2):
          # Source(2) = mlVolumeSetTable SNMP table
          # ID;SizeMB;RAIDLevelCode
          type: snmpTable
          oid: 1.3.6.1.4.1.795.12.2.9.1.1
          selectColumns: "ID,3,5"
          computes:
            # Translate the RAIDLevelCode into an actual RAID level
            # ID;SizeMB;RAIDLevel
          - type: translate
            column: 3
            translationTable: RAIDLevelCodeTranslationTable
            # Convert the ID into a diskOID
            # diskOID;SizeMB;RAIDLevel
          - type: leftConcat
            column: 1
            value: 1.3.6.1.4.1.795.12.2.9.1.1.1.
            # Convert sizeMB to bytes
            # diskOID;SizeBytes;RAIDLevel
          - type: multiply
            column: 2
            value: 1048576
        source(3):
          # Source(3) = Union of source(1) and source(2)
          # diskOID;SizeBytes;RAIDLevel
          type: tableUnion
          tables:
          - $monitors.logical_disk.discovery.sources.source(1)$
          - $monitors.logical_disk.discovery.sources.source(2)$
        source(4):
          # Source(4) = associationTable
          # associationType;oid1;oid2
          type: snmpTable
          oid: 1.3.6.1.4.1.795.12.2.12.1.1
          selectColumns: "2,3,4"
          computes:
            # Filter: keep only "Shortcut: Logical to Physical Organization"
            # associationType;oid1;oid2
          - type: keepOnlyMatchingLines
            column: 1
            regExp: "Shortcut: Logical to Physical Organization"
          # Keep only lines with a controllerID
          - type: keepOnlyMatchingLines
            column: 3
            regExp: 1\.3\.6\.1\.4\.1\.795\.12\.2\.3\.1\.1\.1\.
            # Extract the controller device ID from oid2
            # associationType;oid1;controllerID
          - type: replace
            column: 3
            existingValue: 1.3.6.1.4.1.795.12.2.3.1.1.1.
            newValue: ""
        source(5):
          # Source(5) = Table Joint of Source(3) with Source(4)
          # diskOID;SizeBytes;RAIDLevel;associationType;oid1;controllerID
          type: tableJoin
          leftTable: $monitors.logical_disk.discovery.sources.source(3)$
          rightTable: $monitors.logical_disk.discovery.sources.source(4)$
          leftKeyColumn: 1
          rightKeyColumn: 2
      mapping:
        # Instance Table = Source(5)
        source: $monitors.logical_disk.discovery.sources.source(5)$
        attributes:
          id: $column(1)
          hw.logical_disk.limit: $column(2)
          raid_level: $column(3)
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $column(6))"
          name: "sprintf(\"%s (%s - %s)\", $column(1), $column(3), $column(2))"
    collect:
      # Collect type is: multi-instance
      type: monoInstance
      sources:
        source(1):
          # Source(1) = the associationTable SNMP table
          # associationType;oid1;oid2
          type: snmpTable
          oid: 1.3.6.1.4.1.795.12.2.12.1.1
          selectColumns: "2,3,4"
          computes:
            # Filter: keep only "Operational State"
            # associationType;diskOID;stateOID
          - type: keepOnlyMatchingLines
            column: 1
            regExp: Operational State
            # Keep only the line corresponding to the logical disk OID we're processing
            # associationType;diskOID;stateOID (one line)
          - type: keepOnlyMatchingLines
            column: 2
            valueList: '%LogicalDisk.Collect.DeviceID%'
        source(2):
          # Source(2) = the operationalStateTable
          # stateID;operationalCurrentErrorStatus
          type: snmpTable
          oid: 1.3.6.1.4.1.795.12.2.16.1.1
          selectColumns: "ID,10"
          computes:
            # Convert the state ID into a stateOID
            # stateOID;operationalCurrentErrorStatus
          - type: leftConcat
            column: 1
            value: 1.3.6.1.4.1.795.12.2.16.1.1.1.
        source(3):
          # Source(3) = table joint between source(1) and source(2)
          # associationType;diskOID;stateOID;stateOID;operationalCurrentErrorStatus (one line)
          type: tableJoin
          leftTable: $monitors.logical_disk.collect.sources.source(1)$
          rightTable: $monitors.logical_disk.collect.sources.source(2)$
          leftKeyColumn: 3
          rightKeyColumn: 1
          computes:
            # Duplicate the operationalCurrentErrorStatus
            # associationType;diskOID;stateOID;stateOID;operationalCurrentErrorStatus;operationalCurrentErrorStatus (one line)
          - type: duplicateColumn
            column: 5
            # Translate the first status value into a PATROL Status (see translation table in the physical disk section)
            # associationType;diskOID;stateOID;stateOID;patrolStatus;operationalCurrentErrorStatus (one line)
          - type: translate
            column: 5
            translationTable: DiskStatusTranslationTable
            # Translate the second status value into a more readable information (see translation table in the physical disk section)
            # associationType;diskOID;stateOID;stateOID;patrolStatus;statusInformation (one line)
          - type: translate
            column: 6
            translationTable: DiskStatusInformationTranslationTable
      mapping:
        # The collect table = Source(3)
        source: $monitors.logical_disk.collect.sources.source(3)$
        metrics:
          hw.status{hw.type="logical_disk"}: $column(5)
        legacyTextParameters:
          StatusInformation: $column(6)
