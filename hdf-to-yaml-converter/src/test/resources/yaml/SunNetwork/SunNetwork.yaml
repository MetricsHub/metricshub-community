---
extends:
- ../SunEthernetDriver-header/SunEthernetDriver-header
connector:
  displayName: Oracle/Sun Solaris - Network
  platforms: Oracle/Sun
  reliesOn: "Sun Solaris system commands (kstat, ndd, ifconfig, dladm, etc.)"
  version: 1.3
  information: This connector provides the monitoring of network cards on all Sun Solaris systems.
  detection:
    connectionTypes:
    - remote
    - local
    appliesTo:
    - Solaris
    criteria:
    - type: deviceType
      keep:
      - SunOS
      - Solaris
    - type: osCommand
      commandLine: /usr/sbin/ifconfig -a
      expectedResult: flags=
sudoCommands:
- /usr/sbin/ndd
- /usr/sbin/dladm
monitors:
  network:
    discovery:
      sources:
        source(1):
          # Source(1) = output of ifconfig -a
          type: osCommand
          commandLine: /usr/sbin/ifconfig -a
          computes:
            # Process the output of ifconfig through an AWK script
            # LogicalDeviceID;MacAddress;IPAddress;
          - type: awk
            script: "${file::embeddedFile-1}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5"
        source(2):
          # Source(2) = output of prtconf -D or dladm show-dev
          # with only the network instances
          type: osCommand
          commandLine: "/bin/sh ${file::embeddedFile-5}"
          keep: "\\(network, instance #[0-9]\\)\\|\\(link:.*speed:.*duplex:\\)\\|\\(: flags=\\)\\|\\(SUNW,qfe\\)\\|\\(FJSV,pgtb\\)\\|\\(LinkID:.*DeviceID:\\)"
          computes:
            # Process the output of prtconf through an AWK script to keep only the NIC ID
            # DeviceID;Driver;
          - type: awk
            script: "${file::embeddedFile-4}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3"
        source(3):
          # Source(3) = output of dladm show-phys
          # This command will only work on Solaris 11.  A blank table is expected on other versions.
          # LogicalDeviceID;PhysicalID
          type: osCommand
          commandLine: "/bin/sh ${file::embeddedFile-6}"
          keep: "[A-Za-z].*[0-9];[A-Za-z].*[0-9]"
          computes:
            # Add a "" to column2 to force the PSL/Java close out column 2
            # LogicalDeviceID;PhysicalID;
          - type: rightConcat
            column: 2
            value: ""
        source(4):
          # Source(4) = Table joint of Source(2) and Source(3)
          # Solaris 11 machines, the DeviceID from Table 2 will match the PhysicalID
          # For other versions, it will not match, so we put a marker in
          # DeviceID;Driver;LogicalDeviceID;PhysicalID;
          type: tableJoin
          leftTable: "${source::monitors.network.discovery.sources.source(2)}"
          rightTable: "${source::monitors.network.discovery.sources.source(3)}"
          leftKeyColumn: 1
          rightKeyColumn: 2
          defaultRightLine: NotSolaris11;;
          computes:
            # For non-Solaris 11 machines, we will copy the deviceID into the PhysicalID column (where we put the marker NotSolaris11)
            # DeviceID;Driver;LogicalDeviceID;PhysicalID;
          - type: replace
            column: 3
            existingValue: NotSolaris11
            newValue: $1
        source(5):
          # Source(3) = Table joint of Source(2) and Source(1)
          # DeviceID;Driver;LogicalDeviceID;PhysicalID;LogicalDeviceID;MacAddress;IPAddress;
          type: tableJoin
          leftTable: "${source::monitors.network.discovery.sources.source(4)}"
          rightTable: "${source::monitors.network.discovery.sources.source(1)}"
          leftKeyColumn: 3
          rightKeyColumn: 1
          defaultRightLine: ;;;
          computes:
            # Translate the Driver column into a model name
            #  DeviceID;Model;LogicalDeviceID;PhysicalID;LogicalDeviceID;MacAddress;IPAddress;
          - type: translate
            column: 2
            translationTable: "${translation::DriverTranslationTable}"
      mapping:
        # InstanceTable = Source(3)
        # DeviceID;Model;LogicalDeviceID;PhysicalID;LogicalDeviceID;MacAddress;IPAddress;
        source: "${source::monitors.network.discovery.sources.source(5)}"
        attributes:
          id: $3
          __display_id: $3
          model: $2
          physical_address: $6
          physical_address_type: MAC
          logical_address: $7
          logical_address_type: IP
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s)\", $3, $2)}"
    collect:
      # Collect type is: mono-collect
      type: monoInstance
      sources:
        source(1):
          # Source(1) = output of the embedded script 2 (ifconfig output)
          # DeviceID;ifconfigFlags
          type: osCommand
          commandLine: "if /usr/sbin/ifconfig ${network::id}; then /usr/bin/echo; else /usr/bin/echo \"${network::id}: flags=00000000:UNPLUMBED\"; fi"
          keep: "^${network::id}: flags="
          separators: :<>
          selectColumns: "1,3"
          computes:
            # Duplicate the ifconfigFlags
            # DeviceID;ifconfigFlags;ifconfigFlags;
          - type: duplicateColumn
            column: 2
            # Translate the first ifconfig flags
            # DeviceID;StatusArray;ifconfigFlags;
          - type: arrayTranslate
            column: 2
            translationTable: "${translation::ifconfigFlagsTranslationTable}"
            arraySeparator: ","
            resultSeparator: '|'
            # Convert StatusArray into Status
            # DeviceID;Status;StatusInformation;
          - type: convert
            column: 2
            conversion: array2SimpleStatus
        source(2):
          # Source(2) = output of embedded script 4 (complicated shell script)
          type: osCommand
          commandLine: "/bin/sh ${file::embeddedFile-2} ${network::id}"
          computes:
            # Process the output of this script through a smart AWK script
            # DeviceID;LinkStatus;LinkSpeed;DuplexMode;ReceivedPacket;TransmittedPackets;Errors;ReceivedBytes;TransmittedBytes;
          - type: awk
            script: "${file::embeddedFile-3}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5,6,7,8,9,10"
        source(3):
          # Source(3) = table joint of Source(1) and Source(2)
          # DeviceID;Status;StatusInformation;DeviceID;LinkStatus;LinkSpeed;DuplexMode;ReceivedPacket;TransmittedPackets;Errors;ReceivedBytes;TransmittedBytes;
          type: tableJoin
          leftTable: "${source::monitors.network.collect.sources.source(1)}"
          rightTable: "${source::monitors.network.collect.sources.source(2)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          defaultRightLine: ;;;;;;;;;
      mapping:
        # And here is the ValueTable
        source: "${source::monitors.network.collect.sources.source(3)}"
        metrics:
          hw.status{hw.type="network"}: $2
          hw.network.up: legacyLinkStatus($5)
          hw.network.bandwidth.limit: megaBit2Bit($6)
          hw.network.full_duplex: legacyFullDuplex($7)
          hw.network.packets{direction="receive"}: $8
          hw.network.packets{direction="transmit"}: $9
          hw.errors{hw.type="network"}: $10
          hw.network.io{direction="receive"}: $11
          hw.network.io{direction="transmit"}: $12
        legacyTextParameters:
          StatusInformation: $3
translations:
  ifconfigFlagsTranslationTable:
    FAILED: failed
    INACTIVE: ok
    RUNNING: ok
    STANDBY: ok
    UP: ok
    DEPRECATED: ok
    UNPLUMBED: ok
    Default: ok
    OFFLINE: ok
