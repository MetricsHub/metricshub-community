---
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Source(1) = Run auunitinfo through EF1
          type: osCommand
          commandLine: _EF1_COMMAND_PART1 auunitinfo _EF1_COMMAND_PART2
          executeLocally: true
          timeout: 1200
          forceSerialization: true
          computes:
            # Process the command through an AWK script
            # MSHW;systemName;model;firmware;serialNumber;
          - type: awk
            script: "${file::embeddedFile-2}"
            keep: ^MSHW
            separators: ;
        source(2):
          # Now discover information for other discoveries
          # Source(2) = Run auparts through EF1
          type: osCommand
          commandLine: _EF1_COMMAND_PART1 auparts _EF1_COMMAND_PART2
          executeLocally: true
          timeout: 1200
          forceSerialization: true
          computes:
            # Process the command through an AWK script
            # MSHW_Class;systemName;DeviceID;DisplayID;Status;Status;
          - type: awk
            script: "${file::embeddedFile-3}"
            keep: ^MSHW
            separators: ;
      mapping:
        # Instance Table
        # MSHW;systemName;model;firmware;serialNumber;
        source: "${source::monitors.enclosure.discovery.sources.source(1)}"
        attributes:
          id: $2
          __display_id: $2
          vendor: Hitachi
          model: $3
          serial_number: $5
          type: Storage
          name: "${awk::sprintf(\"Storage: %s (%s %s)\", $2, \"Hitachi\", $3)}"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Now discover information for other discoveries
          # Source(1) = Run auparts through EF1
          type: osCommand
          commandLine: _EF1_COMMAND_PART1 auparts _EF1_COMMAND_PART2
          executeLocally: true
          timeout: 1200
          forceSerialization: true
          computes:
            # Process the command through an AWK script
            # MSHW_Class;systemName;DeviceID;DisplayID;Status;Status;
          - type: awk
            script: "${file::embeddedFile-3}"
            keep: ^MSHW
            separators: ;
      mapping:
        # The value table (taken from enclosure.discovery, since we don't actually want to collect anything.
        source: "${source::monitors.enclosure.discovery.sources.source(1)}"
        attributes:
          id: $2
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) =  audrive -vendor
          type: osCommand
          commandLine: _EF1_COMMAND_PART1 audrive -vendor _EF1_COMMAND_PART2
          executeLocally: true
          timeout: 1200
          forceSerialization: true
          computes:
            # Process the command through an AWK script
            # MSHW;systemName;DeviceID;DisplayID;CapacityGB;DriveType;Speed;Vendor;Model;Firmware;Serial;
          - type: awk
            script: "${file::embeddedFile-4}"
            keep: ^MSHW
            separators: ;
            # Convert Size from Gbytes to bytes
            # MSHW;systemName;DeviceID;DisplayID;CapacityB;DriveType;Speed;Vendor;Model;Firmware;Serial;
          - type: multiply
            column: 5
            value: 1073741824
          - type: leftConcat
            column: 6
            value: "Type: "
      mapping:
        # The discovery table
        #   1      2        # 3       4        # 5         6        7      8      9   10        11
        # MSHW;systemName;DeviceID;DisplayID;CapacityB;DriveType;Speed;Vendor;Model;Firmware;Serial;
        source: "${source::monitors.physical_disk.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          vendor: $8
          model: $9
          serial_number: $11
          firmware_version: $10
          info: "${awk::join(\" \", $7, $6)}"
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s (%s - %s)\", $4, $8, bytes2HumanFormatBase10($5))}"
        metrics:
          hw.physical_disk.size: $5
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = audrive -status
          type: osCommand
          commandLine: _EF1_COMMAND_PART1 audrive -status _EF1_COMMAND_PART2
          executeLocally: true
          timeout: 1200
          forceSerialization: true
          computes:
            # Process the command through an AWK script
            # MSHW;DeviceID;Status;StatusInformation;
          - type: awk
            script: "${file::embeddedFile-5}"
            keep: ^MSHW
            separators: ;
            # Translate the Status
            # MSHW;DeviceID;Status;StatusInformation;
          - type: translate
            column: 3
            translationTable: "${translation::DriveStatusTT}"
      mapping:
        # The value table
        # MSHW;DeviceID;Status;StatusInformation;
        source: "${source::monitors.physical_disk.collect.sources.source(1)}"
        attributes:
          id: $2
        metrics:
          hw.status{hw.type="physical_disk"}: $3
        legacyTextParameters:
          StatusInformation: $4
  logical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) =  auluref -m
          type: osCommand
          commandLine: _EF1_COMMAND_PART1 auluref -m _EF1_COMMAND_PART2
          executeLocally: true
          timeout: 1200
          forceSerialization: true
          computes:
            # Process the command through an AWK script
            # MSHW;systemName;DeviceID;DisplayID;CapacityGB;StripeSize;RAIDGroup;RaidLevel;DiskType;Status;StatusInformation;LogicalDiskType;UseInCapacity;CapacityFreeGB;
          - type: awk
            script: "${file::embeddedFile-6}"
            keep: ^MSHW
            separators: ;
        source(2):
          # Source(1) =  aurgref -m
          type: osCommand
          commandLine: _EF1_COMMAND_PART1 aurgref -m _EF1_COMMAND_PART2
          executeLocally: true
          timeout: 1200
          forceSerialization: true
          computes:
            # Process the command through an AWK script
            # MSHW;systemName;DeviceID;DisplayID;CapacityGB;StripeSize;RAIDGroup;RaidLevel;DiskType;Status;StatusInformation;LogicalDiskType;UseInCapacity;CapacityFreeGB;
          - type: awk
            script: "${file::embeddedFile-7}"
            keep: ^MSHW
            separators: ;
        source(3):
          # Union Volumes (1) and Raid Groups (2)
          # MSHW;systemName;DeviceID;DisplayID;CapacityGB;StripeSize;RAIDGroup;RaidLevel;DiskType;Status;StatusInformation;LogicalDiskType;UseInCapacity;CapacityFreeGB;
          type: tableUnion
          tables:
          - "${source::monitors.logical_disk.discovery.sources.source(1)}"
          - "${source::monitors.logical_disk.discovery.sources.source(2)}"
          computes:
            # Convert Size from Gbytes to bytes
            # MSHW;systemName;DeviceID;DisplayID;CapacityB;StripeSize;RAIDGroup;RaidLevel;DiskType;Status;StatusInformation;LogicalDiskType;UseInCapacity;CapacityFreeGB;
          - type: multiply
            column: 5
            value: 1073741824
          - type: leftConcat
            column: 9
            value: "Disk Type: "
          - type: leftConcat
            column: 6
            value: "Stripe Size: "
      mapping:
        # The discovery table
        #   1      2        # 3       4        # 5         6        7        # 8         9        10        11        #   12        #     13        #      14
        # MSHW;systemName;DeviceID;DisplayID;CapacityB;StripeSize;RAIDGroup;RaidLevel;DiskType;Status;StatusInformation;LogicalDiskType;UseInCapacity;CapacityFreeGB;
        source: "${source::monitors.logical_disk.discovery.sources.source(3)}"
        attributes:
          id: $3
          __display_id: $4
          type: $12
          __use_for_capacity_report: $13
          raid_level: $8
          info: "${awk::join(\" \", $9, $6)}"
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s (%s - %s)\", $4, $8, bytes2HumanFormatBase2($5))}"
        metrics:
          hw.logical_disk.limit: $5
        conditionalCollection:
          hw.logical_disk.usage{state="free"}: $14
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = auluref -m
          type: osCommand
          commandLine: _EF1_COMMAND_PART1 auluref -m _EF1_COMMAND_PART2
          executeLocally: true
          timeout: 1200
          forceSerialization: true
          computes:
            # Process the command through an AWK script
            # MSHW;systemName;DeviceID;DisplayID;CapacityGB;StripeSize;RAIDGroup;RaidLevel;DiskType;Status;StatusInformation;LogicalDiskType;UseInCapacity;CapacityFreeGB;
          - type: awk
            script: "${file::embeddedFile-6}"
            keep: ^MSHW
            separators: ;
        source(2):
          # Source(2) = aurgref -m
          type: osCommand
          commandLine: _EF1_COMMAND_PART1 aurgref -m _EF1_COMMAND_PART2
          executeLocally: true
          timeout: 1200
          forceSerialization: true
          computes:
            # Process the command through an AWK script
            # MSHW;systemName;DeviceID;DisplayID;CapacityGB;StripeSize;RAIDGroup;RaidLevel;DiskType;Status;StatusInformation;LogicalDiskType;UseInCapacity;CapacityFreeGB;
          - type: awk
            script: "${file::embeddedFile-7}"
            keep: ^MSHW
            separators: ;
        source(3):
          # Union Volumes (1) and Raid Groups (2)
          # MSHW;systemName;DeviceID;DisplayID;CapacityGB;StripeSize;RAIDGroup;RaidLevel;DiskType;Status;StatusInformation;LogicalDiskType;UseInCapacity;CapacityFreeGB;
          type: tableUnion
          tables:
          - "${source::monitors.logical_disk.collect.sources.source(1)}"
          - "${source::monitors.logical_disk.collect.sources.source(2)}"
          computes:
            # Translate the Status
            # MSHW;systemName;DeviceID;DisplayID;CapacityGB;StripeSize;RAIDGroup;RaidLevel;DiskType;Status;StatusInformation;LogicalDiskType;UseInCapacity;CapacityFreeGB;
          - type: translate
            column: 10
            translationTable: "${translation::LogicalDriveStatusTT}"
      mapping:
        # The value table
        # MSHW;systemName;DeviceID;DisplayID;CapacityGB;StripeSize;RAIDGroup;RaidLevel;DiskType;Status;StatusInformation;LogicalDiskType;UseInCapacity;CapacityFreeGB;
        source: "${source::monitors.logical_disk.collect.sources.source(3)}"
        attributes:
          id: $3
        metrics:
          hw.status{hw.type="logical_disk"}: $10
          hw.logical_disk.usage{state="free"}: $14
          hw.logical_disk.usage{state="used"}: collectAllocatedSpace()
        legacyTextParameters:
          StatusInformation: $11
  fan:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(2)}"
          computes:
            # Keep only Fans
            # MSHW_Fan;systemName;deviceID;displayID;Status;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_FAN$
      mapping:
        # The discovery table
        # MSHW_Fan;systemName;deviceID;displayID;Status;Status;
        source: "${source::monitors.fan.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $4
    collect:
      # Collect
      # Collect type: MultiInstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep only Fan
            # MSHW_Fan;systemName;deviceID;displayID;Status;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_FAN$
            # Now translate  into OK/Warning/Alarm
            # MSHW_Fan;systemName;deviceID;displayID;PatrolStatus;Status;
          - type: translate
            column: 5
            translationTable: "${translation::opStatusTT}"
      mapping:
        # The value table
        # MSHW_Fan;systemName;deviceID;displayID;PatrolStatus;Status;
        source: "${source::monitors.fan.collect.sources.source(1)}"
        attributes:
          id: $3
        metrics:
          hw.status{hw.type="fan"}: $5
        legacyTextParameters:
          StatusInformation: $6
  other_device:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(2)}"
          computes:
            # Keep only OtherDevices
            # MSHW_OtherDevice;systemName;deviceID;displayID;Status;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OtherDevice$
      mapping:
        # The discovery table
        # MSHW_OtherDevice;systemName;deviceID;displayID;Status;Status;
        source: "${source::monitors.other_device.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $4
    collect:
      # Collect
      # Collect type: MultiInstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep only OtherDevice
            # MSHW_OtherDevice;systemName;deviceID;displayID;Status;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OtherDevice$
            # Now translate  into OK/Warning/Alarm
            # MSHW_OtherDevice;systemName;deviceID;displayID;PatrolStatus;Status;
          - type: translate
            column: 5
            translationTable: "${translation::opStatusTT}"
      mapping:
        # The value table
        # MSHW_OtherDevice;systemName;deviceID;displayID;PatrolStatus;Status;
        source: "${source::monitors.other_device.collect.sources.source(1)}"
        attributes:
          id: $3
        metrics:
          hw.status{hw.type="other_device"}: $5
        legacyTextParameters:
          StatusInformation: $6
  memory:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(2)}"
          computes:
            # Keep only Memorys
            # MSHW_Memory;systemName;deviceID;displayID;Status;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_Memory$
      mapping:
        # The discovery table
        # MSHW_Memory;systemName;deviceID;displayID;Status;Status;
        source: "${source::monitors.memory.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $4
    collect:
      # Collect
      # Collect type: MultiInstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep only Memory
            # MSHW_Memory;systemName;deviceID;displayID;Status;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_Memory$
            # Now translate  into OK/Warning/Alarm
            # MSHW_Memory;systemName;deviceID;displayID;PatrolStatus;Status;
          - type: translate
            column: 5
            translationTable: "${translation::opStatusTT}"
      mapping:
        # The value table
        # MSHW_Memory;systemName;deviceID;displayID;PatrolStatus;Status;
        source: "${source::monitors.memory.collect.sources.source(1)}"
        attributes:
          id: $3
        metrics:
          hw.status{hw.type="memory"}: $5
        legacyTextParameters:
          StatusInformation: $6
  network:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(2)}"
          computes:
            # Keep only NetworkCards
            # MSHW_NetworkCard;systemName;deviceID;displayID;Status;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_NetworkCard$
      mapping:
        # The discovery table
        # MSHW_NetworkCard;systemName;deviceID;displayID;Status;Status;
        source: "${source::monitors.network.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $4
    collect:
      # Collect
      # Collect type: MultiInstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep only NetworkCard
            # MSHW_NetworkCard;systemName;deviceID;displayID;Status;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_NetworkCard$
            # Now translate  into OK/Warning/Alarm
            # MSHW_NetworkCard;systemName;deviceID;displayID;PatrolStatus;Status;
          - type: translate
            column: 5
            translationTable: "${translation::opStatusTT}"
      mapping:
        # The value table
        # MSHW_NetworkCard;systemName;deviceID;displayID;PatrolStatus;Status;
        source: "${source::monitors.network.collect.sources.source(1)}"
        attributes:
          id: $3
        metrics:
          hw.status{hw.type="network"}: $5
        legacyTextParameters:
          StatusInformation: $6
  battery:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(2)}"
          computes:
            # Keep only Batterys
            # MSHW_Battery;systemName;deviceID;displayID;Status;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_Battery$
      mapping:
        # The discovery table
        # MSHW_Battery;systemName;deviceID;displayID;Status;Status;
        source: "${source::monitors.battery.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $4
    collect:
      # Collect
      # Collect type: MultiInstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep only Battery
            # MSHW_Battery;systemName;deviceID;displayID;Status;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_Battery$
            # Now translate  into OK/Warning/Alarm
            # MSHW_Battery;systemName;deviceID;displayID;PatrolStatus;Status;
          - type: translate
            column: 5
            translationTable: "${translation::opStatusTT}"
      mapping:
        # The value table
        # MSHW_Battery;systemName;deviceID;displayID;PatrolStatus;Status;
        source: "${source::monitors.battery.collect.sources.source(1)}"
        attributes:
          id: $3
        metrics:
          hw.status{hw.type="battery"}: $5
        legacyTextParameters:
          StatusInformation: $6
  power_supply:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(2)}"
          computes:
            # Keep only PowerSupplys
            # MSHW_PowerSupply;systemName;deviceID;displayID;Status;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PowerSupply$
      mapping:
        # The discovery table
        # MSHW_PowerSupply;systemName;deviceID;displayID;Status;Status;
        source: "${source::monitors.power_supply.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $4
    collect:
      # Collect
      # Collect type: MultiInstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep only PowerSupply
            # MSHW_PowerSupply;systemName;deviceID;displayID;Status;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PowerSupply$
            # Now translate  into OK/Warning/Alarm
            # MSHW_PowerSupply;systemName;deviceID;displayID;PatrolStatus;Status;
          - type: translate
            column: 5
            translationTable: "${translation::opStatusTT}"
      mapping:
        # The value table
        # MSHW_PowerSupply;systemName;deviceID;displayID;PatrolStatus;Status;
        source: "${source::monitors.power_supply.collect.sources.source(1)}"
        attributes:
          id: $3
        metrics:
          hw.status{hw.type="power_supply"}: $5
        legacyTextParameters:
          StatusInformation: $6
translations:
  LogicalDriveStatusTT:
    Normal(Correction: ok
    Normal: ok
    Default: failed
  DriveStatusTT:
    Mounted: ok
    Rebuilding: degraded
    Normal: ok
    Standby: ok
    Default: failed
    Out: ok
  opStatusTT:
    Normal: ok
    Default: failed
