---
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Source(1) = Run auunitinfo through EF1
          type: osCommand
          commandLine: _EF1_COMMAND_PART1 auunitinfo _EF1_COMMAND_PART2
          executeLocally: true
          timeout: 1200
          forceSerialization: true
          computes:
            # Process the command through an AWK script
            # MSHW;systemName;model;firmware;serialNumber;
          - type: awk
            script: $file("embeddedFile-2")$
            keep: ^MSHW
            separators: ;
        source(2):
          # Now discover information for other discoveries
          # Source(2) = Run auparts through EF1
          type: osCommand
          commandLine: _EF1_COMMAND_PART1 auparts _EF1_COMMAND_PART2
          executeLocally: true
          timeout: 1200
          forceSerialization: true
          computes:
            # Process the command through an AWK script
            # MSHW_Class;systemName;DeviceID;DisplayID;Status;Status;
          - type: awk
            script: $file("embeddedFile-3")$
            keep: ^MSHW
            separators: ;
      mapping:
        # Instance Table
        # MSHW;systemName;model;firmware;serialNumber;
        source: $monitors.enclosure.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          __display_id: $column(2)
          vendor: Hitachi
          model: $column(3)
          serial_number: $column(5)
          type: Storage
          name: "sprintf(\"Storage: %s (%s %s)\", $column(2), \"Hitachi\", $column(3))"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Now discover information for other discoveries
          # Source(1) = Run auparts through EF1
          type: osCommand
          commandLine: _EF1_COMMAND_PART1 auparts _EF1_COMMAND_PART2
          executeLocally: true
          timeout: 1200
          forceSerialization: true
          computes:
            # Process the command through an AWK script
            # MSHW_Class;systemName;DeviceID;DisplayID;Status;Status;
          - type: awk
            script: $file("embeddedFile-3")$
            keep: ^MSHW
            separators: ;
      mapping:
        # The value table (taken from enclosure.discovery, since we don't actually want to collect anything.
        source: $monitors.enclosure.discovery.sources.source(1)$
        deviceId: $column(2)
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) =  audrive -vendor
          type: osCommand
          commandLine: _EF1_COMMAND_PART1 audrive -vendor _EF1_COMMAND_PART2
          executeLocally: true
          timeout: 1200
          forceSerialization: true
          computes:
            # Process the command through an AWK script
            # MSHW;systemName;DeviceID;DisplayID;CapacityGB;DriveType;Speed;Vendor;Model;Firmware;Serial;
          - type: awk
            script: $file("embeddedFile-4")$
            keep: ^MSHW
            separators: ;
            # Convert Size from Gbytes to bytes
            # MSHW;systemName;DeviceID;DisplayID;CapacityB;DriveType;Speed;Vendor;Model;Firmware;Serial;
          - type: multiply
            column: 5
            value: 1073741824
          - type: leftConcat
            column: 6
            value: "Type: "
      mapping:
        # The discovery table
        #   1      2        # 3       4        # 5         6        7      8      9   10        11
        # MSHW;systemName;DeviceID;DisplayID;CapacityB;DriveType;Speed;Vendor;Model;Firmware;Serial;
        source: $monitors.physical_disk.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(4)
          vendor: $column(8)
          model: $column(9)
          serial_number: $column(11)
          firmware_version: $column(10)
          info: "join(\" \", $column(7), $column(6))"
          hw.parent.type: enclosure
          hw.parent.id: $column(2)
          name: "sprintf(\"%s (%s - %s)\", $column(4), $column(8), bytes2HumanFormatBase10($column(5)))"
        metrics:
          hw.physical_disk.size: $column(5)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = audrive -status
          type: osCommand
          commandLine: _EF1_COMMAND_PART1 audrive -status _EF1_COMMAND_PART2
          executeLocally: true
          timeout: 1200
          forceSerialization: true
          computes:
            # Process the command through an AWK script
            # MSHW;DeviceID;Status;StatusInformation;
          - type: awk
            script: $file("embeddedFile-5")$
            keep: ^MSHW
            separators: ;
            # Translate the Status
            # MSHW;DeviceID;Status;StatusInformation;
          - type: translate
            column: 3
            translationTable: DriveStatusTT
      mapping:
        # The value table
        # MSHW;DeviceID;Status;StatusInformation;
        source: $monitors.physical_disk.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="physical_disk"}: $column(3)
        legacyTextParameters:
          StatusInformation: $column(4)
  logical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) =  auluref -m
          type: osCommand
          commandLine: _EF1_COMMAND_PART1 auluref -m _EF1_COMMAND_PART2
          executeLocally: true
          timeout: 1200
          forceSerialization: true
          computes:
            # Process the command through an AWK script
            # MSHW;systemName;DeviceID;DisplayID;CapacityGB;StripeSize;RAIDGroup;RaidLevel;DiskType;Status;StatusInformation;LogicalDiskType;UseInCapacity;CapacityFreeGB;
          - type: awk
            script: $file("embeddedFile-6")$
            keep: ^MSHW
            separators: ;
        source(2):
          # Source(1) =  aurgref -m
          type: osCommand
          commandLine: _EF1_COMMAND_PART1 aurgref -m _EF1_COMMAND_PART2
          executeLocally: true
          timeout: 1200
          forceSerialization: true
          computes:
            # Process the command through an AWK script
            # MSHW;systemName;DeviceID;DisplayID;CapacityGB;StripeSize;RAIDGroup;RaidLevel;DiskType;Status;StatusInformation;LogicalDiskType;UseInCapacity;CapacityFreeGB;
          - type: awk
            script: $file("embeddedFile-7")$
            keep: ^MSHW
            separators: ;
        source(3):
          # Union Volumes (1) and Raid Groups (2)
          # MSHW;systemName;DeviceID;DisplayID;CapacityGB;StripeSize;RAIDGroup;RaidLevel;DiskType;Status;StatusInformation;LogicalDiskType;UseInCapacity;CapacityFreeGB;
          type: tableUnion
          tables:
          - $monitors.logical_disk.discovery.sources.source(1)$
          - $monitors.logical_disk.discovery.sources.source(2)$
          computes:
            # Convert Size from Gbytes to bytes
            # MSHW;systemName;DeviceID;DisplayID;CapacityB;StripeSize;RAIDGroup;RaidLevel;DiskType;Status;StatusInformation;LogicalDiskType;UseInCapacity;CapacityFreeGB;
          - type: multiply
            column: 5
            value: 1073741824
          - type: leftConcat
            column: 9
            value: "Disk Type: "
          - type: leftConcat
            column: 6
            value: "Stripe Size: "
      mapping:
        # The discovery table
        #   1      2        # 3       4        # 5         6        7        # 8         9        10        11        #   12        #     13        #      14
        # MSHW;systemName;DeviceID;DisplayID;CapacityB;StripeSize;RAIDGroup;RaidLevel;DiskType;Status;StatusInformation;LogicalDiskType;UseInCapacity;CapacityFreeGB;
        source: $monitors.logical_disk.discovery.sources.source(3)$
        attributes:
          id: $column(3)
          __display_id: $column(4)
          type: $column(12)
          __use_for_capacity_report: $column(13)
          raid_level: $column(8)
          info: "join(\" \", $column(9), $column(6))"
          hw.parent.type: enclosure
          hw.parent.id: $column(2)
          name: "sprintf(\"%s (%s - %s)\", $column(4), $column(8), bytes2HumanFormatBase2($column(5)))"
        metrics:
          hw.logical_disk.limit: $column(5)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = auluref -m
          type: osCommand
          commandLine: _EF1_COMMAND_PART1 auluref -m _EF1_COMMAND_PART2
          executeLocally: true
          timeout: 1200
          forceSerialization: true
          computes:
            # Process the command through an AWK script
            # MSHW;systemName;DeviceID;DisplayID;CapacityGB;StripeSize;RAIDGroup;RaidLevel;DiskType;Status;StatusInformation;LogicalDiskType;UseInCapacity;CapacityFreeGB;
          - type: awk
            script: $file("embeddedFile-6")$
            keep: ^MSHW
            separators: ;
        source(2):
          # Source(2) = aurgref -m
          type: osCommand
          commandLine: _EF1_COMMAND_PART1 aurgref -m _EF1_COMMAND_PART2
          executeLocally: true
          timeout: 1200
          forceSerialization: true
          computes:
            # Process the command through an AWK script
            # MSHW;systemName;DeviceID;DisplayID;CapacityGB;StripeSize;RAIDGroup;RaidLevel;DiskType;Status;StatusInformation;LogicalDiskType;UseInCapacity;CapacityFreeGB;
          - type: awk
            script: $file("embeddedFile-7")$
            keep: ^MSHW
            separators: ;
        source(3):
          # Union Volumes (1) and Raid Groups (2)
          # MSHW;systemName;DeviceID;DisplayID;CapacityGB;StripeSize;RAIDGroup;RaidLevel;DiskType;Status;StatusInformation;LogicalDiskType;UseInCapacity;CapacityFreeGB;
          type: tableUnion
          tables:
          - $monitors.logical_disk.collect.sources.source(1)$
          - $monitors.logical_disk.collect.sources.source(2)$
          computes:
            # Translate the Status
            # MSHW;systemName;DeviceID;DisplayID;CapacityGB;StripeSize;RAIDGroup;RaidLevel;DiskType;Status;StatusInformation;LogicalDiskType;UseInCapacity;CapacityFreeGB;
          - type: translate
            column: 10
            translationTable: LogicalDriveStatusTT
      mapping:
        # The value table
        # MSHW;systemName;DeviceID;DisplayID;CapacityGB;StripeSize;RAIDGroup;RaidLevel;DiskType;Status;StatusInformation;LogicalDiskType;UseInCapacity;CapacityFreeGB;
        source: $monitors.logical_disk.collect.sources.source(3)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="logical_disk"}: $column(10)
          hw.logical_disk.usage{state="free"}: $column(14)
          hw.logical_disk.usage{state="used"}: collectAllocatedSpace()
        legacyTextParameters:
          StatusInformation: $column(11)
  fan:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(2)$
          computes:
            # Keep only Fans
            # MSHW_Fan;systemName;deviceID;displayID;Status;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_FAN$
      mapping:
        # The discovery table
        # MSHW_Fan;systemName;deviceID;displayID;Status;Status;
        source: $monitors.fan.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(4)
          hw.parent.type: enclosure
          hw.parent.id: $column(2)
          name: $column(4)
    collect:
      # Collect
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only Fan
            # MSHW_Fan;systemName;deviceID;displayID;Status;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_FAN$
            # Now translate  into OK/Warning/Alarm
            # MSHW_Fan;systemName;deviceID;displayID;PatrolStatus;Status;
          - type: translate
            column: 5
            translationTable: opStatusTT
      mapping:
        # The value table
        # MSHW_Fan;systemName;deviceID;displayID;PatrolStatus;Status;
        source: $monitors.fan.collect.sources.source(1)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="fan"}: $column(5)
        legacyTextParameters:
          StatusInformation: $column(6)
  other_device:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(2)$
          computes:
            # Keep only OtherDevices
            # MSHW_OtherDevice;systemName;deviceID;displayID;Status;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OtherDevice$
      mapping:
        # The discovery table
        # MSHW_OtherDevice;systemName;deviceID;displayID;Status;Status;
        source: $monitors.other_device.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(4)
          hw.parent.type: enclosure
          hw.parent.id: $column(2)
          name: $column(4)
    collect:
      # Collect
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only OtherDevice
            # MSHW_OtherDevice;systemName;deviceID;displayID;Status;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OtherDevice$
            # Now translate  into OK/Warning/Alarm
            # MSHW_OtherDevice;systemName;deviceID;displayID;PatrolStatus;Status;
          - type: translate
            column: 5
            translationTable: opStatusTT
      mapping:
        # The value table
        # MSHW_OtherDevice;systemName;deviceID;displayID;PatrolStatus;Status;
        source: $monitors.other_device.collect.sources.source(1)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="other_device"}: $column(5)
        legacyTextParameters:
          StatusInformation: $column(6)
  memory:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(2)$
          computes:
            # Keep only Memorys
            # MSHW_Memory;systemName;deviceID;displayID;Status;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_Memory$
      mapping:
        # The discovery table
        # MSHW_Memory;systemName;deviceID;displayID;Status;Status;
        source: $monitors.memory.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(4)
          hw.parent.type: enclosure
          hw.parent.id: $column(2)
          name: $column(4)
    collect:
      # Collect
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only Memory
            # MSHW_Memory;systemName;deviceID;displayID;Status;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_Memory$
            # Now translate  into OK/Warning/Alarm
            # MSHW_Memory;systemName;deviceID;displayID;PatrolStatus;Status;
          - type: translate
            column: 5
            translationTable: opStatusTT
      mapping:
        # The value table
        # MSHW_Memory;systemName;deviceID;displayID;PatrolStatus;Status;
        source: $monitors.memory.collect.sources.source(1)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="memory"}: $column(5)
        legacyTextParameters:
          StatusInformation: $column(6)
  network:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(2)$
          computes:
            # Keep only NetworkCards
            # MSHW_NetworkCard;systemName;deviceID;displayID;Status;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_NetworkCard$
      mapping:
        # The discovery table
        # MSHW_NetworkCard;systemName;deviceID;displayID;Status;Status;
        source: $monitors.network.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(4)
          hw.parent.type: enclosure
          hw.parent.id: $column(2)
          name: $column(4)
    collect:
      # Collect
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only NetworkCard
            # MSHW_NetworkCard;systemName;deviceID;displayID;Status;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_NetworkCard$
            # Now translate  into OK/Warning/Alarm
            # MSHW_NetworkCard;systemName;deviceID;displayID;PatrolStatus;Status;
          - type: translate
            column: 5
            translationTable: opStatusTT
      mapping:
        # The value table
        # MSHW_NetworkCard;systemName;deviceID;displayID;PatrolStatus;Status;
        source: $monitors.network.collect.sources.source(1)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="network"}: $column(5)
        legacyTextParameters:
          StatusInformation: $column(6)
  battery:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(2)$
          computes:
            # Keep only Batterys
            # MSHW_Battery;systemName;deviceID;displayID;Status;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_Battery$
      mapping:
        # The discovery table
        # MSHW_Battery;systemName;deviceID;displayID;Status;Status;
        source: $monitors.battery.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(4)
          hw.parent.type: enclosure
          hw.parent.id: $column(2)
          name: $column(4)
    collect:
      # Collect
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only Battery
            # MSHW_Battery;systemName;deviceID;displayID;Status;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_Battery$
            # Now translate  into OK/Warning/Alarm
            # MSHW_Battery;systemName;deviceID;displayID;PatrolStatus;Status;
          - type: translate
            column: 5
            translationTable: opStatusTT
      mapping:
        # The value table
        # MSHW_Battery;systemName;deviceID;displayID;PatrolStatus;Status;
        source: $monitors.battery.collect.sources.source(1)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="battery"}: $column(5)
        legacyTextParameters:
          StatusInformation: $column(6)
  power_supply:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(2)$
          computes:
            # Keep only PowerSupplys
            # MSHW_PowerSupply;systemName;deviceID;displayID;Status;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PowerSupply$
      mapping:
        # The discovery table
        # MSHW_PowerSupply;systemName;deviceID;displayID;Status;Status;
        source: $monitors.power_supply.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(4)
          hw.parent.type: enclosure
          hw.parent.id: $column(2)
          name: $column(4)
    collect:
      # Collect
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only PowerSupply
            # MSHW_PowerSupply;systemName;deviceID;displayID;Status;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PowerSupply$
            # Now translate  into OK/Warning/Alarm
            # MSHW_PowerSupply;systemName;deviceID;displayID;PatrolStatus;Status;
          - type: translate
            column: 5
            translationTable: opStatusTT
      mapping:
        # The value table
        # MSHW_PowerSupply;systemName;deviceID;displayID;PatrolStatus;Status;
        source: $monitors.power_supply.collect.sources.source(1)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="power_supply"}: $column(5)
        legacyTextParameters:
          StatusInformation: $column(6)
translations:
  LogicalDriveStatusTT:
    Normal(Correction: ok
    Normal: ok
    Default: failed
  DriveStatusTT:
    Mounted: ok
    Rebuilding: degraded
    Normal: ok
    Standby: ok
    Default: failed
    Out: ok
  opStatusTT:
    Normal: ok
    Default: failed
