---
connector:
  displayName: HP P2000 G3 or Later (WBEM)
  platforms: HP StorageWorks P2000 G3
  reliesOn: HP P2000 Management Card
  version: 1.0
  information: "This connector discovers the Environmental, Physical Disk, Logical Disk, Management Network Cards and Fibre Ports on P2000 G3 later Series Filers through the Embedded SMI-S Provider"
  detection:
    connectionTypes:
    - remote
    appliesTo:
    - Storage
    supersedes:
    - MIB2
    - HPDotHill
    criteria:
    - type: wbem
      namespace: root/hpq
      query: SELECT Name FROM HP_TopComputerSystem
    # There also must be a chassis
    - type: wbem
      query: SELECT Tag FROM HP_TopComputerSystemChassis
      namespace: root/hpq
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Source(1) = HP_TopComputerSystem  (This is the main class we'll be linking everything from)
          # HP_TopComputerSystem,Name,Caption,OtherIdentifyingInfo
          type: wbem
          query: "SELECT __Path,Name,Caption,OtherIdentifyingInfo FROM HP_TopComputerSystem"
          namespace: root/hpq
        source(2):
          # Source(2) = HP_TopComputerSystemChassis
          # HP_TopComputerSystemChassis,Model,SerialNumber
          type: wbem
          query: "SELECT __Path,Model,SerialNumber FROM HP_TopComputerSystemChassis"
          namespace: root/hpq
        source(3):
          # Source (20 = Association table for HP_TopComputerSystem to HP_TopComputerSystemChassis
          # HP_TopComputerSystemChassis,HP_TopComputerSystem
          type: wbem
          query: "SELECT Antecedent,Dependent FROM HP_TCS2TCSC"
          namespace: root/hpq
        source(4):
          # Link the System to the Association Table
          # HP_TopComputerSystem,Name,Caption,OtherIdentifyingInfo,HP_TopComputerSystemChassis,HP_TopComputerSystem
          type: tableJoin
          leftTable: "${source::monitors.enclosure.discovery.sources.source(1)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(3)}"
          leftKeyColumn: 1
          rightKeyColumn: 2
          keyType: Wbem
        source(5):
          # Link the System and Association Table to the the Chassis
          # HP_TopComputerSystem,Name,Caption,OtherIdentifyingInfo,HP_TopComputerSystemChassis,HP_TopComputerSystem,HP_TopComputerSystemChassis,Model,SerialNumber
          type: tableJoin
          leftTable: "${source::monitors.enclosure.discovery.sources.source(4)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(2)}"
          leftKeyColumn: 5
          rightKeyColumn: 1
          keyType: Wbem
          computes:
            # Get rid of the Paths so that we can read the table
            # HP_TopComputerSystem,Name,Caption,OtherIdentifyingInfo,HP_TopComputerSystemChassis,HP_TopComputerSystem,HP_TopComputerSystemChassis,Model,SerialNumber
            # Name,Caption,OtherIdentifyingInfo,Model,SerialNumber
          - type: keepColumns
            columnNumbers: "2,3,4,8,9"
          - type: replace
            column: 3
            existingValue: '|'
            newValue: ""
          - type: leftConcat
            column: 3
            value: "IP Address: "
        source(6):
          # Get the Controller Id
          # HP_Controller,ControllerID
          type: wbem
          query: "SELECT __PATH,Name FROM HP_Controller"
          namespace: root/hpq
        source(7):
          # Need to build controller to system for attaching ports to systems
          # HP_TopComputerSystem,HP_Controller
          type: wbem
          query: "SELECT GroupComponent,PartComponent FROM HP_TCS2C"
          namespace: root/hpq
        source(8):
          # Link TopComputerSystem to the Association Table
          # HP_Controller,ControllerID,HP_TopComputerSystem,HP_Controller
          type: tableJoin
          leftTable: "${source::monitors.enclosure.discovery.sources.source(6)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(7)}"
          leftKeyColumn: 1
          rightKeyColumn: 2
          keyType: Wbem
        source(9):
          # Attach the Controller table to the System/Association Table.
          # HP_Controller,ControllerID,HP_TopComputerSystem,HP_Controller,HP_TopComputerSystem,SystemID,Caption,OtherIdentifyingInfo
          type: tableJoin
          leftTable: "${source::monitors.enclosure.discovery.sources.source(8)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(1)}"
          leftKeyColumn: 3
          rightKeyColumn: 1
          keyType: Wbem
          computes:
            # Keep only the SystemID and ControllerID
            # ControllerID;SystemID;
          - type: keepColumns
            columnNumbers: "2,6"
      mapping:
        # Instance Table
        # Name,Caption,OtherIdentifyingInfo,Model,SerialNumber
        source: "${source::monitors.enclosure.discovery.sources.source(5)}"
        attributes:
          id: $1
          __display_id: $2
          vendor: HP
          model: $4
          serial_number: $5
          type: Storage
          info: $3
          name: "${awk::sprintf(\"Storage: %s (%s %s)\", $2, \"HP\", $4)}"
    collect:
      # Collect type is multiinstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = CIM_ComputerSystem
          # Name;OperationalStatus;
          type: wbem
          query: "SELECT Name,OperationalStatus FROM HP_TopComputerSystem"
          namespace: root/hpq
          computes:
            # Duplicate the "OperationalStatusArray" column
            # Name;OperationalStatus;OperationalStatus;
          - type: duplicateColumn
            column: 2
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # Name;PATROLStatusArray;OperationalStatus;
          - type: arrayTranslate
            column: 2
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # Name;PATROLStatusArray;StatusDescriptions;
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # Name;PATROLStatus;StatusDescriptions;
          - type: convert
            column: 2
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # Name;PATROLStatus;StatusDescriptions;
        source: "${source::monitors.enclosure.collect.sources.source(1)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="enclosure"}: $2
        legacyTextParameters:
          StatusInformation: $3
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = HP_DiskDrive  (This is the main class we'll be linking everything from)
          # HP_DiskDrive,DeviceID,SystemName,DiskType,MaxMediaSize
          type: wbem
          query: "SELECT __Path,DeviceID,SystemName,DiskType,MaxMediaSize FROM HP_DiskDrive"
          namespace: root/hpq
          computes:
            # Multiply the Size by 1000
            # HP_DiskDrive,DeviceID,SystemName,DiskType,Size
          - type: multiply
            column: 5
            value: 1000
            # Translate the Disk Type
            # HP_DiskDrive,DeviceID,SystemName,DiskType,Size
          - type: translate
            column: 4
            translationTable: "${translation::PhysicalDiskTypeTranslationTable}"
        source(2):
          # Source(2) = HP_DiskDriveTray
          # HP_DiskDriveTray,Model,SerialNumber,Version
          type: wbem
          query: "SELECT __Path,Model,SerialNumber,Version FROM HP_DiskDriveTray"
          namespace: root/hpq
        source(3):
          # Source (20 = Association table for HP_DiskDriveTray to HP_DiskDrive
          # HP_DiskDriveTray,HP_DiskDrive
          type: wbem
          query: "SELECT Antecedent,Dependent FROM HP_DD2DDT"
          namespace: root/hpq
        source(4):
          # Link the System to the Association Table
          # HP_DiskDrive,DeviceID,SystemName,DiskType,MaxMediaSize,HP_DiskDriveTray,HP_DiskDrive
          type: tableJoin
          leftTable: "${source::monitors.physical_disk.discovery.sources.source(1)}"
          rightTable: "${source::monitors.physical_disk.discovery.sources.source(3)}"
          leftKeyColumn: 1
          rightKeyColumn: 2
          keyType: Wbem
        source(5):
          # Link the System and Association Table to the the Chassis
          # HP_DiskDrive,DeviceID,SystemName,DiskType,MaxMediaSize,HP_DiskDriveTray,HP_DiskDrive,HP_DiskDriveTray,Model,SerialNumber,Version
          type: tableJoin
          leftTable: "${source::monitors.physical_disk.discovery.sources.source(4)}"
          rightTable: "${source::monitors.physical_disk.discovery.sources.source(2)}"
          leftKeyColumn: 6
          rightKeyColumn: 1
          keyType: Wbem
          computes:
            # Get rid of the Paths so that we can read the table
            # HP_DiskDrive,DeviceID,SystemName,DiskType,Size,HP_DiskDriveTray,HP_DiskDrive,HP_DiskDriveTray,Model,SerialNumber,Version
            # DeviceID,SystemName,DiskType,Size,Model,SerialNumber,Version
          - type: keepColumns
            columnNumbers: "2,3,4,5,9,10,11"
          - type: leftConcat
            column: 3
            value: "Type: "
      mapping:
        # Instance Table
        # DeviceID,SystemName,DiskType,MaxMediaSize,Model,SerialNumber,Version
        source: "${source::monitors.physical_disk.discovery.sources.source(5)}"
        attributes:
          id: $1
          __display_id: $1
          model: $5
          serial_number: $6
          info: "${awk::join(\" \", $7, $3)}"
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s (%s)\", $1, bytes2HumanFormatBase10($4))}"
        metrics:
          hw.physical_disk.size: $4
    collect:
      # Collect type is multiinstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = HP_PSU
          # DeviceID;OperationalStatus;
          type: wbem
          query: "SELECT DeviceID,OperationalStatus FROM HP_DiskDrive"
          namespace: root/hpq
          computes:
            # Duplicate the "OperationalStatusArray" column
            # DeviceID;OperationalStatus;OperationalStatus;
          - type: duplicateColumn
            column: 2
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # DeviceID;PATROLStatusArray;OperationalStatus;
          - type: arrayTranslate
            column: 2
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # DeviceID;PATROLStatusArray;StatusDescriptions;
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # DeviceID;PATROLStatus;StatusDescriptions;
          - type: convert
            column: 2
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # DeviceID;PATROLStatus;StatusDescriptions;
        source: "${source::monitors.physical_disk.collect.sources.source(1)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="physical_disk"}: $2
        legacyTextParameters:
          StatusInformation: $3
  power_supply:
    discovery:
      sources:
        source(1):
          # Source(1) = HP_PSU
          # DeviceID,SystemName,Name
          type: wbem
          query: "SELECT DeviceID,SystemName,Name FROM HP_PSU"
          namespace: root/hpq
      mapping:
        # Instance Table
        # DeviceID,SystemName,Name
        source: "${source::monitors.power_supply.discovery.sources.source(1)}"
        attributes:
          id: $1
          __display_id: $3
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $3
    collect:
      # Collect type is multiinstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = HP_PSU
          # DeviceID;OperationalStatus;
          type: wbem
          query: "SELECT DeviceID,OperationalStatus FROM HP_PSU"
          namespace: root/hpq
          computes:
            # Duplicate the "OperationalStatusArray" column
            # DeviceID;OperationalStatus;OperationalStatus;
          - type: duplicateColumn
            column: 2
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # DeviceID;PATROLStatusArray;OperationalStatus;
          - type: arrayTranslate
            column: 2
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # DeviceID;PATROLStatusArray;StatusDescriptions;
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # DeviceID;PATROLStatus;StatusDescriptions;
          - type: convert
            column: 2
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # DeviceID;PATROLStatus;StatusDescriptions;
        source: "${source::monitors.power_supply.collect.sources.source(1)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="power_supply"}: $2
        legacyTextParameters:
          StatusInformation: $3
  temperature:
    discovery:
      sources:
        source(1):
          # Source(1) = HP_OverallTempSensor
          # DeviceID,SystemName,Name
          type: wbem
          query: "SELECT DeviceID,SystemName,Caption FROM HP_OverallTempSensor"
          namespace: root/hpq
      mapping:
        # Instance Table
        # DeviceID,SystemName,Name
        source: "${source::monitors.temperature.discovery.sources.source(1)}"
        attributes:
          id: $1
          __display_id: $3
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $3
    collect:
      # Collect type is multiinstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = HP_OverallTempSensor
          # DeviceID;OperationalStatus;
          type: wbem
          query: "SELECT DeviceID,OperationalStatus FROM HP_OverallTempSensor"
          namespace: root/hpq
          computes:
            # Duplicate the "OperationalStatusArray" column
            # DeviceID;OperationalStatus;OperationalStatus;
          - type: duplicateColumn
            column: 2
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # DeviceID;PATROLStatusArray;OperationalStatus;
          - type: arrayTranslate
            column: 2
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # DeviceID;PATROLStatusArray;StatusDescriptions;
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # DeviceID;PATROLStatus;StatusDescriptions;
          - type: convert
            column: 2
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # DeviceID;PATROLStatus;StatusDescriptions;
        source: "${source::monitors.temperature.collect.sources.source(1)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="temperature"}: $2
        legacyTextParameters:
          StatusInformation: $3
  voltage:
    discovery:
      sources:
        source(1):
          # Source(1) = HP_SuperCap
          # DeviceID,SystemName,Name,HealthState
          type: wbem
          query: "SELECT DeviceID,SystemName,Caption,HealthState FROM HP_SuperCap"
          namespace: root/hpq
          computes:
            # Exclude Ports with a HealthState of "0" (ports don't exist)
            # DeviceID,SystemName,Name,HealthState
          - type: excludeMatchingLines
            column: 4
            valueList: 0
      mapping:
        # Instance Table
        # DeviceID,SystemName,Name
        source: "${source::monitors.voltage.discovery.sources.source(1)}"
        attributes:
          id: $1
          __display_id: $3
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $3
    collect:
      # Collect type is multiinstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = CIM_ComputerSystem
          # DeviceID;OperationalStatus;
          type: wbem
          query: "SELECT DeviceID,OperationalStatus FROM HP_SuperCap"
          namespace: root/hpq
          computes:
            # Duplicate the "OperationalStatusArray" column
            # DeviceID;OperationalStatus;OperationalStatus;
          - type: duplicateColumn
            column: 2
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # DeviceID;PATROLStatusArray;OperationalStatus;
          - type: arrayTranslate
            column: 2
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # DeviceID;PATROLStatusArray;StatusDescriptions;
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # DeviceID;PATROLStatus;StatusDescriptions;
          - type: convert
            column: 2
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # DeviceID;PATROLStatus;StatusDescriptions;
        source: "${source::monitors.voltage.collect.sources.source(1)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="voltage"}: $2
        legacyTextParameters:
          StatusInformation: $3
  fan:
    discovery:
      sources:
        source(1):
          # Source(1) = HP_PSUFan
          # DeviceID,SystemName,Name
          type: wbem
          query: "SELECT DeviceID,SystemName,Name FROM HP_HP_PSUFanPSU"
          namespace: root/hpq
      mapping:
        # Instance Table
        # DeviceID,SystemName,Name
        source: "${source::monitors.fan.discovery.sources.source(1)}"
        attributes:
          id: $1
          __display_id: $3
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $3
    collect:
      # Collect type is multiinstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = HP_PSUFan
          # DeviceID;OperationalStatus;
          type: wbem
          query: "SELECT DeviceID,OperationalStatus FROM HP_PSUFan"
          namespace: root/hpq
          computes:
            # Duplicate the "OperationalStatusArray" column
            # DeviceID;OperationalStatus;OperationalStatus;
          - type: duplicateColumn
            column: 2
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # DeviceID;PATROLStatusArray;OperationalStatus;
          - type: arrayTranslate
            column: 2
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # DeviceID;PATROLStatusArray;StatusDescriptions;
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # DeviceID;PATROLStatus;StatusDescriptions;
          - type: convert
            column: 2
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # DeviceID;PATROLStatus;StatusDescriptions;
        source: "${source::monitors.fan.collect.sources.source(1)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="fan"}: $2
        legacyTextParameters:
          StatusInformation: $3
  other_device:
    discovery:
      sources:
        source(1):
          # Source(1) = HP_ControllerDevice
          # DeviceID,SystemName,Name
          type: wbem
          query: "SELECT DeviceID,SystemName,ElementName FROM HP_ControllerDevice"
          namespace: root/hpq
          computes:
            # Add the Type
            # DeviceID,SystemName,Name,Type
          - type: rightConcat
            column: 3
            value: ;Controller
        source(2):
          # Source (2) = HP_TopComputerSystemControllerCard
          # DeviceID,Name
          type: wbem
          query: "SELECT InstanceID,ElementName FROM HP_TopComputerSystemControllerCard"
          namespace: root/hpq
        source(3):
          # Match the HP_ControllerDevice with the HP_TopComputerSystemControllerCard
          # DeviceID,SystemName,Name,Type,DeviceID,Name
          type: tableJoin
          leftTable: "${source::monitors.other_device.discovery.sources.source(1)}"
          rightTable: "${source::monitors.other_device.discovery.sources.source(2)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          computes:
            # Replace the HP_ControllerDevice's Name with the HP_TopComputerSystemControllerCard
            # DeviceID,SystemName,Name,Type,DeviceID,Name
          - type: replace
            column: 3
            existingValue: $3
            newValue: $6
            # Remove extra columns
            # DeviceID,SystemName,Name,Type
          - type: keepColumns
            columnNumbers: "1,2,3,4"
            # Remove "Controller " from the display ID
            # DeviceID,SystemName,Name,Type
          - type: replace
            column: 3
            existingValue: 'Controller '
            newValue: ""
        source(4):
          # Source(2) = HP_DiskSASPort
          # DeviceID,SystemName,Name
          type: wbem
          query: "SELECT DeviceID,SystemName,Name FROM HP_DiskSASPort"
          namespace: root/hpq
          computes:
            # Add the Type
            # DeviceID,SystemName,Name,Type
          - type: rightConcat
            column: 3
            value: ;DiskSASPort
        source(5):
          # Source(2) = HP_SASPort
          # DeviceID,ControllerID,Name,HealthState
          type: wbem
          query: "SELECT DeviceID,SystemName,ElementName,HealthState FROM HP_SASPort"
          namespace: root/hpq
          computes:
            # Exclude Ports with a HealthState of "0" (ports don't exist)
            # DeviceID,ControllerID,Name,HealthState
          - type: excludeMatchingLines
            column: 4
            valueList: 0
            # Remove Health State
            # DeviceID,ControllerID,Name
          - type: keepColumns
            columnNumbers: "1,2,3"
            # Add the Type
            # DeviceID,ControllerID,Name,Type
          - type: rightConcat
            column: 3
            value: ;SASPort
            # Change Underscores to Spaces
            # DeviceID,ControllerID,Name,Type
          - type: replace
            column: 3
            existingValue: _
            newValue: ' '
        source(6):
          # Try and match the SASPort's Controller with the System
          # DeviceID,ControllerID,Name,Type,ControllerID,SystemID
          type: tableJoin
          leftTable: "${source::monitors.other_device.discovery.sources.source(5)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(9)}"
          leftKeyColumn: 2
          rightKeyColumn: 1
          computes:
            # Move the SystemID to Column 2
            # DeviceID,SystemID,Name,Type,ControllerID,SystemID
          - type: replace
            column: 2
            existingValue: $2
            newValue: $6
            # Trim the table down
            # DeviceID,SystemID,Name,Type
          - type: keepColumns
            columnNumbers: "1,2,3,4"
        source(7):
          # Union of 1, 2 & 3
          # DeviceID,SystemName,Name,Type
          type: tableUnion
          tables:
          - "${source::monitors.other_device.discovery.sources.source(3)}"
          - "${source::monitors.other_device.discovery.sources.source(4)}"
          - "${source::monitors.other_device.discovery.sources.source(6)}"
      mapping:
        # Instance Table
        # DeviceID,SystemName,Name,Type
        source: "${source::monitors.other_device.discovery.sources.source(7)}"
        attributes:
          id: $1
          __display_id: $3
          device_type: $4
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s: %s\", $4, $3)}"
    collect:
      # Collect type is multiinstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = HP_ControllerDevice
          # DeviceID;OperationalStatus;
          type: wbem
          query: "SELECT DeviceID,OperationalStatus FROM HP_ControllerDevice"
          namespace: root/hpq
        source(2):
          # Source(2) = HP_SASPort
          # DeviceID;OperationalStatus;
          type: wbem
          query: "SELECT DeviceID,OperationalStatus FROM HP_SASPort"
          namespace: root/hpq
        source(3):
          # Source(3) = HP_DiskSASPort
          # DeviceID;OperationalStatus;
          type: wbem
          query: "SELECT DeviceID,OperationalStatus FROM HP_DiskSASPort"
          namespace: root/hpq
        source(4):
          # Union of 1, 2 & 3
          # DeviceID;OperationalStatus;
          type: tableUnion
          tables:
          - "${source::monitors.other_device.collect.sources.source(1)}"
          - "${source::monitors.other_device.collect.sources.source(2)}"
          - "${source::monitors.other_device.collect.sources.source(3)}"
          computes:
            # Duplicate the "OperationalStatusArray" column
            # DeviceID;OperationalStatus;OperationalStatus;
          - type: duplicateColumn
            column: 2
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # DeviceID;PATROLStatusArray;OperationalStatus;
          - type: arrayTranslate
            column: 2
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # DeviceID;PATROLStatusArray;StatusDescriptions;
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # DeviceID;PATROLStatus;StatusDescriptions;
          - type: convert
            column: 2
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # DeviceID;PATROLStatus;StatusDescriptions;
        source: "${source::monitors.other_device.collect.sources.source(4)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="other_device"}: $2
        legacyTextParameters:
          StatusInformation: $3
  logical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = CIM_StoragePool
          # InstanceID,SystemName,ElementName,TotalManagedSpace
          type: wbem
          query: "SELECT InstanceID,SystemName,ElementName,TotalManagedSpace FROM CIM_StoragePool"
          namespace: root/hpq
      mapping:
        # Instance Table
        # DeviceID,SystemName,Name,TotalManagedSpace
        source: "${source::monitors.logical_disk.discovery.sources.source(1)}"
        attributes:
          id: $1
          __display_id: $3
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s (%s)\", $3, bytes2HumanFormatBase2($4))}"
        metrics:
          hw.logical_disk.limit: $4
    collect:
      # Collect type is multiinstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = CIM_StoragePool
          # InstanceID;OperationalStatus;
          type: wbem
          query: "SELECT InstanceID,OperationalStatus FROM CIM_StoragePool"
          namespace: root/hpq
          computes:
            # Duplicate the "OperationalStatusArray" column
            # InstanceID;OperationalStatus;OperationalStatus;
          - type: duplicateColumn
            column: 2
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # InstanceID;PATROLStatusArray;OperationalStatus;
          - type: arrayTranslate
            column: 2
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # InstanceID;PATROLStatusArray;StatusDescriptions;
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # InstanceID;PATROLStatus;StatusDescriptions;
          - type: convert
            column: 2
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # InstanceID;PATROLStatus;StatusDescriptions;
        source: "${source::monitors.logical_disk.collect.sources.source(1)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="logical_disk"}: $2
        legacyTextParameters:
          StatusInformation: $3
  network:
    discovery:
      sources:
        source(1):
          # Source(1) = HP_FCPort
          # DeviceID,ControllerID,Name,HealthState,PermanentAddress
          type: wbem
          query: "SELECT DeviceID,SystemName,Name,HealthState,PermanentAddress FROM HP_FCPort"
          namespace: root/hpq
          computes:
            # Add the AddressType and Type
            # DeviceID,ControllerID,AddressType,Name,HealthState,PermanentAddress
          - type: leftConcat
            column: 3
            value: WWN;FC-
        source(2):
          # Source(2) = HP_EthernetPort
          # DeviceID,ControllerID,Name,HealthState,PermanentAddress
          type: wbem
          query: "SELECT DeviceID,SystemName,Name,HealthState,PermanentAddress FROM HP_EthernetPort"
          namespace: root/hpq
          computes:
            # Add the AddressType
            # DeviceID,ControllerID,AddressType,Name,HealthState,PermanentAddress
          - type: leftConcat
            column: 3
            value: ;
        source(3):
          # Union of 1 & 2
          # DeviceID,ControllerID,AddressType,Name,HealthState,PermanentAddress
          type: tableUnion
          tables:
          - "${source::monitors.network.discovery.sources.source(1)}"
          - "${source::monitors.network.discovery.sources.source(2)}"
          computes:
            # Exclude Ports with a HealthState of "0" (ports don't exist)
            # DeviceID,ControllerID,AddressType,Name,HealthState,PermanentAddress
          - type: excludeMatchingLines
            column: 5
            valueList: 0
        source(4):
          # Try and match the SASPort's Controller with the System
          # DeviceID,ControllerID,AddressType,Name,HealthState,PermanentAddress,ControllerID,SystemID
          type: tableJoin
          leftTable: "${source::monitors.network.discovery.sources.source(3)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(9)}"
          leftKeyColumn: 2
          rightKeyColumn: 1
      mapping:
        # Instance Table
        # DeviceID,ControllerID,AddressType,Name,HealthState,PermanentAddress,ControllerID,SystemID
        source: "${source::monitors.network.discovery.sources.source(4)}"
        attributes:
          id: $1
          __display_id: $4
          physical_address: $6
          physical_address_type: $3
          hw.parent.type: enclosure
          hw.parent.id: $8
          name: $4
    collect:
      # Collect type is multiinstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = HP_ControllerDevice
          # DeviceID;OperationalStatus;Speed;
          type: wbem
          query: "SELECT DeviceID,OperationalStatus,Speed FROM HP_FCPort"
          namespace: root/hpq
        source(2):
          # Source(2) = HP_SASPort
          # DeviceID;OperationalStatus;Speed;
          type: wbem
          query: "SELECT DeviceID,OperationalStatus,Speed FROM HP_EthernetPort"
          namespace: root/hpq
        source(3):
          # Union of 1, 2 & 3
          # DeviceID;OperationalStatus;Speed;
          type: tableUnion
          tables:
          - "${source::monitors.network.collect.sources.source(1)}"
          - "${source::monitors.network.collect.sources.source(2)}"
          computes:
            # Duplicate the "OperationalStatusArray" column
            # DeviceID;OperationalStatus;OperationalStatus;Speed;
          - type: duplicateColumn
            column: 2
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # DeviceID;PATROLStatusArray;OperationalStatus;Speed;
          - type: arrayTranslate
            column: 2
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # DeviceID;PATROLStatusArray;StatusDescriptions;Speed;
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # DeviceID;PATROLStatus;StatusDescriptions;Speed;
          - type: convert
            column: 2
            conversion: array2SimpleStatus
            # Duplicate the Speed
            # DeviceID;PATROLStatus;StatusDescriptions;Speed;Speed;
          - type: duplicateColumn
            column: 4
            # Translate a Speed into the Link Status
            # DeviceID;PATROLStatus;StatusDescriptions;LinkStatus;Speed;
          - type: translate
            column: 4
            translationTable: "${translation::LinkstatusTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        # DeviceID;PATROLStatus;StatusDescriptions;LinkStatus;Speed;
        source: "${source::monitors.network.collect.sources.source(3)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="network"}: $2
          hw.network.up: legacyLinkStatus($4)
          hw.network.bandwidth.limit: megaBit2Bit($5)
        legacyTextParameters:
          StatusInformation: $3
translations:
  PhysicalDiskTypeTranslationTable:
    "2": HDD
    "3": SSD
    "4": Hybrid
    Default: ""
  DMTFOperationStatusTranslationTable:
    "11": degraded
    "12": failed
    "13": failed
    "14": failed
    "15": ok
    "16": degraded
    "17": ok
    "18": ok
    Default: UNKNOWN
    "2": ok
    "3": degraded
    "4": degraded
    "5": degraded
    "6": failed
    "7": failed
    "8": degraded
    "9": degraded
    "10": failed
  DMTFOperationStatusInformationTranslationTable:
    "11": In Service
    "12": No Contact
    "13": Lost Communication
    "14": Aborted
    "15": Dormant
    "16": Supporting Entity in Error
    "17": Completed
    "18": Power Mode
    Default: ""
    "2": ""
    "3": Degraded
    "4": Stressed
    "5": Predicted Failure
    "6": Error
    "7": Non-Recoverable Error
    "8": Starting
    "9": Stopping
    "10": Stopped
  LinkstatusTranslationTable:
    "0": degraded
    Default: ok
