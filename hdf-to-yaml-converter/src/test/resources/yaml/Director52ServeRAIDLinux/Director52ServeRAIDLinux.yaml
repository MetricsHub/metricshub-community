---
connector:
  displayName: SMI-S Compliant RAID Controller - Linux
  platforms: Any system with RAID Controller
  reliesOn: SMI-S Compliant WBEM Provider
  version: 1.2
  information: This connector provides disk controller monitoring through any SMI-S compliant WBEM provider.
  detection:
    connectionTypes:
    - remote
    - local
    appliesTo:
    - Linux
    - OOB
    supersedes:
    - SMISDiskArray
    - VMwareESXiDisksStorage
    - VMwareESXiDisksIPMI
    - LSIMegaRaidSAS5
    - LSIMegaRaidSAS
    - LSIUtilUNIX
    criteria:
    # OS must be Linux
    - type: deviceType
      keep:
      - Linux
      - OOB
    # Verify that there is a WBEM namespace with a CIM_ComputerSystem.Dedicated == 3
    - type: wbem
      namespace: Automatic
      query: SELECT Dedicated FROM CIM_ComputerSystem
      expectedResult: \(^30|\)\|\(|30|\)\|\(^3|\)\|\(|3|\)\|\(^2|\)\|\(|2|\)
    # There must be disk drives declared int he root/LSI_IR_1_2_0 namespace
    - type: wbem
      query: SELECT Name FROM CIM_DiskDrive
      namespace: Automatic
monitors:
  disk_controller:
    discovery:
      sources:
        source(1):
          # Source(1) = CIM_ComputerSystem
          # This class is linked to many useful information and actually represents the RAID controller
          # ComputerSystemID;Dedicated;Name;
          type: wbem
          query: "SELECT __PATH,Dedicated,Name FROM CIM_ComputerSystem"
          namespace: Automatic
          computes:
            # Keep only CIM_ComputerSystems that are RAID controllers
            # ComputerSystemID;Dedicated;Name;
          - type: keepOnlyMatchingLines
            column: 2
            regExp: \(^30|\)\|\(|30|\)\|\(^3|\)\|\(|3|\)\|\(^2|\)\|\(|2|\)
            # This is bad, but I can't find another way to exclude "enclosure" instances, which I can't care less in this case
            # ComputerSystemID;Dedicated;Name;
          - type: excludeMatchingLines
            column: 1
            regExp: "[Ee]nclosure"
        source(2):
          # Source(2) = CIM_LogicalIdentity
          # This is the link between CIM_ComputerSystem and CIM_PortController
          # SameElement;SystemElement;
          type: wbem
          query: "SELECT SameElement,SystemElement FROM CIM_LogicalIdentity"
          namespace: Automatic
        source(3):
          # Source(3) = CIM_Realizes
          # Makes the link between CIM_PortController and CIM_Card
          # PhysicalPackageID;LogicalElementID;
          type: wbem
          query: "SELECT Antecedent,Dependent FROM CIM_Realizes"
          namespace: Automatic
        source(4):
          # Source(4) = CIM_Card
          # CardTag;Manufacturer;Model;SerialNumber;
          type: wbem
          query: "SELECT __PATH,Manufacturer,Model,SerialNumber FROM CIM_Card"
          namespace: Automatic
        source(5):
          # Source(5) = CIM_ElementSoftwareIdentity
          # Makes the link between CIM_SoftwareIdentity and CIM_ComputerSystem
          # SoftwareID;ComputerSystemID;
          type: wbem
          query: "SELECT Antecedent,Dependent FROM CIM_ElementSoftwareIdentity"
          namespace: Automatic
        source(6):
          # Source(6) = CIM_SoftwareIdentity
          # SoftwareID;Classifications;VersionString
          type: wbem
          query: "SELECT __PATH,Classifications,VersionString FROM CIM_SoftwareIdentity"
          namespace: Automatic
          computes:
            # Take the first classification item from the "Classifications" column, which actually is an array
            # SoftwareID;Classification;VersionString
          - type: extract
            column: 2
            subColumn: 1
            subSeparators: '|'
        source(7):
          # Source(7) = Copy of Source(6) [CIM_SoftwareIdentity], but with only where Classifications == 11, i.e. BIOS
          # SoftwareID;Classifications;BIOSVersion;
          type: copy
          from: "${source::monitors.disk_controller.discovery.sources.source(6)}"
          computes:
          - type: keepOnlyMatchingLines
            column: 2
            valueList: 11
        source(8):
          # Source(8) = Copy of Source(6) [CIM_SoftwareIdentity], but with only where Classifications == 10, i.e. Firmware
          # SoftwareID;Classifications;FirmwareVersion
          type: copy
          from: "${source::monitors.disk_controller.discovery.sources.source(6)}"
          computes:
          - type: keepOnlyMatchingLines
            column: 2
            valueList: 10
        source(9):
          # Source(9) = Copy of Source(6) [CIM_SoftwareIdentity], but with only where Classifications == 2, i.e. Driver
          # SoftwareID;Classifications;DriverVersion
          type: copy
          from: "${source::monitors.disk_controller.discovery.sources.source(6)}"
          computes:
          - type: keepOnlyMatchingLines
            column: 2
            valueList: 2
        source(10):
          # Source(10) = Table joint between Source(1) and Source(2)
          # ComputerSystemID;Dedicated;Name;SameElement;SystemElement;
          type: tableJoin
          leftTable: "${source::monitors.disk_controller.discovery.sources.source(1)}"
          rightTable: "${source::monitors.disk_controller.discovery.sources.source(2)}"
          leftKeyColumn: 1
          rightKeyColumn: 2
          keyType: Wbem
          defaultRightLine: RemoveMe;;
        source(11):
          # Source(11) = Table joint between Source(3) and Source(4)
          # PhysicalPackageID;LogicalElementID;CardTag;Manufacturer;Model;SerialNumber;
          type: tableJoin
          leftTable: "${source::monitors.disk_controller.discovery.sources.source(3)}"
          rightTable: "${source::monitors.disk_controller.discovery.sources.source(4)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          keyType: Wbem
          defaultRightLine: ;;;;
        source(12):
          # Source(12) = Table joint between Source(10) and Source(11)
          # ComputerSystemID;Dedicated;Name;SameElement;SystemElement;PhysicalPackageID;LogicalElementID;CardTag;Manufacturer;Model;SerialNumber;
          type: tableJoin
          leftTable: "${source::monitors.disk_controller.discovery.sources.source(10)}"
          rightTable: "${source::monitors.disk_controller.discovery.sources.source(11)}"
          leftKeyColumn: 4
          rightKeyColumn: 2
          keyType: Wbem
          defaultRightLine: ;;;;;;
          computes:
            # Keep only useful columns
            # ComputerSystemID;Name;Manufacturer;Model;SerialNumber;
          - type: keepColumns
            columnNumbers: "1,3,9,10,11"
        source(13):
          # Source(13) = Table joint between Source(5) and Source(7)
          # SoftwareID;ComputerSystemID;SoftwareID;Classifications;BIOSVersion;
          type: tableJoin
          leftTable: "${source::monitors.disk_controller.discovery.sources.source(5)}"
          rightTable: "${source::monitors.disk_controller.discovery.sources.source(7)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          keyType: Wbem
        source(14):
          # Source(14) = Table joint between Source(5) and Source(8)
          # SoftwareID;ComputerSystemID;SoftwareID;Classifications;FirmwareVersion;
          type: tableJoin
          leftTable: "${source::monitors.disk_controller.discovery.sources.source(5)}"
          rightTable: "${source::monitors.disk_controller.discovery.sources.source(8)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          keyType: Wbem
        source(15):
          # Source(15) = Table joint between Source(5) and Source(9)
          # SoftwareID;ComputerSystemID;SoftwareID;Classifications;DriverVersion;
          type: tableJoin
          leftTable: "${source::monitors.disk_controller.discovery.sources.source(5)}"
          rightTable: "${source::monitors.disk_controller.discovery.sources.source(9)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          keyType: Wbem
        source(16):
          # Source(16) = Table joint between Source(12) and Source(13)
          # ComputerSystemID;Name;Manufacturer;Model;SerialNumber;SoftwareID;ComputerSystemID;SoftwareID;Classifications;BIOSVersion;
          type: tableJoin
          leftTable: "${source::monitors.disk_controller.discovery.sources.source(12)}"
          rightTable: "${source::monitors.disk_controller.discovery.sources.source(13)}"
          leftKeyColumn: 1
          rightKeyColumn: 2
          keyType: Wbem
          defaultRightLine: ;;;;;
        source(17):
          # Source(17) = Table joint between Source(14) and Source(15)
          # SoftwareID;ComputerSystemID;SoftwareID;Classifications;FirmwareVersion;SoftwareID;ComputerSystemID;SoftwareID;Classifications;DriverVersion;
          type: tableJoin
          leftTable: "${source::monitors.disk_controller.discovery.sources.source(14)}"
          rightTable: "${source::monitors.disk_controller.discovery.sources.source(15)}"
          leftKeyColumn: 2
          rightKeyColumn: 2
          keyType: Wbem
          defaultRightLine: ;;;;;
        source(18):
          # Source(18) = Table joint between Source(16) and Source(17)
          # ComputerSystemID;Name;Manufacturer;Model;SerialNumber;SoftwareID;ComputerSystemID;SoftwareID;Classifications;BIOSVersion;SoftwareID;ComputerSystemID;SoftwareID;Classifications;FirmwareVersion;SoftwareID;ComputerSystemID;SoftwareID;Classifications;DriverVersion;
          type: tableJoin
          leftTable: "${source::monitors.disk_controller.discovery.sources.source(16)}"
          rightTable: "${source::monitors.disk_controller.discovery.sources.source(17)}"
          leftKeyColumn: 1
          rightKeyColumn: 2
          keyType: Wbem
          defaultRightLine: ;;;;;;;;;;
          computes:
            # Keep only useful columns (makes things clearer)
            # ComputerSystemID;Name;Manufacturer;Model;SerialNumber;BIOSVersion;FirmwareVersion;DriverVersion;
          - type: keepColumns
            columnNumbers: "1,2,3,4,5,10,15,20"
            # Exclude any PartComponents (DeviceIDs) of "Empty" that have made it this far
            # ComputerSystemID;Name;Manufacturer;Model;SerialNumber;BIOSVersion;FirmwareVersion;DriverVersion;
          - type: excludeMatchingLines
            column: 1
            regExp: ^$
        source(19):
          # Source(19) = CIM_SystemDevice
          # Will be useful for physical and logical disks discovery (to attach them to the controller)
          # GroupComponent;PartComponent
          type: wbem
          query: "SELECT GroupComponent,PartComponent FROM CIM_SystemDevice"
          namespace: Automatic
        source(20):
          # Source(20) = table joint of source(19) and source(18)
          # This is just to keep only cim_systemdevice instances that correspond to the RAID controller, and not to other painfully useless other objects
          # GroupComponent;PartComponent;ComputerSystemID;Name;Manufacturer;Model;SerialNumber;BIOSVersion;FirmwareVersion;DriverVersion;
          type: tableJoin
          leftTable: "${source::monitors.disk_controller.discovery.sources.source(19)}"
          rightTable: "${source::monitors.disk_controller.discovery.sources.source(18)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          keyType: Wbem
          computes:
          # PartComponent;DiskControllerID;Name;
          - type: keepColumns
            columnNumbers: "2,3,4"
        source(21):
          # Let's see if there's a computer system with a controller battery.
          # Name,BatteryStatus
          type: wbem
          query: "SELECT Name,BatteryStatus FROM CIM_ComputerSystem"
          namespace: Automatic
          computes:
            # Keep only instances with valid Battery Status
            # Name;BatteryStatus;
          - type: keepOnlyMatchingLines
            column: 2
            valueList: "1,2,3"
        source(22):
          # Join the original discovery with the batteries (linking the system to the controller)
          # ComputerSystemID;Name;Manufacturer;Model;SerialNumber;BIOSVersion;FirmwareVersion;DriverVersion;Name;BatteryStatus;
          type: tableJoin
          leftTable: "${source::monitors.disk_controller.discovery.sources.source(18)}"
          rightTable: "${source::monitors.disk_controller.discovery.sources.source(21)}"
          leftKeyColumn: 2
          rightKeyColumn: 1
          defaultRightLine: ;;
        source(23):
          # Get a list of Physical Disks
          # CIM_DiskDrive;
          type: wbem
          query: SELECT __PATH FROM CIM_DiskDrive
          namespace: Automatic
        source(24):
          # Match these disks with the PartComponent to GroupComponent table we built
          # CIM_DiskDrive;PartComponent;DiskControllerID;
          type: tableJoin
          leftTable: "${source::monitors.disk_controller.discovery.sources.source(23)}"
          rightTable: "${source::monitors.disk_controller.discovery.sources.source(20)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          keyType: Wbem
          defaultRightLine: ;;
        source(25):
          # Take Disk Controller instance table and make sure that each controller matches one of the discovered physical disks (all controllers must have and associated physical disk)
          # ComputerSystemID;Name;Manufacturer;Model;SerialNumber;BIOSVersion;FirmwareVersion;DriverVersion;Name;BatteryStatus;CIM_DiskDrive;PartComponent;DiskControllerID;
          type: tableJoin
          leftTable: "${source::monitors.disk_controller.discovery.sources.source(22)}"
          rightTable: "${source::monitors.disk_controller.discovery.sources.source(24)}"
          leftKeyColumn: 1
          rightKeyColumn: 3
          keyType: Wbem
      mapping:
        # The Instance table
        # ComputerSystemID;Name;Manufacturer;Model;SerialNumber;BIOSVersion;FirmwareVersion;DriverVersion;Name;BatteryStatus;CIM_DiskDrive;PartComponent;DiskControllerID;
        source: "${source::monitors.disk_controller.discovery.sources.source(25)}"
        attributes:
          id: $2
          __display_id: $2
          controller_number: $1
          vendor: $3
          model: $4
          serial_number: $5
          bios_version: $6
          firmware_version: $7
          driver_version: $8
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"Disk Controller: %s (%s %s)\", $2, $3, $4)}"
        conditionalCollection:
          batterystatus: $10
    collect:
      # The DiskController collect is a "MultiInstance" collect
      # Only ONE WBEM query will be done in order to get the information for all disk controllers
      # Less WBEM queries gives faster results
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = CIM_ComputerSystem
          # ComputerID;OperationalStatus;
          type: wbem
          query: "SELECT Name,OperationalStatus FROM CIM_ComputerSystem"
          namespace: Automatic
          computes:
            # Duplicate the "OperationalStatusArray" column
            # ComputerID;OperationalStatusArray;OperationalStatusArray;
          - type: duplicateColumn
            column: 2
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # ComputerID;PATROLStatusArray;Status
          - type: arrayTranslate
            column: 2
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # ComputerID;PATROLStatusArray;StatusInformation
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # ComputerID;PATROLStatus;StatusInformation
          - type: convert
            column: 2
            conversion: array2SimpleStatus
        source(2):
          # Let's see if there's a computer system with a controller battery.
          # Name,BatteryStatus
          type: wbem
          query: "SELECT Name,BatteryStatus FROM CIM_ComputerSystem"
          namespace: Automatic
          computes:
            # Keep only Computer Systems with a Battery Status
            # Name,BatteryStatus
          - type: keepOnlyMatchingLines
            column: 2
            regExp: .
            # Translate the Battery Status
            # Name,BatteryStatus
          - type: translate
            column: 2
            translationTable: "${translation::BatteryStatusTranslationTable}"
        source(3):
          # Join the original discovery with the batteries (linking the system to the controller)
          # ComputerID;PATROLStatus;StatusInformation;Name;BatteryStatus;
          type: tableJoin
          leftTable: "${source::monitors.disk_controller.collect.sources.source(1)}"
          rightTable: "${source::monitors.disk_controller.collect.sources.source(2)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          defaultRightLine: ;;
      mapping:
        # ValueTable = Source(1)
        source: "${source::monitors.disk_controller.collect.sources.source(3)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="disk_controller"}: $2
        legacyTextParameters:
          StatusInformation: $3
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = CIM_DiskDrive
          # CIM_DiskDrive;SizeK;DeviceID;ElementName;
          type: wbem
          query: "SELECT __PATH,MaxMediaSize,DeviceID,ElementName FROM CIM_DiskDrive"
          namespace: Automatic
          computes:
            # Convert SizeK from 1000 of bytes to bytes
            # CIM_DiskDrive;Size;DeviceID;ElementName;
          - type: multiply
            column: 2
            value: 1000
            # Use DeviceID as ElementName if Element Name not available
            # CIM_DiskDrive;Size;DeviceID;ElementName;
          - type: leftConcat
            column: 4
            value: _MSHW_
          - type: rightConcat
            column: 4
            value: _MSHW_
            # Replace the Blank Value with Column 3
            # CIM_DiskDrive;Size;DeviceID;ElementName;
          - type: replace
            column: 4
            existingValue: _MSHW__MSHW_
            newValue: $3
            # Remove the unwanted _MSHW_
            # CIM_DiskDrive;Size;DeviceID;ElementName;
          - type: replace
            column: 4
            existingValue: _MSHW_
            newValue: ""
        source(2):
          # Source(2) = CIM_PhysicalPackage
          # CIM_PhysicalPackage;Model;SerialNumber;
          type: wbem
          query: "SELECT __PATH,Model,SerialNumber FROM CIM_PhysicalPackage"
          namespace: Automatic
        source(3):
          # Source(3) = Table joint of Source(1) and DiskController.Discovery.Source(3)
          # CIM_DiskDrive;Size;DeviceID;ElementName;PhysicalPackageID;LogicalElementID;
          type: tableJoin
          leftTable: "${source::monitors.physical_disk.discovery.sources.source(1)}"
          rightTable: "${source::monitors.disk_controller.discovery.sources.source(3)}"
          leftKeyColumn: 1
          rightKeyColumn: 2
          keyType: Wbem
          defaultRightLine: ;;
        source(4):
          # Source(4) = Table joint of Source(3) and Source(2)
          # CIM_DiskDrive;Size;DeviceID;ElementName;PhysicalPackageID;LogicalElementID;CIM_PhysicalPackage;Model;SerialNumber;
          type: tableJoin
          leftTable: "${source::monitors.physical_disk.discovery.sources.source(3)}"
          rightTable: "${source::monitors.physical_disk.discovery.sources.source(2)}"
          leftKeyColumn: 5
          rightKeyColumn: 1
          keyType: Wbem
          defaultRightLine: ;;;
        source(5):
          # Source(5) = Table joint of Source(4) and DiskController.Discovery.Source(20)
          # CIM_DiskDrive;Size;DeviceID;ElementName;PhysicalPackageID;LogicalElementID;CIM_PhysicalPackage;Model;SerialNumber;PartComponent;DiskControllerID;
          type: tableJoin
          leftTable: "${source::monitors.physical_disk.discovery.sources.source(4)}"
          rightTable: "${source::monitors.disk_controller.discovery.sources.source(20)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          keyType: Wbem
          defaultRightLine: ;;
          computes:
            # Exclude any PartComponents (DeviceIDs) of "Empty" that have made it this far
            # CIM_DiskDrive;Size;DeviceID;ElementName;PhysicalPackageID;LogicalElementID;CIM_PhysicalPackage;Model;SerialNumber;PartComponent;DiskControllerID;
          - type: excludeMatchingLines
            column: 1
            regExp: ^$
        source(6):
          # Now let's see if there's a size in the Storage Extent
          # CIM_StorageExtent,BlockSize,NumberofBlocks
          type: wbem
          query: "SELECT __PATH,BlockSize,NumberofBlocks FROM CIM_StorageExtent"
          namespace: Automatic
          computes:
            # Multiply blocksize by number of blocks to get size
            # CIM_StorageExtent,Size,NumberofBlocks
          - type: multiply
            column: 2
            value: $3
            # Select Columns
            # CIM_StorageExtent,Size
          - type: keepColumns
            columnNumbers: "1,2"
        source(7):
          # Get Link Disk Drive to Storage Extent
          # CIM_DiskDrive,CIM_StorageExtent
          type: wbem
          query: "SELECT Antecedent,Dependent FROM CIM_MediaPresent"
          namespace: Automatic
        source(8):
          # Link Disk Drive to Storage Extent
          # CIM_DiskDrive,CIM_StorageExtent,CIM_StorageExtent,Size
          type: tableJoin
          leftTable: "${source::monitors.physical_disk.discovery.sources.source(7)}"
          rightTable: "${source::monitors.physical_disk.discovery.sources.source(6)}"
          leftKeyColumn: 2
          rightKeyColumn: 1
          keyType: Wbem
          computes:
            # Select Columns
            # CIM_DiskDrive,Size
          - type: keepColumns
            columnNumbers: "1,4"
        source(9):
          # Link Main Table with Size from Storage Extent
          # CIM_DiskDrive;Size;DeviceID;ElementName;PhysicalPackageID;LogicalElementID;CIM_PhysicalPackage;Model;SerialNumber;PartComponent;DiskControllerID;CIM_DiskDrive;Size;
          type: tableJoin
          leftTable: "${source::monitors.physical_disk.discovery.sources.source(5)}"
          rightTable: "${source::monitors.physical_disk.discovery.sources.source(8)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          keyType: Wbem
          defaultRightLine: ;;
          computes:
            # Use StorageExtentSize as Size if DiskDriveDize not available
            # CIM_DiskDrive;Size;DeviceID;ElementName;PhysicalPackageID;LogicalElementID;CIM_PhysicalPackage;Model;SerialNumber;PartComponent;DiskControllerID;CIM_DiskDrive;Size;
          - type: leftConcat
            column: 2
            value: _MSHW_
          - type: rightConcat
            column: 2
            value: _MSHW_
          # Replace the Blank Value with Column 13
          - type: replace
            column: 2
            existingValue: _MSHW__MSHW_
            newValue: $14
          # Replace the zero Value with Column 13
          - type: replace
            column: 2
            existingValue: _MSHW_0_MSHW_
            newValue: $14
          # Remove the unwanted _MSHW_
          - type: replace
            column: 2
            existingValue: _MSHW_
            newValue: ""
      mapping:
        # Finally here is the instance table...
        # CIM_DiskDrive;Size;DeviceID;ElementName;PhysicalPackageID;LogicalElementID;Tag;Model;SerialNumber;PartComponent;DiskControllerID;DiskControllerName;CIM_DiskDrive;Size;
        source: "${source::monitors.physical_disk.discovery.sources.source(9)}"
        attributes:
          id: $3
          __display_id: $4
          vendor: $8
          serial_number: $9
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $11)"
          name: "${awk::sprintf(\"%s (%s - %s)\", $4, $8, bytes2HumanFormatBase10($2))}"
        metrics:
          hw.physical_disk.size: $2
    collect:
      # The physical disk collect is a "MultiInstance" collect
      # Only ONE WBEM query will be done in order to get the information for all physical disks
      # Less WBEM queries gives faster results
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = the only source = CIM_DiskDrive
          # DeviceID;OperationalStatusArray
          type: wbem
          query: "SELECT DeviceID,OperationalStatus FROM CIM_DiskDrive"
          namespace: Automatic
          computes:
            # Duplicate the "OperationalStatusArray" column
            # ComputerID;OperationalStatusArray;OperationalStatusArray;
          - type: duplicateColumn
            column: 2
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # ComputerID;PATROLStatusArray;Status
          - type: arrayTranslate
            column: 2
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # ComputerID;PATROLStatusArray;StatusInformation
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # ComputerID;PATROLStatus;StatusInformation
          - type: convert
            column: 2
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        source: "${source::monitors.physical_disk.collect.sources.source(1)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="physical_disk"}: $2
        legacyTextParameters:
          StatusInformation: $3
  logical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = CIM_StorageVolume
          # CIM_StorageVolume;BlockSize;SizeInBlocks;DeviceID;ElementName;SystemName;
          type: wbem
          query: "SELECT __PATH,BlockSize,NumberOfBlocks,DeviceID,ElementName,SystemName FROM CIM_StorageVolume"
          namespace: Automatic
          computes:
            # Compute the real size of the volumes (SizeInBlocks * BlockSize)
            # CIM_StorageVolume;BlockSize;SizeBytes;DeviceID;ElementName;SystemName;
          - type: multiply
            column: 3
            value: $2
            # Add an Underscore to the System Name
            # CIM_StorageVolume;BlockSize;SizeBytes;DeviceID;ElementName;SystemName;
          - type: rightConcat
            column: 6
            value: _
            # Remove the SystemName from the DeviceID
            # CIM_StorageVolume;BlockSize;SizeBytes;DeviceID;ElementName;SystemName;
          - type: replace
            column: 4
            existingValue: $6
            newValue: ""
            # Remove the System Name Column
            # CIM_StorageVolume;BlockSize;SizeBytes;DeviceID;ElementName;
          - type: keepColumns
            columnNumbers: "1,2,3,4,5"
            # Use DeviceID as ElementName if Element Name not available
            # CIM_StorageVolume;BlockSize;SizeBytes;DeviceID;ElementName;
          - type: leftConcat
            column: 5
            value: _MSHW_
          - type: rightConcat
            column: 5
            value: _MSHW_
            # Replace the Blank Value with Column 4
            # CIM_StorageVolume;BlockSize;SizeBytes;DeviceID;ElementName;
          - type: replace
            column: 5
            existingValue: _MSHW__MSHW_
            newValue: $4
            # Remove the unwanted _MSHW_
            # CIM_StorageVolume;BlockSize;SizeBytes;DeviceID;ElementName;
          - type: replace
            column: 5
            existingValue: _MSHW_
            newValue: ""
        source(2):
          # Source(2) = CIM_StorageSetting
          # StorageSettingInstanceID;Description;
          type: wbem
          query: "SELECT __PATH,Description FROM CIM_StorageSetting"
          namespace: Automatic
        source(3):
          # Source(3) = CIM_ElementSettingData
          # This is the link between CIM_StorageSetting and CIM_StorageVolumne
          # ManagedElement;SettingData
          type: wbem
          query: "SELECT ManagedElement,SettingData FROM CIM_ElementSettingData"
          namespace: Automatic
        source(4):
          # Source(4) = Table joint of  Source(1) and Source(3)
          # CIM_StorageVolume;BlockSize;SizeBytes;DeviceID;ElementName;ManagedElement;SettingData;
          type: tableJoin
          leftTable: "${source::monitors.logical_disk.discovery.sources.source(1)}"
          rightTable: "${source::monitors.logical_disk.discovery.sources.source(3)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          keyType: Wbem
          defaultRightLine: ;;
        source(5):
          # Source(5) = Table joint of Source(4) and Source(2)
          # CIM_StorageVolume;BlockSize;SizeBytes;DeviceID;ElementName;ManagedElement;SettingData;StorageSettingInstanceID;Description;
          type: tableJoin
          leftTable: "${source::monitors.logical_disk.discovery.sources.source(4)}"
          rightTable: "${source::monitors.logical_disk.discovery.sources.source(2)}"
          leftKeyColumn: 7
          rightKeyColumn: 1
          keyType: Wbem
          defaultRightLine: ;;
        source(6):
          # Source(6) = Table joint of Source(5) and DiskController.Discovery.Source(20)
          # CIM_StorageVolume;BlockSize;SizeBytes;DeviceID;ElementName;ManagedElement;SettingData;StorageSettingInstanceID;Description;PartComponent;DiskControllerID;
          type: tableJoin
          leftTable: "${source::monitors.logical_disk.discovery.sources.source(5)}"
          rightTable: "${source::monitors.disk_controller.discovery.sources.source(20)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          keyType: Wbem
          defaultRightLine: ;;
          computes:
            # Exclude any PartComponents (DeviceIDs) of "Empty" that have made it this far
            # CIM_StorageVolume;BlockSize;SizeBytes;DeviceID;ElementName;ManagedElement;SettingData;StorageSettingInstanceID;Description;PartComponent;DiskControllerID;
          - type: excludeMatchingLines
            column: 1
            regExp: ^$
      mapping:
        # Here is the instance table
        # CIM_StorageVolume;BlockSize;SizeBytes;DeviceID;ElementName;ManagedElement;SettingData;StorageSettingInstanceID;Description;PartComponent;DiskControllerID;
        source: "${source::monitors.logical_disk.discovery.sources.source(6)}"
        attributes:
          id: $4
          __display_id: $5
          raid_level: $9
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $11)"
          name: "${awk::sprintf(\"%s (%s - %s)\", $5, $9, bytes2HumanFormatBase2($3))}"
        metrics:
          hw.logical_disk.limit: $3
    collect:
      # The physical disk collect is a "MultiInstance" collect
      # Only ONE WBEM query will be done in order to get the information for all physical disks
      # Less WBEM queries gives faster results
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = the only source = CIM_StorageVolume
          # DeviceID;OperationalStatusArray
          type: wbem
          query: "SELECT DeviceID,OperationalStatus,SystemName FROM CIM_StorageVolume"
          namespace: Automatic
          computes:
            # Add an Underscore to the System Name
            # DeviceID;OperationalStatusArray;SystemName;
          - type: rightConcat
            column: 3
            value: _
            # Remove the SystemName from the DeviceID
            # DeviceID;OperationalStatusArray;SystemName;
          - type: replace
            column: 1
            existingValue: $3
            newValue: ""
            # Remove the System Name Column
            # DeviceID;OperationalStatusArray;
          - type: keepColumns
            columnNumbers: "1,2"
            # Duplicate the "OperationalStatusArray" column
            # ComputerID;OperationalStatusArray;OperationalStatusArray;
          - type: duplicateColumn
            column: 2
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # ComputerID;PATROLStatusArray;Status
          - type: arrayTranslate
            column: 2
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # ComputerID;PATROLStatusArray;StatusInformation
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # ComputerID;PATROLStatus;StatusInformation
          - type: convert
            column: 2
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        source: "${source::monitors.logical_disk.collect.sources.source(1)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="logical_disk"}: $2
        legacyTextParameters:
          StatusInformation: $3
  battery:
    discovery:
      sources:
        source(1):
          # Source(1) = CIM_Battery
          # CIM_Battery;DeviceID;OperationalStatus;
          type: wbem
          query: "SELECT __PATH,DeviceID,OperationalStatus FROM CIM_Battery"
          namespace: Automatic
          computes:
            # Exclude Batteries that have a Status of "12", i.e. no contact (not present)
            # CIM_Battery;DeviceID;OperationalStatus;
          - type: excludeMatchingLines
            column: 3
            regExp: 12|
        source(2):
          # Get the association table between Battery and Controller.  We have to use quite a generic association class.
          # Cim_ComputerSystem;CIM_Battery
          type: wbem
          query: "SELECT GroupComponent,PartComponent FROM CIM_Component"
          namespace: Automatic
        source(3):
          # Associate the Disk Controller with the Association Table to ensure that we have the Group Component we associate the Battery to is in fact the Disk Controller.
          # Cim_ComputerSystem;CIM_Battery;ComputerSystemID;Manufacturer;Model;SerialNumber;BIOSVersion;FirmwareVersion;DriverVersion;Cim_ComputerSystem;CIM_Battery;
          type: tableJoin
          leftTable: "${source::monitors.battery.discovery.sources.source(2)}"
          rightTable: "${source::monitors.disk_controller.discovery.sources.source(18)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          keyType: Wbem
          computes:
            # Keep only the Computer System and Battery paths.
            # Cim_ComputerSystem;CIM_Battery
          - type: keepColumns
            columnNumbers: "1,2"
        source(4):
          # Attach the discovered batteries to the assocation table
          # CIM_Battery;DeviceID;OperationalStatus;Cim_ComputerSystem;CIM_Battery
          type: tableJoin
          leftTable: "${source::monitors.battery.discovery.sources.source(1)}"
          rightTable: "${source::monitors.battery.discovery.sources.source(3)}"
          leftKeyColumn: 1
          rightKeyColumn: 2
          keyType: Wbem
        source(5):
          # As we've modified the Disk Controller's device id from its path to its name, we need to table join the controllers name
          # CIM_Battery;DeviceID;OperationalStatus;Cim_ComputerSystem;CIM_Battery;ComputerSystemID;Dedicated;Name;
          type: tableJoin
          leftTable: "${source::monitors.battery.discovery.sources.source(4)}"
          rightTable: "${source::monitors.disk_controller.discovery.sources.source(1)}"
          leftKeyColumn: 4
          rightKeyColumn: 1
          keyType: Wbem
          computes:
            # Keep only the Computer System and Battery paths.
            #      1           2           3            #     4            #  5            6            #  7     8
            # CIM_Battery;DeviceID;OperationalStatus;Cim_ComputerSystem;CIM_Battery;ComputerSystemID;Dedicated;Name;
            # CIM_Battery;DeviceID;            #             #             #             #             #       ComputerSystemName;
          - type: keepColumns
            columnNumbers: "1,2,8"
      mapping:
        # The Instance table
        # CIM_Battery;DeviceID;ComputerSystemName;
        source: "${source::monitors.battery.discovery.sources.source(5)}"
        attributes:
          id: $2
          hw.parent.type: disk_controller
          hw.parent.id: $3
          name: $2
    collect:
      # The physical disk collect is a "MultiInstance" collect
      # Only ONE WBEM query will be done in order to get the information for all physical disks
      # Less WBEM queries gives faster results
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = the only source = CIM_StorageVolume
          # DeviceID;OperationalStatusArray;
          type: wbem
          query: "SELECT DeviceID,OperationalStatus FROM CIM_Battery"
          namespace: Automatic
          computes:
            # Duplicate the "OperationalStatusArray" column
            # DeviceID;OperationalStatusArray;OperationalStatusArray;
          - type: duplicateColumn
            column: 2
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # We use a battery-specific translation table here because the '11' code should be WARN (as per DMTF) while in the real life, it's OK.
            # DeviceID;PATROLStatusArray;Status
          - type: arrayTranslate
            column: 2
            translationTable: "${translation::BatteryDMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # DeviceID;PATROLStatusArray;StatusInformation
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # DeviceID;PATROLStatus;StatusInformation
          - type: convert
            column: 2
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        source: "${source::monitors.battery.collect.sources.source(1)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="battery"}: $2
        legacyTextParameters:
          StatusInformation: $3
translations:
  DMTFOperationStatusTranslationTable:
    "11": degraded
    "12": failed
    "13": failed
    "14": failed
    "15": degraded
    "16": degraded
    "17": ok
    "18": ok
    Default: UNKNOWN
    "2": ok
    "3": degraded
    "4": degraded
    "5": degraded
    "6": failed
    "7": failed
    "8": degraded
    "9": degraded
    "10": failed
  BatteryStatusTranslationTable:
    "1": ok
    "2": failed
    "3": degraded
    Default: UNKNOWN
  BatteryDMTFOperationStatusTranslationTable:
    "11": ok
    "12": failed
    "13": failed
    "14": failed
    "15": degraded
    "16": degraded
    "17": ok
    "18": ok
    Default: UNKNOWN
    "2": ok
    "3": degraded
    "4": degraded
    "5": degraded
    "6": failed
    "7": failed
    "8": degraded
    "9": degraded
    "10": failed
  DMTFOperationStatusInformationTranslationTable:
    "11": In Service
    "12": No Contact
    "13": Lost Communication
    "14": Aborted
    "15": Dormant
    "16": Supporting Entity in Error
    "17": Completed
    "18": Power Mode
    Default: ""
    "2": ""
    "3": Degraded
    "4": Stressed
    "5": Predicted Failure
    "6": Error
    "7": Non-Recoverable Error
    "8": Starting
    "9": Stopping
    "10": Stopped
