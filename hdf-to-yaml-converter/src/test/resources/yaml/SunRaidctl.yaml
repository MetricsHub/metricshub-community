---
connector:
  displayName: Oracle/Sun Solaris - RAID Disks (raidctl)
  platforms: Oracle/Sun
  reliesOn: Sun Solaris system commands (raidctl)
  information: This connector discovers and monitors physical disks and logical disks behind a physical RAID controller.
  version: 1.0
  detection:
    connectionTypes:
    - remote
    appliesTo:
    - Solaris
    criteria:
    - type: deviceType
      keep:
      - SunOS
      - Solaris
    - type: osCommand
      commandLine: "%{SUDO:/usr/sbin/raidctl}/usr/sbin/raidctl -S"
      expectedResult: "^[0-9]"
      forceSerialization: true
      errorMessage: There is no disk attached to the controller(s).
sudoCommands:
- /usr/sbin/raidctl
monitors:
  disk_controller:
    discovery:
      sources:
        source(1):
          # Source(1) = Runs shell script that takes results from raidctl -S, then runs them through raidctl -l to get controller information
          # MSHW;Controller Number;Model;Firmware
          type: osCommand
          commandLine: /bin/sh $embedded.EmbeddedFile(1)$
          forceSerialization: true
          keep: ^MSHW;
          separators: ;
          selectColumns: "2,3,4"
        source(2):
          # Source(2) = Runs raidctl -S
          # MSHW;Controller Number;Model;Firmware
          type: osCommand
          commandLine: "%{SUDO:/usr/sbin/raidctl}/usr/sbin/raidctl -S"
          forceSerialization: true
          computes:
            # Reformat raidctl -S output to give us a dependency table to link controllers to disks to arrays
            # MSHW;Controller Number;Array;Disk
          - type: awk
            script: EmbeddedFile(2)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4"
        source(3):
          # Source (3) Table Join of Source (1) and Source (2) to keep only controllers that have logical disks (arrays) associated with them
          # Controller Number;Model;Firmware;Controller Number;Array;Disk
          type: tableJoin
          leftTable: $monitors.disk_controller.discovery.sources.source(1)$
          rightTable: $monitors.disk_controller.discovery.sources.source(2)$
          leftKeyColumn: 1
          rightKeyColumn: 1
      mapping:
        # InstanceTable = Source(3)
        # Controller Number;Model;Firmware;Controller Number;Array;Disk
        source: $monitors.disk_controller.discovery.sources.source(3)$
        attributes:
          id: $column(1)
          controller_number: $column(1)
          model: $column(2)
          firmware_version: $column(3)
          hw.parent.type: enclosure
          name: "sprintf(\"Disk Controller: %s (%s)\", $column(1), $column(2))"
  logical_disk:
    discovery:
      sources:
        source(1):
          # Discovery
          # Source(1) = List all logical drives and  info
          # MSHW;Logical disks;size;raid type
          type: osCommand
          commandLine: /bin/sh $embedded.EmbeddedFile(3)$
          forceSerialization: true
          keep: ^MSHW;
          separators: ;
          selectColumns: "2,3,4"
          computes:
            # Translate size into bytes
            # Logical disks;size;raid type
          - type: multiply
            column: 2
            value: 1073741824
        source(2):
          # Source (2) Table Join of Source (1) and DiskController Source (2)
          # Logical disks;size;raid type;Controller Number;Array;Disk
          type: tableJoin
          leftTable: $monitors.logical_disk.discovery.sources.source(1)$
          rightTable: $monitors.disk_controller.discovery.sources.source(2)$
          leftKeyColumn: 1
          rightKeyColumn: 2
      mapping:
        # The InstanceTable
        # Logical disks;size;raid type;Controller Number;Array;Disk
        source: $monitors.logical_disk.discovery.sources.source(2)$
        attributes:
          id: $column(1)
          hw.logical_disk.limit: $column(2)
          raid_level: $column(3)
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $column(4))"
          name: "sprintf(\"%s (%s - %s)\", $column(1), $column(3), $column(2))"
    collect:
      # Collect type = MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = List all logical drives and status of those
          # The status can be either OPTIMAL, DEGRADED, FAILED, or SYNCING.
          # MSHW;ID;Status
          type: osCommand
          commandLine: /bin/sh $embedded.EmbeddedFile(4)$
          forceSerialization: true
          keep: ^MSHW;
          separators: ;
          selectColumns: "2,3"
          computes:
            # Duplicate the status column
            # ID;Status;Status
          - type: duplicateColumn
            column: 2
            # Translate the first status column into a PATROL status
            # ID;PATROLStatus;Status
          - type: translate
            column: 2
            translationTable: LogicalDiskStatusTranslationTable
            # Translate the second status column into a more readable string
            # ID;PATROLStatus;StatusInformation
          - type: translate
            column: 3
            translationTable: LogicalDiskStatusInformationTranslationTable
      mapping:
        # The ValueTable = source(1)
        source: $monitors.logical_disk.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="logical_disk"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
  physical_disk:
    discovery:
      sources:
        source(1):
          # Discovery
          # Source(1) = List all physical disks and  their status - Status: GOOD/FAILED/MISSING
          # MSHW;ID;Size;Status
          type: osCommand
          commandLine: /bin/sh $embedded.EmbeddedFile(5)$
          forceSerialization: true
          keep: ^MSHW;
          separators: ;
          selectColumns: "2,3"
          computes:
            # Translate size into bytes
            # ID;Size
          - type: multiply
            column: 2
            value: 1073741824
        source(2):
          # Source (2) Table join of Physical Disks and Controller
          # ID;Size;Controller Number;Array;Disk
          type: tableJoin
          leftTable: $monitors.physical_disk.discovery.sources.source(1)$
          rightTable: $monitors.disk_controller.discovery.sources.source(2)$
          leftKeyColumn: 1
          rightKeyColumn: 3
      mapping:
        # The InstanceTable
        source: $monitors.physical_disk.discovery.sources.source(2)$
        attributes:
          id: $column(1)
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $column(3))"
          name: "sprintf(\"%s (%s)\", $column(1), $column(2))"
        metrics:
          hw.physical_disk.size: $column(2)
    collect:
      # Collect type = MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = List all physical disks and  their status
          # The status can be either GOOD, FAILED or MISSING.
          # MSHW;ID;Size;Status
          type: osCommand
          commandLine: /bin/sh $embedded.EmbeddedFile(5)$
          forceSerialization: true
          keep: ^MSHW;
          separators: ;
          selectColumns: "2,3,4"
          computes:
            # Duplicate the status column
            # ID;Size;Status;Status
          - type: duplicateColumn
            column: 3
            # Translate the first status column into a PATROL status
            # ID;Size;PATROLStatus;Status
          - type: translate
            column: 3
            translationTable: PhysicalDiskStatusTranslationTable
            # Translate the second status column into a more readable string
            # ID;Size;PATROLStatus;StatusInformation
          - type: translate
            column: 4
            translationTable: PhysicalDiskStatusInformationTranslationTable
      mapping:
        # The ValueTable = source(1)
        source: $monitors.physical_disk.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="physical_disk"}: $column(3)
        legacyTextParameters:
          StatusInformation: $column(4)
embedded:
  EmbeddedFile(1): |-
    CONTROLLERLIST=`%{SUDO:/usr/sbin/raidctl}/usr/sbin/raidctl -S|/usr/bin/nawk '{if ($2 ~ /"/) {print $1}}'`
    for CONTROLLER in $CONTROLLERLIST
        do
        %{SUDO:/usr/sbin/raidctl}/usr/sbin/raidctl -l $CONTROLLER | /usr/bin/nawk -v controller=$CONTROLLER '{if ($1 ~ /c[0-9]+/) {print ("MSHW;"controller";"$2";"$3";")}}'
        done
  EmbeddedFile(3): |-
    LOGICALDRIVELIST=`%{SUDO:/usr/sbin/raidctl}/usr/sbin/raidctl -S|/usr/bin/nawk '{if ($1 ~ /c[0-9]t[0-9]d[0-9]/) {print $1}}'`
    for LOGICALDRIVE in $LOGICALDRIVELIST
        do
        %{SUDO:/usr/sbin/raidctl}/usr/sbin/raidctl -l $LOGICALDRIVE | /usr/bin/nawk -v logicalDrive=$LOGICALDRIVE '{if ($1 ~ /c[0-9]t[0-9]d[0-9]/) {size=$2;
                                                                                                                 raid=$NF; gsub (/[A-Z]/,"",raid);
                                                                                                                 if (size ~ /[Gg]/) {gsub (/[Gg]/,"",size) ; }
                                                                                                                 if (size ~ /[Mm]/) {gsub (/[Mm]/,"",size) ; size = size / 1024};
                                                                                                                 if (size ~ /[Tt]/) {gsub (/[Tt]/,"",size) ; size = size * 1024};
                                                                                                                 print ("MSHW;"logicalDrive";"size";"raid";")}}'
        done
  EmbeddedFile(2): |-
    BEGIN {controller="";logicalDrive="";disk="";}
    $2 ~ /"/ {controller=$1}
    $1 ~ /c[0-9]t[0-9]d[0-9]/ {logicalDrive=$1;
                               for (i=3; i<=(NF-2); i++) { if ($i ~ /[0-9]\.[0-9]\.[0-9]/) {print ("MSHW;"controller";"logicalDrive";"$i);}}
                               }
  EmbeddedFile(5): |-
    LOGICALDRIVELIST=`%{SUDO:/usr/sbin/raidctl}/usr/sbin/raidctl -S|/usr/bin/nawk '{if ($1 ~ /c[0-9]t[0-9]d[0-9]/) {print $1}}'`
    for VOLUME in $LOGICALDRIVELIST
            do
            %{SUDO:/usr/sbin/raidctl}/usr/sbin/raidctl -l $VOLUME | /usr/bin/nawk '{if ($1 ~ /[0-9]\056[0-9]\056[0-9]/) {Size=$2;
                                                                                            if (Size ~ /[Gg]/) {gsub (/[Gg]/,"",Size) ; }
                                                                                            if (Size ~ /[Mm]/) {gsub (/[Mm]/,"",Size) ; Size = Size / 1024};
                                                                                            if (Size ~ /[Tt]/) {gsub (/[Tt]/,"",Size) ; Size = Size * 1024};
                                                                                            print ("MSHW;"$1";"Size";"$3";")}}'
            done
  EmbeddedFile(4): |
    LOGICALDRIVELIST=`%{SUDO:/usr/sbin/raidctl}/usr/sbin/raidctl -S|/usr/bin/nawk '{if ($1 ~ /c[0-9]t[0-9]d[0-9]/) {print $1}}'`
    for VOLUME in $LOGICALDRIVELIST
            do
            %{SUDO:/usr/sbin/raidctl}/usr/sbin/raidctl -l $VOLUME | egrep 'OPTIMAL|DEGRADED|FAILED|SYNCING' | awk '{print ("MSHW;"$1";"$4";")}'
            done
translations:
  PhysicalDiskStatusInformationTranslationTable:
    default: Unknown
    missing: Missing
    failed: Failed
    good: Good
  LogicalDiskStatusInformationTranslationTable:
    default: Unknown
    optimal: Optimal
    syncing: Syncing
    failed: Failed
    degraded: Degraded
  PhysicalDiskStatusTranslationTable:
    default: UNKNOWN
    missing: degraded
    failed: failed
    good: ok
  LogicalDiskStatusTranslationTable:
    default: UNKNOWN
    optimal: ok
    syncing: ok
    failed: failed
    degraded: degraded
