---
connector:
  displayName: Emulex HBAs (hbacmd)
  platforms: Any system with Emulex
  reliesOn: Emulex's hbacmd utility
  information: This connector discovers Emulex HBAs of servers running UNIX or Linux using the hbacmd utility provided with the Emulex Drivers.
  version: 1.0
  detection:
    connectionTypes:
    - remote
    appliesTo:
    - Linux
    - Solaris
    supersedes:
    - CpqHBA
    - SMISHBA
    criteria:
    # Test the hbacmd command for ports
    - type: osCommand
      commandLine: "%{SUDO:hbacmd} hbacmd ListHBAs"
      expectedResult: Port WWN
      timeout: 120
sudoCommands:
- hbacmd
monitors:
  network:
    discovery:
      sources:
        source(1):
          # Get the list of Ports from hbacmd ListHBAs
          type: osCommand
          commandLine: "%{SUDO:hbacmd} hbacmd ListHBAs"
          timeout: 120
          computes:
            # AWK it
            # Model;WWN;
          - type: awk
            script: EmbeddedFile(1)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3"
        source(2):
          # Get the list of Ports from hbacmd PortAttrib
          type: osCommand
          commandLine: "for HBA in `%{SUDO:hbacmd} hbacmd ListHBAs | /usr/bin/awk '($1 == \"Port\" && $2 == \"WWN\") {print $4}'`;do %{SUDO:hbacmd} hbacmd PortAttrib $HBA;done;"
          timeout: 120
          computes:
            # AWK it
            # Speed;Status;WWN;
          - type: awk
            script: EmbeddedFile(2)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4"
            # Convert Speed from Gbps to Mbps (multiply by 1000)
            # Speed;Status;WWN;
          - type: multiply
            column: 1
            value: 1000
        source(3):
          # Source (3) = TJ of 1 & 2
          # Model;WWN;Speed;Status;WWN;
          type: tableJoin
          leftTable: $monitors.network.discovery.sources.source(1)$
          rightTable: $monitors.network.discovery.sources.source(2)$
          leftKeyColumn: 2
          rightKeyColumn: 3
      mapping:
        # InstanceTable = Source(3)
        # Model;WWN;Speed;Status;WWN;
        source: $monitors.network.discovery.sources.source(3)$
        attributes:
          id: $column(2)
          model: $column(1)
          physical_address: $column(2)
          physical_address_type: WWN
          device_type: HBA FC Port
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s - %s)\", $column(2), \"HBA FC Port\", $column(1))"
    collect:
      # The NetworkCard collect is a "MultiInstance" collect
      type: multiInstance
      sources:
        source(1):
          # Get the list of Ports from hbacmd PortAttrib
          type: osCommand
          commandLine: "for HBA in `%{SUDO:hbacmd} hbacmd ListHBAs | /usr/bin/awk '($1 == \"Port\" && $2 == \"WWN\") {print $4}'`;do %{SUDO:hbacmd} hbacmd PortAttrib $HBA;done;"
          timeout: 120
          computes:
            # AWK it
            # Speed;Status;WWN;
          - type: awk
            script: EmbeddedFile(2)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4"
            # Duplicate Staus Column
            # Speed;Status;Status;Status;WWN;
          - type: duplicateColumn
            column: 2
          - type: duplicateColumn
            column: 2
            # Translate Network Status
            # Speed;PatrolStatus;Status;Status;WWN;
          - type: translate
            column: 2
            translationTable: NetworkStatusTranslationTable
            # Translate Network Status Information
            # Speed;PatrolStatus;StatusInformation;Status;WWN;
          - type: translate
            column: 3
            translationTable: NetworkStatusInfoTranslationTable
            # Translate Network Status Information
            # Speed;PatrolStatus;StatusInformation;LinkStatus;WWN;
          - type: translate
            column: 4
            translationTable: NetworkLinkStatusTranslationTable
            # Convert Speed from Gbps to Mbps (multiply by 1000)
            # Speed;PatrolStatus;StatusInformation;LinkStatus;WWN;
          - type: multiply
            column: 1
            value: 1000
        source(2):
          # Get the list of Ports from hbacmd PortStat
          type: osCommand
          commandLine: "for HBA in `%{SUDO:hbacmd} hbacmd ListHBAs | /usr/bin/awk '($1 == \"Port\" && $2 == \"WWN\") {print $4}'`;do %{SUDO:hbacmd} hbacmd PortStat $HBA;done;"
          timeout: 120
          computes:
            # AWK it
            # TxFrame;RxFrame;TxB;RxB;ErrorCount;WWN;
          - type: awk
            script: EmbeddedFile(3)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5,6,7"
        source(3):
          # Source (3) = TJ of 1 & 2
          # Speed;PatrolStatus;StatusInformation;LinkStatus;WWN;TxFrame;RxFrame;TxB;RxB;ErrorCount;WWN;
          type: tableJoin
          leftTable: $monitors.network.collect.sources.source(1)$
          rightTable: $monitors.network.collect.sources.source(2)$
          leftKeyColumn: 5
          rightKeyColumn: 6
      mapping:
        # ValueTable = Source(1)
        # Speed;PatrolStatus;StatusInformation;LinkStatus;WWN;TxFrame;RxFrame;TxB;RxB;ErrorCount;WWN;
        source: $monitors.network.collect.sources.source(3)$
        deviceId: $column(5)
        metrics:
          hw.network.bandwidth.limit: megaBit2Bit($column(1))
          hw.status{hw.type="network"}: $column(2)
          hw.network.up: legacyLinkStatus($column(4))
          hw.network.packets{direction="receive"}: $column(7)
          hw.network.packets{direction="transmit"}: $column(6)
          hw.errors{hw.type="network"}: $column(10)
          hw.network.io{direction="receive"}: $column(9)
          hw.network.io{direction="transmit"}: $column(8)
        legacyTextParameters:
          StatusInformation: $column(3)
embedded:
  EmbeddedFile(1): |-
    BEGIN {
        WWN = "";
        PortNumber = "";
        Model = "";
    }

    ($1 == "Port" && $2 == "WWN") { WWN = $4; gsub(":", "", WWN); }

    ($1 == "Model") { Model = $3; }

    (NF == 0 && WWN != "") {
        print "MSHW;" Model ";" WWN ";"
        WWN = "";
        Model = "";
    }
  EmbeddedFile(3): |-
    BEGIN {FS="[:]";WWN="";}

    $1 ~ /Port Statistics for/ {WWNNF=split($0,WWNArray,/ /);WWN=WWNArray[WWNNF];gsub(/:/,"",WWN)}

    $1 ~ /^Tx Frame Count +$/ {TxFrame=$2;gsub (/^ +/,"",TxFrame);}

    $1 ~ /^Rx Frame Count +$/ {RxFrame=$2;gsub (/^ +/,"",RxFrame);}

    $1 ~ /^Tx KB Count +$/ {TxB=$2;gsub (/^ +/,"",TxKB);TxB=TxB*1024;}

    $1 ~ /^Rx KB Count +$/ {RxB=$2;gsub (/^ +/,"",RxKB);RxB=RxB*1024;}

    $1 ~ /^Error Frame Count +$/ && WWN != "" {ErrorCount=$2;gsub (/^ +/,"",ErrorCount);
                                                 print ("MSHW;"TxFrame";"RxFrame";"TxB";"RxB";"ErrorCount";"WWN";")
                                                 WWN="";}
  EmbeddedFile(2): |-
    BEGIN {FS="[:]";WWN="";}

    $1 ~ /Port Attributes for/ {WWNNF=split($0,WWNArray,/ /);WWN=WWNArray[WWNNF];gsub(/:/,"",WWN)}

    $1 ~ /^Port State +$/ {Status=$2;gsub (/^ +/,"",Status);}

    $1 ~ /^Port Speed +$/ {Speed=$2;gsub (/^ +/,"",Speed);Speed=$2;gsub (/[^0-9]/,"",Speed);
                                          print ("MSHW;"Speed";"Status";"WWN";")
                                          WWN="";}
translations:
  NetworkStatusInfoTranslationTable:
    operational. need adapter port reset: Operational. Need Adapter Port Reset.
    other: Other
    default: UNKNOWN
    in diagnostic mode: In Diagnostic Mode
    link down. need adapter port reset: Link Down. Need Adapter Port Reset.
    bypassed: Bypassed
    link down: Link Down
    operational: ""
    user offline: User Offline
    down: Port Down
    port error: Port Error
    loopback: Loopback
  NetworkLinkStatusTranslationTable:
    default: UNKNOWN
    link down: degraded
    operational: ok
  NetworkStatusTranslationTable:
    operational. need adapter port reset: degraded
    other: UNKNOWN
    default: UNKNOWN
    in diagnostic mode: degraded
    link down. need adapter port reset: degraded
    bypassed: degraded
    link down: ok
    operational: ok
    user offline: degraded
    down: failed
    port error: failed
    loopback: degraded
