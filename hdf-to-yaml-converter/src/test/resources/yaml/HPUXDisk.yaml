---
connector:
  displayName: HP-UX - Disks
  platforms: "HP 9000,HP Integrity,HP SuperDome"
  reliesOn: "HP-UX system commands (pvdisplay, ioscan, etc.)"
  information: Provides hardware SCSI disks status information on HP-UX systems. Requires root privileges.
  version: 1.0
  detection:
    connectionTypes:
    - remote
    appliesTo:
    - HP
    criteria:
    # OS should be HP (for HP-UX, whatever version)
    - type: deviceType
      keep:
      - HP
    # STM should not be present, because in this case, we will use the HPUX-CSTM connector
    - type: osCommand
      commandLine: if /bin/test ! -f /usr/bin/stm ; then /bin/echo "NO STM"; fi
      expectedResult: ^NO STM$
    # The various following tools have to be present
    - type: osCommand
      commandLine: "FIRSTRAWDEVICE=`/bin/ls /dev/rdsk|/bin/head -1`; %{SUDO:/usr/sbin/diskinfo}/usr/sbin/diskinfo /dev/rdsk/$FIRSTRAWDEVICE"
      expectedResult: ^SCSI describe of /dev/rdsk/
sudoCommands:
- /usr/sbin/diskinfo
monitors:
  disk_controller:
    discovery:
      sources:
        source(1):
          # Source(1) = output of EmbeddedFile(1)
          # diskNumber;controllerID;deviceID;Vendor Model;size
          type: osCommand
          commandLine: /bin/sh $embedded.EmbeddedFile(1)$
          timeout: 60
          keep: ^MSHW;
          separators: ;
          selectColumns: "2,3,4,5,6"
        source(2):
          # Source(2) = output of ioscan -kFC ext_bus
          # DeviceID;Model
          type: osCommand
          commandLine: /usr/sbin/ioscan -kFC ext_bus
          keep: ':ext_bus:'
          separators: ':'
          selectColumns: "11,18"
        source(3):
          # Source(3) = table joint of Source(2) and Source(1)
          # This is to keep only disk controllers that actually have disks
          # ControllerDeviceID;Model;diskNumber;controllerID;deviceID;Vendor Model;size
          type: tableJoin
          leftTable: $monitors.disk_controller.discovery.sources.source(2)$
          rightTable: $monitors.disk_controller.discovery.sources.source(1)$
          leftKeyColumn: 1
          rightKeyColumn: 2
      mapping:
        # InstanceTable = Source(3)
        source: $monitors.disk_controller.discovery.sources.source(3)$
        attributes:
          id: $column(1)
          controller_number: $column(1)
          model: $column(2)
          hw.parent.type: enclosure
          name: "sprintf(\"Disk Controller: %s (%s)\", $column(1), $column(2))"
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = copy of the DiskController.Discovery.Source(1)
          # diskNumber;controllerID;deviceID;Vendor Model;size
          type: copy
          from: $monitors.disk_controller.discovery.sources.source(1)$
      mapping:
        # InstanceTable = Source(1)
        source: $monitors.physical_disk.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          vendor: $column(4)
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $column(2))"
          name: "sprintf(\"%s (%s - %by10hf.s)\", $column(3), $column(4), $column(5))"
        metrics:
          hw.physical_disk.size: $column(5)
    collect:
      # Collect type is "mono-instance
      type: monoInstance
      sources:
        source(1):
          # Source(1) = output of the pvdisplay command
          type: osCommand
          commandLine: /usr/sbin/pvdisplay /dev/dsk/%PhysicalDisk.Collect.DeviceID%
          computes:
            # Process output of pvdisplay through a awk script
            # PV Status
          - type: awk
            script: "/^PV Status/ {print \"MSHW;\" $3 \"-\" $4}"
            keep: ^MSHW;
            separators: ;
            selectColumns: 2
            # Duplicate the (single) status column
            # PV Status;PV Status
          - type: duplicateColumn
            column: 1
            # Translate the PV status into a PATROL status
            # PATROLStatus;PV Status
          - type: translate
            column: 1
            translationTable: PhysicalDiskStatusTranslationTable
            # Translate the second PV Status into a more readable string
            # PATROLStatus;StatusInformation
          - type: translate
            column: 2
            translationTable: PhysicalDiskStatusInformationTranslationTable
      mapping:
        # ValueTable = Source(1)
        source: $monitors.physical_disk.collect.sources.source(1)$
        metrics:
          hw.status{hw.type="physical_disk"}: $column(1)
        legacyTextParameters:
          StatusInformation: $column(2)
embedded:
  EmbeddedFile(1): |-
    echo "Retrieving disk devices"
    diskList=`/usr/sbin/ioscan -kfnC disk|/bin/grep -e DEVICE -e /dev|/bin/awk '{
        if ($1 == "disk")
        {
            diskNumber = $2
            hardwarePath = $3
            rawDevicePath = ""
        }
        if ($2 ~ "^/dev/rdsk/")
        {
            deviceID = substr($2, 11)
            controllerIndex = match(hardwarePath, "\.[0-9]+\.[0-9]+$")
            if (diskNumber != "" && hardwarePath != "" && controllerIndex > 0)
            {
                controllerID = substr(hardwarePath, 1, controllerIndex - 1)
                print diskNumber ";" controllerID ";" deviceID
            }
            deviceID = ""
            deviceNumber = ""
            hardwarePath = ""
        }
    }'`

    for diskInformation in $diskList
    do
    deviceID=`/bin/echo $diskInformation|/bin/awk -F";" '{print $3}'`
    %{SUDO:/usr/sbin/diskinfo}/usr/sbin/diskinfo /dev/rdsk/$deviceID|/bin/awk -v diskInformation=$diskInformation '{
        if ($0 ~ "^SCSI describe of /dev/rdsk")
        {
            vendor = ""
            productID = ""
            type = "";
            size = "";
        }

        if ($1 == "vendor:")
        {
            vendor = $2
        }

        if ($1 == "product" && $2 == "id:")
        {
            productID = $3
        }

        if ($1 == "type:")
        {
            type = $2 " " $3
        }

        if ($1 == "size:")
        {
            size = $2
            if (type == "direct access" && vendor != "" && productID != "" && size > 0)
            {
                printf("MSHW;%s;%s;%.0f\n", diskInformation, vendor " " productID, size*1024)
            }
        }
    }'
    done
translations:
  PhysicalDiskStatusInformationTranslationTable:
    available/data-spared: Spared
    unavailable/standby-spare: Unavailable spare
    default: Unknown Status
    unavailable-: Unavailable
    available/active-spare: Active spare
    available/standby-spare: Spare
    available-: ""
    unavailable/data-spared: Unavailable but spared
    unavailable/active-spare: "Dead spare: Data loss!"
  PhysicalDiskStatusTranslationTable:
    available/data-spared: ok
    unavailable/standby-spare: degraded
    default: UNKNOWN
    unavailable-: failed
    available/active-spare: ok
    available/standby-spare: ok
    available-: ok
    unavailable/data-spared: degraded
    unavailable/active-spare: failed
