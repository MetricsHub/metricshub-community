---
connector:
  displayName: Oracle/Sun Solaris - RAID Disks (raidctl)
  platforms: Oracle/Sun
  reliesOn: Sun Solaris system commands (raidctl)
  information: This connector discovers and monitors physical disks and logical disks behind a physical RAID controller.
  version: 1.0
  detection:
    connectionTypes:
    - remote
    - local
    appliesTo:
    - Solaris
    criteria:
    - type: deviceType
      keep:
      - SunOS
      - Solaris
    - type: osCommand
      commandLine: "%{SUDO:/usr/sbin/raidctl}/usr/sbin/raidctl -S"
      expectedResult: "^[0-9]"
      forceSerialization: true
      errorMessage: There is no disk attached to the controller(s).
sudoCommands:
- /usr/sbin/raidctl
monitors:
  disk_controller:
    discovery:
      sources:
        source(1):
          # Source(1) = Runs shell script that takes results from raidctl -S, then runs them through raidctl -l to get controller information
          # MSHW;Controller Number;Model;Firmware
          type: osCommand
          commandLine: "/bin/sh ${file::embeddedFile-1}"
          forceSerialization: true
          keep: ^MSHW;
          separators: ;
          selectColumns: "2,3,4"
        source(2):
          # Source(2) = Runs raidctl -S
          # MSHW;Controller Number;Model;Firmware
          type: osCommand
          commandLine: "%{SUDO:/usr/sbin/raidctl}/usr/sbin/raidctl -S"
          forceSerialization: true
          computes:
            # Reformat raidctl -S output to give us a dependency table to link controllers to disks to arrays
            # MSHW;Controller Number;Array;Disk
          - type: awk
            script: "${file::embeddedFile-2}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4"
        source(3):
          # Source (3) Table Join of Source (1) and Source (2) to keep only controllers that have logical disks (arrays) associated with them
          # Controller Number;Model;Firmware;Controller Number;Array;Disk
          type: tableJoin
          leftTable: "${source::monitors.disk_controller.discovery.sources.source(1)}"
          rightTable: "${source::monitors.disk_controller.discovery.sources.source(2)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
      mapping:
        # InstanceTable = Source(3)
        # Controller Number;Model;Firmware;Controller Number;Array;Disk
        source: "${source::monitors.disk_controller.discovery.sources.source(3)}"
        attributes:
          id: $1
          controller_number: $1
          model: $2
          firmware_version: $3
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"Disk Controller: %s (%s)\", $1, $2)}"
  logical_disk:
    discovery:
      sources:
        source(1):
          # Discovery
          # Source(1) = List all logical drives and  info
          # MSHW;Logical disks;size;raid type
          type: osCommand
          commandLine: "/bin/sh ${file::embeddedFile-3}"
          forceSerialization: true
          keep: ^MSHW;
          separators: ;
          selectColumns: "2,3,4"
          computes:
            # Translate size into bytes
            # Logical disks;size;raid type
          - type: multiply
            column: 2
            value: 1073741824
        source(2):
          # Source (2) Table Join of Source (1) and DiskController Source (2)
          # Logical disks;size;raid type;Controller Number;Array;Disk
          type: tableJoin
          leftTable: "${source::monitors.logical_disk.discovery.sources.source(1)}"
          rightTable: "${source::monitors.disk_controller.discovery.sources.source(2)}"
          leftKeyColumn: 1
          rightKeyColumn: 2
      mapping:
        # The InstanceTable
        # Logical disks;size;raid type;Controller Number;Array;Disk
        source: "${source::monitors.logical_disk.discovery.sources.source(2)}"
        attributes:
          id: $1
          raid_level: $3
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $4)"
          name: "${awk::sprintf(\"%s (%s - %s)\", $1, $3, bytes2HumanFormatBase2($2))}"
        metrics:
          hw.logical_disk.limit: $2
    collect:
      # Collect type = MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = List all logical drives and status of those
          # The status can be either OPTIMAL, DEGRADED, FAILED, or SYNCING.
          # MSHW;ID;Status
          type: osCommand
          commandLine: "/bin/sh ${file::embeddedFile-4}"
          forceSerialization: true
          keep: ^MSHW;
          separators: ;
          selectColumns: "2,3"
          computes:
            # Duplicate the status column
            # ID;Status;Status
          - type: duplicateColumn
            column: 2
            # Translate the first status column into a PATROL status
            # ID;PATROLStatus;Status
          - type: translate
            column: 2
            translationTable: "${translation::LogicalDiskStatusTranslationTable}"
            # Translate the second status column into a more readable string
            # ID;PATROLStatus;StatusInformation
          - type: translate
            column: 3
            translationTable: "${translation::LogicalDiskStatusInformationTranslationTable}"
      mapping:
        # The ValueTable = source(1)
        source: "${source::monitors.logical_disk.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="logical_disk"}: $2
        legacyTextParameters:
          StatusInformation: $3
  physical_disk:
    discovery:
      sources:
        source(1):
          # Discovery
          # Source(1) = List all physical disks and  their status - Status: GOOD/FAILED/MISSING
          # MSHW;ID;Size;Status
          type: osCommand
          commandLine: "/bin/sh ${file::embeddedFile-5}"
          forceSerialization: true
          keep: ^MSHW;
          separators: ;
          selectColumns: "2,3"
          computes:
            # Translate size into bytes
            # ID;Size
          - type: multiply
            column: 2
            value: 1073741824
        source(2):
          # Source (2) Table join of Physical Disks and Controller
          # ID;Size;Controller Number;Array;Disk
          type: tableJoin
          leftTable: "${source::monitors.physical_disk.discovery.sources.source(1)}"
          rightTable: "${source::monitors.disk_controller.discovery.sources.source(2)}"
          leftKeyColumn: 1
          rightKeyColumn: 3
      mapping:
        # The InstanceTable
        source: "${source::monitors.physical_disk.discovery.sources.source(2)}"
        attributes:
          id: $1
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $3)"
          name: "${awk::sprintf(\"%s (%s)\", $1, bytes2HumanFormatBase10($2))}"
        metrics:
          hw.physical_disk.size: $2
    collect:
      # Collect type = MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = List all physical disks and  their status
          # The status can be either GOOD, FAILED or MISSING.
          # MSHW;ID;Size;Status
          type: osCommand
          commandLine: "/bin/sh ${file::embeddedFile-5}"
          forceSerialization: true
          keep: ^MSHW;
          separators: ;
          selectColumns: "2,3,4"
          computes:
            # Duplicate the status column
            # ID;Size;Status;Status
          - type: duplicateColumn
            column: 3
            # Translate the first status column into a PATROL status
            # ID;Size;PATROLStatus;Status
          - type: translate
            column: 3
            translationTable: "${translation::PhysicalDiskStatusTranslationTable}"
            # Translate the second status column into a more readable string
            # ID;Size;PATROLStatus;StatusInformation
          - type: translate
            column: 4
            translationTable: "${translation::PhysicalDiskStatusInformationTranslationTable}"
      mapping:
        # The ValueTable = source(1)
        source: "${source::monitors.physical_disk.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="physical_disk"}: $3
        legacyTextParameters:
          StatusInformation: $4
translations:
  PhysicalDiskStatusInformationTranslationTable:
    FAILED: Failed
    GOOD: Good
    MISSING: Missing
    Default: Unknown
  LogicalDiskStatusInformationTranslationTable:
    OPTIMAL: Optimal
    FAILED: Failed
    DEGRADED: Degraded
    SYNCING: Syncing
    Default: Unknown
  PhysicalDiskStatusTranslationTable:
    FAILED: failed
    GOOD: ok
    MISSING: degraded
    Default: UNKNOWN
  LogicalDiskStatusTranslationTable:
    OPTIMAL: ok
    FAILED: failed
    DEGRADED: degraded
    SYNCING: ok
    Default: UNKNOWN
