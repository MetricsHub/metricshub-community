---
sudoCommands:
- Second_Address
connector:
  detection:
    criteria:
    # Only for type storage
    - type: deviceType
      keep:
      - Storage
    # Checks that SMCLI is on the local machine - in Portal smcli is run from the RSM
    - type: osCommand
      commandLine: SMcli
      executeLocally: true
      expectedResult: Incorrect
      errorMessage: SMCLI not installed or not in path.
    # Checks that SMCLI returns a physical disk
    - type: osCommand
      commandLine: "SMcli %{HOSTNAME} %{SUDO:Second_Address} -c \"show _COMMAND;\""
      executeLocally: true
      expectedResult: drive
      errorMessage: "SMCLI did not return any disks, check hostname."
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Source(1) = the output of smcli "show enclosure / show storage array
          type: osCommand
          commandLine: "SMcli %{HOSTNAME} %{SUDO:Second_Address} -c \"show _COMMAND;\""
          executeLocally: true
          timeout: 360
          computes:
          # Process smcli's output through awk EmbeddedFile(1)
          - type: awk
            script: $embedded.EmbeddedFile(1)$
            keep: ^MSHW;
            # Exclude StatusInformation that contain Not Present
            # MSHW;Type;ID;displayID;enclosureID;enclosureType;status;statusInformation;additionalInformation;vendor;serialNumber;<blank>;<blank>;
          - type: excludeMatchingLines
            column: 8
            regExp: Not Present
        source(2):
          # Make a copy of show enclosure
          # Enclosure.Discovery.Source(2)=$monitors.enclosure.discovery.sources.source(1)$
          type: tableUnion
          tables:
          - $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only Enclosures
            #  1    2   3   4         5           6             7      8            #    9            #        10        11         12      13
            # MSHW;Type;ID;displayID;enclosureID;enclosureType;status;statusInformation;additionalInformation;vendor;serialNumber;<blank>;<blank>;
          - type: keepOnlyMatchingLines
            column: 2
            valueList: enclosure
      mapping:
        # The discovery table
        source: $monitors.enclosure.discovery.sources.source(2)$
        attributes:
          id: $column(3)
          __display_id: $column(4)
          vendor: $column(10)
          serial_number: $column(11)
          type: Storage
          info: $column(9)
          name: "sprintf(\"Storage: %s (%s)\", $column(4), $column(10))"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = the output of smcli "show enclosure / show storage array
          type: osCommand
          commandLine: "SMcli %{HOSTNAME} %{SUDO:Second_Address} -c \"show _COMMAND;\""
          executeLocally: true
          timeout: 360
          computes:
          # Process smcli's output through awk EmbeddedFile(1)
          - type: awk
            script: $embedded.EmbeddedFile(1)$
            keep: ^MSHW;
            # Trim down the table to make it easier to understand
            #  1    2   3   4         5           6             7      8            #    9            #        10        11         12       13
            # MSHW;Type;ID;displayID;enclosureID;enclosureType;status;statusInformation;additionalInformation;vendor;serialNumber;<blank>;<blank>;
            # Type;ID;Status;StatusInformation;
          - type: keepColumns
            columnNumbers: "2,3,7,8"
        source(2):
          # Make a copy of show enclosure
          # Source(1) will be for other classes that do NOT want a translated status value
          # Source(2) will be for other classes that want a translated status value
          # Type;ID;Status;StatusInformation;
          # Enclosure.Collect.Source(2)=$monitors.enclosure.collect.sources.source(1)$
          type: tableUnion
          tables:
          - $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Now translate Status into OK/Warning/Alarm
            # Only the first two words of the status are used to translate.  The full status is left in StatusInformation
            # Type;ID;PatrolStatus;StatusInformation;
          - type: translate
            column: 3
            translationTable: statusTranslationTable
        source(3):
          # Make a copy of Source(2) to use in Enclosure Collect
          # Enclosure.Collect.Source(3)=$monitors.enclosure.collect.sources.source(2)$
          type: tableUnion
          tables:
          - $monitors.enclosure.collect.sources.source(2)$
          computes:
            # Keep only Enclosures
            # Type;ID;PatrolStatus;StatusInformation;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: enclosure
      mapping:
        # Value Table
        # Type;ID;PatrolStatus;StatusInformation;
        source: $monitors.enclosure.collect.sources.source(3)$
        deviceId: $column(2)
  blade:
    discovery:
      sources:
        source(1):
          # Make a copy of Enclosure(1)
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only Blade Classes
            #  1    2   3   4         5           6             7      8            #    9            #        10        11         12     13
            # MSHW;Type;ID;displayID;enclosureID;enclosureType;status;statusInformation;additionalInformation;model;serialNumber;<blank>;<blank>;
          - type: keepOnlyMatchingLines
            column: 2
            valueList: Controller
      mapping:
        # Instance Table
        source: $monitors.blade.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(4)
          model: $column(10)
          serial_number: $column(11)
          info: $column(9)
          hw.parent.type: $column(6)
          hw.parent.id: $column(5)
          name: "sprintf(\"%s (%s)\", $column(4), $column(10))"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Make a copy of Enclosure Source(2)
          type: copy
          from: $monitors.enclosure.collect.sources.source(2)$
          computes:
            # Keep only Enclosures
            # Type;ID;PatrolStatus;StatusInformation;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: Controller
      mapping:
        # Value Table
        # Type;ID;PatrolStatus;StatusInformation;
        source: $monitors.blade.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="blade"}: $column(3)
        legacyTextParameters:
          StatusInformation: $column(4)
  battery:
    discovery:
      sources:
        source(1):
          # Make a copy of Enclosure(1)
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only Battery Classes
            #  1    2   3   4         5           6             7      8            #    9            #        10        11       12    13
            # MSHW;Type;ID;displayID;enclosureID;enclosureType;status;statusInformation;additionalInformation;<blank>;<blank>;<blank>;<blank>;
          - type: keepOnlyMatchingLines
            column: 2
            valueList: battery
      mapping:
        # Instance Table
        source: $monitors.battery.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(4)
          info: $column(9)
          hw.parent.type: $column(6)
          hw.parent.id: $column(5)
          name: $column(4)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Make a copy of Enclosure Source(2)
          type: copy
          from: $monitors.enclosure.collect.sources.source(2)$
          computes:
            # Keep only Enclosures
            # Type;ID;PatrolStatus;StatusInformation;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: battery
      mapping:
        # Value Table
        # Type;ID;PatrolStatus;StatusInformation;
        source: $monitors.battery.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="battery"}: $column(3)
        legacyTextParameters:
          StatusInformation: $column(4)
  fan:
    discovery:
      sources:
        source(1):
          # Make a copy of Enclosure(1)
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only Fan Classes
            #  1    2   3   4         5           6             7      8            #    9            #        10        11      12     13
            # MSHW;Type;ID;displayID;enclosureID;enclosureType;status;statusInformation;additionalInformation;<blank>;<blank>;<blank>;<blank>;
          - type: keepOnlyMatchingLines
            column: 2
            valueList: fan
      mapping:
        # Instance Table
        source: $monitors.fan.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(4)
          info: $column(9)
          hw.parent.type: $column(6)
          hw.parent.id: $column(5)
          name: $column(4)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Make a copy of Enclosure Source(2)
          type: copy
          from: $monitors.enclosure.collect.sources.source(2)$
          computes:
            # Keep only Enclosures
            # Type;ID;PatrolStatus;StatusInformation;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: fan
      mapping:
        # Value Table
        # Type;ID;PatrolStatus;StatusInformation;
        source: $monitors.fan.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="fan"}: $column(3)
        legacyTextParameters:
          StatusInformation: $column(4)
  power_supply:
    discovery:
      sources:
        source(1):
          # Make a copy of Enclosure(1)
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only PowerSupply Classes
            #  1    2   3   4         5           6             7      8            #    9            #        10        11      12     13
            # MSHW;Type;ID;displayID;enclosureID;enclosureType;status;statusInformation;additionalInformation;<blank>;<blank>;<blank>;<blank>;
          - type: keepOnlyMatchingLines
            column: 2
            valueList: power_supply
      mapping:
        # Instance Table
        source: $monitors.power_supply.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(4)
          info: $column(9)
          hw.parent.type: $column(6)
          hw.parent.id: $column(5)
          name: $column(4)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Make a copy of Enclosure Source(2)
          type: copy
          from: $monitors.enclosure.collect.sources.source(2)$
          computes:
            # Keep only Enclosures
            # Type;ID;PatrolStatus;StatusInformation;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: power_supply
      mapping:
        # Value Table
        # Type;ID;PatrolStatus;StatusInformation;
        source: $monitors.power_supply.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="power_supply"}: $column(3)
        legacyTextParameters:
          StatusInformation: $column(4)
  temperature:
    discovery:
      sources:
        source(1):
          # Make a copy of Enclosure(1)
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only Temperature Classes
            #  1    2   3   4         5           6             7      8            #    9            #        10        11      12     13
            # MSHW;Type;ID;displayID;enclosureID;enclosureType;status;statusInformation;additionalInformation;<blank>;<blank>;<blank>;<blank>;
          - type: keepOnlyMatchingLines
            column: 2
            valueList: temperature
      mapping:
        # Instance Table
        source: $monitors.temperature.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(4)
          info: $column(9)
          hw.parent.type: $column(6)
          hw.parent.id: $column(5)
          name: $column(4)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Make a copy of Enclosure Source(2)
          type: copy
          from: $monitors.enclosure.collect.sources.source(2)$
          computes:
            # Keep only Enclosures
            # Type;ID;PatrolStatus;StatusInformation;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: temperature
      mapping:
        # Value Table
        # Type;ID;PatrolStatus;StatusInformation;
        source: $monitors.temperature.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="temperature"}: $column(3)
        legacyTextParameters:
          StatusInformation: $column(4)
  physical_disk:
    discovery:
      sources:
        source(1):
          # Make a copy of Enclosure(1)
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only PhysicalDisk Classes
            #  1    2   3   4         5           6             7      8            #    9            #        10        11         12     13
            # MSHW;Type;ID;displayID;enclosureID;enclosureType;status;statusInformation;additionalInformation;sizeGB;serialNumber;model;vendor;
          - type: keepOnlyMatchingLines
            column: 2
            valueList: physical_disk
            # ConvertGB to B
            # MSHW;Type;ID;displayID;enclosureID;enclosureType;status;statusInformation;additionalInformation;sizeB;serialNumber;model;vendor;
          - type: multiply
            column: 10
            value: 1000000000
      mapping:
        # Instance Table
        source: $monitors.physical_disk.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(4)
          serial_number: $column(11)
          model: $column(12)
          vendor: $column(13)
          info: $column(9)
          hw.parent.type: $column(6)
          hw.parent.id: $column(5)
          name: "sprintf(\"%s (%s - %by10hf.s)\", $column(4), $column(13), $column(10))"
        metrics:
          hw.physical_disk.size: $column(10)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Make a copy of Enclosure Source(2)
          type: copy
          from: $monitors.enclosure.collect.sources.source(2)$
          computes:
            # Keep only Enclosures
            # Type;ID;PatrolStatus;StatusInformation;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: physical_disk
      mapping:
        # Value Table
        # Type;ID;PatrolStatus;StatusInformation;
        source: $monitors.physical_disk.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="physical_disk"}: $column(3)
        legacyTextParameters:
          StatusInformation: $column(4)
  logical_disk:
    discovery:
      sources:
        source(1):
          # Make a copy of Enclosure(1)
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only LogicalDisk Classes
            #  1    2   3   4         5           6             7      8            #    9            #        10        11      12     13
            # MSHW;Type;ID;displayID;enclosureID;enclosureType;status;statusInformation;additionalInformation;Size;<blank>;<blank>;<blank>;
          - type: keepOnlyMatchingLines
            column: 2
            valueList: DiskGroup
            # ConvertGB to B
            # MSHW;Type;ID;displayID;enclosureID;enclosureType;status;statusInformation;additionalInformation;sizeB;serialNumber;model;vendor;
          - type: multiply
            column: 10
            value: 1000000000
      mapping:
        # Instance Table
        source: $monitors.logical_disk.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(4)
          info: $column(9)
          hw.parent.type: $column(6)
          hw.parent.id: $column(5)
          name: "sprintf(\"%s (%by2hf.s)\", $column(4), $column(10))"
        metrics:
          hw.logical_disk.limit: $column(10)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Make a copy of Enclosure Source(2)
          type: copy
          from: $monitors.enclosure.collect.sources.source(2)$
          computes:
            # Keep only Enclosures
            # Type;ID;PatrolStatus;StatusInformation;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: DiskGroup
      mapping:
        # Value Table
        # Type;ID;PatrolStatus;StatusInformation;
        source: $monitors.logical_disk.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="logical_disk"}: $column(3)
        legacyTextParameters:
          StatusInformation: $column(4)
  network:
    discovery:
      sources:
        source(1):
          # Make a copy of Enclosure(1)
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only NetworkCard Classes
            #  1    2   3   4         5           6             7      8            #    9            #        10        11            12     13
            # MSHW;Type;ID;displayID;enclosureID;enclosureType;status;statusInformation;additionalInformation;MacAddress;AddressType;<blank>;<blank>;
          - type: keepOnlyMatchingLines
            column: 2
            valueList: "EthernetPort,HostInterface,PhysicalDiskInterface"
      mapping:
        # Instance Table
        source: $monitors.network.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(4)
          physical_address: $column(10)
          physical_address_type: $column(11)
          info: $column(9)
          hw.parent.type: $column(6)
          hw.parent.id: $column(5)
          name: $column(4)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Make a copy of Enclosure Source(1) (Not 2 as we need raw data)
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only Enclosures
            # Type;ID;LinkStatus;Speed>;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: "EthernetPort,HostInterface,PhysicalDiskInterface"
            # Translate the Link STATUS
            # Type;ID;PatrolStatus;Speed;
          - type: translate
            column: 3
            translationTable: linkStatusTranslationTable
      mapping:
        # Value Table
        # Type;ID;PatrolStatus;Speed;
        source: $monitors.network.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.network.up: legacyLinkStatus($column(3))
          hw.network.bandwidth.limit: megaBit2Bit($column(4))
  other_device:
    discovery:
      sources:
        source(1):
          # Make a copy of Enclosure(1)
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Exclude Known Classes
            #  1    2   3   4         5           6             7      8            #    9            #        10        11      12     13
            # MSHW;Type;ID;displayID;enclosureID;enclosureType;status;statusInformation;additionalInformation;<blank>;<blank>;<blank>;<blank>;
          - type: excludeMatchingLines
            column: 2
            valueList: "ERROR;Enclosure,Controller,Battery,PhysicalDisk,PowerSupply,Fan,Temperature,DiskGroup,EthernetPort,HostInterface,PhysicalDiskInterface"
      mapping:
        # Instance Table
        source: $monitors.other_device.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(4)
          device_type: $column(2)
          info: $column(9)
          hw.parent.type: $column(6)
          hw.parent.id: $column(5)
          name: "sprintf(\"%s: %s\", $column(2), $column(4))"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Make a copy of Enclosure Source(2)
          type: copy
          from: $monitors.enclosure.collect.sources.source(2)$
          computes:
            # Exclude Known Classes
            # Type;ID;PatrolStatus;StatusInformation;
          - type: excludeMatchingLines
            column: 1
            valueList: "ERROR;Enclosure,Controller,Battery,PhysicalDisk,PowerSupply,Fan,Temperature,DiskGroup,EthernetPort,HostInterface,PhysicalDiskInterface"
      mapping:
        # Value Table
        # Type;ID;PatrolStatus;StatusInformation;
        source: $monitors.other_device.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="other_device"}: $column(3)
        legacyTextParameters:
          StatusInformation: $column(4)
embedded:
  EmbeddedFile(1): |-
    #
    # FUNCTIONS
    #

    # Set a value in an array (label optional)
    # A value should only be set once, so it will ignore future values
    function setArray(array,arrayID,value,label) {
      if (ID == "") { return }
      if (tolower(value)=="available" && tolower($(NF-1)) == "not") { value = "Not Available" }
      if (label != "") { value = label ": " value }
      if (array[arrayID] == "") {
        array[arrayID] = value
      } else {
        print "MSHW;ERROR; - Multiple Values for same Component- ID: " arrayID " - LineNumber: " NR " - Section: " section " - SubSection: " subsection " - Line: " $0
      }
    }

    # Append a value to an array  (label optional)
    function appendArray(array,arrayID,value,label) {
      if (ID == "") { return }
      if (tolower(value)=="available" && tolower($(NF-1)) == "not") { value = "Not Available" }
      gsub(/ *$/,"",value);
      # Don't populate additional information with Not Available
      if (value == "Not Available" || value == "") { return }
      if (label != "") {
        value = label ": " value ;
        # Check the exact label is already there
        # Java Awk doesn't like building regexs on the fly, so putting them in variables first
        labeltest1 = " - " label ":"
        labeltest2 = "^" label ":"
        if (array[arrayID] ~ labeltest1 || array[arrayID] ~ labeltest2) {
          # Replacement Part Number / Part Number is often repeated, so if this is the problem, skip...
          if (tolower(label) ~ /part number/) { return }
          print "MSHW;ERROR; - Label Already Added - ID: " arrayID " - LineNumber: " NR "- Line: " $0 ;
          return
        }
      }
      if (array[arrayID] == "") {
        array[arrayID] = value
      } else {
        array[arrayID] = array[arrayID] " - " value
      }
    }

    function stripFormatting(value){
      gsub(/.*: */,"",value);
      gsub(/ *$/,"",value);
      return value;
    }

    #
    # MAIN SECTION
    #

    # Reset Section
    $NF ~ /-------------------/ {
      section = "" ;
      ID = "" ;
      subsection == ""
    }

    $1 ~ /^SUMMARY---*$/ { section = "Summary" }

    section == "Summary" {
      if ($1 ~ /Current/ && $2 ~ /configuration/) { subsection = "currentConfiguration"}
      if (subsection == "currentConfiguration") {
        if ($1 ~ /Pending/ && $2 ~ /configuration/) { subsection = ""}
        if ($1 ~ /Firmware/ && $2 ~ /version/) { appendArray(Firmware,"system",$NF,"Firmware Version") }
        if ($1 ~ /NVSRAM/ && $2 ~ /version/) { appendArray(Firmware,"system",$NF,"NVSRAM Version") }
        if ($1 ~ /AMW/ && $2 ~ /version/) { appendArray(Firmware,"system",$NF,"AMW Version") }
      }
    }

    section != "" {
      # LastSubSectionFlag
      # Set conditions here to reset subsection when subsection header is missing
      if (lastsubsectionFlag == "1") {
        lastsubsectionFlag = "0"
        if ($1 ~ /Status:/) {
          subsection = lastsubsection
          ID = ""
        }
      }

      # Universal Fields
      if ($1 ~ /Status/) {
        statusInformationValue = $0 ;
        gsub(/.*Status: */,"",statusInformationValue);
        gsub(/ *$/,"",statusInformationValue);
        setArray(statusInformation,ID,statusInformationValue,"")
        statusValue = $2 ;
        if ($3 != "") { statusValue = statusValue " " $3 }
        setArray(status,ID,statusValue,"")
      }
      if ($1 ~ /Part/ && $2 ~ /number/) { appendArray(additionalInformation,ID,$NF,"Part Number") }
      if ($1 ~ /Serial/ && $2 ~ /number/) { appendArray(additionalInformation,ID,$NF,"Serial Number") }
      if ($1 ~ /Replacement/ && $2 ~ /part/) { appendArray(additionalInformation,ID,$NF,"Alternate Part Number") }
      if ($1 ~ /Product/ && $2 ~ /ID/) { appendArray(additionalInformation,ID,stripFormatting($0),"Part Number") }
      if ($1 ~ /Type:/) { appendArray(additionalInformation,ID,stripFormatting($0),"Type") }
      if ($1 ~ /Manufacturer/ || $1 ~ /Vendor/) { appendArray(additionalInformation,ID,stripFormatting($NF),"Vendor") }
      # Can be Revision or Revision Level or Product Revision
      if (($1 ~ /Revision/ || $2 ~ /[Rr]evision/) && $NF !~/:/) { appendArray(additionalInformation,ID,$NF,"Version") }
      if ($1 ~ /Link/ && $2 ~ /status/) { setArray(linkStatus,ID,$3,"") }
    }


    # Controller Information
    $1 ~ /^CONTROLLERS---*$/ { section = "Controllers" }
    section == "Controllers" {
      #MD3000
      if ($0 ~ /RAID Controller Module in Enclosure /) {
        ID = $0;
        gsub(/.*RAID Controller Module in /,"",ID);
          displayID[ID] = "Controller in " ID
          controllerID = ID
        type[ID] = "Controller"
        enclosureID[ID] = $6;
        gsub(/,/,"",enclosureID[ID]);
        enclosureType[ID] = "Enclosure"
      }
      #               #DS3200                           #DS4500
      if ($0 ~ /Controller in Enclosure/ || $0 ~ /Controller in Slot/) {
        ID = $0;
        gsub(/.*Controller in /,"",ID);
        displayID[ID] = "Controller in " ID
        controllerID = ID
        type[ID] = "Controller"
        # If the enclosure not specified, then set it to TemporaryEnclosureID and it will be replaced later
        if ($0 ~ /Controller in Slot/) { enclosureID[ID] = "TemporaryEnclosureID" }
        if ($0 ~ /Controller in Enclosure/) {
          enclosureID[ID] = $4 ;
          gsub(/,/,"",enclosureID[ID]);
        }
        enclosureType[ID] = "Enclosure"
      }
      if ($1 ~ /Location:/) { appendArray(additionalInformation,ID,$NF,"Location") }
      if ($1 ~ /Current/ && $2 ~ /configuration/) { subsection = "currentConfiguration"}
      if ($1 ~ /Pending/ && $2 ~ /configuration/) { subsection = ""}
      if (subsection == "currentConfiguration") {
        if ($1 ~ /Firmware/ && $2 ~ /version/) { appendArray(firmware,ID,$NF,"Firmware Version") }
        if ($1 ~ /Appware/ && $2 ~ /version/) { appendArray(firmware,ID,$NF,"Appware Version") }
        if ($1 ~ /Bootware/ && $2 ~ /version/) { appendArray(firmware,ID,$NF,"Bootware Version") }
      }
      if (subsection == "") {
        if ($1 ~ /Model/ && $2 ~ /name/) { setArray(model,ID,stripFormatting($0),"") }
        if ($1 ~ /Board/ && $2 ~ /ID/) { appendArray(additionalInformation,ID,$NF,"Board ID") }
        if ($1 ~ /Submodel/ && $2 ~ /ID/) { appendArray(additionalInformation,ID,$NF,"Submodel ID") }
        if ($1 ~ /Vendor:/) { appendArray(additionalInformation,ID,stripFormatting($0),"Vendor") }
      }

      # Data Cache Module
      # Processor Cache Module
      # Host Interface Board
      # Cache Backup Device

      if ($1 ~ /Data/ && $2 ~ /[Cc]ache/ && $3 ~ /[Mm]odule/) {
        subsection = "DataCacheModule"
        ID = ""
      }
      if ($1 ~ /Processor/ && $2 ~ /[Cc]ache/ && $3 ~ /[Mm]odule/) {
        subsection = "ProcessorCacheModule"
        ID = ""
      }
      if ($1 ~ /Host/ && $2 ~ /[Ii]nterface/ && $3 ~ /[Bb]oard/) {
        subsection = "HostInterfaceBoard"
        ID = ""
      }
      if ($1 ~ /Cache/ && $2 ~ /[Bb]ackup/ && $3 ~ /[Dd]evice/) {
        subsection = "CacheBackupDevice"
        ID = ""
      }
      if (subsection == "DataCacheModule" || subsection == "ProcessorCacheModule" || subsection == "HostInterfaceBoard" || subsection == "CacheBackupDevice") {
        if ($1 ~ /[Ss]tatus:/) {
          statusValue = $2;
          if ($3 != "") { statusValue = statusValue $3 }
          statusInformationValue = stripFormatting($0);
        }
        if ($2 ~ /[Ss]tatus:/) {
          statusValue = $3;
          if ($4 != "") { statusValue = statusValue $4 }
          statusInformationValue = stripFormatting($0);
        }
        if ($3 ~ /[Ss]tatus:/) {
          statusValue = $4;
          if ($5 != "") { statusValue = statusValue $5 }
          statusInformationValue = stripFormatting($0);
        }
        # If we get all the way to Vendor without finding a status, then print with no "location"
        if ($1 ~ /Location:/ || ($1 ~ /Vendor/ && ID == "")) {
          if ($1 ~ /Location:/) { location = stripFormatting($0) }
          if ($1 ~ /Vendor/) { location = "NoLocation" }
          ID = subsection "-" controllerID "-" location
          displayID[ID] = location
          type[ID] = subsection
            setArray(statusInformation,ID,statusInformationValue,"")
            setArray(status,ID,statusValue,"")
          enclosureType[ID] = "Blade"
          enclosureID[ID] = controllerID
        }
        if ($1 ~ /Capacity:/) { appendArray(additionalInformation,ID,stripFormatting($0),"Capacity") }
        if ($0 ~ /Date of manufacture/) {
          ID = controllerID ;
          lastsubsectionFlag = 1 ;
          lastsubsection = subsection;
          subsection = "" ;
        }
      }

      # Ethernet Port
      if ($1 ~ /Ethernet/ && $2 ~ /port:/) {
        subsection = "ethernetPort"
        ID = "ETH-" controllerID "-" $NF
        displayID[ID] = "Ethernet Port-" $NF
        type[ID] = "EthernetPort"
        enclosureType[ID] = "Blade"
        enclosureID[ID] = controllerID
      }
      if (subsection == "ethernetPort") {
        if ($1 ~ /MAC/ && $2 ~ /address/) { setArray(macAddress,ID,$NF,"") }
        if ($1 ~ /Port/ && $2 ~ /speed/) {
          speed = $3 ;
          if (speed ~ "/") { gsub(".*/","",speed) }
          gsub(/[Uu]nknown/,"0",speed)
          if ($4 ~ /[Gg]bps/) { speed = speed * 1000 }
          setArray(portSpeed,ID,speed,"")
        }
      }

      # Physical Disk Interface
      if (($1 ~ /Physical/ && $2 ~ /Disk/ && $3 ~ /[Ii]nterface:/) || ($1 ~ /Drive/ && $2 ~ /[Ii]nterface:/)) {
        subsection = "PhysicalDiskInterface"
        ID = "PDI-" controllerID "-" $NF
        displayIDtemp = "Physical Disk Interface-" $NF
        getline
        ID = ID "-Channel-" $NF
        displayIDtemp = displayIDtemp "-Channel-" $NF
        getline
        ID = ID "-Port-" $NF ;
        displayID[ID] = displayIDtemp "-Port-" $NF ;
        type[ID] = "PhysicalDiskInterface"
        enclosureType[ID] = "Blade"
        enclosureID[ID] = controllerID
      }
      if (subsection == "PhysicalDiskInterface") {
        if ($1 ~ /Port/ && $2 ~ /speed/) {
          speed = $3 ;
          gsub(/[Uu]nknown/,"",speed)
          gsub(/[Nn]ot/,"",speed)
          if ($4 ~ /[Gg]bps/) { speed = speed * 1000 }
          setArray(portSpeed,ID,speed,"")
        }
        if ($1 ~ /Current/ && $2 ~ /data/ && $3 ~ /rate/) {
          speed = $4 ;
          gsub(/[Uu]nknown/,"",speed)
          gsub(/[Nn]ot/,"",speed)
          if ($5 ~ /[Gg]bps/) { speed = speed * 1000 }
          setArray(portSpeed,ID,speed,"")
        }
      }
      # Host Interface
      if ($1 ~ /Host/ && $2 ~ /interface:/) {
        subsection = "hostInterface"
        displayIDtemp = "Host Interface-" $NF
        ID = "HI-" controllerID "-" $NF
        getline
        if ($1 ~ /Channel/) {
          ID = ID "-Channel-" $NF;
          displayIDtemp = displayIDtemp "-Channel-" $NF
        }
        if ($1 ~ /Port/) {
          ID = ID "-Port-" $NF;
          displayIDtemp = displayIDtemp "-Port-" $NF
        }
        getline
        if ($1 ~ /Channel/) {
          ID = ID "-Channel-" $NF;
          displayIDtemp = displayIDtemp "-Channel-" $NF
        }
        if ($1 ~ /Port/) {
          ID = ID "-Port-" $NF;
          displayIDtemp = displayIDtemp "-Port-" $NF
        }
        displayID[ID] = displayIDtemp
        type[ID] = "HostInterface"
        enclosureType[ID] = "Blade"
        enclosureID[ID] = controllerID
      }
      if (subsection == "hostInterface") {
        if ($1 ~ /Vendor:/) { appendArray(additionalInformation,ID,stripFormatting($0),"Vendor") }
        if ($1 ~ /MAC/ && $2 ~ /address/) { setArray(macAddress,ID,$NF,"") }
        if ($1 ~ /Current/ && ($2 ~ /data/ || $2 ~ /port/)) {
          speed = $4 ;
          gsub(/[Uu]nknown/,"",speed)
          gsub(/[Nn]ot/,"",speed)
          if ($5 ~ /[Gg]bps/) { speed = speed * 1000 }
          setArray(portSpeed,ID,speed,"")
        }
        if ($1 ~ /Part/ && $2 ~ /type/) {
          appendArray(additionalInformation,ID,$3,"Part Type") ;
          appendArray(additionalInformation,ID,$5,"Version")
        }
      }
    }

    # Arrays (Disk Group)
    $1 ~ /ARRAYS---*$/ { section = "Arrays" }
    section == "Arrays" {
      if ($1 ~ /Array/ && $3 ~ /RAID/) {
        ID = "DG-" $2
        displayID[ID] = "Disk Group-" $2
        type[ID] = "DiskGroup"
        enclosureType[ID] = "Enclosure"
        enclosureID[ID] = "Global"
        raidLevelTemp = $4;
        gsub(/[)]/,"",raidLevelTemp)
        appendArray(additionalInformation,ID,raidLevelTemp,"Raid Level")
      }
    }

    # Disk Groups Information
    $1 ~ /DISK/ && $2 ~ /GROUPS---*$/ { section = "DiskGroup" }
    section == "DiskGroup" {
      if ($1 ~ /Name:/) {
        ID = "DG-" $NF
        displayID[ID] = "Disk Group-" $NF
        type[ID] = "DiskGroup"
        enclosureType[ID] = "Enclosure"
        enclosureID[ID] = "Global"
      }
      if ($1 ~ /[Cc]apacity/) {
        capacityTemp = $2 ;
        gsub(/,/,"",capacityTemp)
        # Covert to Megabytes
        if ($3 == "GB") { capacityTemp = capacityTemp * 1.073509134 }
        if ($3 == "TB") { capacityTemp = capacityTemp * 1073.509134369 }
        if ($3 == "MB") { capacityTemp = capacityTemp * 0.001073509 }
        setArray(size,ID,capacityTemp,"")
      }
      if ($1 ~ /RAID/ && $2 ~ /[Ll]evel/) { appendArray(additionalInformation,ID,$NF,"Raid Level") }
      if ($3 ~ /[Ss]tatus:/) {
        statusValue = $4;
        if ($5 != "") { statusValue = statusValue $5 }
        setArray(statusInformation,ID,stripFormatting($0),"")
        setArray(status,ID,statusValue,"")
      }
    }

    # Drives
    $1 ~ /DRIVES---*$/ {section = "Drives" }
    section == "Drives" {
      #MD3000
      if ($0 ~ /Physical Disk at Enclosure/) {
        ID = $0 ;
        gsub(/.*Physical Disk at /,"",ID);
        ID = "PD-" ID;
        displayID[ID] = "Slot " $7;
        enclosureType[ID] = "Enclosure"
        enclosureID[ID] = $5;
        gsub(/,/,"",enclosureID[ID])
          type[ID] = "PhysicalDisk"
      }
      #DS3200
      if ($0 ~ /Drive at Enclosure/) {
        ID = $0;
        gsub(/.*Drive at /,"",ID);
        ID = "PD-" ID;
        displayID[ID] = "Slot " $6;
        enclosureType[ID] = "Enclosure"
        enclosureID[ID] = $4;
        gsub(/,/,"",enclosureID[ID])
        type[ID] = "PhysicalDisk"
        # For systems with only one enclosure, sometimes the ID isn't specified, so we will extract and put it in an array
        TemporaryEnclosureIDtemp = $4;
        gsub(/,/,"",TemporaryEnclosureIDtemp)
        TemporaryEnclosureArray[ID] = TemporaryEnclosureIDtemp
      }

      if ($1 ~ /Raw/ && $2 ~ /[Cc]apacity:/) {
        capacityTemp = $(NF-1) ;
        gsub(/,/,"",capacityTemp)
        # Covert to Megabytes
        if ($NF == "GB") { capacityTemp = capacityTemp *    1.073741824 }
        if ($NF == "TB") { capacityTemp = capacityTemp *    1073.741824 }
        if ($NF == "MB") { capacityTemp = capacityTemp * 0.001073741824 }
        setArray(size,ID,capacityTemp,"")
      }
      if ($1 ~ /Mode:/) {
        typeTemp = $0;
        gsub(/.*: */,"",typeTemp);
        appendArray(additionalInformation,ID,typeTemp,"Mode")
      }
      if ($1 ~ /Media/ && $2 ~ /type/) {
        typeTemp = $0;
        gsub(/.*: */,"",typeTemp);
        appendArray(additionalInformation,ID,typeTemp,"Media Type")
      }
      if ($1 ~ /Interface/ && $2 ~ /type/) {
        typeTemp = $0;
        gsub(/.*: */,"",typeTemp);
        appendArray(additionalInformation,ID,typeTemp,"Interface Type")
      }
      if ($0 ~ /Physical Disk Firmware Version:/) { appendArray(additionalInformation,ID,$NF,"Firmware") }
      if ($1 ~ /Manufacturer:/) { setArray(vendor,ID,$NF,"") }
      if ($1 ~ /Vendor:/) { setArray(vendor,ID,$NF,"") }
      if ($1 ~ /Product/ && $2 ~ /ID/) { setArray(model,ID,stripFormatting($0),"") }
      if ($1 ~ /Serial/ && $2 ~ /number/) { setArray(serialNumber,ID,$NF,"") }
      # Some disks have information about ATA translators at the end we don't care about, but raise flags, so will reset ID to igrnore (DS4300)
      if ($1 ~ /ATA/ && $2 ~ /Translator/) { ID = "" }
    }

    # Enclosure
    $1 ~ /ENCLOSURES---*$/ {
      section = "Enclosure"
      # Reset variables that shouldn't be carried between enclosure discoveries
      attachedToTemp = ""
    }

    section == "Enclosure" {
      if ($0 ~ / Overall Component Information/) {
        ID = $(NF-3)
        # On some systems, system are titled "Controller/Drive Enclosure Overall Component Information", we will put a marker
        if (ID ~ /Enclosure/) { ID = "TemporaryEnclosureID" }
        currentEnclosureID = ID
        displayID[ID] = $0 ; gsub(/ Overall Component Information/,"",displayID[ID]); gsub(/^ */,"",displayID[ID]);
        type[ID] = "Enclosure"
      }
      if ($1 ~ /Service/ && $2 ~ /tag/) {
        appendArray(additionalInformation,ID,$NF,"Service Tag")
        setArray(serialNumber,ID,$NF,"")
      }
      if ($1 ~ /Asset/ && $2 ~ /tag/) { appendArray(additionalInformation,ID,$NF,"Asset Tag") }
      if ($1 ~ /Chassis/ && $2 ~ /name/) { appendArray(additionalInformation,ID,$NF,"Chassis Name") }
      if ($1 ~ /Vendor/) {
        appendArray(additionalInformation,ID,$NF,"Vendor")
        setArray(vendor,ID,$NF,"")
      }

      # Battery
      # The ID is shown after the status, which causes issues all subsequent "location" will trigger a new instance, so we'll set a Flag to only trigger on the next location
      if ($1 ~ /Battery/ && $2 ~ /[Ss]tatus/) {
        statusInformationValue = stripFormatting($0);
        statusValue = $3;
        if ($4 != "") { statusValue = statusValue " " $4 }
        subsection = "battery"
        batteryFlag = "true"
      }
      if (subsection == "battery") {
        if ($1 ~ /Location:/ && batteryFlag == "true") {
          batteryFlag = "false"
          location = stripFormatting($0);
          ID = "Battery-Enclosure-" currentEnclosureID "-" location
          displayID[ID] = location
          type[ID] = "Battery"
          setArray(statusInformation,ID,statusInformationValue,"")
          setArray(status,ID,statusValue,"")
          enclosureType[ID] = "Enclosure"
          enclosureID[ID] = currentEnclosureID
        }
      }

      # Interconnect battery Canister
      # This is the overall status of the Interconnect Batteries (DS4800)
      if ($1 ~ /Interconnect-[Bb]attery/ && $2 ~ /[Cc]anister/ && $3 ~ /[Ss]tatus:/) {
        ID = "Interconnect-Battery-Cannister-Enclosure-" currentEnclosureID
        displayID[ID] = "Interconnect Battery Cannister"
        statusValue = $4 ;
        if ($5 != "") { statusValue = statusValue " " $5 }
          setArray(statusInformation,ID,stripFormatting($0),"")
          setArray(status,ID,statusValue,"")
        type[ID] = "Battery"
        enclosureType[ID] = "Enclosure"
        enclosureID[ID] = currentEnclosureID
      }

    # # Interconnect battery CRUs
    # This is the overall status of the Interconnect Batteries (DS5100)
      if ($1 ~ /Interconnect-[Bb]attery/ && $2 ~ /CRU/ && $3 ~ /[Ss]tatus:/) {
        ID = "Interconnect-Battery-CRU-Enclosure-" currentEnclosureID
        displayID[ID] = "Interconnect Battery CRU"
        statusValue = $4 ; if ($5 != "") {statusValue = statusValue " " $5 } ;
        setArray(statusInformation,ID,stripFormatting($0),"")
        setArray(status,ID,statusValue,"")
        type[ID] = "Battery"
        enclosureType[ID] = "Enclosure"
        enclosureID[ID] = currentEnclosureID
      }

      # Power Supply
      #              MD3000                   DS3200
      if ($0 ~ /Power [Ss]upply.*status:/ || $0 ~ /Power-fan.*status:/) {
        subsection = "PowerSupply"
        # Get Status first as we might need to getline
        statusInformationValue = $0 ;
        gsub(/.*status: */,"",statusInformationValue);
        gsub(/ *$/,"",statusInformationValue);
        # if the line does not contain a location (Something between Supply and Status), do a getline
        if ($0 ~ /Power [Ss]upply status:/) {
          getline
          if ($1 ~ /Location:/) {
            location = $0 ; gsub(/.*: */,"",location);
            ID = "PowerSupply-Enclosure-" currentEnclosureID "-" location
            displayID[ID] = location; gsub(/[Cc]anister ?/,"",displayID[ID]);
          } else {
            next
          }
        } else {
          location = $0 ;
          gsub(/ status:.*$/,"",location);
          gsub(/^ */,"",location);
          ID = "PowerSupplyCanister-Enclosure-" currentEnclosureID "-" location
          displayID[ID] = location ;
        }
        gsub(/ *$/,"",location);
        type[ID]="PowerSupply"
        # We only want the first two words of the statusInformation
        split(statusInformationValue,statusValueArray," ")
        statusValue = statusValueArray[1]
        if (statusValueArray[2] != "") { statusValue = statusValue " " statusValueArray[2] }
        setArray(statusInformation,ID,statusInformationValue,"")
        setArray(status,ID,statusValue,"")
        enclosureType[ID] = "Enclosure"
        enclosureID[ID] = currentEnclosureID
      }

      # Power Supply Canisters
      # Specific to DS4300-2-MSHW-1498 output, otherwise found in PSU section
      # Also DS4500
      # Instances can have no location so we will blank the ID to prevent an error from status set
      if ($1 ~ /Power/ && $2 ~ /[Ss]upply/ && $3 ~ /[Cc]anister/) {
        subsection = "PowerSupplyCanister"
        canisterFlag="true"
        ID = ""
      }

      # Fan Canisters
      # Specific to DS4300-2-MSHW-1498 output, otherwise found in Fan section
      # Also DS4500
      # Instances can have no location so we will blank the ID to prevent an error from status set
      if ($1 ~ /Fan/ && $2 ~ /[Cc]anister/) {
        subsection = "FanCanister"
        canisterFlag="true"
        ID = ""
      }

      if (subsection == "PowerSupplyCanister" || subsection == "FanCanister") {
        if ($1 ~ /Location:/ && canisterFlag == "true") {
          canisterFlag="false"
          location = stripFormatting($0);
          ID = subsection "-" currentEnclosureID "-" location
          displayID[ID] = subsection "-" location
          enclosureType[ID] = "Enclosure"
          enclosureID[ID] = currentEnclosureID
          if (subsection == "PowerSupplyCanister") { type[ID] = "PowerSupply" }
          if (subsection == "FanCanister") { type[ID] = "Fan" }
        }
        if ($1 ~ /Status:/ && ID == "") {
          canisterFlag="false"
          ID = subsection "-" currentEnclosureID "-" location
          if (type[ID] != "") { ID = ID "1" }
          displayID[ID] = subsection "-" location
          if (subsection == "PowerSupplyCanister") { type[ID] = "PowerSupply" }
          if (subsection == "FanCanister") { type[ID] = "Fan" }
          statusValue = $2 ; if ($3 != "") {statusValue = statusValue " " $3 } ;
          setArray(statusInformation,ID,stripFormatting($0),"")
          setArray(status,ID,statusValue,"")
          enclosureType[ID] = "Enclosure"
          enclosureID[ID] = currentEnclosureID
        }
      }

      # Fans
      # The ID is shown after the status, which causes issues all subsequent "location" will trigger a new instance, so we'll set a Flag to only trigger on the next location
      if ($1 ~ /Fan/ && $2 ~ /[Ss]tatus/) {
        statusValue = $3 ;
        if ($4 != "") { statusValue = statusValue " " $4 }
        subsection = "fan"
        fanFlag = "true" ;
        fanStatusSet = "true" ;
      }
      if (subsection == "fan") {
        if ($1 ~ /Location:/ && fanFlag == "true") {
          fanFlag = "false"
          location = stripFormatting($0);
          ID = "Fan-Enclosure-" currentEnclosureID "-" location
          # Sometimes the ID is not unique due to output, so we'll just add a "1".
          if (type[ID] != "") { ID = ID "1" }
          displayID[ID] = location
          type[ID] = "Fan"
          if (fanStatusSet == "true") {
            setArray(statusInformation,ID,stripFormatting($0),"")
            setArray(status,ID,statusValue,"")
            fanStatusSet = "false"
          }
          enclosureType[ID] = "Enclosure"
          enclosureID[ID] = currentEnclosureID
        }
      }

      # EMM/ESM Cards
      # The ID is shown after the status, which causes issues all subsequent "location" will trigger a new instance, so we'll set a Flag to only trigger on the next location
      # The location is often several lines after the status line, so will set ID to nul
      if ($1 ~ /EMM/ && $2 ~ /card/ && $3 ~ /[Ss]tatus/) {
        statusInformationValue = stripFormatting($0);
        statusValue = $4 ;
        if ($5 != "") { statusValue = statusValue " " $5 }
        subsection = "EMM"
        emmFlag = "true" ;
        emmStatusSet = "true"
        ID = ""
      }
      if ($1 ~ /ESM/ && $2 ~ /card/ && $3 ~ /[Ss]tatus/) {
        statusInformationValue = stripFormatting($0);
        statusValue = $4 ;
        if ($5 != "") { statusValue = statusValue " " $5 }
        subsection = "ESM"
        emmFlag = "true"
        emmStatusSet = "true"
        ID = ""
      }
      if ($1 ~ /ESM/ && $2 ~ /card/ && NF == 2) {
        subsection = "ESM"
        emmFlag = "true" ;
        getline
        if ($1 ~ /Status/) {
          statusInformationValue = stripFormatting($0);
          statusValue = $2;
          if ($3 != "") { statusValue = statusValue " " $3 }
          emmStatusSet = "true"
        }
      }
      if (subsection == "EMM" || subsection == "ESM") {
        if ($1 ~ /Location:/ && emmFlag == "true") {
          emmFlag = "false"
          location = stripFormatting($0);
          ID = subsection "-Enclosure-" currentEnclosureID "-" location
          displayID[ID] = location
          type[ID] = subsection
          if (emmStatusSet == "true") {
            setArray(statusInformation,ID,statusInformationValue,"")
            setArray(status,ID,statusValue,"")
            emmStatusSet = "false"
          }
          enclosureType[ID] = "Enclosure"
          enclosureID[ID] = currentEnclosureID
          # to insert the mini-hub into the ID, we put it in attachedToTemp which is used by SFP
          attachedToTemp = subsection "-" location "-"
        }
      }

      # Mini Hubs
      # Only found on one model. DS4500
      if ($1 ~ /Host/ && $2 ~ /[Mm]ini.[Hh]ub/ && $3 ~ /[Cc]anister/) {
        subsection = "HostMiniHub"
        minihubflag = "true"
        ID = ""
      }
      if ($1 ~ /Drive/ && $2 ~ /[Mm]ini.[Hh]ub/ && $3 ~ /[Cc]anister/) {
        subsection = "DriveMiniHub"
        minihubflag = "true"
        ID = ""
      }
      if (subsection == "DriveMiniHub" || subsection == "HostMiniHub") {
        if ($1 ~ /Status:/) {
          statusValue = $2;
          if ($3 != "") { statusValue = statusValue " " $3 }
          canisterStatusFound = "true" ;
        }
        if ($1 ~ /Location:/) {
          location = stripFormatting($0);
          ID = subsection "-" currentEnclosureID "-" location
          displayID[ID] = currentEnclosureID "-" location
          type[ID] = subsection
          enclosureType[ID] = "Enclosure"
          enclosureID[ID] = currentEnclosureID
          # to insert the mini-hub into the ID, we put it in attachedToTemp which is used by SFP
          attachedToTemp = subsection "-" location "-"
          if (canisterStatusFound == "true") {
            setArray(statusInformation,ID,stripFormatting($0),"")
            setArray(status,ID,statusValue,"")
            canisterStatusFound = "false"
          }
        }
      }

      # SFP Cards
      # The ID is shown after the status, which causes issues all subsequent "location" will trigger a new instance, so we'll set a Flag to only trigger on the next location
      # The location is often several lines after the status line, so will set ID to nul
      # SFPs can also be in "mini-hub" canisters.  See Mini-Hub section for these SFPs.
      if ($1 ~ /SFP/ && $2 ~ /[Ss]tatus/) {
        statusInformationValue = stripFormatting($0);
        statusValue = $3;
        if ($4 != "") { statusValue = statusValue " " $4 }
        subsection = "SFP"
        sfpFlag = "true" ;
        sfpStatusFound = "true"
        ID = ""
      }
      if ($1 ~ /SFP/ && NF == 1) {
        subsection = "SFP"
        sfpFlag = "true" ;
        getline
        if ($1 ~ /Status/) {
          statusInformationValue = stripFormatting($0);
          statusValue = $2;
          if ($3 != "") { statusValue = statusValue " " $3 }
          sfpStatusFound = "true"
        }
      }
      if (subsection == "SFP") {
        if ($1 ~ /Attached/ && $2 ~ /[Tt]o:/) { attachedToTemp = stripFormatting($0) }
        if ($1 ~ /Location:/ && sfpFlag == "true") {
          sfpFlag = "false"
          location = stripFormatting($0);
          ID = "SFP-Enclosure-" currentEnclosureID "-" attachedToTemp "-" location
          # Sometimes the ID is not unique due to output, so we'll just add a "1".
          if (type[ID] != "") { ID = ID "1" }
          displayID[ID] =  attachedToTemp "-" location
          type[ID] = "SFP"
          if (sfpStatusFound == "true") {
            setArray(statusInformation,ID,statusInformationValue,"")
            setArray(status,ID,statusValue,"")
            sfpStatusFound = "false"
          }
          enclosureType[ID] = "Enclosure"
          enclosureID[ID] = currentEnclosureID
        }
      }

      # Temperature
      # The ID is shown after the status, which causes issues all subsequent "location" will trigger a new instance, so we'll set a Flag to only trigger on the next location
      if ($0 ~ /Temperature.* [Ss]tatus:/) {
        statusInformationValue = $0;
        gsub(/.*status: */,"",statusInformationValue);
        gsub(/ *$/,"",statusInformationValue);
        subsection = "temperature"
        temperatureFlag = "true" ;
      }
      if (subsection == "temperature") {
        if ($1 ~ /Location:/ && temperatureFlag == "true") {
          temperatureFlag = "false"
          location = $0 ;
          gsub(/.*: */,"",location) ;
          ID = "Temperature-Enclosure-" currentEnclosureID "-" location
          # Sometimes the ID is not unique due to output, so we'll just add a "1".
          if (type[ID] != "") { ID = ID "1" }
          displayID[ID] = location
          type[ID] = "Temperature"
          split(statusInformationValue,statusValueArray," ")
          statusValue = statusValueArray[1]
          if (statusValueArray[2] != "") { statusValue = statusValue " " statusValueArray[2] }
          setArray(statusInformation,ID,statusInformationValue,"")
          setArray(status,ID,statusValue,"")
          enclosureType[ID] = "Enclosure"
          enclosureID[ID] = currentEnclosureID
        }
      }
    }

    END {
      # Create a General enclosure
      type["Global"]="Enclosure";
      displayID["Global"]="Global";

      # If we have an object with an ID of "TemporaryEnclosureID", then
      # Search the TemporaryEnclosureArray for an enclosure number that is not known
      if (type["TemporaryEnclosureID"] != "") {
        for (forID in TemporaryEnclosureArray) {
          matchFound = "false"
          for (ID in type) {
            if (type[ID] == "Enclosure") {
              if (ID == TemporaryEnclosureArray[forID]) { matchFound = "true" }
            }
          }
          if (matchFound == "false") { TemporaryEnclosureID = TemporaryEnclosureArray[forID] }
        }
        # If we don't find a match, it means the ID-less enclosure doesn't have any disks... Uggh
        # We will just have to make a name up
        if (TemporaryEnclosureID == "") { TemporaryEnclosureID = "Controller" }
      }

      # Print the Array
      for (ID in type) {
        # Replace TemporaryEnclosureID in ID, displayID
        IDtemp = ID ; gsub(/TemporaryEnclosureID/,TemporaryEnclosureID,IDtemp)
        gsub(/TemporaryEnclosureID/,TemporaryEnclosureID,displayID[ID])
        gsub(/TemporaryEnclosureID/,TemporaryEnclosureID,enclosureID[ID])
        additionalfield1 = "" ; additionalfield2 = "" ; additionalfield3 = "" ; additionalfield4 = "" ;
        # For network cards, put link status in status and speed in statusInformation
        if (type[ID] == "EthernetPort" || type[ID] == "HostInterface" || type[ID] == "PhysicalDiskInterface") {
          statusInformation[ID] = portSpeed[ID] ;
          additionalfield1 = macAddress[ID]
          if (macAddress[ID] != "") {additionalfield2 = "MAC"}
          if (status[ID] == "") { status[ID] = linkStatus[ID] }
          # if there is no link status still, use speed to determine up/down
          if (status[ID] == "") {
            if (statusInformation[ID] == "0" || statusInformation[ID] == "") {
              status[ID] = "Down"
            } else {
              status[ID] = "Up"
            }
          }
        }
        # Some classes require additional information to be in separate fields, here we put then in additionalfields before printing (lets us only have one print statement)
        if (type[ID] == "Enclosure") {
          additionalfield1 = vendor[ID];
          additionalfield2 = serialNumber[ID];
        }
        if (type[ID] == "Controller") {
          additionalfield1 = model[ID];
          additionalfield2 = serialNumber[ID];
        }
        if (type[ID] == "DiskGroup") { additionalfield1 = size[ID] }
        if (type[ID] == "PhysicalDisk") {
          additionalfield1 = size[ID];
          additionalfield2 = serialNumber[ID];
          additionalfield3 = model[ID];
          additionalfield4 = vendor[ID];

          # remove duplicate serialNumber if property exists in both addition information and parameter
          labeltest1 = " - Serial Number:"
          labeltest2 = "^Serial Number:"
          if (additionalInformation[ID] ~ labeltest1 || additionalInformation[ID] ~ labeltest2) {
            replace = "Serial Number: " additionalfield2;
            gsub(replace, "", additionalInformation[ID]);
            gsub(/ - $/, "", additionalInformation[ID]);
          }

          # remove duplicate vendor if property exists in both addition information and parameter
          labeltest1 = " - Vendor:"
          labeltest2 = "^Vendor:"
          if (additionalInformation[ID] ~ labeltest1 || additionalInformation[ID] ~ labeltest2) {
            replace = "Vendor: " additionalfield4;
            gsub(replace, "", additionalInformation[ID]);
            gsub(/ - $/, "", additionalInformation[ID]);
          }

          # remove duplicate PartNumber if property exists in both addition information and parameter
          labeltest1 = " - Part Number:"
          labeltest2 = "^Part Number:"
          if (additionalInformation[ID] ~ labeltest1 || additionalInformation[ID] ~ labeltest2) {
            replace = "Part Number: " additionalfield3;
            gsub(replace, "", additionalInformation[ID]);
            gsub(/ - $/, "", additionalInformation[ID]);
          }

          # remove trailing " - " which should not exist but it does.
          gsub(/ - $/, "", additionalInformation[ID]);
        }
        if (type[ID] != "") {
          print "MSHW;" type[ID] ";" IDtemp ";" displayID[ID] ";" enclosureID[ID] ";" enclosureType[ID] ";" status[ID] ";" statusInformation[ID] ";" additionalInformation[ID] ";" additionalfield1 ";" additionalfield2 ";" additionalfield3 ";" additionalfield4 ";"
        }
      }
    }
translations:
  linkStatusTranslationTable:
    Down: degraded
    Connected: ok
    Failed: degraded
    Up: ok
    Default: degraded
  statusTranslationTable:
    ? ""
    : ""
    Near expiration: degraded
    Failed: failed
    Contacting Storage: degraded
    Offline: failed
    Battery maintenance: ok
    Removed: failed
    Default: degraded
    Unresponsive: failed
    Needs Attention: failed
    By-passed: failed
    Battery learning: ok
    Battery replacement: failed
    Needs Upgrade: failed
    Online: ok
    Optimal: ok
    Fixing: degraded
    Impending failure: degraded
