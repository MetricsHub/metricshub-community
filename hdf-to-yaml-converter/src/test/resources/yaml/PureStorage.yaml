---
embedded:
  EmbeddedFile(1): |-
    BEGIN {outputMatch = 0}
    $1 ~ /[Nn]ame/ && $2 ~ /[Tt]ype/ && $3 ~ /[Ss]tatus/ && $4 ~ /[Cc]apacity/ {outputMatch = 1}
    outputMatch == 1 && $4 ~ /^[0-9.]+/ {
          enclosure = $1 ; gsub ("[.].+","",enclosure);
          displayID = $1 ; gsub ("^.+[.]","",displayID);
          size = $4 ;
          if (size ~ /[Gg]/) {gsub(/[Gg]/,"",size) }
          if (size ~ /[Mm]/) {gsub(/[Mm]/,"",size); size = size / 1024}
          if (size ~ /[Tt]/) {gsub(/[Tt]/,"",size); size = size * 1024}
    #            MSHW;ID;Type;Status;Status;Capacity;Enclosure;DisplayID;
          print "MSHW;" $1 ";" $2 ";" $3 ";" $3 ";" size ";" enclosure ";" displayID ";"
        }
  EmbeddedFile(2): |-
    BEGIN {outputMatch = 0}
    $1 ~ /[Nn]ame/ && $2 ~ /[Ss]tatus/ && $3 ~ /[Ii]dentify/ {outputMatch = 1}
    outputMatch == 1 && $1 ~ /^[SC][HT][0-9]/ {
          type = $1 ;
          enclosure = $1 ; gsub ("[.].+","",enclosure);
          displayID = $1 ; gsub ("^.+[.]","",displayID);
          if ($2 ~ /not_installed/) {next}
          if (type ~ /^[SC][HT][0-9]+\.BAY/) {next}
          if (type ~ /^[SC][HT][0-9]+\.DRV/) {next}
             if (type ~ /^CT[0-9]+$/) {type = "MSHW_Enclosure;Controller" }
             if (type ~ /^[SC][HT][0-9]+\.FAN/) {type = "MSHW_Fan" ;
                                              CurrentReading = $6 ; gsub (/rpm/,"",CurrentReading);
                                             }
          if (type ~ /^[SC][HT][0-9]+\.PWR/) {type = "MSHW_PSU" }
          if (type ~ /^[SC][HT][0-9]+\.ETH/ || type ~ /^[SC][HT][0-9]+\.FC/ || type ~ /^[SC][HT][0-9]+\.SAS/ || type ~ /^[SC][HT][0-9]+\.IB/) {
                                          type = "MSHW_NetworkCard"
                                            CurrentReading = $6
                                            LinkStatus = 1
                                            if ($7 ~ /Gb/) {
                                                                            CurrentReading = CurrentReading * 1000
                                                                           }
                                          if (CurrentReading == 0) {
                                              CurrentReading = ""
                                              LinkStatus = 0
                                              }
                                         }
          if (type ~ /^SH[0-9]+$/) {type = "MSHW_Enclosure;Disk Shelf" }
          if (type ~ /^CH[0-9]+$/) {type = "MSHW_Enclosure;Chassis" }
          if (type ~ /^[SC][HT][0-9]+\.IOM/) {type = "MSHW_OtherDevice" }
    #All         MSHW_Type;ID;Status;Status;CurrentReading;Enclosure;DisplayID;
    #OtherDevice/Controller/Shelf MSHW_Type;DeviceType;ID;Status;Status;CurrentReading;Enclosure;DisplayID;LinkStatus;
          print type ";" $1 ";" $2 ";" $2";" CurrentReading ";" enclosure ";" displayID ";" LinkStatus ";"
         }
translations:
  statusInformationTranslationTable:
    failed: Failed
    ok: ""
    degraded: Degraded
    not_installed: Missing
  statusTranslationTable:
    default: failed
    failed: failed
    ok: ok
    degraded: degraded
    not_installed: failed
  linkTranslationTable:
    "0": degraded
    default: ok
  driveTranslationTable:
    default: failed
    healthy: ok
    missing: failed
    failed: failed
    reachable: degraded
    foreign: degraded
  driveInformationTranslationTable:
    healthy: healthy
    missing: 'Missing - '
    failed: 'Failed - '
    reachable: 'Reachable but not initialized - '
    foreign: 'Drive is foreign to the array - '
connector:
  displayName: Pure Storage FA Series (SSH)
  platforms: Pure Storage
  reliesOn: Pure Storage Management Card
  version: 1.0
  information: "This connector discovers the environmental, physical disks, management network cards and fiber ports on Pure Storage FA Series arrays."
  detection:
    connectionTypes:
    - remote
    appliesTo:
    - Storage
    criteria:
    # Test the  command
    - type: osCommand
      commandLine: puredrive list
      expectedResult: BAY
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Get the list of Hardware Components
          type: osCommand
          commandLine: purehw list
          computes:
            # Run this through awk EF2
            # All         MSHW_Type;ID;Status;Status;CurrentReading;
            # OtherDevice/Enc MSHW_Type;DeviceType;ID;Status;Status;CurrentReading;Enclosure;DisplayID;
          - type: awk
            script: EmbeddedFile(2)
            separators: ;
            keep: ^MSHW
        source(2):
          # Make a copy of Table 1 so that a clean copy can be used by other discoveries
          # MSHW_Type;DeviceType;ID;Status;Status;CurrentReading;Enclosure;DisplayID;
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only components of basetype "system"
            # MSHW_Type;DeviceType;ID;Status;Status;CurrentReading;Enclosure;DisplayID;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_Enclosure$
        source(3):
          # as this command will be used for otherdevices and physical disks we run it during the enclosure discovery
          type: osCommand
          commandLine: puredrive list
          computes:
            # Run this through awk EF1
            # MSHW;ID;Type;Status;Status;Capacity;Enclosure;DisplayID;
          - type: awk
            script: EmbeddedFile(1)
            separators: ;
            keep: ^MSHW
      mapping:
        # Instances
        # MSHW_Type;DeviceType;ID;Status;Status;CurrentReading;Enclosure;DisplayID;
        source: $monitors.enclosure.discovery.sources.source(2)$
        attributes:
          id: $column(3)
          __display_id: $column(8)
          vendor: Pure Storage
          model: $column(2)
          name: "sprintf(\"%s (%s %s)\", $column(8), \"Pure Storage\", $column(2))"
    collect:
      # MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Get the list of Hardware Components
          type: osCommand
          commandLine: purehw list
          computes:
            # Run this through awk EF2
            # All         MSHW_Type;ID;Status;Status;CurrentReading;Enclosure;DisplayID;
            # OtherDevice/Enc MSHW_Type;DeviceType;ID;Status;Status;CurrentReading;Enclosure;DisplayID;
          - type: awk
            script: EmbeddedFile(2)
            separators: ;
            keep: ^MSHW
        source(2):
          # Make a copy of Table 1 so that a clean copy can be used by other collects
          # MSHW_Type;DeviceType;ID;Status;Status;CurrentReading;Enclosure;DisplayID;
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only components of basetype "system"
            # MSHW_Type;DeviceType;ID;Status;Status;CurrentReading;Enclosure;DisplayID;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_Enclosure$
            # Now translate  into OK/Warning/Alarm
            # MSHW_Type;DeviceType;ID;PatrolStatus;Status;CurrentReading;Enclosure;DisplayID;
          - type: translate
            column: 4
            translationTable: statusTranslationTable
            # Translate Status Information
            # MSHW_Type;DeviceType;ID;PatrolStatus;StatusInformation;CurrentReading;Enclosure;DisplayID;
          - type: translate
            column: 5
            translationTable: statusInformationTranslationTable
        source(3):
          # we run the command for other devices and physical disks collect
          type: osCommand
          commandLine: puredrive list
          computes:
            # Run this through awk EF1
            # MSHW;ID;Type;Status;Status;Capacity;Enclosure;DisplayID;
          - type: awk
            script: EmbeddedFile(1)
            separators: ;
            keep: ^MSHW
            # Now translate  into OK/Warning/Alarm
            # MSHW;ID;Type;PatrolStatus;Status;Capacity;Enclosure;DisplayID;
          - type: translate
            column: 4
            translationTable: driveTranslationTable
            # Translate Status Information
            # MSHW;ID;Type;PatrolStatus;StatusInformation;Capacity;Enclosure;DisplayID;
          - type: translate
            column: 5
            translationTable: driveInformationTranslationTable
      mapping:
        # Value Table
        # MSHW_Type;DeviceType;ID;PatrolStatus;StatusInformation;CurrentReading;Enclosure;DisplayID;
        source: $monitors.enclosure.collect.sources.source(2)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="enclosure"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(5)
  temperature:
    discovery:
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Discovery.Source(2)
          # MSHW_Type;ID;Status;Status;CurrentReading;Enclosure;DisplayID;
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only components of basetype "system"
            # MSHW_Type;ID;Status;Status;CurrentReading;Enclosure;DisplayID;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_Temperature$
      mapping:
        # InstanceTable = Source(1)
        # MSHW_Type;ID;Status;Status;CurrentReading;Enclosure;DisplayID;
        source: $monitors.temperature.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          __display_id: $column(7)
          hw.parent.type: enclosure
          hw.parent.id: $column(6)
          name: $column(7)
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Collect.Source(1)
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only components of basetype "system"
            # MSHW_Type;ID;Status;Status;CurrentReading;Enclosure;DisplayID;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_Temperature$
            # Now translate  into OK/Warning/Alarm
            # MSHW_Type;ID;PatrolStatus;Status;CurrentReading;Enclosure;DisplayID;
          - type: translate
            column: 3
            translationTable: statusTranslationTable
            # Translate Status Information
            # MSHW_Type;ID;PatrolStatus;StatusInformation;CurrentReading;Enclosure;DisplayID;
          - type: translate
            column: 4
            translationTable: statusInformationTranslationTable
      mapping:
        # ValueTable = Source(1)
        # MSHW_Type;ID;PatrolStatus;StatusInformation;CurrentReading;Enclosure;DisplayID;
        source: $monitors.temperature.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.temperature: $column(5)
          hw.status{hw.type="temperature"}: $column(3)
        legacyTextParameters:
          StatusInformation: $column(4)
  fan:
    discovery:
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Discovery.Source(2)
          # MSHW_Type;ID;Status;Status;CurrentReading;Enclosure;DisplayID;
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only components of basetype "system"
            # MSHW_Type;ID;Status;Status;CurrentReading;Enclosure;DisplayID;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_Fan$
      mapping:
        # InstanceTable = Source(1)
        # MSHW_Type;ID;Status;Status;CurrentReading;Enclosure;DisplayID;
        source: $monitors.fan.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          __display_id: $column(7)
          hw.parent.type: enclosure
          hw.parent.id: $column(6)
          name: $column(7)
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Collect.Source(1)
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only components of basetype "system"
            # MSHW_Type;ID;Status;Status;CurrentReading;Enclosure;DisplayID;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_Fan$
            # Now translate  into OK/Warning/Alarm
            # MSHW_Type;ID;PatrolStatus;Status;CurrentReading;Enclosure;DisplayID;
          - type: translate
            column: 3
            translationTable: statusTranslationTable
            # Translate Status Information
            # MSHW_Type;ID;PatrolStatus;StatusInformation;CurrentReading;Enclosure;DisplayID;
          - type: translate
            column: 4
            translationTable: statusInformationTranslationTable
      mapping:
        # ValueTable = Source(1)
        # MSHW_Type;ID;PatrolStatus;StatusInformation;CurrentReading;Enclosure;DisplayID;
        source: $monitors.fan.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="fan"}: $column(3)
        legacyTextParameters:
          StatusInformation: $column(4)
  power_supply:
    discovery:
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Discovery.Source(2)
          # MSHW_Type;ID;Status;Status;CurrentReading;Enclosure;DisplayID;
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only components of basetype "system"
            # MSHW_Type;ID;Status;Status;CurrentReading;Enclosure;DisplayID;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PSU$
      mapping:
        # InstanceTable = Source(1)
        # MSHW_Type;ID;Status;Status;CurrentReading;Enclosure;DisplayID;
        source: $monitors.power_supply.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          __display_id: $column(7)
          hw.parent.type: enclosure
          hw.parent.id: $column(6)
          name: "sprintf(\"%s, $column(7))"
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Collect.Source(1)
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only components of basetype "system"
            # MSHW_Type;ID;Status;Status;CurrentReading;Enclosure;DisplayID;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PSU$
            # Now translate  into OK/Warning/Alarm
            # MSHW_Type;ID;PatrolStatus;Status;CurrentReading;Enclosure;DisplayID;
          - type: translate
            column: 3
            translationTable: statusTranslationTable
            # Translate Status Information
            # MSHW_Type;ID;PatrolStatus;StatusInformation;CurrentReading;Enclosure;DisplayID;
          - type: translate
            column: 4
            translationTable: statusInformationTranslationTable
      mapping:
        # ValueTable = Source(1)
        # MSHW_Type;ID;PatrolStatus;StatusInformation;CurrentReading;Enclosure;DisplayID;
        source: $monitors.power_supply.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="power_supply"}: $column(3)
        legacyTextParameters:
          StatusInformation: $column(4)
  network:
    discovery:
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Discovery.Source(2)
          # MSHW_Type;ID;Status;Status;CurrentReading;Enclosure;DisplayID;
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only components of basetype "system"
            # MSHW_Type;ID;Status;Status;CurrentReading;Enclosure;DisplayID;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_NetworkCard
      mapping:
        # InstanceTable = Source(1)
        # MSHW_Type;ID;Status;Status;CurrentReading;Enclosure;DisplayID;
        source: $monitors.network.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          __display_id: $column(7)
          hw.parent.type: enclosure
          hw.parent.id: $column(6)
          name: $column(7)
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Collect.Source(1)
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only components of basetype "system"
            # MSHW_Type;ID;Status;Status;CurrentReading;Enclosure;DisplayID;LinkStatus
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_NetworkCard
            # Now translate  into OK/Warning/Alarm
            # MSHW_Type;ID;PatrolStatus;Status;CurrentReading;Enclosure;DisplayID;LinkStatus
          - type: translate
            column: 3
            translationTable: statusTranslationTable
            # Translate Status Information
            # MSHW_Type;ID;PatrolStatus;StatusInformation;CurrentReading;Enclosure;DisplayID;LinkStatus
          - type: translate
            column: 4
            translationTable: statusInformationTranslationTable
            # Translate Speed into Link
            # MSHW_Type;ID;PatrolStatus;StatusInformation;CurrentReading;Enclosure;DisplayID;LinkStatus
          - type: translate
            column: 8
            translationTable: linkTranslationTable
      mapping:
        # ValueTable = Source(1)
        # MSHW_Type;ID;PatrolStatus;StatusInformation;CurrentReading;Enclosure;DisplayID;LinkStatus
        source: $monitors.network.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="network"}: $column(3)
          hw.network.up: legacyLinkStatus($column(8))
          hw.network.bandwidth.limit: megaBit2Bit($column(5))
        legacyTextParameters:
          StatusInformation: $column(4)
  physical_disk:
    discovery:
      sources:
        source(1):
          # Get the list of Disk Components
          type: copy
          from: $monitors.enclosure.discovery.sources.source(3)$
          computes:
            # Convert the size into bytes
            # MSHW;ID;Type;Status;Status;Capacity;Enclosure;DisplayID;
          - type: multiply
            column: 6
            value: 1073741824
            # Remove Nvram
            # MSHW;ID;Type;Status;Status;Capacity;Enclosure;DisplayID;
          - type: excludeMatchingLines
            column: 3
            valueList: NVRAM
            # Remove unused slots
            # MSHW;ID;Type;Status;Status;Capacity;Enclosure;DisplayID;
          - type: excludeMatchingLines
            column: 4
            valueList: unused
      mapping:
        # MSHW;ID;Type;Status;Status;Capacity;Enclosure;DisplayID;
        source: $monitors.physical_disk.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          __display_id: $column(8)
          hw.parent.type: enclosure
          hw.parent.id: $column(7)
          name: "sprintf(\"%s (%s)\", $column(8), $column(6))"
        metrics:
          hw.physical_disk.size: $column(6)
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Get the list of Disk Components
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
      mapping:
        # ValueTable = Source(1)
        # MSHW;ID;Type;PatrolStatus;StatusInformation;Capacity;Enclosure;DisplayID;
        source: $monitors.physical_disk.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="physical_disk"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(5)
  other_device:
    discovery:
      sources:
        source(1):
          # discover NVRAMs
          type: copy
          from: $monitors.enclosure.discovery.sources.source(3)$
          computes:
            # keeponly nvram
            # MSHW;ID;Type;Status;Status;Capacity;Enclosure;DisplayID;
          - type: keepOnlyMatchingLines
            column: 3
            valueList: NVRAM
            # keeponly nvram
            # MSHW;ID;Type;Status;Status;Capacity;Enclosure;DisplayID;
          - type: excludeMatchingLines
            column: 4
            valueList: unused
        source(2):
          # copy enclosure table to keep only otherdevice
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only OtherDevice
            # MSHW_Type;ID;Status;Status;CurrentReading;Enclosure;DisplayID;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_OtherDevice
            # standardize both sources
            # MSHW_Type;ID;IOM;Status;Status;CurrentReading;Enclosure;DisplayID;
          - type: rightConcat
            column: 2
            value: ;IOM
        source(3):
          # tableunion of otherdevice.disco(1) and 2
          type: tableUnion
          tables:
          - $monitors.other_device.discovery.sources.source(1)$
          - $monitors.other_device.discovery.sources.source(2)$
      mapping:
        # value table = source(3)
        # MSHW_Type;ID;Type;Status;Status;CurrentReading;Enclosure;DisplayID;
        source: $monitors.other_device.discovery.sources.source(3)$
        attributes:
          id: $column(2)
          __display_id: $column(8)
          device_type: $column(3)
          hw.parent.type: enclosure
          hw.parent.id: $column(7)
          name: "sprintf(\"%s: %s\", $column(3), $column(8))"
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Collect.Source(1)
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only components of basetype "system"
            # MSHW_Type;ID;Status;Status;CurrentReading;Enclosure;DisplayID;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OtherDevice
            # Now translate  into OK/Warning/Alarm
            # MSHW_Type;ID;PatrolStatus;Status;CurrentReading;Enclosure;DisplayID;
          - type: translate
            column: 3
            translationTable: statusTranslationTable
            # Translate Status Information
            # MSHW_Type;ID;PatrolStatus;StatusInformation;CurrentReading;Enclosure;DisplayID;
          - type: translate
            column: 4
            translationTable: statusInformationTranslationTable
            # standardize both sources
            # MSHW_Type;ID;IOM;Status;Status;CurrentReading;Enclosure;DisplayID;
          - type: rightConcat
            column: 2
            value: ;IOM
        source(2):
          # / Get the list of Disk Components
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
        source(3):
          # tableunion of otherdevice.collect(1) and 2
          type: tableUnion
          tables:
          - $monitors.other_device.collect.sources.source(1)$
          - $monitors.other_device.collect.sources.source(2)$
      mapping:
        # ValueTable = Source(3)
        # MSHW;ID;Type;PatrolStatus;StatusInformation;Capacity;Enclosure;DisplayID;
        source: $monitors.other_device.collect.sources.source(3)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="other_device"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(5)
