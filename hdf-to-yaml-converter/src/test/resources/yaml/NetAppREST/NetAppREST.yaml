---
connector:
  displayName: NetApp Filer (REST)
  platforms: NetApp
  reliesOn: NetApp REST API
  version: 1.0
  information: "This connector discovers the enclosure and the disks of NetApp disk arrays (filer) as well as the various environment sensors (temperatures, fans, power supplies, etc.). It relies on the REST API protocol."
  detection:
    connectionTypes:
    - remote
    appliesTo:
    - Storage
    criteria:
    # Check that system-get-vendor-info at least contains "NetApp
    - type: http
      method: POST
      url: /servlets/netapp.servlets.admin.XMLrequest_filer
      body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><system-node-get-iter/></netapp>
      expectedResult: <product-version>NetApp
      errorMessage: Credentials Incorrect / Not a NetApp Filer system
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Source(1) = Nodes
          # Get XML from REST API Call <system-node-get-iter/>
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><system-node-get-iter/></netapp>
          computes:
          # Convert xml output to multiLine
          - type: awk
            script: "${file::embeddedFile-18}"
        source(2):
          # Source(2) = Multi-line XML for Nodes
          # Preserve Enclosure Discovery Source 1 for use elsewhere
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Convert xml output to CSV
            # MSHW;node;node-model;node-serial;product-version;cup-firmware-version;is-node-healthy
          - type: awk
            script: "${file::embeddedFile-1}"
          # Add Node column to act as type
          - type: rightConcat
            column: 1
            value: ;Node
        source(3):
          # Source(3) = Storage Shelves
          # Get XML from REST API Call <storage-shelf-info-get-iter/>
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><storage-shelf-info-get-iter/></netapp>
          computes:
          # Convert xml output to multiLine
          - type: awk
            script: "${file::embeddedFile-18}"
        source(4):
          # Source(4) = Multi-line XML for Shelves
          # Preserve Enclosure Discovery Source 3 for use elsewhere
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(3)}"
          computes:
            # Convert xml output to CSV
            # MSHW;shelf;shelf-model;serial-number;;;op-status
          - type: awk
            script: "${file::embeddedFile-2}"
            # Concat ";Shelf" to Column for type
            # MSHW;type;shelf;shelf-model;serial-number;;;op-status
          - type: rightConcat
            column: 1
            value: ;Shelf
        source(5):
          # Source(5) = All enclosures (Nodes + Shelves)\nUnion the Nodes and Shelves tables\nTable 1 // MSHW;type;node; node-model; node-serial;  product-version;cpu-firmware-version;is-node-healthy\nTable 2 // MSHW;type;shelf;shelf-model;serial-number;\t\t\t\t\t\t   ;\t\t\t\t\t\t\t\t\t  ;op-status\nindex   //    1;   2;    3;          4;            5;              6;                   7;\t\t   \t\t\t\t8
          type: tableUnion
          tables:
          - "${source::monitors.enclosure.discovery.sources.source(2)}"
          - "${source::monitors.enclosure.discovery.sources.source(4)}"
          computes:
          - type: leftConcat
            column: 6
            value: "Firmware Version: "
      mapping:
        # Enclosure Instance Table
        # MSHW;type;node;model;serial;product-version;firmware;status
        source: "${source::monitors.enclosure.discovery.sources.source(5)}"
        attributes:
          type: $2
          id: $3
          __display_id: $3
          vendor: NetApp
          model: $4
          serial_number: $5
          info: $6
          name: "${awk::sprintf(\"Enclosure: %s (%s %s)\", $3, \"NetApp\", $4)}"
    collect:
      # Collection Type (Multi-instance)
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Nodes
          # Get XML from REST API Call <system-node-get-iter/>
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><system-node-get-iter/></netapp>
          computes:
          # Convert xml output to multiLine
          - type: awk
            script: "${file::embeddedFile-18}"
        source(2):
          # Source(2) = Multi-line XML for Nodes
          # Preserve Enclosure Discovery Source 1 for use elsewhere
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Convert xml output to CSV
            # MSHW;node;node-model;node-serial;product-version;cup-firmware-version;is-node-healthy
          - type: awk
            script: "${file::embeddedFile-1}"
        source(3):
          # Source(3) = Shelves
          # Get XML from REST API Call <storage-shelf-info-get-iter/>
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><storage-shelf-info-get-iter/></netapp>
          computes:
          # Convert xml output to multiLine
          - type: awk
            script: "${file::embeddedFile-18}"
        source(4):
          # Source(4) = Multi-line XML for Nodes
          # Preserve Enclosure Discovery Source 3 for use elsewhere
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(3)}"
          computes:
            # Convert xml output to CSV
            # MSHW;shelf;shelf-model;serial-number;;;op-status
          - type: awk
            script: "${file::embeddedFile-2}"
        source(5):
          # Union the Nodes and Shelves tables\nSource(5) = All enclosures (Nodes + Shelves)\nTable 1 // MSHW; node; node-model; node-serial;  product-version;cpu-firmware-version;is-node-healthy\nTable 2 // MSHW;shelf;shelf-model;serial-number;\t\t\t\t\t\t    ;\t\t\t\t\t\t\t\t\t   ;op-status\nindex   //    1;   2;    3;          4;            5;              6;                   7;
          type: tableUnion
          tables:
          - "${source::monitors.enclosure.collect.sources.source(2)}"
          - "${source::monitors.enclosure.collect.sources.source(4)}"
          computes:
          - type: duplicateColumn
            column: 7
            # Translate is-node-healthy to PatrolStatus
            # MSHW;node;node-model;node-serial;product-version;cup-firmware-version;is-node-healthy
          - type: translate
            column: 7
            translationTable: "${translation::EnclosureHealthTranslationTable}"
          - type: translate
            column: 8
            translationTable: "${translation::EnclosureStatusInformationTable}"
      mapping:
        # Enclosure Value Table
        # MSHW;node;node-model;node-serial;product-version;cup-firmware-version;is-node-healthy
        source: "${source::monitors.enclosure.collect.sources.source(5)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="enclosure"}: $7
  power_supply:
    discovery:
      sources:
        source(1):
          # Source(1) = Nodes
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Xml2Cvs using AWK
            # MSHW;node;env-failed-power-supply-count;env-failed-power-supply-message;
          - type: awk
            script: "${file::embeddedFile-3}"
            # Add "Global" as name
            # MSHW;node;Name;env-failed-power-supply-count;env-failed-power-supply-message;
          - type: rightConcat
            column: 2
            value: ;Global
            # Duplicate node to align with second source table and provide unique ID.
            # MSHW;node;node;Name;env-failed-power-supply-count;env-failed-power-supply-message;
          - type: duplicateColumn
            column: 2
        source(2):
          # Source(3) = Storage Shelves
          # Use XML from AWK after it's been multi-lined
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(3)}"
          computes:
            # Xml2Cvs using AWK
            # MSHW;shelf;psu-id;op-status;
          - type: awk
            script: "${file::embeddedFile-4}"
          # Duplicate psu-id for use in uniqueId and DisplayID
          - type: duplicateColumn
            column: 3
          # Create unique-id by concating shelf and psu-id (computes 3-4)
          - type: leftConcat
            column: 3
            value: .
          # MSHW;shelf;psu-id;psu-id;op-status;
          - type: leftConcat
            column: 3
            value: $2
          # Append "PSU - " to ID to create displayID
          - type: leftConcat
            column: 4
            value: 'PSU - '
        source(3):
          # Source(3) = All PSUs
          # Union Node and Shelf PSUs
          # Combine both node and shelve power supplies.
          # If the nodes report on the status of the shelf power supplies. We will get duplicate events.
          # table 1 // MSHW; node;     node;       name;env-failed-power-supply-count;env-failed-power-supply-message;
          # table 2 // MSHW;shelf;unique-id;displayname;op-status;
          # index   //    1    2          3           4
          type: tableUnion
          tables:
          - "${source::monitors.power_supply.discovery.sources.source(1)}"
          - "${source::monitors.power_supply.discovery.sources.source(2)}"
      mapping:
        # Powersupply Instance Table
        source: "${source::monitors.power_supply.discovery.sources.source(3)}"
        attributes:
          id: $3
          __display_id: $4
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $4
    collect:
      # Collection Type (Multi-instance)
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Nodes
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Convert XML to CSV
            # MSHW;node;env-failed-power-supply-count;env-failed-power-supply-message;
          - type: awk
            script: "${file::embeddedFile-3}"
        source(2):
          # Source(2) = Shelves
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(3)}"
          computes:
            # Convert XML to CSV
            # MSHW;shelf;psu-id;op-status;
          - type: awk
            script: "${file::embeddedFile-4}"
            # Create unique-id (computes 2-3)
            # MSHW;shelf;unique-id;op-status;
          - type: leftConcat
            column: 3
            value: .
          - type: leftConcat
            column: 3
            value: $2
            # Drop columns to align with Nodes
            # MSHW;unique-id;op-status;
          - type: keepColumns
            columnNumbers: "1,3,4"
            # Duplicate status to be used as StatusInformation
            # MSHW;unique-id;op-status;op-status
          - type: duplicateColumn
            column: 3
        source(3):
          # Source(3) = All PSUs
          # Union Nodes and Shelves
          # Combine both node and shelve power supplies.
          # If the nodes report on the status of the shelf power supplies. We will get duplicate events.
          # table 1 // MSHW;node;     PatrolStatus;env-failed-power-supply-message;
          # table 2 // MSHW;unique-id;PatrolStatus;op-status
          type: tableUnion
          tables:
          - "${source::monitors.power_supply.collect.sources.source(1)}"
          - "${source::monitors.power_supply.collect.sources.source(2)}"
          computes:
            # Translate status to PatrolStatus
            # MSHW;unique-id;PatrolStatus;StatusInformation
          - type: translate
            column: 3
            translationTable: "${translation::PowerSupplyStatusTranslationTable}"
      mapping:
        # PowerSupply Value Table
        # MSHW;unique-id;PatrolStatus;StatusInformation
        source: "${source::monitors.power_supply.collect.sources.source(3)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="power_supply"}: $3
        legacyTextParameters:
          StatusInformation: $4
  fan:
    discovery:
      sources:
        source(1):
          # Source(1) = Nodes
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Xml2Cvs using AWK
            # MSHW;node;env-failed-fan-count;env-failed-fan-message;
          - type: awk
            script: "${file::embeddedFile-5}"
            # Add "Global" as name
            # MSHW;node;name;env-failed-fan-count;env-failed-fan-message;
          - type: rightConcat
            column: 2
            value: ;Global
            # Duplicate column 2 to use as uniqueID
            # MSHW;node;node;name;env-failed-fan-count;env-failed-fan-message;
          - type: duplicateColumn
            column: 2
        source(2):
          # Source(2) = Storage Shelves
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(3)}"
          computes:
            # Xml2Cvs using AWK
            # MSHW;shelf;fan-id;op-status;
          - type: awk
            script: "${file::embeddedFile-6}"
            # Duplicate fan-id since we need it for uniqueId and displayID
            # MSHW;shelf;fan-id;fan-id;op-status;
          - type: duplicateColumn
            column: 3
          # Combine shelf and fan-id to create uniqueID (Computes 3-4)
          - type: leftConcat
            column: 3
            value: .
          # MSHW;shelf;unique-id;fan-id;op-status;
          - type: leftConcat
            column: 3
            value: $2
            # Add "Fan - " to ID for display name
            # MSHW;shelf;unique-id;name;op-status;
          - type: leftConcat
            column: 4
            value: 'Fan - '
        source(3):
          # Source(3) = All Fans
          # Union Node and Shelf PSUs
          # Table 1 // MSHW;node; node;     name;env-failed-fan-count;env-failed-fan-message;
          # Table 2 // MSHW;shelf;unique-id;name;op-status;
          type: tableUnion
          tables:
          - "${source::monitors.fan.discovery.sources.source(1)}"
          - "${source::monitors.fan.discovery.sources.source(2)}"
      mapping:
        # Fan Instance Table
        # MSHW;node;uniqueId;name;env-failed-fan-count;env-failed-fan-message;
        source: "${source::monitors.fan.discovery.sources.source(3)}"
        attributes:
          id: $3
          __display_id: $4
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $4
    collect:
      # Collection Type (Multi-instance)
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Nodes
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Xml2Cvs using AWK
            # MSHW;node;env-failed-fan-count;env-failed-fan-message;
          - type: awk
            script: "${file::embeddedFile-5}"
        source(2):
          # Source(2) = Shelves
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(3)}"
          computes:
            # Xml2Cvs using AWK
            # MSHW;shelf;psu-id;op-status;
          - type: awk
            script: "${file::embeddedFile-6}"
            # Concat Shelf and fan-id to create uniqueID (computes 2-3)
            # MSHW;shelf;psu-id;op-status;
          - type: leftConcat
            column: 3
            value: .
          # MSHW;shelf;unique-id;op-status;
          - type: leftConcat
            column: 3
            value: $2
            # drop "shelf" (Column(2)) to align with node table
            # MSHW;unique-id;op-status;
          - type: keepColumns
            columnNumbers: "1,3,4"
            # Duplicate Column 3 for StatusInformation
            # MSHW;unique-id;op-status;op-status
          - type: duplicateColumn
            column: 3
        source(3):
          # Source(3) = All Fans
          # Table Union
          # Table 1 // MSHW;node;     env-failed-fans-count;env-failed-power-supply-message;
          # Table 2 // MSHW;unique-id;op-status;          # op-status
          type: tableUnion
          tables:
          - "${source::monitors.fan.collect.sources.source(1)}"
          - "${source::monitors.fan.collect.sources.source(2)}"
          computes:
            # Translate Fan status into PatrolStatus
            # MSHW;unique-id;PatrolStatus;StatusInformation
          - type: translate
            column: 3
            translationTable: "${translation::FanStatusTranslationTable}"
      mapping:
        # Fan Value Table
        # MSHW;unique-id;PatrolStatus;StatusInformation
        source: "${source::monitors.fan.collect.sources.source(3)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="fan"}: $3
        legacyTextParameters:
          StatusInformation: $4
  battery:
    discovery:
      sources:
        source(1):
          # Source(1) = Nodes
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Xml2Cvs using AWK
            # MSHW;node;nvram-battery-status
          - type: awk
            script: "${file::embeddedFile-7}"
            # Add "NV RAM" as battery name (Column 2)
            # MSHW;node;name;nvram-battery-status
          - type: rightConcat
            column: 2
            value: ;NV RAM
      mapping:
        # Battery Instance Table
        source: "${source::monitors.battery.discovery.sources.source(1)}"
        attributes:
          id: $2
          __display_id: $3
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $3
    collect:
      sources:
        source(1):
          # Source(1) = Nodes
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Xml2Cvs using AWK
            # MSHW;node;nvram-battery-status
          - type: awk
            script: "${file::embeddedFile-7}"
            # Duplicate status column for StatusInformation
            # MSHW;node;nvram-battery-status;battery-status
          - type: duplicateColumn
            column: 3
            # Translate nvram-battery-status to PatrolStatus
            # MSHW;node;PatrolStatus;battery-status
          - type: translate
            column: 3
            translationTable: "${translation::BatteryStatusTranslationTable}"
            # Translate battery-status into StatusInformation
            # MSHW;node;PatrolStatus;StatusInformation
          - type: translate
            column: 4
            translationTable: "${translation::BatteryStatusInformationTranslationTable}"
      mapping:
        # Battery Value Table
        # MSHW;node;PatrolStatus;StatusInformation
        source: "${source::monitors.battery.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="battery"}: $3
        legacyTextParameters:
          StatusInformation: $4
  temperature:
    discovery:
      sources:
        source(1):
          # Source(1) = Nodes
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Xml2Cvs using AWK
            # MSHW;node;env-over-temperature
          - type: awk
            script: "${file::embeddedFile-8}"
            # Add "Global" as bettery name (Column 2)
            # MSHW;node;name;env-over-temperature
          - type: rightConcat
            column: 2
            value: ;Global
            # Duplicate node as uniqueID
            # MSHW;node;node;name;env-over-temperature
          - type: duplicateColumn
            column: 2
        source(2):
          # Source(3) = Shelves
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(3)}"
          computes:
            # Xml2Cvs using AWK
            # MSHW;shelf;Temperature-id;op-status;
          - type: awk
            script: "${file::embeddedFile-9}"
            # Duplicate temperature-id for use in uniqueID and name
            # MSHW;shelf;Temperature-id;Temperature-id;op-status;
          - type: duplicateColumn
            column: 3
          # Create uniqueID (computes 3-4)
          - type: leftConcat
            column: 3
            value: .
          # MSHW;shelf;unique-id;Temperature-id;op-status;
          - type: leftConcat
            column: 3
            value: $2
          # MSHW;shelf;unique-id;name;op-status;
          - type: leftConcat
            column: 4
            value: 'Temperature - '
        source(3):
          # Source(3) = All Temperatures
          # Union Node and Shelf Temperatures
          # Table 1 // MSHW;node;name;env-over-temperature
          # Table 2 // MSHW;shelf;unique-id;name;status;
          type: tableUnion
          tables:
          - "${source::monitors.temperature.discovery.sources.source(1)}"
          - "${source::monitors.temperature.discovery.sources.source(2)}"
      mapping:
        # Temperature Instance Table
        # MSHW;node;uniqueID;name;env-over-temperature
        source: "${source::monitors.temperature.discovery.sources.source(3)}"
        attributes:
          id: $3
          __display_id: $4
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $4
    collect:
      # Collection Type (Multi-instance)
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Nodes
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Xml2Cvs using AWK
            # MSHW;node;env-over-temperature
          - type: awk
            script: "${file::embeddedFile-8}"
        source(2):
          # Source(2) = Shelves
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(3)}"
          computes:
            # Xml2Cvs using AWK
            # MSHW;shelf;temp-sensor-id;temp-sens-op-status
          - type: awk
            script: "${file::embeddedFile-9}"
          # Create unique ID
          - type: leftConcat
            column: 3
            value: .
          # MSHW;shelf;uniqueID;temp-sensor-id;temp-sens-op-status
          - type: leftConcat
            column: 3
            value: $2
            # Drop "shelf" (Column(2)) to align tables
            # MSHW;unique-id;op-status;
          - type: keepColumns
            columnNumbers: "1,3,4"
            # Duplicate op-status for StatusInformation
            # MSHW;unique-id;op-status;op-status
          - type: duplicateColumn
            column: 3
        source(3):
          # Source(3) = All Temperatures
          # Table Union
          # MSHW;node;env-over-temperature
          # MSHW;unique-id;PatrolStatus;op-status
          type: tableUnion
          tables:
          - "${source::monitors.temperature.collect.sources.source(1)}"
          - "${source::monitors.temperature.collect.sources.source(2)}"
          computes:
          # Translate status information into PatrolStatus
          - type: translate
            column: 3
            translationTable: "${translation::TemperatureStatusTranslationTable}"
      mapping:
        # Temperature Value Table
        # MSHW;unique-id;PatrolStatus;StatusInformation
        source: "${source::monitors.temperature.collect.sources.source(3)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="temperature"}: $3
        legacyTextParameters:
          StatusInformation: $4
  voltage:
    discovery:
      sources:
        source(1):
          # Source(1) = Shelves
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(3)}"
          computes:
            # Xml2Cvs using AWK
            # MSHW;shelf;Voltage-id;voltage-op-status;
          - type: awk
            script: "${file::embeddedFile-10}"
            # Duplicate voltage-id for use in uniqueID and name
            # MSHW;shelf;voltage-sensor-id;voltage-sensor-id;voltage-op-status
          - type: duplicateColumn
            column: 3
          # Create uniqueID (computes 3-4)
          - type: leftConcat
            column: 3
            value: .
          # MSHW;shelf;unique-id;Voltage-id;op-status;
          - type: leftConcat
            column: 3
            value: $2
            # Append Voltage to id to create name
            # MSHW;shelf;unique-id;Voltage-name;op-status;
          - type: leftConcat
            column: 4
            value: 'Voltage - '
      mapping:
        # Voltage Instance Table
        # MSHW;shelf;uniqueID;name;env-over-Voltage
        source: "${source::monitors.voltage.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $4
    collect:
      # Collection Type (Multi-Instance)
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Shelves
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(3)}"
          computes:
            # Xml2Cvs using AWK
            # MSHW;shelf;Voltage-id;voltage-op-status;
          - type: awk
            script: "${file::embeddedFile-10}"
          # create uniqueID
          - type: leftConcat
            column: 3
            value: .
          # MSHW;shelf;unique-id;voltage-op-status;
          - type: leftConcat
            column: 3
            value: $2
          # MSHW;shelf;unique-id;voltage-id;op-status;
          - type: duplicateColumn
            column: 4
          # MSHW;shelf;unique-id;voltage-id;op-status;
          - type: translate
            column: 4
            translationTable: "${translation::VoltageStatusTranslationTable}"
      mapping:
        # Voltage value Table
        # MSHW;shelf;unique-id;voltage-id;op-status;
        source: "${source::monitors.voltage.collect.sources.source(1)}"
        deviceId: $3
        metrics:
          hw.status{hw.type="voltage"}: $4
        legacyTextParameters:
          StatusInformation: $5
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = Storage Shelf Info
          # Get XML from REST API Call <storage-shelf-info-get-iter/>
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><storage-shelf-info-get-iter/></netapp>
          computes:
          # Convert xml output to multiLine
          - type: awk
            script: "${file::embeddedFile-18}"
        source(2):
          # Source(2) = Storage Shelf Info
          type: copy
          from: "${source::monitors.physical_disk.discovery.sources.source(1)}"
          computes:
            # Xml2Cvs using AWK
            # MSHW;shelf;bay-id;bay-has-disk;bay-type;bay-op-status;
          - type: awk
            script: "${file::embeddedFile-11}"
          # create uniqueID (Computes 2-3)
          - type: leftConcat
            column: 3
            value: .
          # MSHW;shelf;unique-id;bay-has-disk;bay-type;bay-op-status;
          - type: leftConcat
            column: 3
            value: $2
          # Exclude bays that report no drive
          - type: excludeMatchingLines
            column: 4
            regExp: "false"
        source(3):
          # Source(3) = Disks
          # Get XML from REST API Call <storage-disk-get-iter/>
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><storage-disk-get-iter/></netapp>
          computes:
          # Convert xml to multi-line
          - type: awk
            script: "${file::embeddedFile-18}"
        source(4):
          # Source(4) = Disks
          type: copy
          from: "${source::monitors.physical_disk.discovery.sources.source(3)}"
          computes:
            # Xml2Cvs using AWK
            # MSHW;disk-cluster-name;shelf-bay;model;serial-number;bytes-per-sector;capacity-sector;rpm;disk-type
          - type: awk
            script: "${file::embeddedFile-12}"
            # multiply bytes-per-sector (column 6) by capacity-sector (column 7) for size
            # MSHW;uniqueID;shelf-bay;model;serial-number;size;capacity-sector;rpm;disk-type
          - type: multiply
            column: 6
            value: $7
          # MSHW;uniqueID;shelf-bay;model;serial-number;size;capacity-sector;rpm;disk-type
          - type: leftConcat
            column: 8
            value: "RPM: "
        source(5):
          # Source(5) = Table joint of Source(2) and Source(4)
          # Left  // MSHW;shelf;unique-id;bay-has-disk;bay-type;bay-op-status;
          # right // MSHW;uniqueID;shelf-bay;model;serial-number;size;capacity-sector;rpm;disk-type
          # results;
          # MSHW;shelf;uniqueID;bay-has-disk;bay-type;bay-op-status;MSHW;uniqueID;shelf-bay;model;serial-number;size;capacity-sector;rpm;disk-type
          #  1      2        3      4          #  5       6           7     8         9      10    11          # 12      13           14      15
          type: tableJoin
          leftTable: "${source::monitors.physical_disk.discovery.sources.source(2)}"
          rightTable: "${source::monitors.physical_disk.discovery.sources.source(4)}"
          leftKeyColumn: 3
          rightKeyColumn: 2
          defaultRightLine: ;;;;;;;;;;;
          computes:
          - type: leftConcat
            column: 4
            value: "Type: "
      mapping:
        # PhysicalDisk Instancce
        # MSHW;shelf-id;bay-id;bay-has-disk;bay-type;bay-op-status;MSHW;shelf-bay;model;serial-number;size;capacity-sector;rpm;disk-type
        source: "${source::monitors.physical_disk.discovery.sources.source(5)}"
        attributes:
          id: $3
          __display_id: $3
          model: $10
          serial_number: $11
          info: "${awk::join(\" \", $14, $15)}"
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s (%s)\", $3, bytes2HumanFormatBase10($12))}"
        metrics:
          hw.physical_disk.size: $12
    collect:
      # Collect
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = PhysicalDisks
          # Get XML from REST API Call
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><storage-shelf-info-get-iter/></netapp>
          computes:
          - type: awk
            script: "${file::embeddedFile-18}"
        source(2):
          # Source(2) = PhysicalDisks
          type: copy
          from: "${source::monitors.physical_disk.collect.sources.source(1)}"
          computes:
            # Xml2Cvs with Awk
            # MSHW;shelf-id;bay-id;bay-has-disk;bay-type;bay-op-status;
          - type: awk
            script: "${file::embeddedFile-11}"
            # Translate bay-op-status into PatrolStatus
            # MSHW;shelf-id;bay-id;bay-has-disk;bay-type;PatrolStatus;
          - type: translate
            column: 6
            translationTable: "${translation::PhysicalDiskTranslationTable}"
          # create uniqueID (Computes 3-4)
          - type: leftConcat
            column: 3
            value: .
          # MSHW;shelf;unique-id;bay-has-disk;bay-type;PatrolStatus;
          - type: leftConcat
            column: 3
            value: $2
      mapping:
        # PhysicalDisk Value Table
        # MSHW;shelf;unique-id;bay-has-disk;bay-type;PatrolStatus;
        source: "${source::monitors.physical_disk.collect.sources.source(2)}"
        deviceId: $3
        metrics:
          hw.status{hw.type="physical_disk"}: $6
  network:
    discovery:
      sources:
        source(1):
          # Source(1) = NetworkCards
          # Get XML from REST API Call
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><net-port-get-iter/></netapp>
          computes:
          # multi-line the xml response
          - type: awk
            script: "${file::embeddedFile-18}"
        source(2):
          # Source(2) = NetworkCards
          type: copy
          from: "${source::monitors.network.discovery.sources.source(1)}"
          computes:
            # Xml2Cvs with Awk
            # MSHW;node;port;link-status;health-status;mac-address;operational-speed
          - type: awk
            script: "${file::embeddedFile-13}"
            # Add port identifying information for this source (always MAC and "Ethernet Port")
            # MSHW;node;port;link-status;health-status;mac-address;operational-speed;physical-address-type;device-type
          - type: rightConcat
            column: 7
            value: ;MAC;Ethernet Port
        source(3):
          # Fiber ports
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><fcp-adapter-get-iter/></netapp>
          computes:
          # multi-line the xml response
          - type: awk
            script: "${file::embeddedFile-18}"
        source(4):
          # Source(4) = Fiber Channels
          type: copy
          from: "${source::monitors.network.discovery.sources.source(3)}"
          computes:
            # Xml2Cvs with Awk
            # MSHW;node;adapter;link-status;status-description;mac;max-speed
          - type: awk
            script: "${file::embeddedFile-17}"
          # Multiply column 8 to convert gbit/s to mbit/s
          - type: multiply
            column: 7
            value: 1000
            # Add port identifying information for this source (always WWN and "FC Port")
            # MSHW;node;adapter;link-status;status-description;mac;max-speed;physical-address-type;device-type
          - type: rightConcat
            column: 7
            value: ;WWN;FC Port
          # Replace "0" with "" (computes 4-6)
          - type: leftConcat
            column: 7
            value: MSHW
          - type: replace
            column: 7
            existingValue: MSHW0
            newValue: ""
          - type: replace
            column: 7
            existingValue: MSHW
            newValue: ""
        source(5):
          # Source(5) Union of all Network Cards (Ethernet + FCs)
          # Table1   // MSHW;node;port;link-status;health-status;mac-address;operational-speed;physical-address-type;device-type
          # Table2   // MSHW;node;adapter;link-status;status-description;mac;max-speed;physical-address-type;device-type
          type: tableUnion
          tables:
          - "${source::monitors.network.discovery.sources.source(2)}"
          - "${source::monitors.network.discovery.sources.source(4)}"
          computes:
            # Create uniqueID (computes 2-4)
            # MSHW;node;port;port;link-status;health-status;mac-address;speed;physical-address-type;device-type
          - type: duplicateColumn
            column: 3
          - type: leftConcat
            column: 3
            value: .
          # MSHW;node;uniqueId;port;link-status;health-status;mac-address;speed;physical-address-type;device-type
          - type: leftConcat
            column: 3
            value: $2
      mapping:
        # NetworkCard Instance Table
        # MSHW;node;uniqueId;port;link-status;health-status;mac-address;link-speed;physical-address-type;device-type
        source: "${source::monitors.network.discovery.sources.source(5)}"
        attributes:
          id: $3
          __display_id: $4
          physical_address: $7
          physical_address_type: $9
          device_type: $10
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s (%s)\", $4, $10)}"
    collect:
      # Collection type (Multi-instance)
      type: multiInstance
      sources:
        source(1):
          # Source(1) = NetworkCards
          # Get XML from REST API Call
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><net-port-get-iter/></netapp>
          computes:
          # xml to multi-line
          - type: awk
            script: "${file::embeddedFile-18}"
        source(2):
          # Source(2) = NetworkCards
          type: copy
          from: "${source::monitors.network.collect.sources.source(1)}"
          computes:
            # Xml2Cvs using AWK
            # MSHW;node;port;link-status;health-status;mac-address;operational-speed
          - type: awk
            script: "${file::embeddedFile-13}"
        source(3):
          # Source(1) = NetworkCards
          # Get XML from REST API Call
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><fcp-adapter-get-iter/></netapp>
          computes:
          # xml to multi-line
          - type: awk
            script: "${file::embeddedFile-18}"
        source(4):
          # Source(4) = Fiber Channels
          type: copy
          from: "${source::monitors.network.collect.sources.source(3)}"
          computes:
            # Xml2Cvs using AWK
            # MSHW;node;adapter;link-status;status-description;mac;max-speed
          - type: awk
            script: "${file::embeddedFile-17}"
          - type: multiply
            column: 7
            value: 1000
        source(5):
          # Source(5) Union of all Network Cards (Ethernet + FCs)
          # Table1   // MSHW;node;uniqueId;port;   link-status;health-status;     mac;speed
          # Table2   // MSHW;node;uniqueID;adapter;link-status;status-description;mac;speed
          type: tableUnion
          tables:
          - "${source::monitors.network.collect.sources.source(2)}"
          - "${source::monitors.network.collect.sources.source(4)}"
          computes:
            # Duplicate status column (link status)
            # MSHW;node;port;link-status;link-status;health-status;mac-address;operational-speed
          - type: duplicateColumn
            column: 4
            # Duplicate status column (status information)
            # MSHW;node;port;link-status;link-status;link-status;health-status;mac-address;operational-speed
          - type: duplicateColumn
            column: 4
            # Translate NetworkCardStatus into PatrolStatus
            # MSHW;node;port;PatrolStatus;link-status;link-status;health-status;mac-address;operational-speed
          - type: translate
            column: 4
            translationTable: "${translation::NetworkCardStatusTranslationTable}"
            # Translate link-status status into LinkStatus
            # MSHW;node;port;PatrolStatus;link-status;link-status;health-status;mac-address;operational-speed
          - type: translate
            column: 5
            translationTable: "${translation::LinkStatusTranslationTable}"
            # Create uniqueID (computes 5-6)
            # MSHW;node;unique-id;PatrolStatus;link-status;health-status;mac-address;operational-speed
          - type: leftConcat
            column: 3
            value: .
          - type: leftConcat
            column: 3
            value: $2
      mapping:
        # NetworkCard Value Table
        # MSHW;node;unique-id;PatrolStatus;link-status;health-status;mac-address;operational-speed
        source: "${source::monitors.network.collect.sources.source(5)}"
        deviceId: $3
        metrics:
          hw.status{hw.type="network"}: $4
          hw.network.up: legacyLinkStatus($5)
          hw.network.bandwidth.limit: megaBit2Bit($9)
        legacyTextParameters:
          StatusInformation: $6
  logical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = Aggregate (raid) information
          # Get XML from REST API Call
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><aggr-get-iter/></netapp>
          computes:
          # XML to multi-line xml
          - type: awk
            script: "${file::embeddedFile-18}"
        source(2):
          # Source(2) = Aggregate (raid) inforamtion
          type: copy
          from: "${source::monitors.logical_disk.discovery.sources.source(1)}"
          computes:
            # Xml2Cvs using Awk
            # MSHW;;aggregate-uuid;aggregate-name;raid-type;raid-status;
          - type: awk
            script: "${file::embeddedFile-14}"
        source(3):
          # Source(3) = Aggregate (raid) information (node)
          type: copy
          from: "${source::monitors.logical_disk.discovery.sources.source(1)}"
          computes:
            # Xml2Cvs using Awk
            # MSHW;node-name;aggregate-uuid;
          - type: awk
            script: "${file::embeddedFile-15}"
        source(4):
          # Source (4) Join Raid and Node information
          # table1 // MSHW;         ;aggregate-uuid;aggregate-name;raid-type;raid-status;
          # table2 // MSHW;node-name;aggregate-uuid;
          type: tableJoin
          leftTable: "${source::monitors.logical_disk.discovery.sources.source(2)}"
          rightTable: "${source::monitors.logical_disk.discovery.sources.source(3)}"
          leftKeyColumn: 3
          rightKeyColumn: 3
          defaultRightLine: ;;;;;;;
          computes:
          # Move AttachedToDeviceID to column 2
          - type: replace
            column: 2
            existingValue: $2
            newValue: $8
      mapping:
        # LogicalDisk Instance Table
        # MSHW;node-name;aggregate-uuid;aggregate-name;raid-type;raid-status;
        source: "${source::monitors.logical_disk.discovery.sources.source(4)}"
        attributes:
          id: $3
          __display_id: $4
          raid_level: $5
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s (%s)\", $4, $5)}"
    collect:
      # CollectionType (Multi-instance)
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Aggregate (raid) information
          # Get XML from REST API Call
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><aggr-get-iter/></netapp>
          computes:
          # XML to multi-line XML
          - type: awk
            script: "${file::embeddedFile-18}"
        source(2):
          # Source(2) = Aggregate (raid) information
          type: copy
          from: "${source::monitors.logical_disk.collect.sources.source(1)}"
          computes:
            # Xml2Cvs using Awk
            # MSHW;;aggregate-uuid;aggregate-name;raid-type;raid-status;
          - type: awk
            script: "${file::embeddedFile-14}"
            # Duplicate Raid Status for StatusInformation
            # MSHW;node-name;aggregate-uuid;aggregate-name;raid-type;raid-status;StatusInformation;
          - type: duplicateColumn
            column: 6
            # Array Translate Column(7) for raid-status1
            # Replace "," with "|"
          - type: replace
            column: 6
            existingValue: ","
            newValue: '|'
          - type: replace
            column: 6
            existingValue: ' '
            newValue: ""
        source(3):
          # To see what I'm inputting into array translate.
          type: copy
          from: "${source::monitors.logical_disk.collect.sources.source(2)}"
          computes:
          - type: arrayTranslate
            column: 6
            translationTable: "${translation::RaidStatusTranslationTable}"
          # Convert PATROLStatusArray to a simple (unique) PATROLStatus
          - type: convert
            column: 6
            conversion: array2SimpleStatus
            # Remove temporary work Column (and unneeded)
            # MSHW;aggregate-uuid;raid-status;StatusInformation
          - type: keepColumns
            columnNumbers: "1,3,6,7"
      mapping:
        # LogicalDisk Value Table
        # MSHW;aggregate-uuid;PatrolStatus;StatusInformation;
        source: "${source::monitors.logical_disk.collect.sources.source(3)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="logical_disk"}: $3
        legacyTextParameters:
          StatusInformation: $4
  disk_controller:
    discovery:
      sources:
        source(1):
          # Source(1) = Environment Sensors
          # Get XML from REST API Call
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><environment-sensors-get-iter/></netapp>
          computes:
          # xml to multi-line xml
          - type: awk
            script: "${file::embeddedFile-18}"
        source(2):
          # Source(2) = Environment Sensors
          type: copy
          from: "${source::monitors.disk_controller.discovery.sources.source(1)}"
          computes:
            # Xml2Cvs using awk
            # MSHW;node-name;sensor-name;discrete-sensor-state;discrete-sensor-value;
          - type: awk
            script: "${file::embeddedFile-16}"
          # Keep only "SP Status" sensor-names (DiskController)
          - type: keepOnlyMatchingLines
            column: 3
            regExp: SP Status
            # Create uniqueID (computes 3-5)
            # MSHW;node-name;sensor-name;sensor-name;discrete-sensor-state;discrete-sensor-value;
          - type: duplicateColumn
            column: 3
          - type: leftConcat
            column: 3
            value: .
          # MSHW;node-name;unique-id;sensor-name;discrete-sensor-state;discrete-sensor-value;
          - type: leftConcat
            column: 3
            value: $2
      mapping:
        # DiskController Instance Table
        # MSHW;node-name;unique-id;sensor-name;discrete-sensor-state;discrete-sensor-value;
        source: "${source::monitors.disk_controller.discovery.sources.source(2)}"
        attributes:
          id: $3
          __display_id: $4
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: "${awk::sprintf(\"Disk Controller: %s\", $4)}"
    collect:
      # Collection Type (Multi-instance)
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Environment Sensors
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><environment-sensors-get-iter/></netapp>
          computes:
          # XML to multi-line XML
          - type: awk
            script: "${file::embeddedFile-18}"
        source(2):
          # Source(2) = Environment sensors
          type: copy
          from: "${source::monitors.disk_controller.collect.sources.source(1)}"
          computes:
            # Xml2Cvs using awk
            # MSHW;node-name;sensor-name;discrete-sensor-state;discrete-sensor-value;
          - type: awk
            script: "${file::embeddedFile-16}"
            # Translate discrete-sensor-state to PatrolStatus
            # MSHW;node-name;sensor-name;PatrolStatus;discrete-sensor-value;
          - type: translate
            column: 4
            translationTable: "${translation::DiskControllerStatusTranslationTable}"
          # Create uniqueID (computes 3-4)
          - type: leftConcat
            column: 3
            value: .
          # MSHW;node-name;unique-id;discrete-sensor-state;discrete-sensor-value;
          - type: leftConcat
            column: 3
            value: $2
      mapping:
        # DiskController Value Table
        source: "${source::monitors.disk_controller.collect.sources.source(2)}"
        deviceId: $3
        metrics:
          hw.status{hw.type="disk_controller"}: $4
        legacyTextParameters:
          StatusInformation: $5
translations:
  PhysicalDiskTranslationTable:
    normal: ok
    Default: failed
  BatteryStatusInformationTranslationTable:
    battery_ok: Battery OK
    Default: ""
  TemperatureStatusTranslationTable:
    normal: ok
    "false": ok
    Default: failed
  FanStatusTranslationTable:
    "0": ok
    normal: ok
    Default: failed
  VoltageStatusTranslationTable:
    normal: ok
    Default: failed
  BatteryStatusTranslationTable:
    battery_ok: ok
    Default: failed
  PowerSupplyStatusTranslationTable:
    "0": ok
    normal: ok
    Default: failed
  RaidStatusTranslationTable:
    mixed_raid_type: UNKNOWN
    normal: ok
    raid_dp: UNKNOWN
    hybrid: UNKNOWN
    Default: failed
  NetworkCardStatusTranslationTable:
    no carrier: ok
    inactive: ok
    online: ok
    link not connected: ok
    up: ok
    Default: failed
  DiskControllerStatusTranslationTable:
    normal: ok
    Default: failed
  EnclosureHealthTranslationTable:
    normal: ok
    "true": ok
    Default: failed
  LinkStatusTranslationTable:
    no carrier: degraded
    inactive: degraded
    online: ok
    link not connected: degraded
    up: ok
    Default: degraded
  EnclosureStatusInformationTable:
    normal: ""
    "false": Node is not healthy.
    "true": Node is healthy.
    Default: ""
