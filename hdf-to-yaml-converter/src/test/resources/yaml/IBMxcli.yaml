---
embedded:
  EmbeddedFile(1): "$1 ~ /</ && $2 ~ /id=/ {\n    type=$1\n    gsub(/</,\"\",type)\n    }\n\n$1 ~ /</ && $2 ~ /value=/ {\n    field= $1\n    gsub(/</,\"\",field)\n    value = $0\n    gsub(/.*value=\"/,\"\",value)\n    gsub(/\".>/,\"\",value)\n    if ($1 ~ /component_id/) {\n        ID = value\n        typeArray[ID] = type\n        }\n    if ($1 ~ /name/ && type == \"config\") {\n        typeArray[\"system\"] = type\n        ID = \"system\"\n        }\n    if (ID != \"\") {\n        fullArray[ID,field] = value\n        }\n    # Override if in config section\n    if (type == \"config\") {\n        name = fullArray[\"system\",\"name\"]\n        fullArray[\"system\",name] = value\n        }\n    }\n\nEND {\n\n\n    for (ID in typeArray) {\n        split(ID,enclosureArray,\":\")\n        enclosureID = enclosureArray[3]\n        if (tolower(typeArray[ID]) == \"ats\") {\n            print \"MSHW;OTHER;\" enclosureID \";\" ID \";ATS; Model: \" fullArray[ID,\"model\"] \";\" \";\" \";\"\n            }\n        if (tolower(typeArray[ID]) == \"module\") {\n            print \"MSHW;ENCLOSURE;\" enclosureID \";\" ID \";\" fullArray[ID,\"serial\"] \";\" fullArray[ID,\"part_number\"] \";\" fullArray[ID,\"bios_version\"] \";Module Part Number: \" fullArray[ID,\"part_number\"] \";System Model: \" fullArray[\"system\",\"machine_type\"] fullArray[\"system\",\"machine_model\"] \";System Name: \" fullArray[\"system\",\"system_name\"] \";\"\n            }\n        if (tolower(typeArray[ID]) == \"ups\") {\n            print \"MSHW;ENCLOSURE;\" ID \";\" ID \";\" fullArray[ID,\"serial\"] \";\"                             \";AOS Version: \" fullArray[ID,\"aos_version\"] \";\"                                     \";\"                                                                                          \";\"                                                                                                                        \";\"\n        # UPS-NMC No useful info, but need to attach it to the UPS, print one for each UPS found\n            print \"MSHW;OTHER;\" ID \";\" \"1:UPS_NMC: \" enclosureID \";UPS_NMC\" \";\" \";\" \";\" \";\"\n            }\n\t\t# Physical Disks - Part Number Often Missing\n        if (tolower(typeArray[ID]) == \"disk\") {\n            print \"MSHW;PHYS_DISK;\" enclosureID \";\" ID \";\" fullArray[ID,\"size\"] \";\" fullArray[ID,\"model\"] \";\" fullArray[ID,\"serial\"] \";\" fullArray[ID,\"firmware\"] \";\" fullArray[ID,\"part_number\"] \";\"\n            }\n        if (tolower(typeArray[ID]) == \"switch\") {\n            print \"MSHW;ENCLOSURE;\" ID \";\" ID \";\" fullArray[ID,\"serial\"] \";\" \";\" fullArray[ID,\"current_active_version\"] \";\" \";\" \";\" \";\"\n            }\n        # Management Modules - Part and Serial often missing\n        if (tolower(typeArray[ID]) == \"mm\") {\n            print \"MSHW;OTHER;\" enclosureID \";\" ID \";MM;Part Number: \" fullArray[ID,\"part_number\"] \";Serial Number: \" fullArray[ID,\"serial\"] \";IP: \" fullArray[ID,\"ip_1\"] \" / \" fullArray[ID,\"ip_2\"] \";\"\n            }\n        # Fans (no useful info for now)\n        if (tolower(typeArray[ID]) == \"fan\") {\n            print \"MSHW;FAN;\" enclosureID \";\" ID \";\" \";\" \";\" \";\"\n            }\n        # ATS (no useful info - will default to other)\n        # Ethernet-Cables (exclude - network discovery will be done seperately)\n        # PSU - FRU information often missing\n        if (tolower(typeArray[ID]) == \"psu\") {\n            print \"MSHW;PSU;\" enclosureID \";\" ID \"; \" \"Serial Number: \" fullArray[ID,\"serial\"] \";\" \"Firmware: \" fullArray[ID,\"firmware_version\"] \";\"  \"Part Number: \" fullArray[ID,\"part_number\"] \";\"\n            }\n        if (tolower(typeArray[ID]) == \"dimm\") {\n            print \"MSHW;MEMORY;\" enclosureID \";\" ID \"; \" fullArray[ID,\"serial\"] \";\" fullArray[ID,\"manufacturer\"] \";Part Number: \" fullArray[ID,\"part_number\"] \";\" \"Channel: \"fullArray[ID,\"channel\"] \" - Bank: \"fullArray[ID,\"bank\"] \";\" \"Speed: \"fullArray[ID,\"speed\"] \";\" fullArray[ID,\"size\"] \";\"\n            }\n        if (tolower(typeArray[ID]) == \"cf\") {\n            print \"MSHW;OTHER;\" enclosureID \";\" ID \";CompactFlash;Device Name: \" fullArray[ID,\"device_name\"] \";Serial Number: \" fullArray[ID,\"serial\"] \";Part Number: \" fullArray[ID,\"part_number\"] \";\"\n            }\n        }\n    }"
  EmbeddedFile(3): |-
    $1 ~ /</ && $2 ~ /id=/ {
        type=$1
        gsub(/</,"",type)
        ID = $0
        gsub(/.*id="/,"",ID)
        gsub(/">/,"",ID )
        typeArray[ID] = type
        }
    $1 ~ /</ && $2 ~ /value=/ {
        field= $1
        gsub(/</,"",field)
        value = $0
        gsub(/.*value="/,"",value)
        gsub(/".>/,"",value)
        fullArray[ID,field] = value
        }
    END {
        for (ID in typeArray) {
            enclosureID = ""; speed = ""; status = ""; address = ""; linkstatus = ""; serial = ""; model = ""; firmware = "" ; deviceID = ""; addressType =""; portType =""
            if (tolower(typeArray[ID]) == "fc_port") {
                module = fullArray[ID,"module"] ; split(module,enclosureArray,":") ; enclosureID = enclosureArray[3] ;
                speed = fullArray[ID,"current_rate"] * 1000
                status = fullArray[ID,"status"]
                address = fullArray[ID,"wwpn"]
                linkstatus = fullArray[ID,"port_state"]
                serial = fullArray[ID,"serial"]
                model = fullArray[ID,"model"]
                firmware = fullArray[ID,"active_firmware"]
                deviceID = fullArray[ID,"component_id"]
                addressType = "WWN"
                portType = "FC"
                }
            if (tolower(typeArray[ID]) == "ib_port") {
            # No available output, so guessing
                switch = fullArray[ID,"component_id"]
                split(switch ,enclosureArray,":")
                enclosureID = enclosureArray[1] ":" enclosureArray[2] ":" enclosureArray[3]
                status = fullArray[ID,"status"]
                deviceID = fullArray[ID,"component_id"]
                portType = "IB"
                }
            if (tolower(typeArray[ID]) == "ethernet_port") {
                if ( fullArray[ID,"role"] == "Internal" ) {
                    switch = fullArray[ID,"connected_component"]
                    split(switch ,enclosureArray,":")
                    enclosureID = enclosureArray[1] ":" enclosureArray[2] ":" enclosureArray[3]
                    deviceID = fullArray[ID,"connected_component"]
                    }
                else if ( fullArray[ID,"role"] == "iSCSI" ) {
                    module = fullArray[ID,"module_id"]
                    split(module,enclosureArray,":")
                    enclosureID = enclosureArray[3]
                    deviceID = fullArray[ID,"ip_interface_name"]
                    }
                else if ( fullArray[ID,"role"] == "Component" ) {
                    module = fullArray[ID,"module_id"]
                    split(module,enclosureArray,":")
                    enclosureID = enclosureArray[3]
                    deviceID = fullArray[ID,"connected_component"]
                    }
                else if ( fullArray[ID,"role"] != "NONE" ) {
                    module = fullArray[ID,"module_id"]
                    split(module,enclosureArray,":")
                    enclosureID = enclosureArray[3]
                    deviceID = fullArray[ID,"module_id"] ":" fullArray[ID,"role"]
                    }
                portType = "Ethernet"
                speed = fullArray[ID,"negotiated_speed_Mbs"]
                linkstatus = fullArray[ID,"is_link_up"]
                }
            if ( deviceID != "" ) {
                print "MSHW;" portType ";" deviceID ";" enclosureID ";" speed ";" status ";" address ";" addressType ";" linkstatus ";" serial ";" model ";Firmware: " firmware ";"
                }
            }
        }
  EmbeddedFile(2): |-
    $1 ~ /</ && $2 ~ /value=/ {
        value = $0
        gsub(/.*value="/,"",value)
        gsub(/".>/,"",value)
        if ($1 ~ /component_id/) { ID = value }
        if ($1 ~ /status/) { status[ID] = value }
        if ($1 ~ /currently_functioning/) { currentFunctioning[ID] = value }
        if ($1 ~ /requires_service/) { requiresService[ID] = value }
        if ($1 ~ /service_reason/) { serviceReason[ID] = value }
        }

    END {
        for (ID in status) {
            statusInformation = ""
            if (currentFunctioning[ID] == "no") { statusInformation = "Not Currently Functioning" }
            if (requiresService[ID] != "") {
                if (statusInformation != "") {statusInformation=statusInformation " - " }
                statusInformation = statusInformation "Requires Service: " requiresService[ID]
                }
            if (serviceReason[ID] != "") {
                if (statusInformation != "") {statusInformation=statusInformation " - " }
                statusInformation = statusInformation "Service Reason: " serviceReason[ID]
                }
            print "MSHW;" ID ";" status[ID] ";" statusInformation ";"
            }
        }
translations:
  linkStatusTranslationTable:
    default: degraded
    "yes": ok
    online: ok
  statusTranslationTable:
    default: failed
    failed: failed
    ok: ok
    notok: degraded
connector:
  displayName: IBM XIV (xcli)
  platforms: IBM XiV Storage System
  reliesOn: xcli command line utility
  version: 1.0
  information: This connector provides hardware monitoring for IBM XIV Storage Systems through the xcli command line utility.
  detection:
    appliesTo:
    - Storage
    connectionTypes:
    - remote
    supersedes:
    - SMISDiskArray
    criteria:
    - _comment: Only for type storage
      type: deviceType
      keep:
      - Storage
    - _comment: Checks that xcli is on the local machine - in Portal smcli is run from the RSM
      type: osCommand
      commandLine: xcli -v
      forceSerialization: true
      executeLocally: true
      expectedResult: 'xcli version:'
      errorMessage: xcli not installed or not in path.
    - _comment: Checks that xcli returns a system name
      type: osCommand
      commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all cod_list"
      forceSerialization: true
      executeLocally: true
      expectedResult: system_name
      errorMessage: xcli could not connect or did not find a system.
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          _comment: Source(1) = list of components
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -t \"component_id\" component_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
          computes:
            # Remove spaces
            # DeviceID
          - type: replace
            column: 1
            existingValue: ' '
            newValue: ""
            # Exclude the header
            # DeviceID
          - type: excludeMatchingLines
            column: 1
            valueList: ComponentID
        source(2):
          _comment: Source(2) = ATS XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all ats_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(3):
          _comment: Source(3) = Module XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all module_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(4):
          _comment: Source(4) = Disk XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all disk_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(5):
          _comment: Source(5) = MM XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all mm_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(6):
          _comment: Source(6) = UPS XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all ups_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(7):
          _comment: Source(7) = Fan XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all fan_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(8):
          _comment: Source(8) = PSU XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all psu_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(9):
          _comment: Source(9) = DIMM XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all dimm_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(10):
          _comment: Source(10) = CF XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all cf_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(11):
          # Join all the XML into one table
          # XML
          type: tableUnion
          tables:
          - $monitors.enclosure.discovery.sources.source(2)$
          - $monitors.enclosure.discovery.sources.source(3)$
          - $monitors.enclosure.discovery.sources.source(4)$
          - $monitors.enclosure.discovery.sources.source(5)$
          - $monitors.enclosure.discovery.sources.source(6)$
        source(12):
          type: tableUnion
          tables:
          - $monitors.enclosure.discovery.sources.source(11)$
          - $monitors.enclosure.discovery.sources.source(7)$
          - $monitors.enclosure.discovery.sources.source(8)$
          - $monitors.enclosure.discovery.sources.source(9)$
          - $monitors.enclosure.discovery.sources.source(10)$
        source(13):
          # COD XML
          # Source(13) = COD XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all cod_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(14):
          # One final table, the System Information
          # Source(13) = Switch XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all switch_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(15):
          # Join union again
          # XML
          type: tableUnion
          tables:
          - $monitors.enclosure.discovery.sources.source(12)$
          - $monitors.enclosure.discovery.sources.source(13)$
          - $monitors.enclosure.discovery.sources.source(14)$
          computes:
            # Run all the XML through an awk script
            # MSHW...
          - type: awk
            script: EmbeddedFile(1)
            keep: ^MSHW
            separators: ;
        source(16):
          # Join the processed XML to the main component discovery
          # DeviceID;MSHW;Type;EnclosureID;DeviceID;....
          type: tableJoin
          leftTable: $monitors.enclosure.discovery.sources.source(1)$
          rightTable: $monitors.enclosure.discovery.sources.source(15)$
          leftKeyColumn: 1
          rightKeyColumn: 4
          defaultRightLine: Default;OTHER;UNKNOWN;UNKNOWN;UNKNOWN;;;;
        source(17):
          # Make a copy to use for enclosure discovery
          # DeviceID;MSHW;Type;EnclosureID;DisplayID;....
          type: copy
          from: $monitors.enclosure.discovery.sources.source(16)$
          computes:
            # Keep Only Enclosures
            # DeviceID;MSHW;ENCLOSURE;EnclosureID;DisplayID;serial;part_number;bios_version;Module Part Number;System Model;System Name/Serial Number;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: ^ENCLOSURE$
          - type: leftConcat
            column: 8
            value: "FirmwareVersion: "
      mapping:
        #  1        2         3       4        #    5     6        #   7        #  8        #    9        #       10        # 11
        # DeviceID;MSHW;ENCLOSURE;EnclosureID;DisplayID;serial;part_number;bios_version;Module Part Number;System Model;System Name/Serial Number;
        source: $monitors.enclosure.discovery.sources.source(17)$
        attributes:
          id: $column(4)
          __display_id: $column(5)
          vendor: IBM
          model: $column(7)
          serial_number: $column(6)
          bios_version: $column(8)
          type: Storage
          info: "join($column(9), $column(10), $column(11), \" \")"
          name: "sprintf(\"%s (%s %s - %s)\", $column(5), \"IBM\", $column(7), \"Storage\")"
    collect:
      _comment: Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          _comment: Source(1) = list of components
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all component_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
          computes:
            # Parse the XML through an awk script
            # DeviceID;Status;StatusInformation;
          - type: awk
            script: EmbeddedFile(2)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4"
            # Now translate into OK/Warning/Alarm
            # DeviceID;Status;StatusInformation;
          - type: translate
            column: 2
            translationTable: statusTranslationTable
        source(2):
          _comment: Copy the table
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep Only Switches
            # Name;PATROLStatus;StatusDescriptions;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: Module
            # Extract the enclosure number from the device ID
            # Name;PATROLStatus;StatusDescriptions;
          - type: extract
            column: 1
            subColumn: 3
            subSeparators: ':'
        source(3):
          _comment: Copy the Table Again
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep Only Switches
            # Name;PATROLStatus;StatusDescriptions;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: \(:Switch:\)\|\(:UPS:\)
        source(4):
          _comment: Union 2 and 3
          type: tableUnion
          tables:
          - $monitors.enclosure.collect.sources.source(2)$
          - $monitors.enclosure.collect.sources.source(3)$
      mapping:
        # ValueTable = Source(1)
        # Name;PATROLStatus;StatusDescriptions;
        source: $monitors.enclosure.collect.sources.source(4)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="enclosure"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
  physical_disk:
    discovery:
      sources:
        source(1):
          # Make a copy to use for enclosure discovery
          # DeviceID;MSHW;Type;EnclosureID;DeviceID;....
          type: copy
          from: $monitors.enclosure.discovery.sources.source(16)$
          computes:
            # Keep Only PhysicalDisks
            # DeviceID;MSHW;PHYS_DISK;enclosureID;ID;size;model;serial;firmware;part_number;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: ^PHYS_DISK$
            # Convert from whatever unit IBM uses to bytes
            # DeviceID;MSHW;PHYS_DISK;enclosureID;ID;size;model;serial;firmware;part_number;
          - type: multiply
            column: 6
            value: 1081348
      mapping:
        # The discovery table
        # DeviceID;MSHW;PHYS_DISK;enclosureID;ID;size;model;serial;firmware;part_number;
        source: $monitors.physical_disk.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          __display_id: $column(1)
          vendor: $column(7)
          model: $column(10)
          serial_number: $column(8)
          firmware_version: $column(9)
          hw.parent.type: enclosure
          hw.parent.id: $column(4)
          name: "sprintf(\"%s (%s - %s)\", $column(1), $column(10), $column(6))"
        metrics:
          hw.physical_disk.size: $column(6)
    collect:
      _comment: Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          _comment: Copy Enclosure Collect
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
      mapping:
        # ValueTable = Source(1)
        # Name;PATROLStatus;StatusDescriptions;
        source: $monitors.physical_disk.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="physical_disk"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
  memory:
    discovery:
      sources:
        source(1):
          # Make a copy to use for enclosure discovery
          # DeviceID;MSHW;Type;EnclosureID;DeviceID;....
          type: copy
          from: $monitors.enclosure.discovery.sources.source(16)$
          computes:
            # Keep Only Memorys
            # DeviceID;MSHW;MEMORY;enclosureID;ID;serial;manufacturer;part_number;location;speed;size;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: ^MEMORY$
      mapping:
        # The discovery table
        # DeviceID;MSHW;Memory;enclosureID;ID;serial;manufacturer;part_number;location;speed;size;
        source: $monitors.memory.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          __display_id: $column(1)
          vendor: $column(7)
          serial_number: $column(6)
          info: "join($column(8), $column(9), $column(10), \" \")"
          hw.parent.type: enclosure
          hw.parent.id: $column(4)
          name: "sprintf(\"%s (%s - %s)\", $column(1), $column(7), $column(11))"
        metrics:
          hw.memory.limit: mebiByte2Byte($column(11))
    collect:
      _comment: Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          _comment: Copy Enclosure Collect
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
      mapping:
        # ValueTable = Source(1)
        # Name;PATROLStatus;StatusDescriptions;
        source: $monitors.memory.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="memory"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
  fan:
    discovery:
      sources:
        source(1):
          # Make a copy to use for enclosure discovery
          # DeviceID;MSHW;Type;EnclosureID;DeviceID;....
          type: copy
          from: $monitors.enclosure.discovery.sources.source(16)$
          computes:
            # Keep Only Fans
            # DeviceID;MSHW;FAN;enclosureID;ID;;;;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: ^FAN$
      mapping:
        # The discovery table
        # DeviceID;MSHW;FAN;enclosureID;ID;;;;
        source: $monitors.fan.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          __display_id: $column(1)
          hw.parent.type: enclosure
          hw.parent.id: $column(4)
          name: $column(1)
    collect:
      _comment: Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          _comment: Copy Enclosure Collect
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
      mapping:
        # ValueTable = Source(1)
        # Name;PATROLStatus;StatusDescriptions;
        source: $monitors.fan.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="fan"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
  power_supply:
    discovery:
      sources:
        source(1):
          # Make a copy to use for enclosure discovery
          # DeviceID;MSHW;Type;EnclosureID;DeviceID;....
          type: copy
          from: $monitors.enclosure.discovery.sources.source(16)$
          computes:
            # Keep Only PowerSupplys
            # DeviceID;MSHW;PowerSupply;enclosureID;ID;SerialNumber;Firmware;PartNumber;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: ^PSU$
      mapping:
        # The discovery table
        # DeviceID;MSHW;PowerSupply;enclosureID;ID;SerialNumber;Firmware;PartNumber;
        source: $monitors.power_supply.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          __display_id: $column(1)
          info: "join($column(6), $column(7), $column(8), \" \")"
          hw.parent.type: enclosure
          hw.parent.id: $column(4)
          name: "sprintf(\"%s, $column(1))"
    collect:
      _comment: Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          _comment: Copy Enclosure Collect
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
      mapping:
        # ValueTable = Source(1)
        # Name;PATROLStatus;StatusDescriptions;
        source: $monitors.power_supply.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="power_supply"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
  other_device:
    discovery:
      sources:
        source(1):
          # Make a copy to use for enclosure discovery
          # DeviceID;MSHW;Type;EnclosureID;DeviceID;....
          type: copy
          from: $monitors.enclosure.discovery.sources.source(16)$
          computes:
            # Keep Only OtherDevices
            # DeviceID;MSHW;OtherDevice;enclosureID;ID;DeviceType;AddInfo1;AddInfo2;AddInfo3;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: ^OTHER$
            # Copy the deviceID into the ID field
            # DeviceID;MSHW;OtherDevice;enclosureID;DeviceID;DeviceType;AddInfo1;AddInfo2;AddInfo3;
          - type: replace
            column: 5
            existingValue: column(5)
            newValue: column(1)
            # Extract the enclosure from the deviceID
            # DeviceID;MSHW;OtherDevice;enclosureID;enclosureID-Extracted;DeviceType;AddInfo1;AddInfo2;AddInfo3;
          - type: extract
            column: 5
            subColumn: 3
            subSeparators: ':'
            # Replace an Unknown Enclosure with the Enclosure extracted from the ID
            # DeviceID;MSHW;OtherDevice;enclosureID;enclosureID-Extracted;DeviceType;AddInfo1;AddInfo2;AddInfo3;
          - type: replace
            column: 4
            existingValue: UNKNOWN
            newValue: column(5)
            # Copy the deviceID into the ID field
            # DeviceID;MSHW;OtherDevice;enclosureID;DeviceID;DeviceType;AddInfo1;AddInfo2;AddInfo3;
          - type: replace
            column: 5
            existingValue: column(5)
            newValue: column(1)
            # Extract the type from the deviceID
            # DeviceID;MSHW;OtherDevice;enclosureID;Type;DeviceType;AddInfo1;AddInfo2;AddInfo3;
          - type: extract
            column: 5
            subColumn: 2
            subSeparators: ':'
            # Replace an Unknown type with the type extracted from the ID
            # DeviceID;MSHW;OtherDevice;enclosureID;Type;DeviceType;AddInfo1;AddInfo2;AddInfo3;
          - type: replace
            column: 6
            existingValue: UNKNOWN
            newValue: column(5)
            # Exclude certain classes
            # DeviceID;MSHW;OtherDevice;enclosureID;ID;DeviceType;AddInfo1;AddInfo2;AddInfo3;
          - type: excludeMatchingLines
            column: 6
            valueList: "SWITCH,UPS,NIC,DIMM,PSU,FC_Port,Ethernet_Cable,MaintenanceModule,Switch,Disk,Interface,Remote,Data,Module"
      mapping:
        # The discovery table
        # DeviceID;MSHW;OtherDevice;enclosureID;ID;DeviceType;AddInfo1;AddInfo2;AddInfo3;
        source: $monitors.other_device.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          __display_id: $column(1)
          device_type: $column(6)
          info: "join($column(7), $column(8), $column(9), \" \")"
          hw.parent.type: enclosure
          hw.parent.id: $column(4)
          name: "sprintf(\"%s: %s\", $column(6), $column(1))"
    collect:
      _comment: Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          _comment: Copy Enclosure Collect
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
      mapping:
        # ValueTable = Source(1)
        # Name;PATROLStatus;StatusDescriptions;
        source: $monitors.other_device.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="other_device"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
  network:
    discovery:
      sources:
        source(1):
          # List of Cards
          # Source(1) = Ethernet XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all ipinterface_list_ports"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(2):
          _comment: Source(2) = FC XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all fc_port_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(3):
          _comment: Source(3) = IB XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all ib_port_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(4):
          # Union all the Port XML
          # XML...
          type: tableUnion
          tables:
          - $monitors.network.discovery.sources.source(1)$
          - $monitors.network.discovery.sources.source(2)$
          - $monitors.network.discovery.sources.source(3)$
          computes:
            # Run all the XML through an awk script
            # MSHW;portType;deviceID;enclosureID;speed;status;address;addressType;linkstatus;serial;model;firmware;
          - type: awk
            script: EmbeddedFile(3)
            keep: ^MSHW
            separators: ;
      mapping:
        # Instance Table
        # MSHW;portType;deviceID;enclosureID;speed;status;address;addressType;linkstatus;serial;model;firmware;
        source: $monitors.network.discovery.sources.source(4)$
        attributes:
          id: $column(3)
          __display_id: $column(3)
          device_type: $column(2)
          physical_address: $column(7)
          physical_address_type: $column(8)
          model: $column(11)
          serial_number: $column(10)
          info: $column(12)
          hw.parent.type: enclosure
          hw.parent.id: $column(4)
          name: "sprintf(\"%s (%s - %s)\", $column(3), $column(2), $column(11))"
    collect:
      _comment: Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # List of Cards
          # Source(1) = Ethernet XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all ipinterface_list_ports"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(2):
          _comment: Source(2) = FC XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all fc_port_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(3):
          _comment: Source(3) = IB XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all ib_port_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(4):
          # Union all the Port XML
          # XML...
          type: tableUnion
          tables:
          - $monitors.network.collect.sources.source(1)$
          - $monitors.network.collect.sources.source(2)$
          - $monitors.network.collect.sources.source(3)$
          computes:
            # Parse the XML through an awk script
            # MSHW;portType;deviceID;enclosureID;speed;status;address;addressType;linkstatus;serial;model;firmware;
            #             # deviceID;            speed;status;            #       linkstatus;
          - type: awk
            script: EmbeddedFile(3)
            keep: ^MSHW;
            separators: ;
            selectColumns: "3,5,6,9"
            # Now translate into OK/Warning/Alarm
            # DeviceID;Speed;Status;LinkStatus;
          - type: translate
            column: 3
            translationTable: statusTranslationTable
            # Now translate linkStatus
            # DeviceID;Speed;Status;LinkStatus;
          - type: translate
            column: 4
            translationTable: linkStatusTranslationTable
      mapping:
        # ValueTable = Source(1)
        # DeviceID;Speed;Status;LinkStatus;
        source: $monitors.network.collect.sources.source(4)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="network"}: $column(3)
          hw.network.up: legacyLinkStatus($column(4))
          hw.network.bandwidth.limit: megaBit2Bit($column(2))
