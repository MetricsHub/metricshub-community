---
connector:
  displayName: EMC Isilon Cluster (REST)
  platforms: EMC Isilon
  version: 1.0
  information: "This connector discovers the status of an EMC Isilon Storage Cluster, as well as the various environment sensors (temperatures, fans, power supplies, etc.). Requires EMC Isilon (v8) or later."
  detection:
    connectionTypes:
    - remote
    appliesTo:
    - Storage
    criteria:
      # Check that we are talking to an Isilon System
      # and that version 3 (IsiFS v8 or later) of the API is available
      # Json Output
    - type: http
      method: GET
      url: /platform/3/cluster/version
      expectedResult: Isilon OneFS
      errorMessage: Credentials Incorrect / Not an Isilon (v8) or later system
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # JSON Output
          type: http
          method: GET
          url: /platform/3/cluster/nodes
          resultContent: body
        source(2):
          # Preserve original source for re-use by other classes
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Transform JSON to CSV to extract information
            # JsonID;NodeID;serial_number;model;nvram;
          - type: json2csv
            entryKey: nodes/hardware
            properties: ../lnn;/serial_number;/product;/nvram;
        source(3):
          # Adding Cluster Enclosure to attach disks to
          type: tableUnion
          tables:
          - "${source::monitors.enclosure.discovery.sources.source(2)}"
          - Cluster;Cluster;;;;
          computes:
          - type: leftConcat
            column: 5
            value: "NVRAM: "
            # Duplicate the NodeID column to use for the display ID
            # JsonID;NodeID;serial_number;model;nvram;displayID
          - type: rightConcat
            column: 5
            value: ;
          - type: rightConcat
            column: 6
            value: $2
            # Add the word Node to the display ID
            # JsonID;NodeID;serial_number;model;nvram;displayID
          - type: leftConcat
            column: 6
            value: 'Node '
      mapping:
        # Instance Table
        # JsonID;NodeID;serial_number;model;nvram;displayID
        source: "${source::monitors.enclosure.discovery.sources.source(3)}"
        attributes:
          id: $2
          __display_id: $6
          serial_number: $3
          model: $4
          vendor: EMC
          type: Storage
          info: $5
          name: "${awk::sprintf(\"Storage: %s (%s %s)\", $6, \"EMC\", $4)}"
    collect:
      # Collect
      type: multiInstance
      sources:
        source(1):
          # JSON Output
          type: http
          method: GET
          url: /platform/3/cluster/nodes
          resultContent: body
        source(2):
          # Preserve original Source for re-use
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Transform JSON to CSV to extract information
            # JsonID;LNN;smartfailed;dead;down;readonly;in_cluster;shutdown_readonly;
            #  1      2          3    4     5   6          7           8
          - type: json2csv
            entryKey: nodes/state/smartfail
            properties: ../../lnn;/smartfailed;/dead;/down;/readonly;/in_cluster;/shutdown_readonly;
            separator: ;
          # Translate the Various Boolean Status
          - type: translate
            column: 3
            translationTable: "${translation::SmartFailedTranslateTable}"
          - type: translate
            column: 4
            translationTable: "${translation::DeadTranslateTable}"
          - type: translate
            column: 5
            translationTable: "${translation::DownTranslateTable}"
          - type: translate
            column: 6
            translationTable: "${translation::ReadOnlyTranslateTable}"
          - type: translate
            column: 7
            translationTable: "${translation::InclusterTranslateTable}"
          - type: translate
            column: 8
            translationTable: "${translation::ShutDownReadOnlyTranslateTable}"
            # Concat all the Status Columns into one Column
            # JsonID;LNN;smartfailed;dead;down;readonly;in_cluster;shutdown_readonly;
            #  1      2          3    4     5   6          7           8
          - type: rightConcat
            column: 3
            value: '|'
          - type: rightConcat
            column: 3
            value: $4
          - type: rightConcat
            column: 3
            value: '|'
          - type: rightConcat
            column: 3
            value: $5
          - type: rightConcat
            column: 3
            value: '|'
          - type: rightConcat
            column: 3
            value: $6
          - type: rightConcat
            column: 3
            value: '|'
          - type: rightConcat
            column: 3
            value: $7
          - type: rightConcat
            column: 3
            value: '|'
          - type: rightConcat
            column: 3
            value: $8
            # Keep only columns
            # JsonID;LNN;StatusArray;
          - type: keepColumns
            columnNumbers: "1,2,3"
        source(3):
          # Make a copy to start the numbering again
          # JsonID;LNN;StatusArray;
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(2)}"
          computes:
            # Duplicate the StatusArray
            # JsonID;LNN;StatusArray;StatusArray;
          - type: duplicateColumn
            column: 3
            # Translate first Status into a PATROL status
            # JsonID;LNN;PatrolStatus;StatusArray;
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::NodeStatusTranslationTable}"
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # JsonID;LNN;PatrolStatus;StatusArray;
          - type: convert
            column: 3
            conversion: array2SimpleStatus
            # Translate second Status into a statusInformation
            # JsonID;LNN;PatrolStatus;StatusArray;
          - type: arrayTranslate
            column: 4
            translationTable: "${translation::NodeStatusInformationTranslationTable}"
        source(4):
          # Adding Cluster collect so not to generate system output errors
          type: tableUnion
          tables:
          - "${source::monitors.enclosure.collect.sources.source(3)}"
          - Cluster;Cluster;;;;
      mapping:
        # Value Table
        # JsonID;LNN;PatrolStatus;StatusInformation;
        source: "${source::monitors.enclosure.collect.sources.source(4)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="enclosure"}: $3
        legacyTextParameters:
          StatusInformation: $3
  fan:
    discovery:
      sources:
        source(1):
          # Discovery
          # Json Output
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Transform JSON to CSV to extract information
            # JsonID;lnn;name;name;
          - type: json2csv
            entryKey: nodes/sensors/sensors/values
            properties: ../../../lnn;../name;/name;
          # Keep only fans
          - type: keepOnlyMatchingLines
            column: 3
            regExp: Fans
            # Duplicate Name Column
            # JsonID;lnn;type;name;name;
          - type: duplicateColumn
            column: 4
            # Translate second name column to Upper and Lower Thresholds
            # JsonID;lnn;type;name;WarningThreshold;AlarmThreshold;
          - type: translate
            column: 5
            translationTable: "${translation::FanThresholdTranslationTable}"
      mapping:
        # Instance Table
        # JsonID;lnn;type;name;LowerThreshold;UpperThreshold
        source: "${source::monitors.fan.discovery.sources.source(1)}"
        attributes:
          id: $1
          __display_id: $4
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $4
        metrics:
          hw.fan.speed.limit{limit_type="low.degraded"}: $5
          hw.fan.speed.limit{limit_type="low.critical"}: $6
    collect:
      # Collect
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Json Output
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Transform JSON to CSV to extract information
            # JsonID;value;
          - type: json2csv
            entryKey: nodes/sensors/sensors/values
            properties: /value;
      mapping:
        # Value Table
        source: "${source::monitors.fan.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.fan.speed: $2
  voltage:
    discovery:
      sources:
        source(1):
          # Json Output
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Transform JSON to CSV to extract information
            # JsonID;lnn;type;name;value;
          - type: json2csv
            entryKey: nodes/sensors/sensors/values
            properties: ../../../lnn;../name;/name;/value;
          # Keep only Voltages
          - type: keepOnlyMatchingLines
            column: 3
            regExp: Volts
          # remove discovered instances with no values
          - type: excludeMatchingLines
            column: 5
            regExp: na
            # Duplacate name column
            # JsonID;lnn;type;name;name;value;
          - type: duplicateColumn
            column: 4
            # Translate new Column in to Upper and Lower Thresholds
            # JsonID;lnn;type;name;LowerThreshold;UpperThreshold;value;
          - type: translate
            column: 5
            translationTable: "${translation::VoltageThresholdTranslationTable}"
      mapping:
        # Instance Table
        # JsonID;lnn;type;name;LowerThreshold;UpperThreshold;value;
        source: "${source::monitors.voltage.discovery.sources.source(1)}"
        attributes:
          id: $1
          __display_id: $4
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $4
        metrics:
          hw.voltage.limit{limit_type="low.critical"}: $5
          hw.voltage.limit{limit_type="high.degraded"}: $6
    collect:
      # Collect
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Json Ouput
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Transform JSON to CSV to extract information
            # JsonID;value;
          - type: json2csv
            entryKey: nodes/sensors/sensors/values
            properties: /value;
          - type: replace
            column: 2
            existingValue: NA
            newValue: ""
          - type: multiply
            column: 2
            value: 1000
      mapping:
        # Value Table
        source: "${source::monitors.voltage.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.voltage: $2
  temperature:
    discovery:
      sources:
        source(1):
          # Discovery
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Transform JSON to CSV to extract information
            # JsonID;lnn;type;name;
          - type: json2csv
            entryKey: nodes/sensors/sensors/values
            properties: ../../../lnn;../name;/name;
          # Keep only Temperatures
          - type: keepOnlyMatchingLines
            column: 3
            regExp: Temps
            # Duplicate name column
            # JsonID;lnn;type;name;name;
          - type: duplicateColumn
            column: 4
            # Translate new column into Warning / Alarm
            # JsonID;lnn;type;name;Warning;Alarm;
          - type: translate
            column: 5
            translationTable: "${translation::TemperatureThresholdTranslationTable}"
      mapping:
        # Instance Table
        source: "${source::monitors.temperature.discovery.sources.source(1)}"
        attributes:
          id: $1
          __display_id: $4
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $4
        metrics:
          hw.temperature.limit{limit_type="high.degraded"}: $5
          hw.temperature.limit{limit_type="high.critical"}: $6
    collect:
      # Collect
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # JSON Output
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Transform JSON to CSV to extract information
            # JsonID;value;
          - type: json2csv
            entryKey: nodes/sensors/sensors/values
            properties: /value;
      mapping:
        source: "${source::monitors.temperature.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.temperature: $2
  power_supply:
    discovery:
      sources:
        source(1):
          # Discovery
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Transform JSON to CSV to extract information
            # JsonID;lnn;name;type;
          - type: json2csv
            entryKey: nodes/status/powersupplies/supplies
            properties: ../../../lnn;/name;/type;
          # AdditionalInformation Vendor
          - type: leftConcat
            column: 4
            value: "Vendor: "
      mapping:
        # The Instance table
        source: "${source::monitors.power_supply.discovery.sources.source(1)}"
        attributes:
          id: $1
          __display_id: $3
          info: $4
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $3
    collect:
      # Collect
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
          # Transform JSON to CSV to extract information
          - type: json2csv
            entryKey: nodes/status/powersupplies/supplies
            properties: /status;/status
            # Fixing some power supply status to be translatable
            # This is necessary as the status returned by the host sometimes contains variables (displayName)
          - type: awk
            script: "${file::embeddedFile-1}"
          - type: translate
            column: 2
            translationTable: "${translation::PowerSupplyStatusTranslationTable}"
      mapping:
        # The Value table
        source: "${source::monitors.power_supply.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="power_supply"}: $2
        legacyTextParameters:
          StatusInformation: $3
  cpu:
    discovery:
      sources:
        source(1):
          # Discovery
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Transform JSON to CSV to extract information
            # JsonID;lnn;model;
          - type: json2csv
            entryKey: nodes/status/cpu
            properties: ../../lnn;/model;
      mapping:
        # The instance table
        source: "${source::monitors.cpu.discovery.sources.source(1)}"
        attributes:
          id: $1
          __display_id: CPUs Overtemp
          model: $3
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s (%s)\", \"CPUs Overtemp\", $3)}"
    collect:
      # Collect
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
          # Transform JSON to CSV to extract information
          - type: json2csv
            entryKey: nodes/status/cpu
            properties: /overtemp;
          - type: translate
            column: 2
            translationTable: "${translation::CPUStatusTranslationTable}"
      mapping:
        # The value table
        source: "${source::monitors.cpu.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="cpu"}: $2
  physical_disk:
    discovery:
      sources:
        source(1):
          # Discovery
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Transform JSON to CSV to extract information
            # Taking logical_block_length as physical_block_length is way off for SSDS
            # JsonID;lnn;location;model;serial;blocks;logical_block_length;ui_state
          - type: json2csv
            entryKey: nodes/drives
            properties: ../lnn;/locnstr;/model;/serial;/blocks;/logical_block_length;/ui_state
            # Get size in Bytes
            # JsonID;lnn;location;model;serial;size(bytes);logical_block_length;ui_state
          - type: multiply
            column: 6
            value: $8
            # Get size in Bytes
            # JsonID;lnn;location;model;serial;size(bytes);logical_block_length;ui_state
          - type: excludeMatchingLines
            column: 8
            regExp: EMPTY
            # Add node and drive information to DisplayName
            # node;lnn;displayID;model;serial;size(bytes);logical_block_length;ui_state
          - type: leftConcat
            column: 3
            value: ' '
          - type: leftConcat
            column: 3
            value: $2
          - type: leftConcat
            column: 3
            value: 'Node '
      mapping:
        # The Instance table
        # node;lnn;displayID;model;serial;size(bytes);logical_block_length;ui_state
        source: "${source::monitors.physical_disk.discovery.sources.source(1)}"
        attributes:
          id: $5
          __display_id: $3
          model: $4
          serial_number: $5
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s (%s)\", $3, bytes2HumanFormatBase10($6))}"
        metrics:
          hw.physical_disk.size: $6
    collect:
      # Collect
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
          # Transform JSON to CSV to extract information
          - type: json2csv
            entryKey: nodes/drives
            properties: /ui_state;/serial
          # JSonID;ui_state;ui_state;serial
          - type: duplicateColumn
            column: 2
          # JsonID;patrolStatus;ui_state;serial
          - type: translate
            column: 2
            translationTable: "${translation::PhysicalDiskStatusTranslationTable}"
      mapping:
        # The value table
        # JsonID;patrolStatus;ui_state;serial
        source: "${source::monitors.physical_disk.collect.sources.source(1)}"
        deviceId: $4
        metrics:
          hw.status{hw.type="physical_disk"}: $2
        legacyTextParameters:
          StatusInformation: $3
  network:
    discovery:
      sources:
        source(1):
          # Discovery
          # Json Output
          type: http
          method: GET
          url: /platform/3/network/interfaces
          resultContent: body
          computes:
            # Transform JSON to CSV to extract information
            # JsonID;lnn;name;status;
          - type: json2csv
            entryKey: interfaces
            properties: /lnn;/name;/status;
          # JsonID;lnn;name;status;
          - type: excludeMatchingLines
            column: 4
            regExp: Not Available
      mapping:
        # Instance Table
        # JsonID;lnn;name;
        source: "${source::monitors.network.discovery.sources.source(1)}"
        attributes:
          id: $1
          __display_id: $3
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $3
    collect:
      # Collect type is MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Json Output
          type: http
          method: GET
          url: /platform/3/network/interfaces
          resultContent: body
          computes:
            # Transform JSON to CSV to extract information
            # JsonID;status;
          - type: json2csv
            entryKey: interfaces
            properties: /status;
            # Duplicate status column
            # JsonID;status;status;
          - type: duplicateColumn
            column: 2
            # Duplicate status column
            # JsonID;status;status;status;
          - type: duplicateColumn
            column: 2
            # Translate NetworkCardStatus into PatrolStatus
            # JsonID;NetworkcardStatus;NetworkcardStatus;status;
          - type: translate
            column: 2
            translationTable: "${translation::NetworkCardStatusTranslationTable}"
            # Translate second status into LinkStatus
            # JsonID;NetworkcardStatus;LinkStatus;status;
          - type: translate
            column: 3
            translationTable: "${translation::LinkStatusTranslationTable}"
      mapping:
        # Value Table
        # JsonID;NetworkcardStatus;LinkStatus;statusInformation
        source: "${source::monitors.network.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="network"}: $2
          hw.network.up: legacyLinkStatus($3)
        legacyTextParameters:
          StatusInformation: $4
  battery:
    discovery:
      sources:
        source(1):
          # ' Discovery'
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Transform JSON to CSV to extract information
            # JsonID;lnn;
          - type: json2csv
            entryKey: nodes/status/batterystatus
            properties: ../../lnn;
        source(2):
          # Copy Source(1) into new Source(2)
          type: copy
          from: "${source::monitors.battery.discovery.sources.source(1)}"
          computes:
          # Add " - 1" to JsonID
          - type: rightConcat
            column: 1
            value: -1
            # Duplicate lnn;
            # JsonID;lnn;lnn;
          - type: duplicateColumn
            column: 2
            # Replace column 3 with Display String
            # JsonID;lnn;DisplayName;
          - type: replace
            column: 3
            existingValue: $3
            newValue: Battery 1
        source(3):
          # Copy Source(1) into new Source(3)
          type: copy
          from: "${source::monitors.battery.discovery.sources.source(1)}"
          computes:
          # Add " - 2" to JsonID
          - type: rightConcat
            column: 1
            value: -2
            # Duplicate lnn;
            # JsonID;lnn;lnn;
          - type: duplicateColumn
            column: 2
            # Replace column 3 with Display String
            # JsonID;lnn;DisplayName;
          - type: replace
            column: 3
            existingValue: $3
            newValue: Battery 2
        source(4):
          # Union Source(2) and Source(3)
          # This creates proper number of discovered instances
          # JsonID;lnn;DisplayName;
          type: tableUnion
          tables:
          - "${source::monitors.battery.discovery.sources.source(2)}"
          - "${source::monitors.battery.discovery.sources.source(3)}"
      mapping:
        # Instance Table
        # JsonID;lnn;DisplayName;
        source: "${source::monitors.battery.discovery.sources.source(4)}"
        attributes:
          id: $1
          __display_id: $3
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $3
    collect:
      # ' Collect'
      type: multiInstance
      sources:
        source(1):
          # Json Output
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Transform JSON to CSV to extract information
            # JsonID;result1;status1;result2;status2;
          - type: json2csv
            entryKey: nodes/status/batterystatus
            properties: /result1;/status1;/result2;/status2;
        source(2):
          # Keep Columns related to battery 1 and store in Source(2)
          # JsonID;result1;status1;
          type: copy
          from: "${source::monitors.battery.collect.sources.source(1)}"
          computes:
          - type: keepColumns
            columnNumbers: "1,2,3"
            # Add " - 1" to JsonID to match discovery instance
            # JsonID;result1;status1;
          - type: rightConcat
            column: 1
            value: -1
        source(3):
          # Keep columns related to battery 2 and store in Source(3)
          # JsonID;result2;status2;
          type: copy
          from: "${source::monitors.battery.collect.sources.source(1)}"
          computes:
          - type: keepColumns
            columnNumbers: "1,4,5"
            # Add " - 2" to JsonID to match discovery instance
            # JsonID;result2;status2;
          - type: rightConcat
            column: 1
            value: -2
        source(4):
          # Union Source(2) and Source(3) to get proper number of collection instances
          type: tableUnion
          tables:
          - "${source::monitors.battery.collect.sources.source(2)}"
          - "${source::monitors.battery.collect.sources.source(3)}"
          computes:
            # Translate battery status into PatrolStatus
            # JsonID;PatrolStatus;StatusInformation;
          - type: translate
            column: 2
            translationTable: "${translation::BatteryStatusTranslationTable}"
      mapping:
        # Value Table
        # JsonID;patrolStatus;status;
        source: "${source::monitors.battery.collect.sources.source(4)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="battery"}: $2
        legacyTextParameters:
          StatusInformation: $3
  logical_disk:
    discovery:
      sources:
        source(1):
          # Discovery
          type: http
          method: GET
          url: /platform/3/storagepool/storagepools
          resultContent: body
          computes:
            # Transform JSON to CSV to extract information
            # JsonID;lnn;
          - type: json2csv
            entryKey: storagepools
            properties: /name;/usage/total_bytes;/protection_policy;
          - type: leftConcat
            column: 4
            value: "Protection Policy: "
      mapping:
        # The Instance table
        # JsonID;lnn;Status;AdditionalInformation;StatusInformation;ID;TotalSize;
        source: "${source::monitors.logical_disk.discovery.sources.source(1)}"
        attributes:
          id: $1
          __display_id: $2
          info: $4
          hw.parent.type: enclosure
          hw.parent.id: Cluster
          name: "${awk::sprintf(\"%s (%s)\", $2, bytes2HumanFormatBase2($3))}"
        metrics:
          hw.logical_disk.limit: $3
    collect:
      # Collect type is MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Json Output
          type: http
          method: GET
          url: /platform/3/storagepool/storagepools
          resultContent: body
          computes:
            # Transform JSON to CSV to extract information
            # JsonID;lnn;underprovisioned;missing_drives;devices_down;devices_smartfailed;waiting_repair
          - type: json2csv
            entryKey: storagepools
            properties: "/health_flags[0];/health_flags[1];/health_flags[2];/health_flags[3];/health_flags[4];"
          - type: rightConcat
            column: 2
            value: '|'
          # missing_drives
          - type: rightConcat
            column: 2
            value: $3
          - type: rightConcat
            column: 2
            value: '|'
          # devices_down
          - type: rightConcat
            column: 2
            value: $4
          - type: rightConcat
            column: 2
            value: '|'
          # devices_smartfailed
          - type: rightConcat
            column: 2
            value: $5
          - type: rightConcat
            column: 2
            value: '|'
          # waiting_repair
          - type: rightConcat
            column: 2
            value: $6
            # Adding default case if no other statuses
            # default_ok
          - type: rightConcat
            column: 2
            value: '|default_ok'
          - type: keepColumns
            columnNumbers: "1,2"
        source(2):
          type: copy
          from: "${source::monitors.logical_disk.collect.sources.source(1)}"
          computes:
            # Duplicate status array column
            # JsonID;StatusArray;
          - type: duplicateColumn
            column: 2
            # Translate StatusArray into PatrolStatus
            # JsonID;StatusArray;StatusArray
          - type: arrayTranslate
            column: 2
            translationTable: "${translation::HealthFlagsTranslationTable}"
            # Translate StatusArray into a StatusInformation
            # JsonID;PATROLStatusArray;StatusArray
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::HealthFlagsDescriptionTranslationTable}"
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # JsonID;PatrolStatusArray;StatusInformation;
          - type: convert
            column: 2
            conversion: array2SimpleStatus
      mapping:
        # The Value Table
        # JsonID;PatrolStatus;StatusInformation;
        source: "${source::monitors.logical_disk.collect.sources.source(2)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="logical_disk"}: $2
        legacyTextParameters:
          StatusInformation: $3
translations:
  SmartFailedTranslateTable:
    "true": SmartFailed
    Default: ""
  VoltageThresholdTranslationTable:
    V3.3_CMD: 3030;3560
    VCC_1V8: 1660;1940
    V1.8: 1660;1940
    V12.0_FAN3: 11020;12960
    V3.3: 3030;3560
    V12.0_FAN1: 11020;12960
    V5.0: 4600;5400
    BB +1.1V STBY: 1060;1150
    V12.0_FAN2: 11020;12960
    BB +1.8V AUX: 1730;1870
    BB 1.5V P2DDR AB: 1410;1590
    BB 1.5V P2DDR CD: 1410;1590
    VCC_1V0: 920;1080
    BB +12.0V: 11050;12870
    VCC_5V0: 4600;5400
    VCC_3V3: 3030;3560
    BB +3.3V: 3070;3510
    V5.0_NVRAM: 4600;5400
    BB +3.3V AUX: 3070;3510
    V5.0_STBY: 4600;5400
    V3.3_STBY: 3030;3560
    VCC_5V0_CBL: 4600;5400
    BB +3.0V VBAT: 2240;
    BB +1.2V P1vcc: 570;1440
    VCC_5V0_SB: 4600;5400
    BB 1.5V P1DDR AB: 1410;1590
    BB 1.5V P1DDR CD: 1410;1590
    V12.0_MB1: 11020;12960
    PS OUT VOLT 2: 11400;12800
    VCC_12V0: 11020;12960
    V12.0_BB_A: 11020;12960
    PS OUT VOLT 1: 11400;12800
    BB -12.0V: -13230;-10640
    V12.0: 11020;12960
    V12.0_MB0: 11020;12960
    PS IN VOLT 1: ;
    PS IN VOLT 2: ;
    Default: ;
    BB +5.0V: 4630;5350
    BB +1.35 P2LV CD: 570;1440
    BB +1.35 P1LV AB: 570;1440
    BB +5.0V STBY: 4630;5350
    V1.0: 920;1080
    BB +1.2V VCCP1: 570;1440
    BB +1.2V P2vcc: 570;1440
    V5.0_FP_X: 4600;5400
  BatteryStatusTranslationTable:
    Ready, enabled, and fully charged: ok
    Good-Test: ok
    Good-Testing: ok
    Testing-Good: ok
    passed: ok
    Good-Good: ok
    Good: ok
    Default: failed
    Ready and enabled: ok
  PowerSupplyStatusTranslationTable:
    Good: ok
    Default: failed
  HealthFlagsTranslationTable:
    missing_drives: degraded
    waiting_repair: degraded
    default_ok: ok
    devices_smartfailed: degraded
    Default: UNKNOWN
    underprovisioned: degraded
    devices_down: degraded
  ReadOnlyTranslateTable:
    "true": ReadOnly
    Default: ""
  CPUStatusTranslationTable:
    Normal: ok
    Default: failed
  NodeStatusInformationTranslationTable:
    ReadOnly: ReadOnly
    Down: Down
    Dead: Dead
    ShutDownReadOnly: ShutDownReadOnly
    SmartFailed: SmartFailed
    NotInCluster: NotInCluster
    InCluster: InCluster
    Default: ""
  NodeStatusTranslationTable:
    ReadOnly: degraded
    Down: failed
    Dead: failed
    ShutDownReadOnly: degraded
    SmartFailed: failed
    NotInCluster: degraded
    InCluster: ok
    Default: ok
  ShutDownReadOnlyTranslateTable:
    "true": ShutDownReadOnly
    Default: ""
  PhysicalDiskStatusTranslationTable:
    NEW: degraded
    WRONG_TYPE: degraded
    SED_ERROR: failed
    L3: ok
    JOURNAL: ok
    SMARTFAIL: degraded
    HEALTHY: ok
    BOOT_DRIVE: ok
    PREPARING: degraded
    STALLED: ok
    Default: failed
    NOT: failed
    UNENCRYPTED: failed
    ERASE: degraded
    RESTRIPE: degraded
    SUSPENDED: degraded
    INSECURE: failed
    USED: degraded
    REPLACE: failed
    EMPTY: degraded
  NetworkCardStatusTranslationTable:
    no carrier: ok
    inactive: ok
    up: ok
    Default: failed
  InclusterTranslateTable:
    "true": InCluster
    "false": NotInCluster
    Default: ""
  TemperatureThresholdTranslationTable:
    BB EDGE Temp: ;65
    P2 Therm Margin: 0;10
    BB BMC Temp: ;100
    SSB Temp: ;95
    P1 Therm Margin: 0;10
    LSI CORE TEMP: ;73
    BB MEM VR Temp: ;115
    LAN NIC Temp: ;115
    Default: ;
    PS TEMP 2: ;95
    PS TEMP 1: ;95
    DIMM Thrm Mrgn 1: 0;5
    P1 DTS Therm Mgn: 0;10
    TEMP SENSOR 2: ;50
    DIMM Thrm Mrgn 3: 0;5
    P2 DTS Therm Mgn: 0;10
    BB P1 VR Temp: ;115
    DIMM Thrm Mrgn 2: 0;5
    DIMM Thrm Mrgn 4: 0;5
    TEMP SENSOR 1: ;50
  HealthFlagsDescriptionTranslationTable:
    missing_drives: Missing Drives
    waiting_repair: Waiting Repair
    devices_smartfailed: Devices Smartfailed
    Default: ""
    underprovisioned: Underprovisioned
    devices_down: Devices Down
  LinkStatusTranslationTable:
    no carrier: degraded
    inactive: degraded
    up: ok
    Default: degraded
  DownTranslateTable:
    "true": Down
  FanThresholdTranslationTable:
    FAN TAC SENSOR 3: ;800
    FAN TAC SENSOR 2: ;800
    PS FAN SPEED 1: ;800
    FAN TAC SENSOR 1: ;800
    PS FAN SPEED 2: ;800
    Default: ;
  DeadTranslateTable:
    "true": Dead
    Default: ""
