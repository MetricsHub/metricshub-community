---
connector:
  displayName: NetApp SolidFire (REST)
  platforms: NetApp SolidFire
  reliesOn: SolidFire API
  version: 1.0
  information: This connector discovers and collects hardware health for NetApp SolidFire Storage Systems and communicates directly with the NetApp SolidFire System.
  detection:
    connectionTypes:
    - remote
    appliesTo:
    - Storage
    criteria:
    # Check that GetClusterInfo is in the expected format for SolidFire systems
    - type: http
      method: POST
      url: /json-rpc/9.0
      header: Content-Type:text/plain
      body: "{\"method\" : \"GetClusterInfo\", \"id\" : \"Detection\" }"
      expectedResult: "{\"id\":\"Detection\""
      errorMessage: Invalid Credentials / Not a SolidFire System
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Discovery
          type: http
          method: POST
          url: /json-rpc/9.0
          header: Content-Type:text/plain
          body: "{ \"method\" : \"GetClusterInfo\" }"
          computes:
          # JSON;Name;UUID
          - type: json2csv
            entryKey: /result/clusterInfo
            properties: /name;/uuid;
        source(2):
          type: http
          method: POST
          url: /json-rpc/9.0
          header: Content-Type:text/plain
          body: "{ \"method\" : \"ListServices\" }"
        source(3):
          type: http
          method: POST
          url: /json-rpc/9.0
          header: Content-Type:text/plain
          body: "{ \"method\": \"GetIpmiInfo\", \"params\" : { \"force\" : true } }"
        source(4):
          # Hardware Info
          type: http
          method: POST
          url: /json-rpc/9.0
          header: Content-Type:text/plain
          body: "{ \"method\": \"GetHardwareInfo\", \"params\" : { \"force\" : true } }"
      mapping:
        # Enclosure Instance Table
        # JSON;Name;UUID
        source: "${source::monitors.enclosure.discovery.sources.source(1)}"
        attributes:
          id: Cluster
          __display_id: $2
          vendor: NetApp
          model: Solid Fire
          type: enclosure
          serial_number: $3
          name: "${awk::sprintf(\"Enclosure: %s (%s %s)\", $2, \"NetApp\", \"Solid Fire\")}"
    collect:
      # Collection Type (Multi-instance)
      type: multiInstance
      sources:
        source(1):
          # Services Table
          type: http
          method: POST
          url: /json-rpc/9.0
          header: Content-Type:text/plain
          body: "{ \"method\" : \"ListServices\" }"
        source(2):
          # Hardware Info
          type: http
          method: POST
          url: /json-rpc/9.0
          header: Content-Type:text/plain
          body: "{ \"method\": \"GetHardwareInfo\", \"params\" : { \"force\" : true } }"
        source(3):
          # Sensor Information
          type: http
          method: POST
          url: /json-rpc/9.0
          header: Content-Type:text/plain
          body: "{ \"method\": \"GetIpmiInfo\", \"params\" : { \"force\" : true } }"
        source(4):
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(3)}"
          computes:
          # JSON;nodeID;sensorID;sensorName;sensorReading
          - type: json2csv
            entryKey: /result/nodes/result/ipmiInfo/sensors
            properties: ../../../nodeID;/sensorID;/sensorName;/sensorReading;
          # JSON;nodeID;sensorID;sensorName;sensorReading
          - type: keepOnlyMatchingLines
            column: 4
            regExp: PW Consumption
          # JSON;nodeID;nodeID-sensorID;sensorName;sensorReading
          - type: leftConcat
            column: 3
            value: $2
            # Extract value from sensorReading;
            # JSON;nodeID;nodeID-sensorID;sensorName;sensorReading
          - type: extract
            column: 5
            subColumn: 1
            subSeparators: ' '
            # Sum sensorReadings from all nodes
            # "Cluster";PowerConsumption;
          - type: awk
            script: "${file::embeddedFile-2}"
      mapping:
        source: "${source::monitors.enclosure.collect.sources.source(4)}"
        deviceId: $1
        metrics:
          hw.enclosure.power: $2
          hw.enclosure.energy: fakeCounter($2)
  disk_controller:
    discovery:
      sources:
        source(1):
          # Discovery
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(2)}"
          computes:
          # JSON;nodeid;servicetype;Name;SoftwareVersion;nodeType;
          - type: json2csv
            entryKey: /result/services/service
            properties: /nodeId;/serviceType;../node/name;../node/softwareVersion;../node/platformInfo/nodeType;
            # Keep only "master" servicetype
            # JSON;nodeid;servicetype;Name;SoftwareVersion;nodeType;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: master
        source(2):
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(4)}"
          computes:
          # JSON;nodeid;servicetype;Name;SoftwareVersion;nodeType;
          - type: json2csv
            entryKey: /result/nodes
            properties: /nodeId;/result/hardwareInfo/boardSerial;
        source(3):
          type: tableJoin
          leftTable: "${source::monitors.disk_controller.discovery.sources.source(1)}"
          rightTable: "${source::monitors.disk_controller.discovery.sources.source(2)}"
          leftKeyColumn: 2
          rightKeyColumn: 2
      mapping:
        # DiskController Instance Table
        # JSON;nodeid;servicetype;Name;SoftwareVersion;nodeType;
        source: "${source::monitors.disk_controller.discovery.sources.source(3)}"
        attributes:
          id: $2
          __display_id: $4
          firmware_version: $5
          model: $6
          serial_number: $9
          hw.parent.type: enclosure
          hw.parent.id: Cluster
          name: "${awk::sprintf(\"Disk Controller: %s (%s)\", $4, $6)}"
    collect:
      # Collect
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
          # JSON;nodeid;servicetype;status;status;
          - type: json2csv
            entryKey: /result/services/service
            properties: /nodeId;/serviceType;/status;/status;
            # Keep only "master" servicetype
            # JSON;nodeid;servicetype;status;status;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: master
            # Translate PatrolStatus
            # JSON;nodeid;servicetype;PatrolStatus;status;
          - type: translate
            column: 4
            translationTable: "${translation::DiskControllerTranslationTable}"
      mapping:
        # DiskController Instance Table
        # JSON;nodeid;servicetype;PatrolStatus;status;
        source: "${source::monitors.disk_controller.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="disk_controller"}: $4
        legacyTextParameters:
          StatusInformation: $5
  memory:
    discovery:
      sources:
        source(1):
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(2)}"
          computes:
          # JSON;nodeid;servicetype;MEMORY_GB
          - type: json2csv
            entryKey: /result/services/service
            properties: /nodeId;/serviceType;../node/platformInfo/nodeMemoryGB;
            # Keep only "master" servicetype
            # JSON;nodeid;servicetype;MEMORY_GB
          - type: keepOnlyMatchingLines
            column: 3
            regExp: master
            # Convert GB to MB
            # JSON;nodeid;servicetype;MEMORY_MB
          - type: multiply
            column: 4
            value: 1024
      mapping:
        # Memory InstanceTable
        # JSON;nodeid;servicetype;MEMORY_MB
        source: "${source::monitors.memory.discovery.sources.source(1)}"
        attributes:
          id: $2
          __display_id: memory
          hw.parent.type: disk_controller
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s (%s MB)\", \"memory\", $4)}"
        metrics:
          hw.memory.limit: mebiByte2Byte($4)
    collect:
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(2)}"
          computes:
          # JSON;DeviceID;Status;StatusInformation;
          - type: json2csv
            entryKey: /result/nodes
            properties: /nodeId;/result/hardwareConfig/MEMORY_GB/Passed;/result/hardwareConfig/MEMORY_GB/Passed;
          # JSON;DeviceID;PatrolStatus;StatusInformation;
          - type: translate
            column: 3
            translationTable: "${translation::HardwareConfigTranslationTable}"
      mapping:
        # Memory Value table
        # JSON;DeviceID;PatrolStatus;StatusInformation;
        source: "${source::monitors.memory.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="memory"}: $3
        legacyTextParameters:
          StatusInformation: $4
  cpu:
    discovery:
      sources:
        source(1):
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(4)}"
          computes:
            # "actual": "Intel(R) Xeon(R) CPU E5-2620 v4 @ 2.10GHz",
            # JSON;nodeid;nodeID;actual;actual;actual;actual;
          - type: json2csv
            entryKey: /result/nodes
            properties: /nodeId;/nodeId;/result/hardwareInfo/hardwareConfig/CPU_MODEL_00/actual;/result/hardwareInfo/hardwareConfig/CPU_MODEL_00/actual;/result/hardwareInfo/hardwareConfig/CPU_MODEL_00/actual;/result/hardwareInfo/hardwareConfig/CPU_MODEL_00/actual;
          # JSON;nodeid;CPU1-nodeID;actual;actual;actual;actual;
          - type: leftConcat
            column: 3
            value: CPU1-
          # JSON;nodeid;CPU1-nodeID;CPU 1;actual;actual;actual;actual;
          - type: rightConcat
            column: 3
            value: ';CPU1 '
        source(2):
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(4)}"
          computes:
            # "actual": "Intel(R) Xeon(R) CPU E5-2620 v4 @ 2.10GHz",
            # JSON;nodeid;actual;actual;actual;actual;
          - type: json2csv
            entryKey: /result/nodes
            properties: /nodeId;/nodeId;/result/hardwareInfo/hardwareConfig/CPU_MODEL_01/actual;/result/hardwareInfo/hardwareConfig/CPU_MODEL_01/actual;/result/hardwareInfo/hardwareConfig/CPU_MODEL_01/actual;/result/hardwareInfo/hardwareConfig/CPU_MODEL_01/actual;
          - type: leftConcat
            column: 3
            value: CPU2-
          # JSON;nodeid;CPU1-nodeID;CPU 1;actual;actual;actual;actual;
          - type: rightConcat
            column: 3
            value: ';CPU2 '
        source(3):
          type: tableUnion
          tables:
          - "${source::monitors.cpu.discovery.sources.source(1)}"
          - "${source::monitors.cpu.discovery.sources.source(2)}"
          computes:
            # Extract Vendor
            # JSON;nodeid;CPU-nodeID;CPU;Vendor;actual;actual;actual;
          - type: extract
            column: 5
            subColumn: 1
            subSeparators: ' '
            # Extract Model
            # JSON;nodeid;CPU-nodeID;CPU;Vendor;Model;actual;actual;
          - type: extract
            column: 6
            subColumn: 2
            subSeparators: ' '
            # Extract Name
            # JSON;nodeid;CPU-nodeID;CPU;Vendor;Model;Name;actual;
          - type: extract
            column: 7
            subColumn: 4
            subSeparators: ' '
            # Extract Speed
            # JSON;nodeid;CPU-nodeID;CPU;Vendor;Model;Name;Speed;
          - type: extract
            column: 8
            subColumn: 2
            subSeparators: '@'
          # JSON;nodeid;CPU-nodeID;DisplayName;Vendor;Model;Name;Speed;
          - type: rightConcat
            column: 4
            value: $7
          - type: replace
            column: 8
            existingValue: GHz
            newValue: ""
          - type: replace
            column: 8
            existingValue: ' '
            newValue: ""
          - type: multiply
            column: 8
            value: 1000
      mapping:
        # CPU Instance Table
        # JSON;nodeid;CPU-nodeID;DisplayName;Vendor;Model;Name;Speed;
        source: "${source::monitors.cpu.discovery.sources.source(3)}"
        attributes:
          id: $3
          __display_id: $4
          vendor: $5
          model: $6
          hw.parent.type: disk_controller
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s (%s - %s - %s)\", $4, $5, $6, megaHertz2HumanFormat($8))}"
        metrics:
          hw.cpu.speed.limit{limit_type="max"}: megaHertz2Hertz($8)
    collect:
      # Collect
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(2)}"
          computes:
          # JSON;NodeID;CPU_MODEL_00_Status;CPU_MODEL_00_Status;
          - type: json2csv
            entryKey: /result/nodes
            properties: /nodeId;/result/hardwareInfo/hardwareConfig/CPU_MODEL_00/Passed;/result/hardwareInfo/hardwareConfig/CPU_MODEL_00/Passed;/result/hardwareInfo/hardwareConfig/CPU_MODEL_00/actual;
          - type: leftConcat
            column: 2
            value: CPU1-
        source(2):
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(2)}"
          computes:
          # JSON;NodeID;CPU_MODEL_00_Status;CPU_MODEL_00_Status;
          - type: json2csv
            entryKey: /result/nodes
            properties: /nodeId;/result/hardwareInfo/hardwareConfig/CPU_MODEL_01/Passed;/result/hardwareInfo/hardwareConfig/CPU_MODEL_01/Passed;/result/hardwareInfo/hardwareConfig/CPU_MODEL_01/actual;
          - type: leftConcat
            column: 2
            value: CPU2-
        source(3):
          type: tableUnion
          tables:
          - "${source::monitors.cpu.collect.sources.source(1)}"
          - "${source::monitors.cpu.collect.sources.source(2)}"
          computes:
          # JSON;NodeID;PatrolStatus;
          - type: translate
            column: 3
            translationTable: "${translation::HardwareConfigTranslationTable}"
      mapping:
        # CPU ValueTable
        # JSON;NodeID;PatrolStatus;StatusInformation
        source: "${source::monitors.cpu.collect.sources.source(3)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="cpu"}: $3
        legacyTextParameters:
          StatusInformation: $4
  physical_disk:
    discovery:
      sources:
        source(1):
          type: http
          method: POST
          url: /json-rpc/9.0
          header: Content-Type:text/plain
          body: "{\"method\" : \"ListDrives\"}"
          computes:
          # JSON;NodeID;DriveID;
          - type: json2csv
            entryKey: /result/drives
            properties: /nodeId;/driveId;
        source(2):
          type: http
          method: POST
          url: /json-rpc/9.0
          header: Content-Type:text/plain
          body: "{ \"method\": \"GetDriveHardwareInfo\", \"params\": { \"driveID\": \"$3\" } }"
          executeForEachEntryOf:
            source: "${source::monitors.physical_disk.discovery.sources.source(1)}"
            concatMethod: json_array_extended
          computes:
          # JSON;NodeID;UUID;logicalName;product;product;serial;size;description;
          - type: json2csv
            entryKey: /Entry/value/result/driveHardwareInfo
            properties: ../../../Column(2);../../../Column(3);/product;/product;/serial;/size;/description;
            # Extract Vendor value from product
            # JSON;NodeID;UUID;logicalName;Vendor;product;serial;size;description;
          - type: extract
            column: 4
            subColumn: 1
            subSeparators: ' '
            # Extract Model value from product
            # JSON;NodeID;UUID;logicalName;Vendor;Model;serial;size;description;
          - type: extract
            column: 5
            subColumn: 2
            subSeparators: ' '
            # Extract type from description
            # JSON;NodeID;UUID;logicalName;Vendor;Model;serial;size;type;
          - type: extract
            column: 8
            subColumn: 1
            subSeparators: ' '
          - type: leftConcat
            column: 8
            value: "Type: "
      mapping:
        # PhysicalDisk Instance
        # JSON;NodeID;UUID;logicalName;Vendor;Model;serial;size;type;
        source: "${source::monitors.physical_disk.discovery.sources.source(2)}"
        attributes:
          id: $3
          __display_id: $3
          vendor: $4
          model: $5
          serial_number: $6
          info: $8
          hw.parent.type: disk_controller
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s (%s - %s)\", $3, $4, bytes2HumanFormatBase10($7))}"
        metrics:
          hw.physical_disk.size: $7
    collect:
      # Collect
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
          # JSON;driveId;driveStatus;driveStatus;
          - type: json2csv
            entryKey: /result/services/drive
            properties: /driveId;/driveStatus;/driveStatus;
            # Translate PatrolStatus
            # JSON;driveId;PatrolStatus;driveStatus;
          - type: translate
            column: 3
            translationTable: "${translation::PhysicalDiskTranslationTable}"
      mapping:
        # PhysicalDisk Value Table
        # MSHW;shelf;unique-id;bay-has-disk;bay-type;PatrolStatus;
        source: "${source::monitors.physical_disk.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="physical_disk"}: $3
        legacyTextParameters:
          StatusInformation: $4
  logical_disk:
    discovery:
      sources:
        source(1):
          # Discovery
          type: http
          method: POST
          url: /json-rpc/9.0
          header: Content-Type:text/plain
          body: "{\"method\" : \"ListVolumes\", \"id\" : \"Cluster\" }"
          computes:
          # JSON;SystemID;UUID;Name;Size
          - type: json2csv
            entryKey: /result/volumes
            properties: ../../id;/volumeUUID;/name;/totalSize;
      mapping:
        # LogicalDisk Instance Table
        # JSON;SystemID;UUID;Name;Size
        source: "${source::monitors.logical_disk.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s (%s)\", $4, bytes2HumanFormatBase2($5))}"
        metrics:
          hw.logical_disk.limit: $5
    collect:
      # CollectionType (Multi-instance)
      type: multiInstance
      sources:
        source(1):
          type: http
          method: POST
          url: /json-rpc/9.0
          header: Content-Type:text/plain
          body: "{\"method\" : \"ListVolumes\", \"id\" : \"Cluster\" }"
          computes:
          # JSON;volumeUUID;Status;Status
          - type: json2csv
            entryKey: /result/volumes
            properties: /volumeUUID;/status;/status;
            # Translate PatrolStatus
            # JSON;volumeUUID;PatrolStatus;StatusInformation
          - type: translate
            column: 3
            translationTable: "${translation::LogicalDiskStatusTranslationTable}"
      mapping:
        # LogicalDisk Value Table
        # JSON;volumeUUID;PatrolStatus;StatusInformation
        source: "${source::monitors.logical_disk.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="logical_disk"}: $3
        legacyTextParameters:
          StatusInformation: $4
  power_supply:
    discovery:
      sources:
        source(1):
          # Discovery
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(3)}"
          computes:
          # JSON;NodeID;SensorID;SensorName;SensorType;statesAsserted
          - type: json2csv
            entryKey: /result/nodes/result/ipmiInfo/sensors
            properties: "../../../nodeID;/sensorID;/sensorName;/sensorType;/statesAsserted[0];"
            # Keep only "master" servicetype
            # JSON;NodeID;SensorID;SensorName;SensorType;statesAsserted
          - type: keepOnlyMatchingLines
            column: 5
            regExp: Power Supply
          # JSON;NodeID;NodeID-SensorID;SensorName;SensorType;statesAsserted
          - type: leftConcat
            column: 3
            value: $2
      mapping:
        # Powersupply Instance Table
        # JSON;NodeID;NodeID-SensorID;SensorName;SensorType;statesAsserted
        source: "${source::monitors.power_supply.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          hw.parent.type: disk_controller
          hw.parent.id: $2
          name: $4
    collect:
      # Collection Type (Multi-instance)
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(3)}"
          computes:
          # JSON;sensorID;statesAsserted;statesAsserted;nodeID
          - type: json2csv
            entryKey: /result/nodes/result/ipmiInfo/sensors
            properties: "/sensorID;/statesAsserted[0];/statesAsserted[0];../../../nodeID;"
          # JSON;sensorID;PatrolStatus;statesAsserted;nodeID
          - type: translate
            column: 3
            translationTable: "${translation::PowerSupplyStatusTranslationTable}"
          # JSON;NodeID-sensorID;PatrolStatus;statesAsserted;nodeID
          - type: leftConcat
            column: 2
            value: $5
      mapping:
        # PowerSupply Value Table
        # JSON;NodeID-sensorID;PatrolStatus;statesAsserted;nodeID
        source: "${source::monitors.power_supply.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="power_supply"}: $3
        legacyTextParameters:
          StatusInformation: $4
  fan:
    discovery:
      sources:
        source(1):
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(3)}"
          computes:
          # JSON;NodeID;sensorID;sensorName;sensorType;status;
          - type: json2csv
            entryKey: /result/nodes/result/ipmiInfo/sensors
            properties: ../../../nodeID;/sensorID;/sensorName;/sensorType;/status;/lowerNonCritical;/upperNonCritical;/normalMinimum;/normalMaximum;
          # JSON;NodeID;sensorID;sensorName;sensorType;status;
          - type: keepOnlyMatchingLines
            column: 5
            regExp: fan
          # JSON;NodeID;sensorID;sensorName;sensorType;status;
          - type: excludeMatchingLines
            column: 6
            valueList: Not Available
          # JSON;NodeID;nodeID-sensorID;sensorName;sensorType;status;
          - type: leftConcat
            column: 3
            value: $2
      mapping:
        # Fan Instance Table
        # JSON;NodeID;nodeID-sensorID;sensorName;sensorType;status;
        source: "${source::monitors.fan.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          hw.parent.type: disk_controller
          hw.parent.id: $2
          name: $4
        metrics:
          hw.fan.speed.limit{limit_type="low.degraded"}: $9
          hw.fan.speed.limit{limit_type="low.critical"}: $7
    collect:
      # Collection Type (Multi-instance)
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(3)}"
          computes:
          # JSON;SensorID;status;status;nodeID;
          - type: json2csv
            entryKey: /result/nodes/result/ipmiInfo/sensors
            properties: /sensorID;/status;/status;../../../nodeID;/sensorReading;
          # JSON;SensorID;PatrolStatus;status;nodeID;
          - type: translate
            column: 3
            translationTable: "${translation::SensorStatusTranslationTable}"
          # JSON;nodeID-SensorID;PatrolStatus;status;nodeID;
          - type: leftConcat
            column: 2
            value: $5
          - type: replace
            column: 6
            existingValue: ' (+/- 0) RPM'
            newValue: ""
      mapping:
        # Fan Value Table
        # JSON;nodeID-SensorID;PatrolStatus;status;nodeID;
        source: "${source::monitors.fan.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="fan"}: $3
          hw.fan.speed: $6
        legacyTextParameters:
          StatusInformation: $4
  temperature:
    discovery:
      sources:
        source(1):
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(3)}"
          computes:
          # JSON;nodeID;sensorID;sensorName;sensorType;status;
          - type: json2csv
            entryKey: /result/nodes/result/ipmiInfo/sensors
            properties: ../../../nodeID;/sensorID;/sensorName;/sensorType;/status;/lowerNonCritical;/upperNonCritical;/normalMinimum;/normalMaximum;
          # JSON;nodeID;sensorID;sensorName;sensorType;status;
          - type: keepOnlyMatchingLines
            column: 5
            regExp: temperature
          # JSON;nodeID;sensorID;sensorName;sensorType;status;
          - type: excludeMatchingLines
            column: 6
            valueList: Not Available
          # JSON;nodeID;nodeID-sensorID;sensorName;sensorType;status;
          - type: leftConcat
            column: 3
            value: $2
          # normalMaximum and normalMinimum tempertures are negative for unknown reason.
          - type: replace
            column: 9
            existingValue: '-'
            newValue: ""
          - type: replace
            column: 10
            existingValue: '-'
            newValue: ""
      mapping:
        # Temperature Instance Table
        # JSON;nodeID;nodeID-sensorID;sensorName;sensorType;status;
        source: "${source::monitors.temperature.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          hw.parent.type: disk_controller
          hw.parent.id: $2
          name: $4
        metrics:
          hw.temperature.limit{limit_type="high.degraded"}: $10
          hw.temperature.limit{limit_type="high.critical"}: $8
    collect:
      # Collection Type (Multi-instance)
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(3)}"
          computes:
          # JSON;sensorID;status;status;nodeID
          - type: json2csv
            entryKey: /result/nodes/result/ipmiInfo/sensors
            properties: /sensorID;/status;/status;../../../nodeID;/sensorReading;
          # JSON;sensorID;PatrolStatus;status;nodeID
          - type: translate
            column: 3
            translationTable: "${translation::SensorStatusTranslationTable}"
          # JSON;NodeID-sensorID;PatrolStatus;status;nodeID
          - type: leftConcat
            column: 2
            value: $5
          - type: replace
            column: 6
            existingValue: ' (+/- 0) degrees C'
            newValue: ""
      mapping:
        # Temperature Value Table
        # JSON;NodeID-sensorID;PatrolStatus;StatusInformation;nodeID
        source: "${source::monitors.temperature.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="temperature"}: $3
          hw.temperature: $6
        legacyTextParameters:
          StatusInformation: $4
  voltage:
    discovery:
      sources:
        source(1):
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(3)}"
          computes:
          # JSON;NodeID;SensorID;SensorName;SensorType;Status;
          - type: json2csv
            entryKey: /result/nodes/result/ipmiInfo/sensors
            properties: ../../../nodeID;/sensorID;/sensorName;/sensorType;/status;/lowerNonCritical;/upperNonCritical;/normalMinimum;/normalMaximum;
          # JSON;NodeID;SensorID;SensorName;SensorType;Status;
          - type: keepOnlyMatchingLines
            column: 5
            regExp: voltage
          # JSON;NodeID;SensorID;SensorName;SensorType;Status;
          - type: excludeMatchingLines
            column: 6
            valueList: Not Available
          # JSON;NodeID;NodeID-SensorID;SensorName;SensorType;Status;
          - type: leftConcat
            column: 3
            value: $2
          - type: multiply
            column: 9
            value: 1000
          - type: multiply
            column: 10
            value: 1000
      mapping:
        # Voltage Instance Table
        # JSON;NodeID;NodeID-SensorID;SensorName;SensorType;Status;
        source: "${source::monitors.voltage.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          hw.parent.type: disk_controller
          hw.parent.id: $2
          name: $4
        metrics:
          hw.voltage.limit{limit_type="low.critical"}: $9
          hw.voltage.limit{limit_type="high.degraded"}: $10
    collect:
      # Collection Type (Multi-instance)
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(3)}"
          computes:
          # JSON;SystemID;UUID;Name;Size
          - type: json2csv
            entryKey: /result/nodes/result/ipmiInfo/sensors
            properties: /sensorID;/status;/status;../../../nodeID;/sensorReading;
          - type: translate
            column: 3
            translationTable: "${translation::SensorStatusTranslationTable}"
          - type: leftConcat
            column: 2
            value: $5
          - type: replace
            column: 6
            existingValue: ' (+/- 0) Volts'
            newValue: ""
          - type: multiply
            column: 6
            value: 1000
      mapping:
        # Voltage Value Table
        # MSHW;unique-id;PatrolStatus;StatusInformation
        source: "${source::monitors.voltage.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="voltage"}: $3
          hw.voltage: $6
        legacyTextParameters:
          StatusInformation: $4
  network:
    discovery:
      sources:
        source(1):
          # Discovery
          type: http
          method: POST
          url: /json-rpc/9.0
          header: Content-Type:text/plain
          body: "{ \"method\": \"GetNetworkConfig\", \"params\": { \"force\" : true } }"
          computes:
          # NodeID ; CardID ; CardDisplayID ; Family ; Speed ; MAC ; Status ;
          - type: awk
            script: "${file::embeddedFile-1}"
      mapping:
        # NetworkCard Instance Table
        # NodeID ; CardID ; CardDisplayID ; Family ; Speed ; MAC ; Status ;
        source: "${source::monitors.network.discovery.sources.source(1)}"
        attributes:
          id: $2
          __display_id: $3
          model: $4
          physical_address: $6
          physical_address_type: MAC
          logical_address: $8
          logical_address_type: IPv4
          hw.parent.type: disk_controller
          hw.parent.id: $1
          name: "${awk::sprintf(\"%s (%s)\", $3, $4)}"
        conditionalCollection:
          hw.network.bandwidth.limit: $5
    collect:
      # Collection type (Multi-instance)
      type: multiInstance
      sources:
        source(1):
          type: http
          method: POST
          url: /json-rpc/9.0
          header: Content-Type:text/plain
          body: "{ \"method\": \"GetNetworkConfig\", \"params\": { \"force\" : true } }"
          computes:
          # NodeID ; CardID ; CardDisplayID ; Family ; Speed ; MAC ; Status ;
          - type: awk
            script: "${file::embeddedFile-1}"
          # NodeID ; CardID ; CardDisplayID ; Family ; Speed ; MAC ; Status ; Status ;
          - type: duplicateColumn
            column: 7
          # NodeID ; CardID ; CardDisplayID ; Family ; Speed ; MAC ; Status ; Status ; Status ; StatusInformation
          - type: duplicateColumn
            column: 7
            # Translate NetworkCardStatus into PatrolStatus
            # NodeID ; CardID ; CardDisplayID ; Family ; Speed ; MAC ; PatrolStatus ; Status ; Status ; StatusInformation
          - type: translate
            column: 7
            translationTable: "${translation::NetworkCardStatusTranslationTable}"
            # Translate link-status status into LinkStatus
            # NodeID ; CardID ; CardDisplayID ; Family ; Speed ; MAC ; PatrolStatus ; LinkStatus ; StatusInformation
          - type: translate
            column: 8
            translationTable: "${translation::LinkStatusTranslationTable}"
      mapping:
        # NetworkCard Value Table
        # NodeID ; CardID ; CardDisplayID ; Family ; Speed ; MAC ; PatrolStatus ; LinkStatus ; StatusInformation
        source: "${source::monitors.network.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.network.bandwidth.limit: megaBit2Bit($5)
          hw.status{hw.type="network"}: $7
          hw.network.up: legacyLinkStatus($8)
        legacyTextParameters:
          StatusInformation: $9
translations:
  PhysicalDiskTranslationTable:
    available: ok
    erasing: degraded
    assigned: ok
    failed: failed
    Default: failed
    removing: degraded
  DiskControllerTranslationTable:
    default: failed
    healthy: ok
  SensorStatusTranslationTable:
    default: failed
    Not Available: ok
    ok: ok
  LinkStatusTranslationTable:
    Down: degraded
    UpAndRunning: ok
    Up: ok
    Default: degraded
  PowerSupplyStatusTranslationTable:
    Presence detected: ok
    Failure detected: failed
    Power Supply AC lost: failed
    Power Supply Inactive: degraded
    AC lost or out-of-range: failed
    AC out-of-range, but present: degraded
    Default: failed
    Config Error: degraded
  HardwareConfigTranslationTable:
    "true": ok
    "false": failed
  LogicalDiskStatusTranslationTable:
    active: ok
    Default: failed
  NetworkCardStatusTranslationTable:
    Down: ok
    UpAndRunning: ok
    Up: ok
    Default: failed
