---
extends:
- SunEthernetDriver-header
connector:
  displayName: Oracle/Sun Solaris - Network
  platforms: Oracle/Sun
  reliesOn: "Sun Solaris system commands (kstat, ndd, ifconfig, dladm, etc.)"
  version: 1.3
  information: This connector provides the monitoring of network cards on all Sun Solaris systems.
  detection:
    connectionTypes:
    - remote
    - local
    appliesTo:
    - Solaris
    criteria:
    - type: deviceType
      keep:
      - SunOS
      - Solaris
    - type: osCommand
      commandLine: /usr/sbin/ifconfig -a
      expectedResult: flags=
sudoCommands:
- /usr/sbin/ndd
- /usr/sbin/dladm
monitors:
  network:
    discovery:
      sources:
        source(1):
          # Source(1) = output of ifconfig -a
          type: osCommand
          commandLine: /usr/sbin/ifconfig -a
          computes:
            # Process the output of ifconfig through an AWK script
            # LogicalDeviceID;MacAddress;IPAddress;
          - type: awk
            script: $embedded.EmbeddedFile(1)$
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5"
        source(2):
          # Source(2) = output of prtconf -D or dladm show-dev
          # with only the network instances
          type: osCommand
          commandLine: /bin/sh $embedded.EmbeddedFile(5)$
          keep: "\\(network, instance #[0-9]\\)\\|\\(link:.*speed:.*duplex:\\)\\|\\(: flags=\\)\\|\\(SUNW,qfe\\)\\|\\(FJSV,pgtb\\)\\|\\(LinkID:.*DeviceID:\\)"
          computes:
            # Process the output of prtconf through an AWK script to keep only the NIC ID
            # DeviceID;Driver;
          - type: awk
            script: $embedded.EmbeddedFile(4)$
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3"
        source(3):
          # Source(3) = output of dladm show-phys
          # This command will only work on Solaris 11.  A blank table is expected on other versions.
          # LogicalDeviceID;PhysicalID
          type: osCommand
          commandLine: /bin/sh $embedded.EmbeddedFile(6)$
          keep: "[A-Za-z].*[0-9];[A-Za-z].*[0-9]"
          computes:
            # Add a "" to column2 to force the PSL/Java close out column 2
            # LogicalDeviceID;PhysicalID;
          - type: rightConcat
            column: 2
            value: ""
        source(4):
          # Source(4) = Table joint of Source(2) and Source(3)
          # Solaris 11 machines, the DeviceID from Table 2 will match the PhysicalID
          # For other versions, it will not match, so we put a marker in
          # DeviceID;Driver;LogicalDeviceID;PhysicalID;
          type: tableJoin
          leftTable: $monitors.network.discovery.sources.source(2)$
          rightTable: $monitors.network.discovery.sources.source(3)$
          leftKeyColumn: 1
          rightKeyColumn: 2
          defaultRightLine: NotSolaris11;;
          computes:
            # For non-Solaris 11 machines, we will copy the deviceID into the PhysicalID column (where we put the marker NotSolaris11)
            # DeviceID;Driver;LogicalDeviceID;PhysicalID;
          - type: replace
            column: 3
            existingValue: NotSolaris11
            newValue: Column(1)
        source(5):
          # Source(3) = Table joint of Source(2) and Source(1)
          # DeviceID;Driver;LogicalDeviceID;PhysicalID;LogicalDeviceID;MacAddress;IPAddress;
          type: tableJoin
          leftTable: $monitors.network.discovery.sources.source(4)$
          rightTable: $monitors.network.discovery.sources.source(1)$
          leftKeyColumn: 3
          rightKeyColumn: 1
          defaultRightLine: ;;;
          computes:
            # Translate the Driver column into a model name
            #  DeviceID;Model;LogicalDeviceID;PhysicalID;LogicalDeviceID;MacAddress;IPAddress;
          - type: translate
            column: 2
            translationTable: DriverTranslationTable
      mapping:
        # InstanceTable = Source(3)
        # DeviceID;Model;LogicalDeviceID;PhysicalID;LogicalDeviceID;MacAddress;IPAddress;
        source: $monitors.network.discovery.sources.source(5)$
        attributes:
          id: $column(3)
          __display_id: $column(3)
          model: $column(2)
          physical_address: $column(6)
          physical_address_type: MAC
          logical_address: $column(7)
          logical_address_type: IP
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s)\", $column(3), $column(2))"
    collect:
      # Collect type is: mono-collect
      type: monoInstance
      sources:
        source(1):
          # Source(1) = output of the embedded script 2 (ifconfig output)
          # DeviceID;ifconfigFlags
          type: osCommand
          commandLine: "if /usr/sbin/ifconfig %NetworkCard.Collect.DeviceID%; then /usr/bin/echo; else /usr/bin/echo \"%NetworkCard.Collect.DeviceID%: flags=00000000:UNPLUMBED\"; fi"
          keep: "^%NetworkCard.Collect.DeviceID%: flags="
          separators: :<>
          selectColumns: "1,3"
          computes:
            # Duplicate the ifconfigFlags
            # DeviceID;ifconfigFlags;ifconfigFlags;
          - type: duplicateColumn
            column: 2
            # Translate the first ifconfig flags
            # DeviceID;StatusArray;ifconfigFlags;
          - type: arrayTranslate
            column: 2
            translationTable: ifconfigFlagsTranslationTable
            arraySeparator: ","
            resultSeparator: '|'
            # Convert StatusArray into Status
            # DeviceID;Status;StatusInformation;
          - type: convert
            column: 2
            conversion: array2SimpleStatus
        source(2):
          # Source(2) = output of embedded script 4 (complicated shell script)
          type: osCommand
          commandLine: /bin/sh $embedded.EmbeddedFile(2)$ %NetworkCard.Collect.DeviceID%
          computes:
            # Process the output of this script through a smart AWK script
            # DeviceID;LinkStatus;LinkSpeed;DuplexMode;ReceivedPacket;TransmittedPackets;Errors;ReceivedBytes;TransmittedBytes;
          - type: awk
            script: $embedded.EmbeddedFile(3)$
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5,6,7,8,9,10"
        source(3):
          # Source(3) = table joint of Source(1) and Source(2)
          # DeviceID;Status;StatusInformation;DeviceID;LinkStatus;LinkSpeed;DuplexMode;ReceivedPacket;TransmittedPackets;Errors;ReceivedBytes;TransmittedBytes;
          type: tableJoin
          leftTable: $monitors.network.collect.sources.source(1)$
          rightTable: $monitors.network.collect.sources.source(2)$
          leftKeyColumn: 1
          rightKeyColumn: 1
          defaultRightLine: ;;;;;;;;;
      mapping:
        # And here is the ValueTable
        source: $monitors.network.collect.sources.source(3)$
        metrics:
          hw.status{hw.type="network"}: $column(2)
          hw.network.up: legacyLinkStatus($column(5))
          hw.network.bandwidth.limit: megaBit2Bit($column(6))
          hw.network.full_duplex: legacyFullDuplex($column(7))
          hw.network.packets{direction="receive"}: $column(8)
          hw.network.packets{direction="transmit"}: $column(9)
          hw.errors{hw.type="network"}: $column(10)
          hw.network.io{direction="receive"}: $column(11)
          hw.network.io{direction="transmit"}: $column(12)
        legacyTextParameters:
          StatusInformation: $column(3)
embedded:
  EmbeddedFile(1): |-
    BEGIN {
        DeviceID = ""
    }
    /^[a-z0-9]+: flags=/ {

        if (DeviceID != "")
        {
            print "MSHW;" DeviceID ";" macAddress ";" ipAddress
            DeviceID = ""
            macAddress = ""
            ipAddress = ""
        }

        ltIndex = index($0, "<")
        if (ltIndex != 0)
        {
            gtIndex = index($0, ">")
            if (gtIndex > ltIndex)
            {
                flags = substr($0, ltIndex + 1, gtIndex - ltIndex - 1)

                if (index(flags, "LOOPBACK") == 0 && index(flags, "OFFLINE") == 0 && index(flags, "UP") > 0)
                {
                    DeviceID = substr($1, 1, length($1) - 1)
                }
            }
        }
    }
    /^[ \t]+inet [0-9]/ {
        ipAddress = $2
    }
    /^[ \t]+ether [0-9A-Za-z]/ {
        macAddress = $2
    }
    END {
        if (DeviceID != "")
        {
            print "MSHW;" DeviceID ";" macAddress ";" ipAddress
        }
    }
  EmbeddedFile(3): |-
    BEGIN {
        deviceID = "";
        linkStatus = "";
        linkDuplex = "";
        linkSpeed = "";
        receivedPackets = "";
        transmittedPackets = "";
        inputErrors = 0;
        outputErrors = 0;
        collisions = 0;
        receivedBytes = "";
        transmittedBytes = "";
    }
    ($1 == "DeviceID") { deviceID = $2; }
    (($1 == "link_up" || $1 == "link_status") && linkStatus != "OK") { if ($2 == 1) { linkStatus = "OK"; } else { linkStatus = "WARN"; } }
    ($1 == "ifspeed" || $1 == "ifSpeed" && linkSpeed == "") { linkSpeed = $2; }
    ($1 == "link_speed") { linkSpeed = $2; }
    ($1 == "duplex") { if ($2 == "full") { linkDuplex = "full"; } else { linkDuplex = "half"; } }
    ($1 == "link_mode") { if ($2 == 1) { linkDuplex = "full"; } else { linkDuplex = "half"; } }
    ($1 == "link_duplex") { if ($2 == 2) { linkDuplex = "full"; } else { linkDuplex = "half"; } }
    ($1 == "ipackets64") { receivedPackets = $2; }
    ($1 == "ipackets" && receivedPackets == "") { receivedPackets = $2; }
    ($1 == "opackets64") { transmittedPackets = $2; }
    ($1 == "opackets" && transmittedPackets == "") { transmittedPackets = $2; }
    ($1 == "ierrors") { inputErrors = $2; }
    ($1 == "oerrors") { outputErrors = $2; }
    ($1 == "collisions") { collisions = $2; }
    ($1 == "rbytes64") { receivedBytes = $2; }
    ($1 == "rbytes" && receivedBytes == "") { receivedBytes = $2; }
    ($1 == "obytes64") { transmittedBytes = $2; }
    ($1 == "obytes" && transmittedBytes == "") { transmittedBytes = $2; }


    # Solaris 10 Aggregate Section
    #
    ($1 == deviceID) && ($2 ~ /[0-9]+/) && ($3 ~ /[0-9]+/) && ($4 ~ /[0-9]+/) && ($5 ~ /[0-9]+/) && ($6 ~ /[0-9]+/) && ($7 ~ /[0-9]+/) {
         print deviceID
        receivedPackets = $2
        receivedBytes = $3
        inputErrors = $4
        transmittedPackets = $5
        transmittedBytes = $6
        outputErrors = $7
        }
    ($1 == deviceID) && ($2 ~ /link=/) && ($3 ~ /speed=/) && ($4 ~ /duplex=/) {
        if ($2 ~ /up/) {linkStatus = "OK"} else { linkStatus = "WARN"; }
      linkSpeed = $3 ; gsub ("speed=","",linkSpeed)
      if ($4 ~ /full/) { linkDuplex = "full"; } else { linkDuplex = "half"; }
    }

    END {
        if (linkSpeed == 0)                 { linkSpeed = 10; }
        else if (linkSpeed == 1)            { linkSpeed = 100; }
        else if (linkSpeed == 10000000)        { linkSpeed = 10; }
        else if (linkSpeed == 100000000)    { linkSpeed = 100; }
        else if (linkSpeed == 1000000000)    { linkSpeed = 1000; }
        else if (linkSpeed == "10000000000")    { linkSpeed = 10000; }

        errors = inputErrors + outputErrors + collisions;

        print "MSHW;" deviceID ";" linkStatus ";" linkSpeed ";" linkDuplex ";" receivedPackets ";" transmittedPackets ";" errors ";" receivedBytes ";" transmittedBytes ";"
    }
  EmbeddedFile(2): |-
    #!/bin/sh

    # First of all, make sure the thing speaks english
    LANG=C
    export LANG

    # Get the Solaris version, because kstat is not available in pre-Solaris 9
    # and netstat -k is not available in Solaris 10...
    OSVERSION=`/usr/bin/uname -r|/usr/bin/awk -F. '{print $2}'`

    # Extract the name of the driver and the instance number
    DRIVER=`/usr/bin/echo $1 | /usr/bin/sed -e "s/[0-9]*$//"`
    INSTANCE=`/usr/bin/echo $1 | /usr/bin/sed -e "s/^$DRIVER//"`

    # Print out the device ID
    /usr/bin/echo "DeviceID $1"

    ####  KERNELSTAT Section (Statistics)

    #
    # Solaris 8 or earlier
    #
    if /usr/bin/test $OSVERSION -le 8; then
        # Check that ifconfig knows the card
        /usr/sbin/ifconfig $1 1>/dev/null 2>/dev/null;
        if [ $? -ne 0 ]; then
            /usr/sbin/ifconfig $1; exit;
        fi

        # Get KernelStat info (in this case netstat)
        KERNELSTAT=`/usr/bin/netstat -k $1|/usr/bin/awk '{
            for (i=1 ; i<=NF ; i++)
            {
                statName = $i;
                i++;
                statValue = $i;
                if ($(i+1) ~ /^[0-9]+$/)
                {
                    i++;
                    statValue = statValue * 4294967296 + $i;
                }
                print statName,statValue;
            }
        }'`
    fi

    #
    # Solaris 9
    #
    if /usr/bin/test $OSVERSION -eq 9; then
        # Check that ifconfig knows the card
        /usr/sbin/ifconfig $1 1>/dev/null 2>/dev/null;
        if [ $? -ne 0 ]; then
            /usr/sbin/ifconfig $1; exit;
        fi
        # Get KernelStat Information
        KERNELSTAT=`/usr/bin/kstat -m $DRIVER -i $INSTANCE -n $1`
    fi

    #
    # Solaris 10
    #
    if /usr/bin/test $OSVERSION -eq 10; then
        # Check that ifconfig knows the card
        /usr/sbin/ifconfig $1 1>/dev/null 2>/dev/null;
        if [ $? -eq 0 ]; then
            KERNELSTAT=`/usr/bin/kstat -m $DRIVER -i $INSTANCE -n $1`
        else
            %{SUDO:/usr/sbin/dladm}/usr/sbin/dladm show-aggr -p | grep $1 1>/dev/null;
            if [ $? -eq 0 ]; then
                # Port is part of a Solaris 10 Aggregate, so print information and exit
                %{SUDO:/usr/sbin/dladm}/usr/sbin/dladm show-dev -s -p $1 ;%{SUDO:/usr/sbin/dladm}/usr/sbin/dladm show-dev -p $1;exit
            else
                echo
                /usr/sbin/ifconfig $1
                echo /usr/sbin/ifconfig and dladm failed;
                echo If port is part of an aggregate, check that patrol user has rights to execute "/usr/sbin/dladm show-dev -s -p $1" and "/usr/sbin/dladm show-dev -p $1" or enable sudo
                echo Otherwise, check that port if plumbed and listed in the output of ifconfig -a
                exit;
            fi
        fi
    fi

    #
    # Solaris 11
    #
    if /usr/bin/test $OSVERSION -eq 11; then
        KERNELSTAT=`/usr/bin/kstat link | /usr/bin/nawk -v port="$1" '{if ($1 ~ /module:/) {correctPort=0};if ($2 == port) {correctPort=1}; if (correctPort==1) {print $0}}'`
    fi


    # Print out the information provided by the kernel
    /usr/bin/echo "$KERNELSTAT"

    # Now, check whether we got the link information that we need
    REQUIRESDLADM=0
    LINKUP=`/usr/bin/echo "$KERNELSTAT"|/usr/bin/grep link_up`
    if /usr/bin/test "$LINKUP" = ""; then
        REQUIRESDLADM=1
    fi
    LINKSPEED=`/usr/bin/echo "$KERNELSTAT"|/usr/xpg4/bin/grep -e link_speed -e ifspeed`
    if /usr/bin/test "$LINKSPEED" = ""; then
        REQUIRESDLADM=1
    fi
    LINKDUPLEX=`/usr/bin/echo "$KERNELSTAT"|/usr/xpg4/bin/grep -e link_duplex -e duplex`
    if /usr/bin/test "$LINKDUPLEX" = ""; then
        REQUIRESDLADM=1
    fi


    #### dladm and maybe ndd section (link status, etc.)

    if /usr/bin/test $REQUIRESDLADM = 1; then

        # We will try ndd if dladm fails (by default, we consider dladm is going to fail, and if successful, we cancel the ndd try)
        REQUIRESNDD=1

        # Solaris 10 or earlier
        if /usr/bin/test $OSVERSION -le 10; then

            # Try dladm if dladm is available
             if /usr/bin/test -x /usr/sbin/dladm; then
                 echo Trying dladm
                 DLADMOUTPUT=`%{SUDO:/usr/sbin/dladm}/usr/sbin/dladm show-dev $1`
                 if /usr/bin/test $? = 0; then
                     REQUIRESNDD=0
                     echo "$DLADMOUTPUT" | /usr/bin/awk '{
                                                if ($2 ~ /link:/ && $3 ~ /up/) {print "link_status 1"}
                                                if ($2 ~ /link:/ && $3 ~ /down/) {print "link_status 0"}
                                                if ($4 ~ /speed:/ && $6 ~ /[Mm]bps/) {print "link_speed " $5}
                                                if ($4 ~ /speed:/ && $6 ~ /[Gg]bps/) {print "link_speed " $5*1000}
                                                if ($7 ~ /duplex:/ ) {print "duplex " $8}
                                                         }'
                fi
            fi

            # If dladm failed, we will have a last try with ndd
            if /usr/bin/test $REQUIRESNDD = 1; then

                if /usr/bin/test "$DRIVER" = "dmfe" -o "$DRIVER" = "bge" -o "$DRIVER" = "e1000g" -o "$DRIVER" = "rge"; then
                    NDDDEV=/dev/$1
                else
                    %{SUDO:/usr/sbin/ndd}/usr/sbin/ndd -set /dev/$DRIVER instance $INSTANCE 2>/dev/null
                    NDDDEV=/dev/$DRIVER
                fi

                # Check we have rights to execute ndd
                if `%{SUDO:/usr/sbin/ndd}/usr/sbin/ndd $NDDDEV ? >/dev/null 2>/dev/null`; then

                    VALUE=`%{SUDO:/usr/sbin/ndd}/usr/sbin/ndd $NDDDEV link_status 2>/dev/null`;  if /usr/bin/test $? = 0; then /usr/bin/echo "link_status $VALUE"; else $REQUIRESDLADM=1; fi
                    VALUE=`%{SUDO:/usr/sbin/ndd}/usr/sbin/ndd $NDDDEV link_speed 2>/dev/null`; if /usr/bin/test $? = 0; then /usr/bin/echo "link_speed $VALUE"; fi
                    VALUE=`%{SUDO:/usr/sbin/ndd}/usr/sbin/ndd $NDDDEV link_mode 2>/dev/null`; if /usr/bin/test $? -eq 0; then /usr/bin/echo "link_mode $VALUE"; fi
                    VALUE=`%{SUDO:/usr/sbin/ndd}/usr/sbin/ndd $NDDDEV link_duplex 2>/dev/null`; if /usr/bin/test $? -eq 0; then /usr/bin/echo "link_duplex $VALUE"; fi

                else

                    echo insufficient rights to execute ndd on $1
                fi
            fi

        fi

        # Solaris 11  (dladm only)
        if /usr/bin/test $OSVERSION -ge 11; then
        %{SUDO:/usr/sbin/dladm}/usr/sbin/dladm show-ether -p -o LINK,STATE,SPEED-DUPLEX $1 | /usr/bin/nawk 'BEGIN{FS=":"} {
                                if ($2 ~ /up/ ) {print "link_status 1"}
                                if ($2 ~ /down/ ) {print "link_status 0"}
                          if ($3 ~ /M/) {speed=$3
                                         gsub(/M.*/,"",speed)
                                         print "link_speed " speed}
                          if ($3 ~ /G/) {speed=$3
                                         gsub(/G.*/,"000",speed)
                                         print "link_speed " speed}
                          if ($3 ~ /-f/) {print "duplex full" }
                                                                             }'
        fi
    fi
  EmbeddedFile(5): |-
    if /usr/bin/test -x /usr/sbin/dladm; then
        if %{SUDO:/usr/sbin/dladm} /usr/sbin/dladm show-dev 2>/dev/null; then
            /usr/bin/echo;
            else
            if showPhys=`%{SUDO:/usr/sbin/dladm} dladm show-phys -o LINK,DEVICE -p 2>/dev/null | grep "[a-zA-Z][0-9][0-9]*:[a-zA-Z]"`; then
                for Phys in $showPhys; do
                    Phys1=`echo $Phys | cut -d: -f1`
                    Phys2=`echo $Phys | cut -d: -f2`
                    echo LinkID: $Phys1 DeviceID: $Phys2
                done
                /usr/bin/echo;
                else /usr/sbin/ifconfig -a;
            fi
        fi
        else /usr/sbin/prtconf -D;
    fi
  EmbeddedFile(4): |-
    /driver name:/ {
        instance = substr($3, 2, length($3) - 1);
        driver = substr($NF, 1, length($NF) - 1);
        if (driver != "lo" && driver != "lpfc" && driver != "jnet" && driver != "dman" && driver != "aggr" && driver != "clprivnet" && driver != "sppp")
        {
            print "MSHW;" driver instance ";" driver
        }
    }
    /link:.*speed:.*duplex:/ {
        deviceid = $1;
        driver = deviceid;
        instance = "";
        while (substr(driver, length(driver), 1) ~ /^[0-9]$/ && length(driver) > 1)
        {
            instance = substr(driver, length(driver), 1) instance;
            driver = substr(driver, 1, length(driver) - 1);
        }
        if (driver != "lo" && driver != "lpfc" && driver != "jnet" && driver != "dman" && driver != "aggr" && driver != "clprivnet" && driver != "sppp")
        {
            print "MSHW;" driver instance ";" driver
        }
    }
    /: flags=/ {
        deviceid = substr($1, 1, length($1) - 1);
        driver = deviceid;
        instance = "";
        while (substr(driver, length(driver), 1) ~ /^[0-9]$/ && length(driver) > 1)
        {
            instance = substr(driver, length(driver), 1) instance;
            driver = substr(driver, 1, length(driver) - 1);
        }
        if (driver != "lo" && driver != "lpfc" && driver != "jnet" && driver != "dman" && driver != "aggr" && driver != "clprivnet" && driver != "sppp")
        {
            print "MSHW;" driver instance ";" driver
        }
    }
    /LinkID:.*DeviceID:/ {
        deviceid = $2;
        driver = $4;
        instance = "";
        while (substr(driver, length(driver), 1) ~ /^[0-9]$/ && length(driver) > 1)
        {
            driver = substr(driver, 1, length(driver) - 1);
        }
        if (driver != "lo" && driver != "lpfc" && driver != "jnet" && driver != "dman" && driver != "aggr" && driver != "clprivnet" && driver != "sppp")
        {
            print "MSHW;" deviceid  ";" driver
        }
    }
  EmbeddedFile(6): "%{SUDO:/usr/sbin/dladm} /usr/sbin/dladm show-phys -o LINK,DEVICE -p 2>/dev/null | /usr/bin/tr ':' ';'"
translations:
  ifconfigFlagsTranslationTable:
    FAILED: failed
    INACTIVE: ok
    RUNNING: ok
    STANDBY: ok
    UP: ok
    DEPRECATED: ok
    UNPLUMBED: ok
    Default: ok
    OFFLINE: ok
