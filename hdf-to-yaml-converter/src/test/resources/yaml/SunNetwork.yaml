---
extends:
- SunEthernetDriver-header
embedded:
  EmbeddedFile(1): "BEGIN {\n\tDeviceID = \"\"\n}\n/^[a-z0-9]+: flags=/ {\n\n\tif (DeviceID != \"\")\n\t{\n\t\tprint \"MSHW;\" DeviceID \";\" macAddress \";\" ipAddress\n\t\tDeviceID = \"\"\n\t\tmacAddress = \"\"\n\t\tipAddress = \"\"\n\t}\n\n\tltIndex = index($0, \"<\")\n\tif (ltIndex != 0)\n\t{\n\t\tgtIndex = index($0, \">\")\n\t\tif (gtIndex > ltIndex)\n\t\t{\n\t\t\tflags = substr($0, ltIndex + 1, gtIndex - ltIndex - 1)\n\n\t\t\tif (index(flags, \"LOOPBACK\") == 0 && index(flags, \"OFFLINE\") == 0 && index(flags, \"UP\") > 0)\n\t\t\t{\n\t\t\t\tDeviceID = substr($1, 1, length($1) - 1)\n\t\t\t}\n\t\t}\n\t}\n}\n/^[ \\t]+inet [0-9]/ {\n\tipAddress = $2\n}\n/^[ \\t]+ether [0-9A-Za-z]/ {\n\tmacAddress = $2\n}\nEND {\n\tif (DeviceID != \"\")\n\t{\n\t\tprint \"MSHW;\" DeviceID \";\" macAddress \";\" ipAddress\n\t}\n}"
  EmbeddedFile(3): "BEGIN {\n\tdeviceID = \"\";\n\tlinkStatus = \"\";\n\tlinkDuplex = \"\";\n\tlinkSpeed = \"\";\n\treceivedPackets = \"\";\n\ttransmittedPackets = \"\";\n\tinputErrors = 0;\n\toutputErrors = 0;\n\tcollisions = 0;\n\treceivedBytes = \"\";\n\ttransmittedBytes = \"\";\n}\n($1 == \"DeviceID\") { deviceID = $2; }\n(($1 == \"link_up\" || $1 == \"link_status\") && linkStatus != \"OK\") { if ($2 == 1) { linkStatus = \"OK\"; } else { linkStatus = \"WARN\"; } }\n($1 == \"ifspeed\" || $1 == \"ifSpeed\" && linkSpeed == \"\") { linkSpeed = $2; }\n($1 == \"link_speed\") { linkSpeed = $2; }\n($1 == \"duplex\") { if ($2 == \"full\") { linkDuplex = \"full\"; } else { linkDuplex = \"half\"; } }\n($1 == \"link_mode\") { if ($2 == 1) { linkDuplex = \"full\"; } else { linkDuplex = \"half\"; } }\n($1 == \"link_duplex\") { if ($2 == 2) { linkDuplex = \"full\"; } else { linkDuplex = \"half\"; } }\n($1 == \"ipackets64\") { receivedPackets = $2; }\n($1 == \"ipackets\" && receivedPackets == \"\") { receivedPackets = $2; }\n($1 == \"opackets64\") { transmittedPackets = $2; }\n($1 == \"opackets\" && transmittedPackets == \"\") { transmittedPackets = $2; }\n($1 == \"ierrors\") { inputErrors = $2; }\n($1 == \"oerrors\") { outputErrors = $2; }\n($1 == \"collisions\") { collisions = $2; }\n($1 == \"rbytes64\") { receivedBytes = $2; }\n($1 == \"rbytes\" && receivedBytes == \"\") { receivedBytes = $2; }\n($1 == \"obytes64\") { transmittedBytes = $2; }\n($1 == \"obytes\" && transmittedBytes == \"\") { transmittedBytes = $2; }\n\n\n# Solaris 10 Aggregate Section\n#\n($1 == deviceID) && ($2 ~ /[0-9]+/) && ($3 ~ /[0-9]+/) && ($4 ~ /[0-9]+/) && ($5 ~ /[0-9]+/) && ($6 ~ /[0-9]+/) && ($7 ~ /[0-9]+/) {\n \tprint deviceID\n\treceivedPackets = $2\n\treceivedBytes = $3\n\tinputErrors = $4\n\ttransmittedPackets = $5\n\ttransmittedBytes = $6\n\toutputErrors = $7\n\t}\n($1 == deviceID) && ($2 ~ /link=/) && ($3 ~ /speed=/) && ($4 ~ /duplex=/) {\n\tif ($2 ~ /up/) {linkStatus = \"OK\"} else { linkStatus = \"WARN\"; }\n  linkSpeed = $3 ; gsub (\"speed=\",\"\",linkSpeed)\n  if ($4 ~ /full/) { linkDuplex = \"full\"; } else { linkDuplex = \"half\"; }\n}\n\nEND {\n\tif (linkSpeed == 0) \t\t\t\t{ linkSpeed = 10; }\n\telse if (linkSpeed == 1)\t\t\t{ linkSpeed = 100; }\n\telse if (linkSpeed == 10000000)\t\t{ linkSpeed = 10; }\n\telse if (linkSpeed == 100000000)\t{ linkSpeed = 100; }\n\telse if (linkSpeed == 1000000000)\t{ linkSpeed = 1000; }\n\telse if (linkSpeed == \"10000000000\")\t{ linkSpeed = 10000; }\n\n\terrors = inputErrors + outputErrors + collisions;\n\n\tprint \"MSHW;\" deviceID \";\" linkStatus \";\" linkSpeed \";\" linkDuplex \";\" receivedPackets \";\" transmittedPackets \";\" errors \";\" receivedBytes \";\" transmittedBytes \";\"\n}"
  EmbeddedFile(2): "#!/bin/sh\n\n# First of all, make sure the thing speaks english\nLANG=C\nexport LANG\n\n# Get the Solaris version, because kstat is not available in pre-Solaris 9\n# and netstat -k is not available in Solaris 10...\nOSVERSION=`/usr/bin/uname -r|/usr/bin/awk -F. '{print $2}'`\n\n# Extract the name of the driver and the instance number\nDRIVER=`/usr/bin/echo $1 | /usr/bin/sed -e \"s/[0-9]*$//\"`\nINSTANCE=`/usr/bin/echo $1 | /usr/bin/sed -e \"s/^$DRIVER//\"`\n\n# Print out the device ID\n/usr/bin/echo \"DeviceID $1\"\n\n####  KERNELSTAT Section (Statistics)\n\n#\n# Solaris 8 or earlier\n#\nif /usr/bin/test $OSVERSION -le 8; then\n\t# Check that ifconfig knows the card\n\t/usr/sbin/ifconfig $1 1>/dev/null 2>/dev/null;\n\tif [ $? -ne 0 ]; then\n\t\t/usr/sbin/ifconfig $1; exit;\n\tfi\n\n\t# Get KernelStat info (in this case netstat)\n\tKERNELSTAT=`/usr/bin/netstat -k $1|/usr/bin/awk '{\n\t\tfor (i=1 ; i<=NF ; i++)\n\t\t{\n\t\t\tstatName = $i;\n\t\t\ti++;\n\t\t\tstatValue = $i;\n\t\t\tif ($(i+1) ~ /^[0-9]+$/)\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t\tstatValue = statValue * 4294967296 + $i;\n\t\t\t}\n\t\t\tprint statName,statValue;\n\t\t}\n\t}'`\nfi\n\n#\n# Solaris 9\n#\nif /usr/bin/test $OSVERSION -eq 9; then\n\t# Check that ifconfig knows the card\n\t/usr/sbin/ifconfig $1 1>/dev/null 2>/dev/null;\n\tif [ $? -ne 0 ]; then\n\t\t/usr/sbin/ifconfig $1; exit;\n\tfi\n\t# Get KernelStat Information\n\tKERNELSTAT=`/usr/bin/kstat -m $DRIVER -i $INSTANCE -n $1`\nfi\n\n#\n# Solaris 10\n#\nif /usr/bin/test $OSVERSION -eq 10; then\n\t# Check that ifconfig knows the card\n\t/usr/sbin/ifconfig $1 1>/dev/null 2>/dev/null;\n\tif [ $? -eq 0 ]; then\n\t\tKERNELSTAT=`/usr/bin/kstat -m $DRIVER -i $INSTANCE -n $1`\n\telse\n\t\t%{SUDO:/usr/sbin/dladm}/usr/sbin/dladm show-aggr -p | grep $1 1>/dev/null;\n\t\tif [ $? -eq 0 ]; then\n\t\t\t# Port is part of a Solaris 10 Aggregate, so print information and exit\n\t\t\t%{SUDO:/usr/sbin/dladm}/usr/sbin/dladm show-dev -s -p $1 ;%{SUDO:/usr/sbin/dladm}/usr/sbin/dladm show-dev -p $1;exit\n\t\telse\n\t\t\techo\n\t\t\t/usr/sbin/ifconfig $1\n\t\t\techo /usr/sbin/ifconfig and dladm failed;\n\t\t\techo If port is part of an aggregate, check that patrol user has rights to execute \"/usr/sbin/dladm show-dev -s -p $1\" and \"/usr/sbin/dladm show-dev -p $1\" or enable sudo\n\t\t\techo Otherwise, check that port if plumbed and listed in the output of ifconfig -a\n\t\t\texit;\n\t\tfi\n\tfi\nfi\n\n#\n# Solaris 11\n#\nif /usr/bin/test $OSVERSION -eq 11; then\n\tKERNELSTAT=`/usr/bin/kstat link | /usr/bin/nawk -v port=\"$1\" '{if ($1 ~ /module:/) {correctPort=0};if ($2 == port) {correctPort=1}; if (correctPort==1) {print $0}}'`\nfi\n\n\n# Print out the information provided by the kernel\n/usr/bin/echo \"$KERNELSTAT\"\n\n# Now, check whether we got the link information that we need\nREQUIRESDLADM=0\nLINKUP=`/usr/bin/echo \"$KERNELSTAT\"|/usr/bin/grep link_up`\nif /usr/bin/test \"$LINKUP\" = \"\"; then\n\tREQUIRESDLADM=1\nfi\nLINKSPEED=`/usr/bin/echo \"$KERNELSTAT\"|/usr/xpg4/bin/grep -e link_speed -e ifspeed`\nif /usr/bin/test \"$LINKSPEED\" = \"\"; then\n\tREQUIRESDLADM=1\nfi\nLINKDUPLEX=`/usr/bin/echo \"$KERNELSTAT\"|/usr/xpg4/bin/grep -e link_duplex -e duplex`\nif /usr/bin/test \"$LINKDUPLEX\" = \"\"; then\n\tREQUIRESDLADM=1\nfi\n\n\n#### dladm and maybe ndd section (link status, etc.)\n\nif /usr/bin/test $REQUIRESDLADM = 1; then\n\n\t# We will try ndd if dladm fails (by default, we consider dladm is going to fail, and if successful, we cancel the ndd try)\n\tREQUIRESNDD=1\n\n\t# Solaris 10 or earlier\n\tif /usr/bin/test $OSVERSION -le 10; then\n\n\t\t# Try dladm if dladm is available\n \t\tif /usr/bin/test -x /usr/sbin/dladm; then\n \t\t\techo Trying dladm\n \t\t\tDLADMOUTPUT=`%{SUDO:/usr/sbin/dladm}/usr/sbin/dladm show-dev $1`\n \t\t\tif /usr/bin/test $? = 0; then\n \t\t\t\tREQUIRESNDD=0\n \t\t\t\techo \"$DLADMOUTPUT\" | /usr/bin/awk '{\n\t\t\t\t\t\t\t\t\t\t\tif ($2 ~ /link:/ && $3 ~ /up/) {print \"link_status 1\"}\n\t\t\t\t\t\t\t\t\t\t\tif ($2 ~ /link:/ && $3 ~ /down/) {print \"link_status 0\"}\n\t\t\t\t\t\t\t\t\t\t\tif ($4 ~ /speed:/ && $6 ~ /[Mm]bps/) {print \"link_speed \" $5}\n\t\t\t\t\t\t\t\t\t\t\tif ($4 ~ /speed:/ && $6 ~ /[Gg]bps/) {print \"link_speed \" $5*1000}\n\t\t\t\t\t\t\t\t\t\t\tif ($7 ~ /duplex:/ ) {print \"duplex \" $8}\n\t                                                 }'\n\t\t\tfi\n\t\tfi\n\n\t\t# If dladm failed, we will have a last try with ndd\n\t\tif /usr/bin/test $REQUIRESNDD = 1; then\n\n\t\t\tif /usr/bin/test \"$DRIVER\" = \"dmfe\" -o \"$DRIVER\" = \"bge\" -o \"$DRIVER\" = \"e1000g\" -o \"$DRIVER\" = \"rge\"; then\n\t\t\t\tNDDDEV=/dev/$1\n\t\t\telse\n\t\t\t\t%{SUDO:/usr/sbin/ndd}/usr/sbin/ndd -set /dev/$DRIVER instance $INSTANCE 2>/dev/null\n\t\t\t\tNDDDEV=/dev/$DRIVER\n\t\t\tfi\n\n\t\t\t# Check we have rights to execute ndd\n\t\t\tif `%{SUDO:/usr/sbin/ndd}/usr/sbin/ndd $NDDDEV ? >/dev/null 2>/dev/null`; then\n\n\t\t\t\tVALUE=`%{SUDO:/usr/sbin/ndd}/usr/sbin/ndd $NDDDEV link_status 2>/dev/null`;  if /usr/bin/test $? = 0; then /usr/bin/echo \"link_status $VALUE\"; else $REQUIRESDLADM=1; fi\n\t\t\t\tVALUE=`%{SUDO:/usr/sbin/ndd}/usr/sbin/ndd $NDDDEV link_speed 2>/dev/null`; if /usr/bin/test $? = 0; then /usr/bin/echo \"link_speed $VALUE\"; fi\n\t\t\t\tVALUE=`%{SUDO:/usr/sbin/ndd}/usr/sbin/ndd $NDDDEV link_mode 2>/dev/null`; if /usr/bin/test $? -eq 0; then /usr/bin/echo \"link_mode $VALUE\"; fi\n\t\t\t\tVALUE=`%{SUDO:/usr/sbin/ndd}/usr/sbin/ndd $NDDDEV link_duplex 2>/dev/null`; if /usr/bin/test $? -eq 0; then /usr/bin/echo \"link_duplex $VALUE\"; fi\n\n\t\t\telse\n\n\t\t\t\techo insufficient rights to execute ndd on $1\n\t\t\tfi\n\t\tfi\n\n\tfi\n\n\t# Solaris 11  (dladm only)\n\tif /usr/bin/test $OSVERSION -ge 11; then\n\t%{SUDO:/usr/sbin/dladm}/usr/sbin/dladm show-ether -p -o LINK,STATE,SPEED-DUPLEX $1 | /usr/bin/nawk 'BEGIN{FS=\":\"} {\n\t\t\t                if ($2 ~ /up/ ) {print \"link_status 1\"}\n\t\t\t                if ($2 ~ /down/ ) {print \"link_status 0\"}\n                      if ($3 ~ /M/) {speed=$3\n                                     gsub(/M.*/,\"\",speed)\n                                     print \"link_speed \" speed}\n                      if ($3 ~ /G/) {speed=$3\n                                     gsub(/G.*/,\"000\",speed)\n                                     print \"link_speed \" speed}\n                      if ($3 ~ /-f/) {print \"duplex full\" }\n\t                                                                     }'\n\tfi\nfi"
  EmbeddedFile(5): |-
    if /usr/bin/test -x /usr/sbin/dladm; then
        if %{SUDO:/usr/sbin/dladm} /usr/sbin/dladm show-dev 2>/dev/null; then
            /usr/bin/echo;
            else
            if showPhys=`%{SUDO:/usr/sbin/dladm} dladm show-phys -o LINK,DEVICE -p 2>/dev/null | grep "[a-zA-Z][0-9][0-9]*:[a-zA-Z]"`; then
                for Phys in $showPhys; do
                    Phys1=`echo $Phys | cut -d: -f1`
                    Phys2=`echo $Phys | cut -d: -f2`
                    echo LinkID: $Phys1 DeviceID: $Phys2
                done
                /usr/bin/echo;
                else /usr/sbin/ifconfig -a;
            fi
        fi
        else /usr/sbin/prtconf -D;
    fi
  EmbeddedFile(4): "/driver name:/ {\n\tinstance = substr($3, 2, length($3) - 1);\n\tdriver = substr($NF, 1, length($NF) - 1);\n\tif (driver != \"lo\" && driver != \"lpfc\" && driver != \"jnet\" && driver != \"dman\" && driver != \"aggr\" && driver != \"clprivnet\" && driver != \"sppp\")\n\t{\n\t\tprint \"MSHW;\" driver instance \";\" driver\n\t}\n}\n/link:.*speed:.*duplex:/ {\n\tdeviceid = $1;\n\tdriver = deviceid;\n\tinstance = \"\";\n\twhile (substr(driver, length(driver), 1) ~ /^[0-9]$/ && length(driver) > 1)\n\t{\n\t\tinstance = substr(driver, length(driver), 1) instance;\n\t\tdriver = substr(driver, 1, length(driver) - 1);\n\t}\n\tif (driver != \"lo\" && driver != \"lpfc\" && driver != \"jnet\" && driver != \"dman\" && driver != \"aggr\" && driver != \"clprivnet\" && driver != \"sppp\")\n\t{\n\t\tprint \"MSHW;\" driver instance \";\" driver\n\t}\n}\n/: flags=/ {\n\tdeviceid = substr($1, 1, length($1) - 1);\n\tdriver = deviceid;\n\tinstance = \"\";\n\twhile (substr(driver, length(driver), 1) ~ /^[0-9]$/ && length(driver) > 1)\n\t{\n\t\tinstance = substr(driver, length(driver), 1) instance;\n\t\tdriver = substr(driver, 1, length(driver) - 1);\n\t}\n\tif (driver != \"lo\" && driver != \"lpfc\" && driver != \"jnet\" && driver != \"dman\" && driver != \"aggr\" && driver != \"clprivnet\" && driver != \"sppp\")\n\t{\n\t\tprint \"MSHW;\" driver instance \";\" driver\n\t}\n}\n/LinkID:.*DeviceID:/ {\n\tdeviceid = $2;\n\tdriver = $4;\n\tinstance = \"\";\n\twhile (substr(driver, length(driver), 1) ~ /^[0-9]$/ && length(driver) > 1)\n\t{\n\t\tdriver = substr(driver, 1, length(driver) - 1);\n\t}\n\tif (driver != \"lo\" && driver != \"lpfc\" && driver != \"jnet\" && driver != \"dman\" && driver != \"aggr\" && driver != \"clprivnet\" && driver != \"sppp\")\n\t{\n\t\tprint \"MSHW;\" deviceid  \";\" driver\n\t}\n}"
  EmbeddedFile(6): "%{SUDO:/usr/sbin/dladm} /usr/sbin/dladm show-phys -o LINK,DEVICE -p 2>/dev/null | /usr/bin/tr ':' ';'"
translations:
  ifconfigFlagsTranslationTable:
    running: ok
    offline: ok
    default: ok
    inactive: ok
    standby: ok
    unplumbed: ok
    deprecated: ok
    failed: failed
    up: ok
connector:
  displayName: Oracle/Sun Solaris - Network
  platforms: Oracle/Sun
  reliesOn: "Sun Solaris system commands (kstat, ndd, ifconfig, dladm, etc.)"
  version: 1.3
  information: This connector provides the monitoring of network cards on all Sun Solaris systems.
  detection:
    connectionTypes:
    - remote
    appliesTo:
    - Solaris
    criteria:
    - type: deviceType
      keep:
      - SunOS
      - Solaris
    - type: osCommand
      commandLine: /usr/sbin/ifconfig -a
      expectedResult: flags=
sudoCommands:
- /usr/sbin/ndd
- /usr/sbin/dladm
monitors:
  network:
    discovery:
      sources:
        source(1):
          _comment: Source(1) = output of ifconfig -a
          type: osCommand
          commandLine: /usr/sbin/ifconfig -a
          computes:
            # Process the output of ifconfig through an AWK script
            # LogicalDeviceID;MacAddress;IPAddress;
          - type: awk
            script: EmbeddedFile(1)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5"
        source(2):
          # Source(2) = output of prtconf -D or dladm show-dev
          # with only the network instances
          type: osCommand
          commandLine: /bin/sh %EmbeddedFile(5)%
          keep: "\\(network, instance #[0-9]\\)\\|\\(link:.*speed:.*duplex:\\)\\|\\(: flags=\\)\\|\\(SUNW,qfe\\)\\|\\(FJSV,pgtb\\)\\|\\(LinkID:.*DeviceID:\\)"
          computes:
            # Process the output of prtconf through an AWK script to keep only the NIC ID
            # DeviceID;Driver;
          - type: awk
            script: EmbeddedFile(4)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3"
        source(3):
          # Source(3) = output of dladm show-phys
          # This command will only work on Solaris 11.  A blank table is expected on other versions.
          # LogicalDeviceID;PhysicalID
          type: osCommand
          commandLine: /bin/sh %EmbeddedFile(6)%
          keep: "[A-Za-z].*[0-9];[A-Za-z].*[0-9]"
          computes:
            # Add a "" to column2 to force the PSL/Java close out column 2
            # LogicalDeviceID;PhysicalID;
          - type: rightConcat
            column: 2
            value: ""
        source(4):
          # Source(4) = Table joint of Source(2) and Source(3)
          # Solaris 11 machines, the DeviceID from Table 2 will match the PhysicalID
          # For other versions, it will not match, so we put a marker in
          # DeviceID;Driver;LogicalDeviceID;PhysicalID;
          type: tableJoin
          leftTable: $monitors.network.discovery.sources.source(2)$
          rightTable: $monitors.network.discovery.sources.source(3)$
          leftKeyColumn: 1
          rightKeyColumn: 2
          defaultRightLine: NotSolaris11;;
          computes:
            # For non-Solaris 11 machines, we will copy the deviceID into the PhysicalID column (where we put the marker NotSolaris11)
            # DeviceID;Driver;LogicalDeviceID;PhysicalID;
          - type: replace
            column: 3
            existingValue: NotSolaris11
            newValue: Column(1)
        source(5):
          # Source(3) = Table joint of Source(2) and Source(1)
          # DeviceID;Driver;LogicalDeviceID;PhysicalID;LogicalDeviceID;MacAddress;IPAddress;
          type: tableJoin
          leftTable: $monitors.network.discovery.sources.source(4)$
          rightTable: $monitors.network.discovery.sources.source(1)$
          leftKeyColumn: 3
          rightKeyColumn: 1
          defaultRightLine: ;;;
          computes:
            # Translate the Driver column into a model name
            #  DeviceID;Model;LogicalDeviceID;PhysicalID;LogicalDeviceID;MacAddress;IPAddress;
          - type: translate
            column: 2
            translationTable: DriverTranslationTable
      mapping:
        # InstanceTable = Source(3)
        # DeviceID;Model;LogicalDeviceID;PhysicalID;LogicalDeviceID;MacAddress;IPAddress;
        source: $monitors.network.discovery.sources.source(5)$
        attributes:
          id: $column(3)
          __display_id: $column(3)
          model: $column(2)
          physical_address: $column(6)
          physical_address_type: MAC
          logical_address: $column(7)
          logical_address_type: IP
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s)\", $column(3), $column(2))"
    collect:
      # Collect type is: mono-collect
      type: monoInstance
      sources:
        source(1):
          # Source(1) = output of the embedded script 2 (ifconfig output)
          # DeviceID;ifconfigFlags
          type: osCommand
          commandLine: "if /usr/sbin/ifconfig %NetworkCard.Collect.DeviceID%; then /usr/bin/echo; else /usr/bin/echo \"%NetworkCard.Collect.DeviceID%: flags=00000000:UNPLUMBED\"; fi"
          keep: "^%NetworkCard.Collect.DeviceID%: flags="
          separators: :<>
          selectColumns: "1,3"
          computes:
            # Duplicate the ifconfigFlags
            # DeviceID;ifconfigFlags;ifconfigFlags;
          - type: duplicateColumn
            column: 2
            # Translate the first ifconfig flags
            # DeviceID;StatusArray;ifconfigFlags;
          - type: arrayTranslate
            column: 2
            translationTable: ifconfigFlagsTranslationTable
            arraySeparator: ","
            resultSeparator: '|'
            # Convert StatusArray into Status
            # DeviceID;Status;StatusInformation;
          - type: convert
            column: 2
            conversion: array2SimpleStatus
        source(2):
          _comment: Source(2) = output of embedded script 4 (complicated shell script)
          type: osCommand
          commandLine: /bin/sh %EmbeddedFile(2)% %NetworkCard.Collect.DeviceID%
          computes:
            # Process the output of this script through a smart AWK script
            # DeviceID;LinkStatus;LinkSpeed;DuplexMode;ReceivedPacket;TransmittedPackets;Errors;ReceivedBytes;TransmittedBytes;
          - type: awk
            script: EmbeddedFile(3)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5,6,7,8,9,10"
        source(3):
          # Source(3) = table joint of Source(1) and Source(2)
          # DeviceID;Status;StatusInformation;DeviceID;LinkStatus;LinkSpeed;DuplexMode;ReceivedPacket;TransmittedPackets;Errors;ReceivedBytes;TransmittedBytes;
          type: tableJoin
          leftTable: $monitors.network.collect.sources.source(1)$
          rightTable: $monitors.network.collect.sources.source(2)$
          leftKeyColumn: 1
          rightKeyColumn: 1
          defaultRightLine: ;;;;;;;;;
      mapping:
        _comment: And here is the ValueTable
        source: $monitors.network.collect.sources.source(3)$
        metrics:
          hw.status{hw.type="network"}: $column(2)
          hw.network.up: legacyLinkStatus($column(5))
          hw.network.bandwidth.limit: megaBit2Bit($column(6))
          hw.network.full_duplex: legacyFullDuplex($column(7))
          hw.network.packets{direction="receive"}: $column(8)
          hw.network.packets{direction="transmit"}: $column(9)
          hw.errors{hw.type="network"}: $column(10)
          hw.network.io{direction="receive"}: $column(11)
          hw.network.io{direction="transmit"}: $column(12)
        legacyTextParameters:
          StatusInformation: $column(3)
