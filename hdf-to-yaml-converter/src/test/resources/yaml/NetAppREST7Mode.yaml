---
embedded:
  EmbeddedFile(1): |-
    BEGIN{
      # Set the name for each object level
        InstanceLevel = "system-info"
        ParentLevel = ""
        GrandParentLevel = ""

      # Set the Properties to Extract
      # The number indicates which column that property will be put in
      # If you specify property[1] and property[3], you will end up with:
      # MSHW;propertyvalue1;;propertyvalue3;
        property[1] = "system-id"
        property[2] = "system-name"
        property[3] = "system-model"
        property[4] = "vendor-id"
        property[5] = "system-serial-number"

      # The rest of this script is standardized
      # and does not need to be edited
      #
      #
      # System Constants
      Level = "Unknown"
      FS="[<>]"
      skip = "0"
      InstanceEnum = "0"
      ParentEnum = "0"
      GrandParentEnum = "0"
      InstanceLevelEnd = "/" InstanceLevel
      ParentLevelEnd = "/" ParentLevel
      GrandParentLevelEnd = "/" GrandParentLevel
      }
    (NF == 3 ) && ($2 == GrandParentLevel) {
      GrandParentEnum = GrandParentEnum + 1
      Level = "GrandParent"
      }
    (NF == 3 ) && ($2 == GrandParentLevelEnd) {
      Level = "Unknown"
      skip = "0"
      }
    (NF == 3) && ($2 == ParentLevel) {
      ParentEnum = ParentEnum + 1
      Level = "Parent"
      skip = "0"
      }
    (NF == 3) && ($2 == ParentLevelEnd) {
      Level = "GrandParent"
      }
    (NF == 3) && ($2 == InstanceLevel) {
      InstanceEnum = InstanceEnum + 1
      InstanceParentID[InstanceEnum] = ParentEnum
      InstanceGrandParentID[InstanceEnum] = GrandParentEnum
      Level = "Instance"
      skip = "0"
      }
    (NF == 3) && ($2 == InstanceLevelEnd) {
      Level = "Parent"
      }

    # Skip unknown subsections
    NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
      skip = "1"
      skipTo = "/" $2
      }
    skip == "1" {
      if ( $2 == skipTo ) { skip = "0"}
        else { next }
      }

    # Values
    # When we get a property, we search through the "property" array to see if it matches something we are looking for
    # We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
    NF == 5 {
      currentProperty = $2
      value = $3
      propertyID = InstanceEnum
      if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
      if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
      for ( pID in property) {
        if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
        }
      }

    END {
      # figure out highest property value
      highestProperty = "0"
      for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
      for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
        printf("%s","MSHW;")
        for ( pID = 1 ; pID <= highestProperty ; pID++) {
          if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
          else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
          else { printID = instanceID ; Level = "Instance" }
          printf("%s",outputArray[Level,printID,pID] ";" )
          }
        print " "
        }
      }
  EmbeddedFile(11): |-
    {
        # the line contains multiple objects
        if ($0 ~ />.*>.*>.*>/) {
        line = $0
        xmlArraySize = split(line,xmlArray,">")
        for ( objectNumber = 1; objectNumber <= xmlArraySize ; objectNumber++ ) {
          name = xmlArray[objectNumber]
          gsub(/.*</,"",name)
          nextobjectNumber = objectNumber + 1
          nextname = xmlArray[nextobjectNumber]
          gsub(/.*</,"",nextname)
          # if the object is blank, or its the second part of an array ( data</objectname ), then skip
          if ( name != "" || xmlArray[objectNumber] ~ /^</ ) {
            # if the next object contains the same object name (basically it's the </object>) , then print both objects
            if ( nextname ~ name && xmlArray[objectNumber] ) {
              print xmlArray[objectNumber] ">" xmlArray[nextobjectNumber] ">" }
            # else just print the current object
            else { print xmlArray[objectNumber] ">" }
            }
          }
        }
      # else if it's in the header, just print the line
      else { print $0 }
    }
  EmbeddedFile(3): |-
    BEGIN{
      # Set the name for each object level
        InstanceLevel = "power-supply-info"
        ParentLevel = "power-supply-list"
        GrandParentLevel = "shelf-environ-shelf-info"

      # Set the Properties to Extract
      # The number indicates which column that property will be put in
      # If you specify property[1] and property[3], you will end up with:
      # MSHW;propertyvalue1;;propertyvalue3;

      property[1] = "power-supply-element-number"
      property[2] = "../../shelf-id"
      property[3] = "power-supply-serial-no"
      property[4] = "power-supply-is-error"
      property[5] = "power-supply-is-not-installed"


      # The rest of this script is standardized
      # and does not need to be edited
      #
      #
      # System Constants
      Level = "Unknown"
      FS="[<>]"
      skip = "0"
      InstanceEnum = "0"
      ParentEnum = "0"
      GrandParentEnum = "0"
      InstanceLevelEnd = "/" InstanceLevel
      ParentLevelEnd = "/" ParentLevel
      GrandParentLevelEnd = "/" GrandParentLevel
      }
    (NF == 3 ) && ($2 == GrandParentLevel) {
      GrandParentEnum = GrandParentEnum + 1
      Level = "GrandParent"
      }
    (NF == 3 ) && ($2 == GrandParentLevelEnd) {
      Level = "Unknown"
      skip = "0"
      }
    (NF == 3) && ($2 == ParentLevel) {
      ParentEnum = ParentEnum + 1
      Level = "Parent"
      skip = "0"
      }
    (NF == 3) && ($2 == ParentLevelEnd) {
      Level = "GrandParent"
      }
    (NF == 3) && ($2 == InstanceLevel) {
      InstanceEnum = InstanceEnum + 1
      InstanceParentID[InstanceEnum] = ParentEnum
      InstanceGrandParentID[InstanceEnum] = GrandParentEnum
      Level = "Instance"
      skip = "0"
      }
    (NF == 3) && ($2 == InstanceLevelEnd) {
      Level = "Parent"
      }

    # Skip unknown subsections
    NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
      skip = "1"
      skipTo = "/" $2
      }
    skip == "1" {
      if ( $2 == skipTo ) { skip = "0"}
        else { next }
      }

    # Values
    # When we get a property, we search through the "property" array to see if it matches something we are looking for
    # We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
    NF == 5 {
      currentProperty = $2
      value = $3
      propertyID = InstanceEnum
      if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
      if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
      for ( pID in property) {
        if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
        }
      }

    END {
      # figure out highest property value
      highestProperty = "0"
      for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
      for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
        printf("%s","MSHW;")
        for ( pID = 1 ; pID <= highestProperty ; pID++) {
          if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
          else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
          else { printID = instanceID ; Level = "Instance" }
          printf("%s",outputArray[Level,printID,pID] ";" )
          }
        print " "
        }
      }
  EmbeddedFile(2): |-
    BEGIN{
    # Set the name for each object level

          InstanceLevel = "ses-generic-info"
            ParentLevel = "shelf-environ-shelf-info"
            GrandParentLevel = ""

    # Set the Properties to Extract
    # The number indicates which column that property will be put in
    # If you specify property[1] and property[3], you will end up with:
    # MSHW;propertyvalue1;;propertyvalue3;

        #storage-shelf-info
        property[1] = "../shelf-id"
        property[2] = "ses-product-id"
        property[3] = "ses-product-id"
        property[4] = "ses-vendor-id"
      property[6] = "../shelf-status"

    # The rest of this script is standardized
    # and does not need to be edited
    #
    #
    # System Constants
      Level = "Unknown"
      FS="[<>]"
      skip = "0"
      InstanceEnum = "0"
      ParentEnum = "0"
      GrandParentEnum = "0"
      InstanceLevelEnd = "/" InstanceLevel
      ParentLevelEnd = "/" ParentLevel
      GrandParentLevelEnd = "/" GrandParentLevel
      }
    (NF == 3 ) && ($2 == GrandParentLevel) {
      GrandParentEnum = GrandParentEnum + 1
      Level = "GrandParent"
      }
    (NF == 3 ) && ($2 == GrandParentLevelEnd) {
      Level = "Unknown"
      skip = "0"
      }
    (NF == 3) && ($2 == ParentLevel) {
      ParentEnum = ParentEnum + 1
      Level = "Parent"
      skip = "0"
      }
    (NF == 3) && ($2 == ParentLevelEnd) {
      Level = "GrandParent"
      }
    (NF == 3) && ($2 == InstanceLevel) {
      InstanceEnum = InstanceEnum + 1
      InstanceParentID[InstanceEnum] = ParentEnum
      InstanceGrandParentID[InstanceEnum] = GrandParentEnum
      Level = "Instance"
      skip = "0"
      }
    (NF == 3) && ($2 == InstanceLevelEnd) {
      Level = "Parent"
      }

    # Skip unknown subsections
    NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
      skip = "1"
      skipTo = "/" $2
      }
    skip == "1" {
      if ( $2 == skipTo ) { skip = "0"}
        else { next }
      }

    # Values
    # When we get a property, we search through the "property" array to see if it matches something we are looking for
    # We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
    NF == 5 {
      currentProperty = $2
      value = $3
      propertyID = InstanceEnum
      if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
      if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
      for ( pID in property) {
        if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
        }
      }

    END {
      # figure out highest property value
      highestProperty = "0"
      for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
      for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
        printf("%s","MSHW;")
        for ( pID = 1 ; pID <= highestProperty ; pID++) {
          if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
          else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
          else { printID = instanceID ; Level = "Instance" }
          printf("%s",outputArray[Level,printID,pID] ";" )
          }
        print " "
        }
      }
  EmbeddedFile(5): |-
    BEGIN{
      # Set the name for each object level
        InstanceLevel = "temp-sensor-info"
        ParentLevel = "temp-sensor-list"
        GrandParentLevel = "shelf-environ-shelf-info"

      # Set the Properties to Extract
      # The number indicates which column that property will be put in
      # If you specify property[1] and property[3], you will end up with:
      # MSHW;propertyvalue1;;propertyvalue3;
        property[1] = "temp-sensor-element-no"
        property[2] = "../../shelf-id"
      property[3] = "temp-sensor-is-error"
      property[4] = "temp-sensor-current-condition"

      # The rest of this script is standardized
      # and does not need to be edited
      #
      #
      # System Constants
      Level = "Unknown"
      FS="[<>]"
      skip = "0"
      InstanceEnum = "0"
      ParentEnum = "0"
      GrandParentEnum = "0"
      InstanceLevelEnd = "/" InstanceLevel
      ParentLevelEnd = "/" ParentLevel
      GrandParentLevelEnd = "/" GrandParentLevel
      }
    (NF == 3 ) && ($2 == GrandParentLevel) {
      GrandParentEnum = GrandParentEnum + 1
      Level = "GrandParent"
      }
    (NF == 3 ) && ($2 == GrandParentLevelEnd) {
      Level = "Unknown"
      skip = "0"
      }
    (NF == 3) && ($2 == ParentLevel) {
      ParentEnum = ParentEnum + 1
      Level = "Parent"
      skip = "0"
      }
    (NF == 3) && ($2 == ParentLevelEnd) {
      Level = "GrandParent"
      }
    (NF == 3) && ($2 == InstanceLevel) {
      InstanceEnum = InstanceEnum + 1
      InstanceParentID[InstanceEnum] = ParentEnum
      InstanceGrandParentID[InstanceEnum] = GrandParentEnum
      Level = "Instance"
      skip = "0"
      }
    (NF == 3) && ($2 == InstanceLevelEnd) {
      Level = "Parent"
      }

    # Skip unknown subsections
    NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
      skip = "1"
      skipTo = "/" $2
      }
    skip == "1" {
      if ( $2 == skipTo ) { skip = "0"}
        else { next }
      }

    # Values
    # When we get a property, we search through the "property" array to see if it matches something we are looking for
    # We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
    NF == 5 {
      currentProperty = $2
      value = $3
      propertyID = InstanceEnum
      if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
      if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
      for ( pID in property) {
        if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
        }
      }

    END {
      # figure out highest property value
      highestProperty = "0"
      for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
      for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
        printf("%s","MSHW;")
        for ( pID = 1 ; pID <= highestProperty ; pID++) {
          if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
          else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
          else { printID = instanceID ; Level = "Instance" }
          printf("%s",outputArray[Level,printID,pID] ";" )
          }
        print " "
        }
      }
  EmbeddedFile(4): |-
    BEGIN{
      # Set the name for each object level
      InstanceLevel = "cooling-element-info"
        ParentLevel = "cooling-element-list"
        GrandParentLevel = "shelf-environ-shelf-info"

      # Set the Properties to Extract
      # The number indicates which column that property will be put in
      # If you specify property[1] and property[3], you will end up with:
      # MSHW;propertyvalue1;;propertyvalue3;
        property[1] = "cooling-element-number"
      property[2] = "../../shelf-id"
        property[3] = "cooling-element-is-error"
        property[4] = "cooling-element-is-not-installed"

      # The rest of this script is standardized
      # and does not need to be edited
      #
      #
      # System Constants
      Level = "Unknown"
      FS="[<>]"
      skip = "0"
      InstanceEnum = "0"
      ParentEnum = "0"
      GrandParentEnum = "0"
      InstanceLevelEnd = "/" InstanceLevel
      ParentLevelEnd = "/" ParentLevel
      GrandParentLevelEnd = "/" GrandParentLevel
      }
    (NF == 3 ) && ($2 == GrandParentLevel) {
      GrandParentEnum = GrandParentEnum + 1
      Level = "GrandParent"
      }
    (NF == 3 ) && ($2 == GrandParentLevelEnd) {
      Level = "Unknown"
      skip = "0"
      }
    (NF == 3) && ($2 == ParentLevel) {
      ParentEnum = ParentEnum + 1
      Level = "Parent"
      skip = "0"
      }
    (NF == 3) && ($2 == ParentLevelEnd) {
      Level = "GrandParent"
      }
    (NF == 3) && ($2 == InstanceLevel) {
      InstanceEnum = InstanceEnum + 1
      InstanceParentID[InstanceEnum] = ParentEnum
      InstanceGrandParentID[InstanceEnum] = GrandParentEnum
      Level = "Instance"
      skip = "0"
      }
    (NF == 3) && ($2 == InstanceLevelEnd) {
      Level = "Parent"
      }

    # Skip unknown subsections
    NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
      skip = "1"
      skipTo = "/" $2
      }
    skip == "1" {
      if ( $2 == skipTo ) { skip = "0"}
        else { next }
      }

    # Values
    # When we get a property, we search through the "property" array to see if it matches something we are looking for
    # We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
    NF == 5 {
      currentProperty = $2
      value = $3
      propertyID = InstanceEnum
      if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
      if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
      for ( pID in property) {
        if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
        }
      }

    END {
      # figure out highest property value
      highestProperty = "0"
      for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
      for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
        printf("%s","MSHW;")
        for ( pID = 1 ; pID <= highestProperty ; pID++) {
          if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
          else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
          else { printID = instanceID ; Level = "Instance" }
          printf("%s",outputArray[Level,printID,pID] ";" )
          }
        print " "
        }
      }
  EmbeddedFile(7): |-
    BEGIN{
        # Set the name for each object level
      InstanceLevel = "interface-config-info"
        ParentLevel = ""
        GrandParentLevel = ""

      # Set the Properties to Extract
      # The number indicates which column that property will be put in
      # If you specify property[1] and property[3], you will end up with:
      # MSHW;propertyvalue1;;propertyvalue3;
        property[1] = "interface-name"
        property[2] = "mac-address"
        property[3] = "mediatype"

      # The rest of this script is standardized
      # and does not need to be edited
      #
      #
      # System Constants
      Level = "Unknown"
      FS="[<>]"
      skip = "0"
      InstanceEnum = "0"
      ParentEnum = "0"
      GrandParentEnum = "0"
      InstanceLevelEnd = "/" InstanceLevel
      ParentLevelEnd = "/" ParentLevel
      GrandParentLevelEnd = "/" GrandParentLevel
      }
    (NF == 3 ) && ($2 == GrandParentLevel) {
      GrandParentEnum = GrandParentEnum + 1
      Level = "GrandParent"
      }
    (NF == 3 ) && ($2 == GrandParentLevelEnd) {
      Level = "Unknown"
      skip = "0"
      }
    (NF == 3) && ($2 == ParentLevel) {
      ParentEnum = ParentEnum + 1
      Level = "Parent"
      skip = "0"
      }
    (NF == 3) && ($2 == ParentLevelEnd) {
      Level = "GrandParent"
      }
    (NF == 3) && ($2 == InstanceLevel) {
      InstanceEnum = InstanceEnum + 1
      InstanceParentID[InstanceEnum] = ParentEnum
      InstanceGrandParentID[InstanceEnum] = GrandParentEnum
      Level = "Instance"
      skip = "0"
      }
    (NF == 3) && ($2 == InstanceLevelEnd) {
      Level = "Parent"
      }

    # Skip unknown subsections
    NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
      skip = "1"
      skipTo = "/" $2
      }
    skip == "1" {
      if ( $2 == skipTo ) { skip = "0"}
        else { next }
      }

    # Values
    # When we get a property, we search through the "property" array to see if it matches something we are looking for
    # We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
    NF == 5 {
      currentProperty = $2
      value = $3
      propertyID = InstanceEnum
      if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
      if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
      for ( pID in property) {
        if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
        }
      }

    END {
      # figure out highest property value
      highestProperty = "0"
      for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
      for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
        printf("%s","MSHW;")
        for ( pID = 1 ; pID <= highestProperty ; pID++) {
          if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
          else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
          else { printID = instanceID ; Level = "Instance" }
          printf("%s",outputArray[Level,printID,pID] ";" )
          }
        print " "
        }
      }
  EmbeddedFile(6): |-
    BEGIN{
        # Set the name for each object level
      InstanceLevel = "disk-detail-info"
        ParentLevel = ""
        GrandParentLevel = ""

      # Set the Properties to Extract
      # The number indicates which column that property will be put in
      # If you specify property[1] and property[3], you will end up with:
      # MSHW;propertyvalue1;;propertyvalue3;
        property[1] = "shelf"
        property[2] = "name"
        property[3] = "disk-model"
      property[4] = "vendor-id"
        property[5] = "serial-number"
        property[6] = "disk-type"
      property[7] = "rpm"
      property[8] = "firmware-revision"
      property[9] = "physical-space"
      property[10] = "is-prefailed"

      # The rest of this script is standardized
      # and does not need to be edited
      #
      #
      # System Constants
      Level = "Unknown"
      FS="[<>]"
      skip = "0"
      InstanceEnum = "0"
      ParentEnum = "0"
      GrandParentEnum = "0"
      InstanceLevelEnd = "/" InstanceLevel
      ParentLevelEnd = "/" ParentLevel
      GrandParentLevelEnd = "/" GrandParentLevel
      }
    (NF == 3 ) && ($2 == GrandParentLevel) {
      GrandParentEnum = GrandParentEnum + 1
      Level = "GrandParent"
      }
    (NF == 3 ) && ($2 == GrandParentLevelEnd) {
      Level = "Unknown"
      skip = "0"
      }
    (NF == 3) && ($2 == ParentLevel) {
      ParentEnum = ParentEnum + 1
      Level = "Parent"
      skip = "0"
      }
    (NF == 3) && ($2 == ParentLevelEnd) {
      Level = "GrandParent"
      }
    (NF == 3) && ($2 == InstanceLevel) {
      InstanceEnum = InstanceEnum + 1
      InstanceParentID[InstanceEnum] = ParentEnum
      InstanceGrandParentID[InstanceEnum] = GrandParentEnum
      Level = "Instance"
      skip = "0"
      }
    (NF == 3) && ($2 == InstanceLevelEnd) {
      Level = "Parent"
      }

    # Skip unknown subsections
    NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
      skip = "1"
      skipTo = "/" $2
      }
    skip == "1" {
      if ( $2 == skipTo ) { skip = "0"}
        else { next }
      }

    # Values
    # When we get a property, we search through the "property" array to see if it matches something we are looking for
    # We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
    NF == 5 {
      currentProperty = $2
      value = $3
      propertyID = InstanceEnum
      if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
      if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
      for ( pID in property) {
        if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
        }
      }

    END {
      # figure out highest property value
      highestProperty = "0"
      for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
      for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
        printf("%s","MSHW;")
        for ( pID = 1 ; pID <= highestProperty ; pID++) {
          if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
          else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
          else { printID = instanceID ; Level = "Instance" }
          printf("%s",outputArray[Level,printID,pID] ";" )
          }
        print " "
        }
      }
  EmbeddedFile(10): |-
    BEGIN{
    # Set the name for each object level

          InstanceLevel = "fcp-config-adapter-info"
            ParentLevel = ""
            GrandParentLevel = ""

    # Set the Properties to Extract
    # The number indicates which column that property will be put in
    # If you specify property[1] and property[3], you will end up with:
    # MSHW;propertyvalue1;;propertyvalue3;

        #storage-shelf-info
        property[1] = "adapter"
        property[2] = "port-name"
        property[3] = "state"
        property[4] = "speed"

    # The rest of this script is standardized
    # and does not need to be edited
    #
    #
    # System Constants
      Level = "Unknown"
      FS="[<>]"
      skip = "0"
      InstanceEnum = "0"
      ParentEnum = "0"
      GrandParentEnum = "0"
      InstanceLevelEnd = "/" InstanceLevel
      ParentLevelEnd = "/" ParentLevel
      GrandParentLevelEnd = "/" GrandParentLevel
      }
    (NF == 3 ) && ($2 == GrandParentLevel) {
      GrandParentEnum = GrandParentEnum + 1
      Level = "GrandParent"
      }
    (NF == 3 ) && ($2 == GrandParentLevelEnd) {
      Level = "Unknown"
      skip = "0"
      }
    (NF == 3) && ($2 == ParentLevel) {
      ParentEnum = ParentEnum + 1
      Level = "Parent"
      skip = "0"
      }
    (NF == 3) && ($2 == ParentLevelEnd) {
      Level = "GrandParent"
      }
    (NF == 3) && ($2 == InstanceLevel) {
      InstanceEnum = InstanceEnum + 1
      InstanceParentID[InstanceEnum] = ParentEnum
      InstanceGrandParentID[InstanceEnum] = GrandParentEnum
      Level = "Instance"
      skip = "0"
      }
    (NF == 3) && ($2 == InstanceLevelEnd) {
      Level = "Parent"
      }

    # Skip unknown subsections
    NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
      skip = "1"
      skipTo = "/" $2
      }
    skip == "1" {
      if ( $2 == skipTo ) { skip = "0"}
        else { next }
      }

    # Values
    # When we get a property, we search through the "property" array to see if it matches something we are looking for
    # We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
    NF == 5 {
      currentProperty = $2
      value = $3
      propertyID = InstanceEnum
      if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
      if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
      for ( pID in property) {
        if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
        }
      }

    END {
      # figure out highest property value
      highestProperty = "0"
      for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
      for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
        printf("%s","MSHW;")
        for ( pID = 1 ; pID <= highestProperty ; pID++) {
          if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
          else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
          else { printID = instanceID ; Level = "Instance" }
          printf("%s",outputArray[Level,printID,pID] ";" )
          }
        print " "
        }
      }
  EmbeddedFile(9): |-
    BEGIN{
    # Set the name for each object level

          InstanceLevel = "es-electronics-info"
            ParentLevel = "shelf-environ-shelf-info"
            GrandParentLevel = ""

    # Set the Properties to Extract
    # The number indicates which column that property will be put in
    # If you specify property[1] and property[3], you will end up with:
    # MSHW;propertyvalue1;;propertyvalue3;

        #storage-shelf-info
        property[1] = "../shelf-id"
        property[2] = "es-electronics-element-no"
        property[3] = "es-electronics-is-error"
        property[4] = "es-electronics-is-reporting-element"

    # The rest of this script is standardized
    # and does not need to be edited
    #
    #
    # System Constants
      Level = "Unknown"
      FS="[<>]"
      skip = "0"
      InstanceEnum = "0"
      ParentEnum = "0"
      GrandParentEnum = "0"
      InstanceLevelEnd = "/" InstanceLevel
      ParentLevelEnd = "/" ParentLevel
      GrandParentLevelEnd = "/" GrandParentLevel
      }
    (NF == 3 ) && ($2 == GrandParentLevel) {
      GrandParentEnum = GrandParentEnum + 1
      Level = "GrandParent"
      }
    (NF == 3 ) && ($2 == GrandParentLevelEnd) {
      Level = "Unknown"
      skip = "0"
      }
    (NF == 3) && ($2 == ParentLevel) {
      ParentEnum = ParentEnum + 1
      Level = "Parent"
      skip = "0"
      }
    (NF == 3) && ($2 == ParentLevelEnd) {
      Level = "GrandParent"
      }
    (NF == 3) && ($2 == InstanceLevel) {
      InstanceEnum = InstanceEnum + 1
      InstanceParentID[InstanceEnum] = ParentEnum
      InstanceGrandParentID[InstanceEnum] = GrandParentEnum
      Level = "Instance"
      skip = "0"
      }
    (NF == 3) && ($2 == InstanceLevelEnd) {
      Level = "Parent"
      }

    # Skip unknown subsections
    NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
      skip = "1"
      skipTo = "/" $2
      }
    skip == "1" {
      if ( $2 == skipTo ) { skip = "0"}
        else { next }
      }

    # Values
    # When we get a property, we search through the "property" array to see if it matches something we are looking for
    # We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
    NF == 5 {
      currentProperty = $2
      value = $3
      propertyID = InstanceEnum
      if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
      if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
      for ( pID in property) {
        if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
        }
      }

    END {
      # figure out highest property value
      highestProperty = "0"
      for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
      for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
        printf("%s","MSHW;")
        for ( pID = 1 ; pID <= highestProperty ; pID++) {
          if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
          else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
          else { printID = instanceID ; Level = "Instance" }
          printf("%s",outputArray[Level,printID,pID] ";" )
          }
        print " "
        }
      }
  EmbeddedFile(8): |-
    BEGIN{
        # Set the name for each object level
      InstanceLevel = "aggr-info"
        ParentLevel = ""
        GrandParentLevel = ""

      # Set the Properties to Extract
      # The number indicates which column that property will be put in
      # If you specify property[1] and property[3], you will end up with:
      # MSHW;propertyvalue1;;propertyvalue3;

      property[1] = "uuid"
        property[2] = "name"
        property[3] = "size-total"
        property[4] = "is-inconsistent"

      # The rest of this script is standardized
      # and does not need to be edited
      #
      #
      # System Constants
      Level = "Unknown"
      FS="[<>]"
      skip = "0"
      InstanceEnum = "0"
      ParentEnum = "0"
      GrandParentEnum = "0"
      InstanceLevelEnd = "/" InstanceLevel
      ParentLevelEnd = "/" ParentLevel
      GrandParentLevelEnd = "/" GrandParentLevel
      }
    (NF == 3 ) && ($2 == GrandParentLevel) {
      GrandParentEnum = GrandParentEnum + 1
      Level = "GrandParent"
      }
    (NF == 3 ) && ($2 == GrandParentLevelEnd) {
      Level = "Unknown"
      skip = "0"
      }
    (NF == 3) && ($2 == ParentLevel) {
      ParentEnum = ParentEnum + 1
      Level = "Parent"
      skip = "0"
      }
    (NF == 3) && ($2 == ParentLevelEnd) {
      Level = "GrandParent"
      }
    (NF == 3) && ($2 == InstanceLevel) {
      InstanceEnum = InstanceEnum + 1
      InstanceParentID[InstanceEnum] = ParentEnum
      InstanceGrandParentID[InstanceEnum] = GrandParentEnum
      Level = "Instance"
      skip = "0"
      }
    (NF == 3) && ($2 == InstanceLevelEnd) {
      Level = "Parent"
      }

    # Skip unknown subsections
    NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
      skip = "1"
      skipTo = "/" $2
      }
    skip == "1" {
      if ( $2 == skipTo ) { skip = "0"}
        else { next }
      }

    # Values
    # When we get a property, we search through the "property" array to see if it matches something we are looking for
    # We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
    NF == 5 {
      currentProperty = $2
      value = $3
      propertyID = InstanceEnum
      if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
      if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
      for ( pID in property) {
        if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
        }
      }

    END {
      # figure out highest property value
      highestProperty = "0"
      for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
      for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
        printf("%s","MSHW;")
        for ( pID = 1 ; pID <= highestProperty ; pID++) {
          if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
          else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
          else { printID = instanceID ; Level = "Instance" }
          printf("%s",outputArray[Level,printID,pID] ";" )
          }
        print " "
        }
      }
translations:
  PhysicalDiskTranslationTable:
    default: failed
    "false": ok
  ServiceElectornicsTranslationTable:
    default: failed
    "false": ok
  TemperatureStatusTranslationTable:
    default: failed
    "false": ok
  FanStatusTranslationTable:
    default: failed
    "false": ok
  EnclosureHealthTranslationTable:
    normal: ok
    default: failed
  LinkStatusTranslationTable:
    ? ""
    : degraded
    no carrier: degraded
    default: degraded
    inactive: degraded
    online: ok
    link not connected: degraded
    up: ok
    offlined by user/system: degraded
  PowerSupplyStatusTranslationTable:
    default: failed
    "false": ok
  RaidStatusTranslationTable:
    default: failed
    "false": ok
  FanStatusInformationTranslationTable:
    default: ""
    "false": No Error Detected
    "true": Error Detected
  NetworkCardStatusTranslationTable:
    ? ""
    : ok
    no carrier: ok
    default: failed
    inactive: ok
    online: ok
    link not connected: ok
    up: ok
    offlined by user/system: ok
  PowerSupplyStatusInformationTranslationTable:
    default: ""
    "false": No Errors
    "true": Error Detected
connector:
  displayName: NetApp 7-Mode Filer (REST)
  platforms: NetApp
  reliesOn: NetApp REST API
  version: 1.0
  information: "This connector discovers the enclosure and the disks of NetApp disk arrays (filer) as well as the various environment sensors (temperatures, fans, power supplies, etc.). It relies on the REST API protocol."
  detection:
    connectionTypes:
    - remote
    appliesTo:
    - Storage
    criteria:
    # Check that system-get-info for partnet-system-id tag to validate 7-Mode
    - type: http
      method: POST
      url: /servlets/netapp.servlets.admin.XMLrequest_filer
      body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><system-get-info/></netapp>
      expectedResult: partner-system-id
      errorMessage: Credentials Incorrect / Not a NetApp 7-Mode Filer
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Source(1) = Nodes
          # Get XML from REST API Call <system-get-info/>
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><system-get-info/></netapp>
          computes:
          # Convert xml output to multiLine
          - type: awk
            script: EmbeddedFile(11)
        source(2):
          # Source(2) = Multi-line XML for Nodes
          # Preserve Enclosure Discovery Source 1 for use elsewhere
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Convert xml output to CSV
            # MSHW;system-id;system-name;system-model;vendor-id;system-serial-number;
          - type: awk
            script: EmbeddedFile(1)
            # Add Node column to act as type
            # MSHW;type;system-id;system-name;system-model;vendor-id;system-serial-number;
          - type: rightConcat
            column: 1
            value: ;Node
          # Replace ID for Global to attach things more easily.
          - type: replace
            column: 3
            existingValue: Column(3)
            newValue: Global
          # Add empty column for parameter activation (no status for controller)
          - type: rightConcat
            column: 7
            value: ;
        source(3):
          # Source(3) = Storage Shelves
          # Get XML from REST API Call <storage-shelf-environment-list-info/>
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><storage-shelf-environment-list-info/></netapp>
          computes:
          # Convert xml output to multiLine
          - type: awk
            script: EmbeddedFile(11)
        source(4):
          # Source(4) = Multi-line XML for Shelves
          # Preserve Enclosure Discovery Source 3 for use elsewhere
          type: copy
          from: $monitors.enclosure.discovery.sources.source(3)$
          computes:
            # Convert xml output to CSV
            # MSHW;shelf-id;ses-product-id;ses-product-id;vendor-id;;op-status
          - type: awk
            script: EmbeddedFile(2)
            # Concat ";Shelf" to Column for type
            # MSHW;type;shelf;shelf-model;serial-number;;;op-status
          - type: rightConcat
            column: 1
            value: ;Shelf
          # add column 7 with value for ParameterActivation
          - type: rightConcat
            column: 7
            value: ;ReportStatus
        source(5):
          # Source(5) = All enclosures (Nodes + Shelves)\nUnion the Nodes and Shelves tables\nTable 1 // MSHW;type; system-id;system-name;  system-model;  vendor-id;system-serial-number;\nTable 2 // MSHW;type; shelf-id;ses-product-id;ses-product-id;vendor-id;                    ;op-status\nindex   //   1;  2;     3;           4;            5;                    7;\t\t        \t\t\t\t8
          type: tableUnion
          tables:
          - $monitors.enclosure.discovery.sources.source(2)$
          - $monitors.enclosure.discovery.sources.source(4)$
      mapping:
        # Enclosure Instance Table
        # MSHW;type;node;model;serial;product-version;firmware;status
        source: $monitors.enclosure.discovery.sources.source(5)$
        attributes:
          type: $column(2)
          id: $column(3)
          __display_id: $column(4)
          vendor: $column(6)
          model: $column(5)
          serial_number: $column(7)
          name: "sprintf(\"%s (%s %s - %s)\", $column(4), $column(6), $column(5), $column(2))"
    collect:
      # Collection Type (Multi-instance)
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Nodes
          # Get XML from REST API Call <system-get-info/>
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><system-get-info/></netapp>
          computes:
          # Convert xml output to multiLine
          - type: awk
            script: EmbeddedFile(11)
        source(2):
          # Source(2) = Multi-line XML for Nodes
          # Preserve Enclosure Discovery Source 1 for use elsewhere
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Convert xml output to CSV
            # MSHW;node;node-model;node-serial;product-version;cup-firmware-version;is-node-healthy
          - type: awk
            script: EmbeddedFile(1)
          - type: replace
            column: 2
            existingValue: Column(2)
            newValue: Global
        source(3):
          # Source(3) = Shelves
          # Get XML from REST API Call <storage-shelf-environment-list-info/>
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><storage-shelf-environment-list-info/></netapp>
          computes:
          # Convert xml output to multiLine
          - type: awk
            script: EmbeddedFile(11)
        source(4):
          # Source(4) = Multi-line XML for Nodes
          # Preserve Enclosure Discovery Source 3 for use elsewhere
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
          computes:
            # Convert xml output to CSV
            # MSHW;shelf;shelf-model;serial-number;;;op-status
          - type: awk
            script: EmbeddedFile(2)
        source(5):
          # Union the Nodes and Shelves tables
          # Source(5) = All enclosures (Nodes + Shelves)
          # Table 1 // MSHW;system-id;system-name;  system-model;  vendor-id;system-serial-number;
          # Table 2 // MSHW;shelf-id;ses-product-id;ses-product-id;vendor-id;     ;op-status
          # index   //    1;   2;    3;          4;          # 5;          #   6;          #        7;
          type: tableUnion
          tables:
          - $monitors.enclosure.collect.sources.source(2)$
          - $monitors.enclosure.collect.sources.source(4)$
          computes:
          - type: duplicateColumn
            column: 7
            # Translate is-node-healthy to PatrolStatus
            # MSHW;node;node-model;node-serial;product-version;cup-firmware-version;is-node-healthy
          - type: translate
            column: 7
            translationTable: EnclosureHealthTranslationTable
      mapping:
        # Enclosure Value Table
        # MSHW;shelf-id;ses-product-id;ses-product-id;vendor-id;serialNumber;op-status
        source: $monitors.enclosure.collect.sources.source(5)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="enclosure"}: $column(7)
        legacyTextParameters:
          StatusInformation: $column(8)
  power_supply:
    discovery:
      sources:
        source(1):
          # Source(1) = Shelves
          type: copy
          from: $monitors.enclosure.discovery.sources.source(3)$
          computes:
            # Xml2Cvs using AWK
            # MSHW;ps-number;shelf-id;serial-no;error;not-installed
          - type: awk
            script: EmbeddedFile(3)
          # API reports ~"not installed = true" so we exclude those
          - type: excludeMatchingLines
            column: 6
            regExp: "true"
            # Duplicate column 2 for displayID
            # MSHW;ps-number;ps-number;shelf-id;serial-no;error;not-installed
          - type: duplicateColumn
            column: 2
          # MSHW;ps-number;DisplayID;shelf-id;serial-no;error;not-installed
          - type: leftConcat
            column: 3
            value: "Power Supply #"
          - type: leftConcat
            column: 5
            value: "Serial Number: "
      mapping:
        # Powersupply Instance Table
        # MSHW;ps-number;DisplayID;shelf-id;serial-no;error;not-installed
        source: $monitors.power_supply.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          __display_id: $column(3)
          info: $column(5)
          hw.parent.type: enclosure
          hw.parent.id: $column(4)
          name: "sprintf(\"%s, $column(3))"
    collect:
      # Collection Type (Multi-instance)
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Shelves
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
          computes:
            # Convert XML to CSV
            # MSHW;ps-number;shelf-id;serial-no;error;not-installed
          - type: awk
            script: EmbeddedFile(3)
          # DuplicateColumn for StatusInformation
          - type: duplicateColumn
            column: 5
            # Translate status to PatrolStatus
            # MSHW;ps-number;shelf-id;serial-no;error;not-installed
          - type: translate
            column: 5
            translationTable: PowerSupplyStatusTranslationTable
            # Translate status to StatusInformation
            # MSHW;ps-number;shelf-id;serial-no;PATROLStatus;error;not-installed;
          - type: translate
            column: 6
            translationTable: PowerSupplyStatusInformationTranslationTable
      mapping:
        # PowerSupply Value Table
        # MSHW;ps-number;shelf-id;serial-no;error;not-installed
        source: $monitors.power_supply.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="power_supply"}: $column(5)
        legacyTextParameters:
          StatusInformation: $column(6)
  fan:
    discovery:
      sources:
        source(1):
          # Source(1) = Shelves
          type: copy
          from: $monitors.enclosure.discovery.sources.source(3)$
          computes:
            # Xml2Cvs using AWK
            # MSHW;number;shelf-id;error;not-installed
          - type: awk
            script: EmbeddedFile(4)
            # API reports ~"not installed = true" so we exclude those
            # MSHW;number;shelf-id;error;not-installed
          - type: excludeMatchingLines
            column: 5
            regExp: "true"
          - type: duplicateColumn
            column: 2
          - type: leftConcat
            column: 3
            value: "Fan #"
      mapping:
        # Fan Instance Table
        # MSHW;number;shelf-id;error;not-installed
        source: $monitors.fan.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          __display_id: $column(3)
          hw.parent.type: enclosure
          hw.parent.id: $column(4)
          name: $column(3)
    collect:
      # Collection Type (Multi-instance)
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Nodes
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
          computes:
            # Xml2Cvs using AWK
            # MSHW;number;shelf-id;error;not-installed
          - type: awk
            script: EmbeddedFile(4)
            # Duplicate Column 4 for StatusInformation
            # MSHW;number;shelf-id;error;not-installed
          - type: duplicateColumn
            column: 4
            # Translate Fan status into PatrolStatus
            # MSHW;number;shelf-id;PatrolStatus;not-installed
          - type: translate
            column: 4
            translationTable: FanStatusTranslationTable
            # Translate Fan status into StatusInformation
            # MSHW;number;shelf-id;PatrolStatus;StatusInformation
          - type: translate
            column: 5
            translationTable: FanStatusInformationTranslationTable
      mapping:
        # Fan Value Table
        # MSHW;unique-id;PatrolStatus;StatusInformation
        source: $monitors.fan.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="fan"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(5)
  temperature:
    discovery:
      sources:
        source(1):
          # Source(1) = Shelves
          type: copy
          from: $monitors.enclosure.discovery.sources.source(3)$
          computes:
            # Xml2Cvs using AWK
            # MSHW;id;shelf-id;is-error;current-condition
          - type: awk
            script: EmbeddedFile(5)
          - type: duplicateColumn
            column: 2
          - type: leftConcat
            column: 3
            value: "Temperature #"
      mapping:
        # Temperature Instance Table
        # MSHW;node;uniqueID;name;env-over-temperature
        source: $monitors.temperature.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          __display_id: $column(3)
          hw.parent.type: enclosure
          hw.parent.id: $column(4)
          name: $column(3)
    collect:
      # Collection Type (Multi-instance)
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Shelves
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
          computes:
            # Xml2Cvs using AWK
            # MSHW;node;env-over-temperature
          - type: awk
            script: EmbeddedFile(5)
          # Translate status information into PatrolStatus
          - type: translate
            column: 4
            translationTable: TemperatureStatusTranslationTable
          - type: replace
            column: 5
            existingValue: _
            newValue: ' '
      mapping:
        # Temperature Value Table
        # MSHW;unique-id;PatrolStatus;StatusInformation
        source: $monitors.temperature.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="temperature"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(5)
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = disk-list-info
          # Get XML from REST API Call <disk-list-info/>
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><disk-list-info/></netapp>
          computes:
          # Convert xml output to multiLine
          - type: awk
            script: EmbeddedFile(11)
        source(2):
          # Source(2) = Storage Shelf Info
          type: copy
          from: $monitors.physical_disk.discovery.sources.source(1)$
          computes:
            # Xml2Cvs using AWK
            # MSHW;shelf;bay;model;vendor;serialNumber;disk-type;rpm;fw;physical-space;is-prefailed;
          - type: awk
            script: EmbeddedFile(6)
          # MSHW;shelf;shelf;bay;model;vendor;serialNumber;disk-type;rpm;fw;physical-space;is-prefailed;
          - type: duplicateColumn
            column: 2
            # create uniqueID (Computes 2-3)
            # MSHW;shelf.;shelf;bay;model;vendor;serialNumber;disk-type;rpm;fw;physical-space;is-prefailed;
          - type: rightConcat
            column: 2
            value: .
          # MSHW;shelf.bay;shelf;bay;model;vendor;serialNumber;disk-type;rpm;fw;physical-space;is-prefailed;
          - type: rightConcat
            column: 2
            value: Column(4)
          - type: leftConcat
            column: 9
            value: "RPM: "
        source(3):
          type: copy
          from: $monitors.physical_disk.discovery.sources.source(2)$
          computes:
          # if Column 12 (is-prefailed) has a value, the disk is assigned.
          - type: keepOnlyMatchingLines
            column: 12
            regExp: .
        source(4):
          type: copy
          from: $monitors.physical_disk.discovery.sources.source(2)$
          computes:
          # if Column 12 (is-prefailed) has no value, the disk is un-assigned.
          - type: excludeMatchingLines
            column: 12
            regExp: .
          # Add description for disks that are not assigned. No status can be provided.
          - type: rightConcat
            column: 4
            value: ' (Unassigned - Not Monitored)'
        source(5):
          # Join the Assigned and un-assigned disk tables.
          type: tableUnion
          tables:
          - $monitors.physical_disk.discovery.sources.source(3)$
          - $monitors.physical_disk.discovery.sources.source(4)$
          computes:
          - type: leftConcat
            column: 8
            value: "Type: "
      mapping:
        # PhysicalDisk Instancce
        # MSHW;shelf.bay;shelf;bay;model;vendor;serialNumber;disk-type;rpm;fw;physical-space;is-prefailed;
        source: $monitors.physical_disk.discovery.sources.source(5)$
        attributes:
          id: $column(2)
          __display_id: $column(4)
          model: $column(5)
          vendor: $column(6)
          serial_number: $column(7)
          firmware_version: $column(10)
          info: "join($column(9), $column(8), \" \")"
          hw.parent.type: enclosure
          hw.parent.id: $column(3)
          name: "sprintf(\"%s (%s - %s)\", $column(4), $column(5), $column(11))"
        metrics:
          hw.physical_disk.size: $column(11)
    collect:
      # Collect
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = disk-list-info
          # Get XML from REST API Call
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><disk-list-info/></netapp>
          computes:
          - type: awk
            script: EmbeddedFile(11)
        source(2):
          # Source(2) = disk-list-info
          type: copy
          from: $monitors.physical_disk.collect.sources.source(1)$
          computes:
            # Xml2Cvs with Awk
            # MSHW;shelf;bay;model;vendor;serialNumber;disk-type;rpm;fw;physical-space;is-prefailed;
          - type: awk
            script: EmbeddedFile(6)
          # MSHW;shelf;shelf;bay;model;vendor;serialNumber;disk-type;rpm;fw;physical-space;is-prefailed;
          - type: duplicateColumn
            column: 2
            # create uniqueID (Computes 2-3)
            # MSHW;shelf.;shelf;bay;model;vendor;serialNumber;disk-type;rpm;fw;physical-space;is-prefailed;
          - type: rightConcat
            column: 2
            value: .
          # MSHW;shelf.bay;shelf;bay;model;vendor;serialNumber;disk-type;rpm;fw;physical-space;is-prefailed;
          - type: rightConcat
            column: 2
            value: Column(4)
          # MSHW;shelf;shelf;bay;model;vendor;serialNumber;disk-type;rpm;fw;physical-space;is-prefailed;
          - type: duplicateColumn
            column: 12
            # Translate bay-op-status into PatrolStatus
            # MSHW;shelf-id;bay-id;bay-has-disk;bay-type;PatrolStatus;
          - type: translate
            column: 12
            translationTable: PhysicalDiskTranslationTable
          - type: leftConcat
            column: 13
            value: "Is prefailed : "
      mapping:
        # PhysicalDisk Value Table
        # MSHW;shelf;unique-id;bay-has-disk;bay-type;PatrolStatus;
        source: $monitors.physical_disk.collect.sources.source(2)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="physical_disk"}: $column(12)
        legacyTextParameters:
          StatusInformation: $column(13)
  network:
    discovery:
      sources:
        source(1):
          # Source(1) = net-config-get-active
          # Get XML from REST API Call
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><net-config-get-active/></netapp>
          computes:
          # multi-line the xml response
          - type: awk
            script: EmbeddedFile(11)
        source(2):
          # Source(2) = NetworkCards
          type: copy
          from: $monitors.network.discovery.sources.source(1)$
          computes:
            # Xml2Cvs with Awk
            # MSHW;interface-name;mac-address;mediatype;
          - type: awk
            script: EmbeddedFile(7)
            # Add port identifying information for this source (always MAC and "Ethernet Port")
            # MSHW;interface-name;mac-address;MAC;Type;mediatype;
          - type: rightConcat
            column: 3
            value: ;MAC;Ethernet Port;
        source(3):
          # Source(3) = fcp-adapter-list-info
          # Get XML from REST API Call
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><fcp-adapter-list-info/></netapp>
          computes:
          # multi-line the xml response
          - type: awk
            script: EmbeddedFile(11)
        source(4):
          type: copy
          from: $monitors.network.discovery.sources.source(3)$
          computes:
            # Xml2Cvs with Awk
            # MSHW;node;adapter;port-name;state;speed;
          - type: awk
            script: EmbeddedFile(10)
            # Add port identifying information for this source (always WWN and "FC Port")
            # MSHW;adapter;port-name;WWN;FC;state;speed;
          - type: rightConcat
            column: 3
            value: ;WWN;FC Port
        source(5):
          type: tableUnion
          tables:
          - $monitors.network.discovery.sources.source(2)$
          - $monitors.network.discovery.sources.source(4)$
          computes:
          # Replace auto with blank to deactivate LinkSpeed
          - type: replace
            column: 7
            existingValue: auto
            newValue: ""
      mapping:
        # NetworkCard Instance Table
        # MSHW;node;uniqueId;port;link-status;health-status;mac-address;link-speed;physical-address-type;device-type
        source: $monitors.network.discovery.sources.source(5)$
        attributes:
          id: $column(2)
          __display_id: $column(2)
          physical_address: $column(3)
          physical_address_type: $column(4)
          device_type: $column(5)
          hw.parent.type: enclosure
          hw.parent.id: Global
          name: "sprintf(\"%s (%s)\", $column(2), $column(5))"
    collect:
      # Collection type (Multi-instance)
      type: multiInstance
      sources:
        source(1):
          # Source(1) = NetworkCards
          # Get XML from REST API Call
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><net-config-get-active/></netapp>
          computes:
          # xml to multi-line
          - type: awk
            script: EmbeddedFile(11)
        source(2):
          # Source(2) = NetworkCards
          type: copy
          from: $monitors.network.collect.sources.source(1)$
          computes:
            # Xml2Cvs using AWK
            # MSHW;interface-name;mac-address;mediatype;
          - type: awk
            script: EmbeddedFile(7)
          # Duplicate status column (status information)
          - type: duplicateColumn
            column: 4
          # MSHW;interface-name;mac-address;auto;speed;duplex;link;mediaType;
          - type: replace
            column: 4
            existingValue: '-'
            newValue: ;
          - type: duplicateColumn
            column: 7
          - type: translate
            column: 7
            translationTable: NetworkCardStatusTranslationTable
          # MSHW;interface-name;mac-address;mediatype;
          - type: translate
            column: 8
            translationTable: LinkStatusTranslationTable
          # Remove t from speed column to be used for LinkSpeed
          - type: replace
            column: 5
            existingValue: t
            newValue: ""
        source(3):
          # Source(3) = fcp-adapter-list-info
          # Get XML from REST API Call
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><fcp-adapter-list-info/></netapp>
          computes:
          # xml to multi-line
          - type: awk
            script: EmbeddedFile(11)
        source(4):
          # Source(2) = NetworkCards
          type: copy
          from: $monitors.network.collect.sources.source(3)$
          computes:
            # Xml2Cvs using AWK
            # MSHW;adapter;adapter-wwnn;status-admin;speed;
          - type: awk
            script: EmbeddedFile(10)
            # Duplicate status column (status information)
            # MSHW;adapter;adapter-wwnn;status-admin;status-admin;speed;
          - type: duplicateColumn
            column: 4
            # Duplicate status column (status information)
            # MSHW;adapter;adapter-wwnn;status-admin;status-admin;status-admin;speed;
          - type: duplicateColumn
            column: 4
            # Duplicate status column (status information)
            # MSHW;adapter;adapter-wwnn;status-admin;status-admin;status-admin;status-admin;speed;
          - type: duplicateColumn
            column: 4
            # Duplicate status column (status information)
            # MSHW;adapter;adapter-wwnn;status-admin;status-admin;status-admin;status-admin;status-admin;speed;
          - type: duplicateColumn
            column: 4
            # Translate NetworkCard Status
            # MSHW;adapter;adapter-wwnn;status-admin;status-admin;status-admin;Status;status-admin;speed;
          - type: translate
            column: 7
            translationTable: NetworkCardStatusTranslationTable
            # Translate NetworkCard LinkStatus
            # MSHW;adapter;adapter-wwnn;status-admin;status-admin;status-admin;Status;LinkStatus;speed;
          - type: translate
            column: 8
            translationTable: LinkStatusTranslationTable
            # Move speed to Column 5 to match Ethernet
            # MSHW;adapter;adapter-wwnn;status-admin;speed;status-admin;Status;LinkStatus;speed;
          - type: replace
            column: 5
            existingValue: Column(5)
            newValue: Column(9)
          # Replace Gb with 000 for LinkSpeed
          - type: replace
            column: 5
            existingValue: Gb
            newValue: '000'
        source(5):
          type: tableUnion
          tables:
          - $monitors.network.collect.sources.source(2)$
          - $monitors.network.collect.sources.source(4)$
      mapping:
        # NetworkCard Value Table
        # MSHW;adapter;adapter-wwnn;status-admin;speed;status-admin;Status;LinkStatus;speed;
        # MSHW;interface-name;mac-address;statusArray;statusArray;statusArray
        source: $monitors.network.collect.sources.source(5)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="network"}: $column(7)
          hw.network.up: legacyLinkStatus($column(8))
          hw.network.bandwidth.limit: megaBit2Bit($column(5))
        legacyTextParameters:
          StatusInformation: $column(9)
  logical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = Aggregate (raid) information
          # Get XML from REST API Call
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><aggr-list-info/></netapp>
          computes:
          # XML to multi-line xml
          - type: awk
            script: EmbeddedFile(11)
        source(2):
          # Source(2) = Aggregate (raid) inforamtion
          type: copy
          from: $monitors.logical_disk.discovery.sources.source(1)$
          computes:
            # Xml2Cvs using Awk
            # MSHW;uuid;name;size;is-inconsistent
          - type: awk
            script: EmbeddedFile(8)
      mapping:
        # LogicalDisk Instance Table
        # MSHW;uuid;name;size;is-inconsistent
        source: $monitors.logical_disk.discovery.sources.source(2)$
        attributes:
          id: $column(2)
          __display_id: $column(3)
          hw.logical_disk.limit: $column(4)
          hw.parent.type: enclosure
          hw.parent.id: Global
          name: "sprintf(\"%s (%s)\", $column(3), $column(4))"
    collect:
      # CollectionType (Multi-instance)
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Aggregate (raid) information
          # Get XML from REST API Call
          type: http
          method: POST
          url: /servlets/netapp.servlets.admin.XMLrequest_filer
          body: <?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><aggr-list-info/></netapp>
          computes:
          # XML to multi-line XML
          - type: awk
            script: EmbeddedFile(11)
        source(2):
          # Source(2) = Aggregate (raid) information
          type: copy
          from: $monitors.logical_disk.collect.sources.source(1)$
          computes:
            # Xml2Cvs using Awk
            # MSHW;uuid;name;size;is-inconsistent
          - type: awk
            script: EmbeddedFile(8)
          # MSHW;uuid;name;size;is-inconsistent
          - type: translate
            column: 5
            translationTable: RaidStatusTranslationTable
      mapping:
        # LogicalDisk Value Table
        # MSHW;aggregate-uuid;PatrolStatus;StatusInformation;
        source: $monitors.logical_disk.collect.sources.source(2)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="logical_disk"}: $column(5)
        legacyTextParameters:
          StatusInformation: $column(6)
  other_device:
    discovery:
      sources:
        source(1):
          type: copy
          from: $monitors.enclosure.discovery.sources.source(3)$
          computes:
            # Xml2Cvs using AWK
            # MSHW;shelf-id;es-electronics-element-no;es-electronics-is-error;es-electronics-is-reporting-element
          - type: awk
            script: EmbeddedFile(9)
          # MSHW;shelf-id;es-electronics-element-no;es-electronics-element-no;es-electronics-is-error;es-electronics-is-reporting-element
          - type: duplicateColumn
            column: 3
          - type: leftConcat
            column: 4
            value: "Service Electronics #"
          - type: excludeMatchingLines
            column: 6
            regExp: "false"
      mapping:
        # LogicalDisk Instance Table
        # MSHW;shelf-id;es-electronics-element-no;es-electronics-element-no;es-electronics-is-error;es-electronics-is-reporting-element
        source: $monitors.other_device.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(4)
          hw.parent.type: enclosure
          hw.parent.id: $column(2)
          name: $column(4)
    collect:
      # Collect type
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
          computes:
          # XML to multi-line XML
          - type: awk
            script: EmbeddedFile(11)
        source(2):
          type: copy
          from: $monitors.other_device.collect.sources.source(1)$
          computes:
            # Xml2Cvs using Awk
            # MSHW;shelf-id;es-electronics-element-no;es-electronics-is-error;es-electronics-is-reporting-element
          - type: awk
            script: EmbeddedFile(9)
            # Translate into PatrolStatus
            # MSHW;shelf-id;es-electronics-element-no;PatrolStatus;StatusDescription
          - type: translate
            column: 4
            translationTable: ServiceElectornicsTranslationTable
      mapping:
        # OtherDevice Value Table
        # MSHW;shelf-id;es-electronics-element-no;PatrolStatus;StatusDescription
        source: $monitors.other_device.collect.sources.source(2)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="other_device"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(5)
