---
connector:
  displayName: Oracle/Sun Solaris - Non-Sun Disks
  platforms: Oracle/Sun
  reliesOn: "Sun Solaris system commands (iostat, dd)"
  information: Gives physical disk information (status and error count) on Sun Solaris systems through the iostat -En utility. Supports only non-Sun official disks.
  version: 1.7
  detection:
    connectionTypes:
    - remote
    appliesTo:
    - Solaris
    criteria:
    # Solaris only
    - type: deviceType
      keep:
      - SunOS
      - Solaris
    # iostat must return something
    - type: osCommand
      commandLine: /usr/bin/iostat -En
      expectedResult: "Soft [Ee]rrors.*Hard [Ee]rrors.*Transport [Ee]rrors"
      errorMessage: iostat seems to not work as expected. Please check the output of 'iostat -En'
sudoCommands:
- /usr/bin/dd
monitors:
  disk_controller:
    discovery:
      sources:
        source(1):
          # Source(1) = output of iostat reformatted by the awk (see EmbeddedFile(1))
          # DeviceID
          type: osCommand
          commandLine: /usr/bin/iostat -En|/usr/bin/awk -f $embedded.EmbeddedFile(1)$|/usr/bin/uniq
          keep: ^MSHW;
          separators: ;
          selectColumns: 2
        source(2):
          # Source(2) = output of iostat
          type: osCommand
          commandLine: iostat -En
          computes:
            # Reformat iostat's output through awk (see EmbeddedFile(2))
            # DeviceID;ControllerNumber;Size;VendorModel;SerialNumber
          - type: awk
            script: EmbeddedFile(2)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5,6"
        source(3):
          # Source(3) = Table Joint of source(1) and source(2)
          # this is to remove disk controllers which don't have physical disks attached to
          # DeviceID;DiskDeviceID;ControllerNumber;Size;VendorModel;SerialNumber
          type: tableJoin
          leftTable: $monitors.disk_controller.discovery.sources.source(1)$
          rightTable: $monitors.disk_controller.discovery.sources.source(2)$
          leftKeyColumn: 1
          rightKeyColumn: 2
      mapping:
        # InstanceTable = Source(3)
        source: $monitors.disk_controller.discovery.sources.source(3)$
        attributes:
          id: $column(1)
          __display_id: $column(1)
          controller_number: $column(1)
          model: ""
          hw.parent.type: enclosure
          name: "sprintf(\"Disk Controller: %s (%s)\", $column(1), \"\")"
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = copy of DiskController.Discovery.Source(2)
          type: copy
          from: $monitors.disk_controller.discovery.sources.source(2)$
      mapping:
        # InstanceTable = Source(1)
        source: $monitors.physical_disk.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          __display_id: $column(1)
          vendor: $column(4)
          serial_number: $column(5)
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $column(2))"
          name: "sprintf(\"%s (%s - %by10hf.s)\", $column(1), $column(4), $column(3))"
        metrics:
          hw.physical_disk.size: $column(3)
    collect:
      # Collect type is "all instances in one shot
      type: multiInstance
      sources:
        source(1):
          # Source(1) = output of iostat
          type: osCommand
          commandLine: /usr/bin/iostat -En
          computes:
            # Source(1) = output of iostat reformatted by awk (see EmbeddedFile(3))
            # DeviceID;ErrorCount;HardErrorCount;MediaErrorCount;DeviceNotReadyErrorCount;NoDeviceErrorCount;TransportErrorCount;RecoverableErrorCount;IllegalRequestErrorCount;PredictedFailure
          - type: awk
            script: EmbeddedFile(3)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5,6,7,8,9,10,11"
        source(2):
          # Source(2) = output of the shell script based on the format command
          # DeviceID;Status;StatusInformation
          type: osCommand
          commandLine: /usr/bin/sh $embedded.EmbeddedFile(4)$
          keep: ^MSHW;
          separators: ;
          selectColumns: "2,3,4"
        source(3):
          # Source(3) = Table joint of Source(1) and Source(2)
          # DeviceID;ErrorCount;HardErrorCount;MediaErrorCount;DeviceNotReadyErrorCount;NoDeviceErrorCount;TransportErrorCount;RecoverableErrorCount;IllegalRequestErrorCount;PredictedFailure;DeviceID;Status;StatusInformation
          type: tableJoin
          leftTable: $monitors.physical_disk.collect.sources.source(1)$
          rightTable: $monitors.physical_disk.collect.sources.source(2)$
          leftKeyColumn: 1
          rightKeyColumn: 1
      mapping:
        # ValueTable = Source(3)
        source: $monitors.physical_disk.collect.sources.source(3)$
        deviceId: $column(1)
        metrics:
          hw.errors{hw.type="physical_disk", hw.error.type="hard"}: $column(3)
          hw.errors{hw.type="physical_disk", hw.error.type="media"}: $column(4)
          hw.errors{hw.type="physical_disk", hw.error.type="device_not_ready"}: $column(5)
          hw.errors{hw.type="physical_disk", hw.error.type="no_device"}: $column(6)
          hw.errors{hw.type="physical_disk", hw.error.type="transport"}: $column(7)
          hw.errors{hw.type="physical_disk", hw.error.type="recoverable"}: $column(8)
          hw.errors{hw.type="physical_disk", hw.error.type="illegal_request"}: $column(9)
          hw.status{hw.type="physical_disk", state="predicted_failure"}: boolean($column(10))
          hw.status{hw.type="physical_disk"}: $column(12)
        legacyTextParameters:
          StatusInformation: $column(13)
embedded:
  EmbeddedFile(1): |-
    {
        if ($0 ~ /^c[0-9]+t[0-9A-Z]+d[0-9]+/ || $0 ~ /^s+d[0-9]+/)
        {
            if ($1 ~ /^c[0-9]+t[0-9A-Z]+d[0-9]+/)
            {
                targetIndex = index($1, "t")
                controller = substr($1, 1, targetIndex - 1)
            }
            else
            {
                controller = "Other"
            }
        }

        if ($0 ~/Illegal Request:/)
        {
            print "MSHW;" controller
        }
    }
  EmbeddedFile(3): |-
    {
        if ($0 ~ /^c[0-9]+t[0-9A-Z]+d[0-9]+/ || $0 ~ /^s+d[0-9]+/)
        {
            disk = $1
            product = ""
            transporterror = 0
            hardwareerror = 0
            mediaerror = 0
            devicenotready = 0
            nodevice = 0
            recoverable = 0
            illegalrequests = 0
            predictivefailureanalysis = 0
            statusinformation = ""
            totalerror = 0
            vendor = ""
            size = 0
        }

        if ($0 ~ /Product: /)
        {
            index1 = index($0, "Product: " ) + length("Product: ")
            product = substr($0, index1, length-index1)
            index1 = index(product, ":")
            if (index1 > 0)
            {
                product = substr(product, 1, index1-1)
                n = split(product, a, " ")
                product = ""
                for (i=1 ; i<n ; i++)
                {
                    product = product a[i]
                    if (i < n-1)
                        product = product " "
                }
            }
        }

        if ($0 ~ /Vendor: /)
        {
            index1 = index($0, "Vendor: " ) + length("Vendor: ")
            vendor = substr($0, index1, length-index1)
            index1 = index(vendor, ":")
            if (index1 > 0)
            {
                vendor = substr(vendor, 1, index1-1)
                n = split(vendor, a, " ")
                vendor = ""
                for (i=1 ; i<n ; i++)
                {
                    vendor = vendor a[i]
                    if (i < n-1)
                        vendor = vendor " "
                }
            }
        }

        if ($0 ~ /Size: /)
        {
            index1 = index($0, "<") + 1
            index2 = index($0, " bytes>")
            size = substr($0, index1, index2-index1)
        }

        if ($8 == "Transport" && ($9 == "Errors:" || $9 == "errors:"))
        {
            transporterror = $10
        }

        if ($5 == "Hard" && ($6 == "Errors:" || $6 == "errors:"))
        {
            hardwareerror = $7
        }

        if ($1 == "Media" && ($2 == "Error:" || $2 == "error:"))
        {
            mediaerror = $3
        }

        if ($4 == "Device" && $5 == "Not" && $6 == "Ready:")
        {
            devicenotready = $7
        }

        if ($8 == "No" && $9 == "Device:")
        {
            nodevice = $10
        }

        if ($11 == "Recoverable:")
        {
            recoverable = $12
        }

        if ($1 == "Illegal" && $2 == "Request:")
        {
            illegalrequests = $3
        }

        if ($4 == "Predictive" && $5 == "Failure" && $6 == "Analysis:")
        {
            predictivefailureanalysis = $7
        }

        if ($0 ~/Illegal Request:/)
        {
            hardwareerror = hardwareerror - mediaerror - devicenotready - nodevice
            if (hardwareerror < 0)
            {
                hardwareerror = 0
            }

            if (predictivefailureanalysis > 0)
            {
                predictivefailureanalysis = "TRUE"
            }
            else
            {
                predictivefailureanalysis = "FALSE"
            }

            totalerror = recoverable + transporterror + mediaerror + devicenotready + nodevice + hardwareerror

    # THE FOLLOWING LINE EXISTS 3 TIMES IN THIS CONNECTOR.  ALL 3 SHOULD BE IDENTICAL
    if (disk != "" && product !~ /SUN[0-9\.]+[GT]/ && vendor != "EMC" && vendor != "LSILOGIC" && vendor != "DGC" && vendor != "StoreAge" && vendor != "SUN" && product != "StorEdge" && product != "StorEDGE" && product !~ /^HSV[0-9]/ && vendor != "EUROLOGC"  && vendor !~ /HP HSV[0-9]/ && product !~ /OPEN-V/ && product !~ /INF-01-00/ && product !~ /DF600F/ && size > 10 && vendor !="NETAPP" && product != "LUN" && vendor !="3PARdata" && (!(vendor == ("IBM") && product == ("2145"))))
            {
                print "MSHW;" disk ";" totalerror ";" hardwareerror ";" mediaerror ";" devicenotready ";" nodevice ";" transporterror ";" recoverable ";" illegalrequests ";" predictivefailureanalysis
            }

            product = ""
            transporterror = 0
            hardwareerror = 0
            mediaerror = 0
            devicenotready = 0
            nodevice = 0
            recoverable = 0
            illegalrequests = 0
            predictivefailureanalysis = 0
            statusinformation = ""
            totalerror = 0
            vendor = ""
            size = 0

        }

    }
  EmbeddedFile(2): |-
    {
        if ($0 ~ /^c[0-9]+t[0-9A-Z]+d[0-9]+/ || $0 ~ /^s+d[0-9]+/)
        {
            disk = $1
            size = "0"
            vendor = ""
            product = ""
            model = ""
            productmodel = ""
            serial = ""
            if (disk ~ /^c[0-9]+t[0-9A-Z]+d[0-9]+/)
            {
                targetIndex = index(disk, "t")
                controller = substr(disk, 1, targetIndex - 1)
            }
            else
            {
                controller = "Other"
            }
        }

        if ($0 ~ /Size: /)
        {
            index1 = index($0, "<") + 1
            index2 = index($0, " bytes>")
            size = substr($0, index1, index2-index1)
        }

        if ($0 ~ /Vendor: /)
        {
            index1 = index($0, "Vendor: " ) + length("Vendor: ")
            vendor = substr($0, index1, length-index1)
            index1 = index(vendor, ":")
            if (index1 > 0)
            {
                vendor = substr(vendor, 1, index1-1)
                n = split(vendor, a, " ")
                vendor = ""
                for (i=1 ; i<n ; i++)
                {
                    vendor = vendor a[i]
                    if (i < n-1)
                        vendor = vendor " "
                }
            }
        }

        if ($0 ~ /Model: /)
        {
            index1 = index($0, "Model: " ) + length("Model: ")
            model = substr($0, index1, length-index1)
            index1 = index(model, ":")
            if (index1 > 0)
            {
                model = substr(model, 1, index1-1)
                n = split(model, a, " ")
                model = ""
                for (i=1 ; i<n ; i++)
                {
                    model = model a[i]
                    if (i < n-1)
                        model = model " "
                }
            }
        }

        if ($0 ~ /Product: /)
        {
            index1 = index($0, "Product: " ) + length("Product: ")
            product = substr($0, index1, length-index1)
            index1 = index(product, ":")
            if (index1 > 0)
            {
                product = substr(product, 1, index1-1)
                n = split(product, a, " ")
                product = ""
                for (i=1 ; i<n ; i++)
                {
                    product = product a[i]
                    if (i < n-1)
                        product = product " "
                }
            }
        }

        if ($0 ~ /Serial No: /)
        {
            index1 = index($0, "Serial No: " ) + length("Serial No: ")
            serial = substr($0, index1, length-index1)
            index1 = index(serial, ":")
            if (index1 > 0)
            {
                serial = substr(serial, 1, index1-1)
                n = split(serial, a, " ")
                serial = ""
                for (i=1 ; i<n ; i++)
                {
                    serial = serial a[i]
                    if (i < n-1)
                        serial = serial " "
                }
            }

        }

        if ($0 ~/Illegal Request:/)
        {
            if (product != "" && model != "")
            {
                productmodel = product " " model
            }
            else
            {
                productmodel = product model
            }

    # THE FOLLOWING LINE EXISTS 3 TIMES IN THIS CONNECTOR.  ALL 3 SHOULD BE IDENTICAL
    if (disk != "" && product !~ /SUN[0-9\.]+[GT]/ && vendor != "EMC" && vendor != "LSILOGIC" && vendor != "DGC" && vendor != "StoreAge" && vendor != "SUN" && product != "StorEdge" && product != "StorEDGE" && product !~ /^HSV[0-9]/ && vendor != "EUROLOGC"  && vendor !~ /HP HSV[0-9]/ && product !~ /OPEN-V/ && product !~ /INF-01-00/ && product !~ /DF600F/ && size > 10 && vendor !="NETAPP" && product != "LUN" && vendor !="3PARdata" && (!(vendor == ("IBM") && product == ("2145"))))
            {
                print "MSHW;" disk ";" controller ";" size ";" vendor " " productmodel ";" serial
            }

            disk = ""
            size = "0"
            vendor = ""
            product = ""
            model = ""
            productmodel = ""
            serial = ""

        }

    }
  EmbeddedFile(4): |-
    DISKLIST=`/usr/bin/iostat -En|/usr/bin/awk '{
        if ($0 ~ /^c[0-9]+t[0-9A-Z]+d[0-9]+/ || $0 ~ /^s+d[0-9]+/)
        {
            disk = $1
            product = ""
            vendor = ""
            size = 0
        }

        if ($0 ~ /Product: /)
        {
            index1 = index($0, "Product: " ) + length("Product: ")
            product = substr($0, index1, length-index1)
            index1 = index(product, ":")
            if (index1 > 0)
            {
                product = substr(product, 1, index1-1)
                n = split(product, a, " ")
                product = ""
                for (i=1 ; i<n ; i++)
                {
                    product = product a[i]
                    if (i < n-1)
                        product = product " "
                }
            }
        }

        if ($0 ~ /Vendor: /)
        {
            index1 = index($0, "Vendor: " ) + length("Vendor: ")
            vendor = substr($0, index1, length-index1)
            index1 = index(vendor, ":")
            if (index1 > 0)
            {
                vendor = substr(vendor, 1, index1-1)
                n = split(vendor, a, " ")
                vendor = ""
                for (i=1 ; i<n ; i++)
                {
                    vendor = vendor a[i]
                    if (i < n-1)
                        vendor = vendor " "
                }
            }
        }

        if ($0 ~ /Size: /)
        {
            index1 = index($0, "<") + 1
            index2 = index($0, " bytes>")
            size = substr($0, index1, index2-index1)
        }

        if ($0 ~/Illegal Request:/)
        {
    # THE FOLLOWING LINE EXISTS 3 TIMES IN THIS CONNECTOR.  ALL 3 SHOULD BE IDENTICAL
    if (disk != "" && product !~ /SUN[0-9\.]+[GT]/ && vendor != "EMC" && vendor != "LSILOGIC" && vendor != "DGC" && vendor != "StoreAge" && vendor != "SUN" && product != "StorEdge" && product != "StorEDGE" && product !~ /^HSV[0-9]/ && vendor != "EUROLOGC"  && vendor !~ /HP HSV[0-9]/ && product !~ /OPEN-V/ && product !~ /INF-01-00/ && product !~ /DF600F/ && size > 10 && vendor !="NETAPP" && product != "LUN" && vendor !="3PARdata" && (!(vendor == ("IBM") && product == ("2145"))))
            {
                print disk
            }

            disk = ""
            product = ""
        }
    }'|/usr/bin/head -30`

    LANG=C
    export LANG

    for DISK in $DISKLIST
    do

        if /usr/bin/echo $DISK|/usr/bin/grep "^c[0-9][0-9]*t[0-9A-Z][0-9A-Z]*d[0-9][0-9]*" 2>/dev/null >/dev/null; then
            CTDSLIST=`/usr/bin/ls /dev/rdsk/$DISK"s"* 2>/dev/null`
        else
            DRIVERNAME=`/usr/bin/echo $DISK|/usr/bin/tr -d [:digit:]`
            INSTANCENUMBER=`/usr/bin/echo $DISK|/usr/bin/tr -d [:alpha:]`
            DEVICEPATH=`/usr/xpg4/bin/awk -v instanceNumber=$INSTANCENUMBER -v driverName=$DRIVERNAME '($(NF-1) == instanceNumber) && ($NF == "\""driverName"\"") { print $1 }' /etc/path_to_inst|/usr/bin/tr -d \"`
            CTDSLIST=`/usr/bin/ls -l /dev/rdsk/c*|/usr/xpg4/bin/awk -v devicePath="$DEVICEPATH" '($NF ~ devicePath && devicePath != "") { print $(NF-2); }'`
        fi

        if /usr/bin/test -z "$CTDSLIST" ; then
            /usr/bin/echo "MSHW;$DISK;UNKNOWN;Couldn't find corresponding block device";
        else
            FOUNDWORKINGCTDS=0
            for CTDS in $CTDSLIST
            do
                ERRORMESSAGE=`%{SUDO:/usr/bin/dd}/usr/bin/dd if=$CTDS of=/dev/null count=20 2>&1`
                if /usr/bin/test "$?" = "0" ; then
                    /usr/bin/echo "MSHW;$DISK;OK;Working"
                    FOUNDWORKINGCTDS=1
                    break
                fi
            done
            if /usr/bin/test "$FOUNDWORKINGCTDS" == "0" ; then
                ERRORMESSAGE=`/usr/bin/echo $ERRORMESSAGE|/usr/bin/awk -F: '($4 !~ /denied/ && $4 !~ /[Nn]o such file/) {print $4}'`
                if /usr/bin/test -z "$ERRORMESSAGE" ; then
                    /usr/bin/echo "MSHW;$DISK;UNKNOWN;Unknown Status";
                else
                    /usr/bin/echo "MSHW;$DISK;ALARM;$ERRORMESSAGE";
                fi
            fi
        fi
    done
