---
connector:
  displayName: Dell DRAC/MC (Dell Remote Access Controller/Modular Chassis)
  platforms: Dell PowerEdge
  reliesOn: Dell Remote Access Controller/Modular Chassis (DRAC/MC)
  information: "Provides environmental information (temperatures, fans and power supplies) on Dell Blade servers through the Dell Remote Access Card (DRAC)"
  version: 1.0
  detection:
    connectionTypes:
    - remote
    appliesTo:
    - OOB
    criteria:
    # Host should respond to telnet the way described below
    - type: osCommand
      commandLine: getsysinfo
      expectedResult: RAC
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Source(1) = Output of the getsysinfo command through telnet
          # Look for the "System Model=" line
          type: osCommand
          commandLine: getsysinfo -c
          computes:
            # Parse the output of getsysinfo with an AWK script
            # Model;SerialNumber
          - type: awk
            script: $embedded.EmbeddedFile(1)$
            keep: MSHW;
            separators: ;
            selectColumns: "2,3"
        source(2):
          # Source(2) = Output of getsensorinfo, getmodinfo and getpbinfo
          type: osCommand
          commandLine: getsensorinfo
        source(3):
          type: osCommand
          commandLine: getmodinfo -A
        source(4):
          type: osCommand
          commandLine: getpbinfo
        source(5):
          type: tableUnion
          tables:
          - $monitors.enclosure.discovery.sources.source(2)$
          - $monitors.enclosure.discovery.sources.source(3)$
          - $monitors.enclosure.discovery.sources.source(4)$
      mapping:
        # The discovery table = source(1)
        source: $monitors.enclosure.discovery.sources.source(1)$
        attributes:
          id: DellBladeChassis
          model: $column(1)
          serial_number: $column(2)
          type: blade
          name: "sprintf(\"Blade Enclosure: (%s)\", $column(1))"
    collect:
      type: monoInstance
      sources:
        source(1):
          # Source(2) = Output of getsensorinfo, getmodinfo and getpbinfo
          type: osCommand
          commandLine: getsensorinfo
        source(2):
          type: osCommand
          commandLine: getmodinfo -A
        source(3):
          type: osCommand
          commandLine: getpbinfo
        source(4):
          type: tableUnion
          tables:
          - $monitors.enclosure.collect.sources.source(1)$
          - $monitors.enclosure.collect.sources.source(2)$
          - $monitors.enclosure.collect.sources.source(3)$
        source(5):
          # Source(2) = copy of Enclosure.Collect.Source(1)
          type: copy
          from: $monitors.enclosure.collect.sources.source(4)$
          computes:
            # Retrieve the overall status of the chassis and its power consumption with a smart AWK script
            # Status;StatusInformation;PowerConsumption
          - type: awk
            script: $embedded.EmbeddedFile(2)$
            keep: MSHW;
            separators: ;
            selectColumns: "2,3,4"
            # Remove the trailing "W" in the PowerConsumption value
            # Status;StatusInformation;PowerConsumption
          - type: replace
            column: 3
            existingValue: W
            newValue: ""
      mapping:
        # ValueTable = Source(1)
        source: $monitors.enclosure.collect.sources.source(5)$
        metrics:
          hw.status{hw.type="enclosure"}: $column(1)
          hw.enclosure.power: $column(3)
          hw.enclosure.energy: fakeCounter($column(3))
        legacyTextParameters:
          StatusInformation: $column(2)
  temperature:
    discovery:
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Discovery.Source(2)
          type: copy
          from: $monitors.enclosure.discovery.sources.source(5)$
          computes:
            # Now, extract the temperatures thanks to a smart AWK script
            # TemperatureID;Location;WarningThreshold;AlarmThreshold
          - type: awk
            script: $embedded.EmbeddedFile(3)$
            separators: ;
            keep: ^MSHW;
            selectColumns: "2,3,4,5"
      mapping:
        # InstanceTable = Source(1)
        source: $monitors.temperature.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          sensor_location: $column(2)
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s)\", $column(1), $column(2))"
        metrics:
          hw.temperature.limit{limit_type="high.degraded"}: $column(3)
          hw.temperature.limit{limit_type="high.critical"}: $column(4)
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Collect.Source(1)
          type: copy
          from: $monitors.enclosure.collect.sources.source(4)$
          computes:
            # Now, extract the temperatures thanks to a smart AWK script
            # TemperatureID;Temperature;Status;
          - type: awk
            script: $embedded.EmbeddedFile(3)$
            separators: ;
            keep: ^MSHW;
            selectColumns: "2,6,7"
            # Duplicate the status column
            # TemperatureID;Temperature;Status;Status;
          - type: duplicateColumn
            column: 3
            # Translate the first status column into a PATROLStatus
            # TemperatureID;Temperature;PATROLStatus;Status;
          - type: translate
            column: 3
            translationTable: DRACStatusTranslationTable
      mapping:
        # ValueTable = Source(1)
        source: $monitors.temperature.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.temperature: $column(2)
          hw.status{hw.type="temperature"}: $column(3)
        legacyTextParameters:
          StatusInformation: $column(4)
  fan:
    discovery:
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Discovery.Source(2)
          type: copy
          from: $monitors.enclosure.discovery.sources.source(5)$
          computes:
            # Now, extract the fans thanks to a smart AWK script
            # FanID;Location;WarningThreshold;AlarmThreshold
          - type: awk
            script: $embedded.EmbeddedFile(4)$
            separators: ;
            keep: ^MSHW;
            selectColumns: "2,3,4,5"
      mapping:
        # InstanceTable = Source(1)
        source: $monitors.fan.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          sensor_location: $column(2)
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s)\", $column(1), $column(2))"
        metrics:
          hw.fan.speed.limit{limit_type="low.degraded"}: $column(3)
          hw.fan.speed.limit{limit_type="low.critical"}: $column(4)
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Collect.Source(1)
          type: copy
          from: $monitors.enclosure.collect.sources.source(4)$
          computes:
            # Now, extract the fans thanks to a smart AWK script
            # FanID;Speed;Status;
          - type: awk
            script: $embedded.EmbeddedFile(4)$
            separators: ;
            keep: ^MSHW;
            selectColumns: "2,6,7"
            # Duplicate the status column
            # FanID;Speed;Status;Status;
          - type: duplicateColumn
            column: 3
            # Translate the first status column into a PATROLStatus
            # FanID;Speed;PATROLStatus;Status;
          - type: translate
            column: 3
            translationTable: DRACStatusTranslationTable
      mapping:
        # ValueTable = Source(1)
        source: $monitors.fan.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.fan.speed: $column(2)
          hw.status{hw.type="fan"}: $column(3)
        legacyTextParameters:
          StatusInformation: $column(4)
  power_supply:
    discovery:
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Discovery.Source(2)
          type: copy
          from: $monitors.enclosure.discovery.sources.source(5)$
          computes:
            # Now, extract the power supplies thanks to a smart AWK script
            # PowerSupplyID;PowerCapacity
          - type: awk
            script: $embedded.EmbeddedFile(5)$
            separators: ;
            keep: ^MSHW;
            selectColumns: "2,3"
            # Remove the trailing "W" in PowerCapacity
            # PowerSupplyID;PowerCapacity
          - type: replace
            column: 2
            existingValue: W
            newValue: ""
      mapping:
        # InstanceTable = Source(1)
        source: $monitors.power_supply.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s W)\", $column(1), $column(2))"
        metrics:
          hw.power_supply.limit: $column(2)
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Collect.Source(1)
          type: copy
          from: $monitors.enclosure.collect.sources.source(4)$
          computes:
            # Now, extract the power supplies status thanks to a smart AWK script
            # PowerSupplyID;Status;StatusInformation
          - type: awk
            script: $embedded.EmbeddedFile(6)$
            separators: ;
            keep: ^MSHW;
            selectColumns: "2,3,4"
            # Translate the status column into a PATROLStatus
            # PowerSupplyID;PATROLStatus;StatusInformation
          - type: translate
            column: 2
            translationTable: DRACStatusTranslationTable
      mapping:
        # ValueTable = Source(1)
        source: $monitors.power_supply.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="power_supply"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
  blade:
    discovery:
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Discovery.Source(2)
          type: copy
          from: $monitors.enclosure.discovery.sources.source(5)$
          computes:
            # Now, extract the blades thanks to a smart AWK script
            # BladeID;BladeName;SerialNumber
          - type: awk
            script: $embedded.EmbeddedFile(7)$
            separators: ;
            keep: ^MSHW;
            selectColumns: "2,3,4"
        source(2):
          # Source(1) = copy of Enclosure.Discovery.Source(2) (again)
          type: copy
          from: $monitors.enclosure.discovery.sources.source(5)$
          computes:
            # But now, extract the model of the blades, always thanks to a smart AWK script
            # BladeName;Model
          - type: awk
            script: $embedded.EmbeddedFile(8)$
            separators: ;
            keep: ^MSHW;
            selectColumns: "2,3"
        source(3):
          # Source(3) = Table joint of Source(1) and source(2)
          # BladeID;BladeName;SerialNumber;BladeName;Model
          type: tableJoin
          leftTable: $monitors.blade.discovery.sources.source(1)$
          rightTable: $monitors.blade.discovery.sources.source(2)$
          leftKeyColumn: 2
          rightKeyColumn: 1
          defaultRightLine: ;;
      mapping:
        # InstanceTable = Source(3)
        source: $monitors.blade.discovery.sources.source(3)$
        attributes:
          id: $column(1)
          blade_name: $column(2)
          model: $column(5)
          serial_number: $column(3)
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s - %s)\", $column(1), $column(2), $column(5))"
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Collect.Source(1)
          type: copy
          from: $monitors.enclosure.collect.sources.source(4)$
          computes:
            # Now, extract the blade status thanks to a smart AWK script
            # BladeID;Status;StatusInformation;PowerState;
          - type: awk
            script: $embedded.EmbeddedFile(7)$
            separators: ;
            keep: ^MSHW;
            selectColumns: "2,5,6,7"
      mapping:
        # ValueTable = Source(1)
        source: $monitors.blade.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="blade"}: $column(2)
          hw.blade.power_state: $column(4)
        legacyTextParameters:
          StatusInformation: $column(3)
  other_device:
    discovery:
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Discovery.Source(2)
          type: copy
          from: $monitors.enclosure.discovery.sources.source(5)$
          computes:
            # Now, extract the switches, DRAC and KVM modules thanks to a smart AWK script
            # OtherDeviceID;DeviceType;DeviceName
          - type: awk
            script: $embedded.EmbeddedFile(9)$
            separators: ;
            keep: ^MSHW;
            selectColumns: "2,3,4"
      mapping:
        # InstanceTable = Source(1)
        source: $monitors.other_device.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          device_type: $column(2)
          additional_label: $column(3)
          hw.parent.type: enclosure
          name: "sprintf(\"%s: %s (%s)\", $column(2), $column(1), $column(3))"
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Collect.Source(1)
          type: copy
          from: $monitors.enclosure.collect.sources.source(4)$
          computes:
            # Now, extract the switches, DRAC and KVM status thanks to a smart AWK script
            # OtherDeviceID;Status;StatusInformation
          - type: awk
            script: $embedded.EmbeddedFile(9)$
            separators: ;
            keep: ^MSHW;
            selectColumns: "2,5,6"
      mapping:
        # ValueTable = Source(1)
        source: $monitors.other_device.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="other_device"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
embedded:
  EmbeddedFile(1): |-
    BEGIN { FS = "="; model = ""; serialNumber = ""; }
    $1 ~ /^System Model *$/ { model = $2; }
    $1 ~ /^Service Tag *$/ { serialNumber = $2; }
    END { print "MSHW;" model ";" serialNumber; }
  EmbeddedFile(3): |-
    ($1 == "Temp" && $6 ~ "[Cc]elsius" && NF == 10) {
        print "MSHW;" $2 ";" $3 ";" $9 ";" $10 ";" $5 ";" $4 ";"
    }
  EmbeddedFile(2): |-
    (NF == 7 && $3 == "Chassis") {
        if ($6 == 0) { status = "UNKNOWN"; statusInformation = "Unknown Status"; }
        else if ($6 == 1) { status = "OK"; statusInformation = "OK"; }
        else if ($6 == 2) { status = "WARN"; statusInformation = "Degraded"; }
        else if ($6 == 3 || $6 == 4) { status = "ALARM"; statusInformation = "Failed"; }
        else { status = "UNKNOWN"; statusInformation = "Unknown Status"; }
    }
    /^ *Total Consumption/ {
        powerConsumption = $NF;
    }
    END {
        print "MSHW;" status ";" statusInformation ";" powerConsumption ";"
    }
  EmbeddedFile(5): |-
    ($1 ~ /^PS-[0-9]$/ && $2 == "Present" && NF == 5) {
        print "MSHW;" $1 ";" $4 ";"
    }
  EmbeddedFile(4): |-
    ($1 == "FanSpeed" && $6 == "rpm" && NF == 10) {
        print "MSHW;" $2 ";" $3 ";" $8 ";" $7 ";" $5 ";" $4 ";"
    }
  EmbeddedFile(7): |-
    (NF == 7 && $3 == "Chassis") { mainSerialNumber = $7 }
    (NF == 7 && $7 != mainSerialNumber && $4 == 2) {
        if ($6 == 0) { status = "UNKNOWN"; statusInformation = "Unknown Status"; }
        else if ($6 == 1) { status = "OK"; statusInformation = "OK"; }
        else if ($6 == 2) { status = "WARN"; statusInformation = "Degraded"; }
        else if ($6 == 3 || $6 == 4) { status = "ALARM"; statusInformation = "Failed"; }
        else { status = "UNKNOWN"; statusInformation = "Unknown Status"; }
        PowerState = ""
        if ($5 == 1) { statusInformation = "OFF - " statusInformation; PowerState = "off"}
        if ($5 == 2) { statusInformation = "ON - " statusInformation; PowerState = "on"}

        print "MSHW;" $1 ";" $3 ";" $7 ";" status ";" statusInformation ";" PowerState ";"
    }
  EmbeddedFile(6): |-
    ($1 == "PWR" && $3 ~ /^PS-[0-9]$/ && NF == 6) {
        statusInformation = $4
        if ($6 == "Present")
        {
            statusInformation = statusInformation " - AC OK"
        }
        else
        {
            statusInformation = statusInformation " - AC NOK"
        }
        statusInformation = statusInformation " - " $5

        print "MSHW;" $3 ";" $5 ";" statusInformation ";"
    }
  EmbeddedFile(9): |-
    (NF == 7 && $4 == 2 && ($3 ~ /^DRAC.MC-[0-9]$/ || $3 ~ /^Switch-[0-9]$/)) || (NF == 6 && $4 == 2 && $3 == "KVM") {
        if ($6 == 0) { status = "UNKNOWN"; statusInformation = "Unknown Status"; }
        else if ($6 == 1) { status = "OK"; statusInformation = "OK"; }
        else if ($6 == 2) { status = "WARN"; statusInformation = "Degraded"; }
        else if ($6 == 3 || $6 == 4) { status = "ALARM"; statusInformation = "Failed"; }
        else { status = "UNKNOWN"; statusInformation = "Unknown Status"; }

        if ($3 ~ /^DRAC.MC-[0-9]$/) { deviceType = "DRAC"; }
        else if ($3 ~ /^Switch-[0-9]$/) { deviceType = "Switch"; }
        else if ($3 == "KVM") { deviceType = "KVM"; }

        print "MSHW;" $1 ";" deviceType ";" $3 ";" status ";" statusInformation ";"
    }
  EmbeddedFile(8): |-
    /Server Module Power Consumption Table/,/^ *$/ {
        if (NF == 5) { print "MSHW;" $2 ";" $3 ";" }
    }
translations:
  DRACStatusTranslationTable:
    Warning: degraded
    Failed: failed
    Alarm: failed
    OK: ok
    Default: UNKNOWN
    Failure: failed
