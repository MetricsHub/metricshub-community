---
connector:
  detection:
    criteria:
      # DETECTION
      # Test if we can connect to the service and get a token
    - type: http
      method: POST
      url: /api/rest/ApiConnection/Login
      header: "${file::embeddedFile-1}"
      expectedResult: sessionKey
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Eclosure Discovery
          type: http
          method: POST
          url: /api/rest/ApiConnection/Login
          header: "${file::embeddedFile-1}"
          resultContent: all
          computes:
          # collect AuthenticationToken
          - type: awk
            script: "${file::embeddedFile-2}"
        source(2):
          # Now we have the token let's perform the StorageCenter Discovery
          type: http
          method: GET
          url: /api/rest/StorageCenter/StorageCenter
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # convert from json to Json2Csv
            # tableID;ID;DisplayName;serialNumber;model
          - type: json2csv
            entryKey: /
            properties: instanceId;instanceName;serialNumber;hostOrIpAddress;modelSeries
            separator: ;
            # remove empty result to avoid phantoms objects
            # tableID;ID;DisplayName;serialNumber;deviceHostname;model
          - type: excludeMatchingLines
            column: 1
            valueList: /
      mapping:
        # Enclosure
        # tableID;ID;DisplayName;serialNumber;deviceHostname;model
        source: "${source::monitors.enclosure.discovery.sources.source(2)}"
        attributes:
          id: $2
          __display_id: $3
          vendor: Dell
          model: $6
          serial_number: $4
          type: Storage
          device_hostname: $5
          name: "${awk::sprintf(\"Storage: %s (%s %s)\", $3, \"Dell\", $6)}"
    collect:
      # Collect type = multi-instance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # 
          type: http
          method: GET
          url: /api/rest/StorageCenter/StorageCenter
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # JSON Status
            # tableID;ID;status;status
          - type: json2csv
            entryKey: /
            properties: instanceId;status;status
            separator: ;
          - type: translate
            column: 3
            translationTable: "${translation::statusTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        # tableID;ID;PatrolStatus;Value;
        source: "${source::monitors.enclosure.collect.sources.source(1)}"
        attributes:
          id: $2
        metrics:
          hw.status{hw.type="enclosure"}: $3
        legacyTextParameters:
          StatusInformation: $4
  blade:
    discovery:
      sources:
        source(1):
          # Now we have the token let's perform the controller's Discovery
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScController
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # convert from json to Json2Csv
            # tableID;ID;DisplayName;serialNumber;model;enclosureID;serviceTag
          - type: json2csv
            entryKey: /
            properties: instanceId;name;hardwareSerialNumber;model;scSerialNumber;serviceTag
            separator: ;
            # add additionnal information type
            # tableID;ID;DisplayName;serialNumber;model;enclosureID;serviceTag
          - type: leftConcat
            column: 7
            value: "Alternative Serial Number: "
            # remove empty output
            # tableID;ID;DisplayName;serialNumber;model;enclosureID;serviceTag
          - type: excludeMatchingLines
            column: 1
            valueList: /
      mapping:
        # tableID;ID;DisplayName;serialNumber;model;enclosureID;serviceTag
        source: "${source::monitors.blade.discovery.sources.source(1)}"
        attributes:
          id: $2
          __display_id: $3
          model: $5
          serial_number: $4
          info: $7
          hw.parent.type: enclosure
          hw.parent.id: $6
          name: "${awk::sprintf(\"%s (%s)\", $3, $5)}"
    collect:
      # Collect type = multi-instance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # 
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScController
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # JSON Status
            # tableID;ID;status;status
          - type: json2csv
            entryKey: /
            properties: instanceId;status;status
            separator: ;
          # ID;PatrolStatus;Value;
          - type: translate
            column: 3
            translationTable: "${translation::statusTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        # tableID;ID;PatrolStatus;Value;
        source: "${source::monitors.blade.collect.sources.source(1)}"
        attributes:
          id: $2
        metrics:
          hw.status{hw.type="blade"}: $3
        legacyTextParameters:
          StatusInformation: $4
  physical_disk:
    discovery:
      sources:
        source(1):
          # Now we have the token let's perform the PhysicalDisk's Discovery
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScDisk
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # convert from json to Json2Csv
            # tableID;ID;DisplayName;size;enclosureID
          - type: json2csv
            entryKey: /
            properties: instanceId;instanceName;size;scSerialNumber
            separator: ;
            # size is returned in format size bytes
            # so lets remove " bytes" from the size field
            # tableID;ID;DisplayName;size;enclosureID
          - type: replace
            column: 4
            existingValue: ' Bytes'
            newValue: ""
        source(2):
          # let's collect serialnumber vendor
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScDiskConfiguration
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # convert from json to Json2Csv
            # tableID;ID;serialNumber;vendor;product
          - type: json2csv
            entryKey: /
            properties: instanceId;serialNumber;vendor;product
            separator: ;
        source(3):
          # now joint both
          # Source(3) = TableJoint of Source(1) and Source(2)
          # tableID;ID;DisplayName;size;enclosureID;tableID;ID;serialNumber;vendor;product
          type: tableJoin
          leftTable: "${source::monitors.physical_disk.discovery.sources.source(1)}"
          rightTable: "${source::monitors.physical_disk.discovery.sources.source(2)}"
          leftKeyColumn: 2
          rightKeyColumn: 2
          defaultRightLine: ;;;;
          computes:
            # remove empty output
            # tableID;ID;DisplayName;size;enclosureID;tableID;ID;serialNumber;vendor;product
          - type: excludeMatchingLines
            column: 1
            valueList: /
      mapping:
        # PhysicalDisk
        # tableID;ID;DisplayName;size;enclosureID;tableID;ID;serialNumber;vendor;product
        source: "${source::monitors.physical_disk.discovery.sources.source(3)}"
        attributes:
          id: $2
          __display_id: $3
          serial_number: $8
          vendor: $9
          model: $10
          hw.parent.type: enclosure
          hw.parent.id: $5
          name: "${awk::sprintf(\"%s (%s - %s)\", $3, $9, bytes2HumanFormatBase10($4))}"
        metrics:
          hw.physical_disk.size: $4
    collect:
      # Collect type = multi-instance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # 
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScDisk
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # JSON Status
            # tableID;ID;status;status
          - type: json2csv
            entryKey: /
            properties: instanceId;status;status
            separator: ;
          # tableid;ID;PatrolStatus;Value;
          - type: translate
            column: 3
            translationTable: "${translation::statusTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        # tableID;ID;PatrolStatus;Value;
        source: "${source::monitors.physical_disk.collect.sources.source(1)}"
        attributes:
          id: $2
        metrics:
          hw.status{hw.type="physical_disk"}: $3
        legacyTextParameters:
          StatusInformation: $4
  power_supply:
    discovery:
      sources:
        source(1):
          # Now we have the token let's perform the PowerSupplies' Discovery
          # source 1 is the enclosure power supplies
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScEnclosurePowerSupply
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # convert from json to Json2Csv
            # tableID;ID;DisplayName;objectType
          - type: json2csv
            entryKey: /
            properties: instanceId;name;objectType
            separator: ;
        source(2):
          # source 2 is the controllers powersupplies.
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScControllerPowerSupply
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # convert from json to Json2Csv
            # tableID;ID;DisplayName;objectType
          - type: json2csv
            entryKey: /
            properties: instanceId;name;objectType
            separator: ;
        source(3):
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: list
          url: /api/rest/StorageCenter/ScChassis/$2/PowerSupplyList
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # convert from json to Json2Csv
            # tableID;ID;DisplayName;objectType
          - type: json2csv
            entryKey: /
            properties: instanceId;name;objectType
            separator: ;
        source(4):
          # Source(3) = Union of Source(1) and Source(2) and "3"
          # tableID;ID;DisplayName;objectType
          type: tableUnion
          tables:
          - "${source::monitors.power_supply.discovery.sources.source(1)}"
          - "${source::monitors.power_supply.discovery.sources.source(2)}"
          - "${source::monitors.power_supply.discovery.sources.source(3)}"
          computes:
            # remove empty output
            # tableID;ID;DisplayName;objectType;enclosure/controllerID;deviceType
          - type: excludeMatchingLines
            column: 1
            valueList: /
            # Now pass everything through an awk to attach the powersupply to the correct device
            # tableID;ID;DisplayName;objectType;enclosure/controllerID;deviceType
          - type: awk
            script: "${file::embeddedFile-4}"
          # remove phantoms
          - type: keepOnlyMatchingLines
            column: 2
            regExp: .
      mapping:
        # PowerSupply
        # tableID;ID;DisplayName;objectType;enclosure/controllerID;deviceType
        source: "${source::monitors.power_supply.discovery.sources.source(4)}"
        attributes:
          id: $2
          __display_id: $3
          hw.parent.type: $6
          hw.parent.id: $5
          name: $3
    collect:
      # Collect type = multi-instance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # collect enclosure's power supplies
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScEnclosurePowerSupply
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # JSON Status
            # tableID;ID;status;status
          - type: json2csv
            entryKey: /
            properties: instanceId;status;status
            separator: ;
        source(2):
          # collect controllers' power supplies
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScControllerPowerSupply
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # JSON Status
            # tableID;ID;status;status
          - type: json2csv
            entryKey: /
            properties: instanceId;status;status
            separator: ;
        source(3):
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: list
          url: /api/rest/StorageCenter/ScChassis/$2/PowerSupplyList
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # JSON Status
            # tableID;ID;status;status
          - type: json2csv
            entryKey: /
            properties: instanceId;status;status
            separator: ;
        source(4):
          type: tableUnion
          tables:
          - "${source::monitors.power_supply.collect.sources.source(1)}"
          - "${source::monitors.power_supply.collect.sources.source(2)}"
          - "${source::monitors.power_supply.collect.sources.source(3)}"
          computes:
          # tableid;ID;PatrolStatus;Value;
          - type: translate
            column: 3
            translationTable: "${translation::statusTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        # tableID;ID;PatrolStatus;Value;
        source: "${source::monitors.power_supply.collect.sources.source(4)}"
        attributes:
          id: $2
        metrics:
          hw.status{hw.type="power_supply"}: $3
        legacyTextParameters:
          StatusInformation: $4
  fan:
    discovery:
      sources:
        source(1):
          # Now we have the token let's perform the PowerSupplies' Discovery
          # source 1 is the enclosure fans
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScEnclosureCoolingFanSensor
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # convert from json to Json2Csv
            # tableID;ID;DisplayName;objectType;currentRpm;lowerNormalThreshold;lowerWarningThreshold
          - type: json2csv
            entryKey: /
            properties: instanceId;name;objectType;currentRpm;lowerNormalThreshold;lowerWarningThreshold
            separator: ;
        source(2):
          # source 2 is the controllers fans
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScControllerFanSensor
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # convert from json to Json2Csv
            # tableID;ID;DisplayName;objectType;currentRpm;lowerNormalThreshold;lowerWarningThreshold
          - type: json2csv
            entryKey: /
            properties: instanceId;name;objectType;currentRpm;lowerNormalThreshold;lowerWarningThreshold
            separator: ;
        source(3):
          # now collect from new source
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: list
          url: /api/rest/StorageCenter/ScChassis/$2/FanSensorList
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # convert from json to Json2Csv
            # tableID;ID;DisplayName;objectType;currentRpm;lowerNormalThreshold;lowerWarningThreshold
          - type: json2csv
            entryKey: /
            properties: instanceId;name;objectType;currentRpm;lowerNormalThreshold;lowerWarningThreshold
            separator: ;
        source(4):
          # Source(4) = Union of Source(1) and Source(2) and source 3
          # tableID;ID;DisplayName;objectType;currentRpm;lowerNormalThreshold;lowerWarningThreshold
          type: tableUnion
          tables:
          - "${source::monitors.fan.discovery.sources.source(1)}"
          - "${source::monitors.fan.discovery.sources.source(2)}"
          - "${source::monitors.fan.discovery.sources.source(3)}"
          computes:
            # remove empty output
            # tableID;ID;DisplayName;objectType;enclosure/controllerID;devicetype
          - type: excludeMatchingLines
            column: 1
            valueList: /
            # Now pass everything through an awk to attach the Fan to the correct device
            # and activate status or fan speed parameter
            # tableID;ID;DisplayName;objectType;enclosure/controllerID;devicetype
          - type: awk
            script: "${file::embeddedFile-8}"
          # remove phantoms
          - type: keepOnlyMatchingLines
            column: 2
            regExp: .
      mapping:
        # Fan
        # tableID;ID;DisplayName;objectType;currentRpm;lowerNormalThreshold;lowerWarningThreshold;statusactivation;controllerID;devicetype
        source: "${source::monitors.fan.discovery.sources.source(4)}"
        attributes:
          id: $2
          __display_id: $3
          hw.parent.type: $10
          hw.parent.id: $9
          name: $3
        metrics:
          hw.fan.speed.limit{limit_type="low.degraded"}: $6
          hw.fan.speed.limit{limit_type="low.critical"}: $7
        conditionalCollection:
          hw.fan.speed: $5
          hw.status{hw.type="fan"}: $8
    collect:
      # Collect type = multi-instance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # collect enclosure's fans
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScEnclosureCoolingFanSensor
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # JSON Status
            # tableID;ID;status;status;speed
          - type: json2csv
            entryKey: /
            properties: instanceId;status;status;currentRpm
            separator: ;
        source(2):
          # collect controllers' fans
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScControllerFanSensor
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # JSON Status
            # tableID;ID;status;status;speed
          - type: json2csv
            entryKey: /
            properties: instanceId;status;status;currentRpm
            separator: ;
        source(3):
          # now collect from new source
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: list
          url: /api/rest/StorageCenter/ScChassis/$2/FanSensorList
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # JSON Status
            # tableID;ID;status;status;speed
          - type: json2csv
            entryKey: /
            properties: instanceId;status;status;currentRpm
            separator: ;
        source(4):
          type: tableUnion
          tables:
          - "${source::monitors.fan.collect.sources.source(1)}"
          - "${source::monitors.fan.collect.sources.source(2)}"
          - "${source::monitors.fan.collect.sources.source(3)}"
          computes:
          # tableid;ID;PatrolStatus;Value;speed
          - type: translate
            column: 3
            translationTable: "${translation::statusTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        # tableID;ID;PatrolStatus;Value;Speed
        source: "${source::monitors.fan.collect.sources.source(4)}"
        attributes:
          id: $2
        metrics:
          hw.status{hw.type="fan"}: $3
          hw.fan.speed: $5
        legacyTextParameters:
          StatusInformation: $4
  temperature:
    discovery:
      sources:
        source(1):
          # Now we have the token let's perform the PowerSupplies' Discovery
          # source 1 is the enclosure temperatures
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScEnclosureTemperatureSensor
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # convert from json to Json2Csv
            # we use upperCriticalThreshold and upper warning for enclosure as we don't have upperNormalThreshold as for controllers.
            # tableID;ID;DisplayName;objectType;currentTemperature;location;lowerCriticalThreshold;lowerWarningThreshold;warn;alarm
          - type: json2csv
            entryKey: /
            properties: instanceId;name;objectType;currentTemperature;location;lowerCriticalThreshold;lowerWarningThreshold;upperWarningThreshold;upperCriticalThreshold
            separator: ;
        source(2):
          # source 2 is the controllers temperature sensors.
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScControllerTemperatureSensor
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # convert from json to Json2Csv
            # tableID;ID;DisplayName;objectType;currentTemperature;location;lowerCriticalThreshold;lowerWarningThreshold;warn;alarm
          - type: json2csv
            entryKey: /
            properties: instanceId;name;objectType;currentTemperature;location;lowerCriticalThreshold;lowerWarningThreshold;upperNormalThreshold;upperWarningThreshold
            separator: ;
        source(3):
          # let's merge both sources.
          # Source(3) = Union of Source(1) and Source(2)
          # tableID;ID;DisplayName;objectType;currentTemperature;location;lowerCriticalThreshold;lowerWarningThreshold;upperNormalThreshold;upperWarningThreshold
          type: tableUnion
          tables:
          - "${source::monitors.temperature.discovery.sources.source(1)}"
          - "${source::monitors.temperature.discovery.sources.source(2)}"
          computes:
            # Now pass everything through an awk to attach the Temperature to the correct device
            # and extract the correct temperature
            # tableID;ID;DisplayName;objectType;currentTemperature;location;lowerCriticalThreshold;lowerWarningThreshold;warning;alarm;enclosure/controllerID;devicetype
          - type: awk
            script: "${file::embeddedFile-5}"
            # remove empty output
            # tableID;ID;DisplayName;objectType;currentTemperature;location;lowerCriticalThreshold;lowerWarningThreshold;warning;alarm;enclosure/controllerID;devicetype
          - type: excludeMatchingLines
            column: 1
            valueList: /
      mapping:
        # Temperature
        # tableID;ID;DisplayName;objectType;currentTemperature;location;lowerCriticalThreshold;lowerWarningThreshold;warning;alarm;deviceType
        source: "${source::monitors.temperature.discovery.sources.source(3)}"
        attributes:
          id: $2
          __display_id: $3
          sensor_location: $6
          hw.parent.type: $12
          hw.parent.id: $11
          name: "${awk::sprintf(\"%s (%s)\", $3, $6)}"
        metrics:
          hw.temperature.limit{limit_type="high.critical"}: $10
          hw.temperature.limit{limit_type="high.degraded"}: $9
    collect:
      # Collect type = multi-instance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # collect enclosure's temperature
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScEnclosureTemperatureSensor
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # JSON Status
            # tableID;ID;DisplayName;objectType;currentTemperature;location;lowerCriticalThreshold;lowerWarningThreshold;upperNormalThreshold;upperWarningThresholdD
          - type: json2csv
            entryKey: /
            properties: instanceId;name;objectType;currentTemperature;location;lowerCriticalThreshold;lowerWarningThreshold;upperNormalThreshold;upperWarningThreshold
            separator: ;
        source(2):
          # collect controllers' temperature sensors
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScControllerTemperatureSensor
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # JSON Status
            # tableID;ID;DisplayName;objectType;currentTemperature;location;lowerCriticalThreshold;lowerWarningThreshold;upperNormalThreshold;upperWarningThresholdD
          - type: json2csv
            entryKey: /
            properties: instanceId;name;objectType;currentTemperature;location;lowerCriticalThreshold;lowerWarningThreshold;upperNormalThreshold;upperWarningThreshold
            separator: ;
        source(3):
          # now join both
          # tableID;ID;DisplayName;objectType;currentTemperature;location;lowerCriticalThreshold;lowerWarningThreshold;upperNormalThreshold;upperWarningThresholdD
          type: tableUnion
          tables:
          - "${source::monitors.temperature.collect.sources.source(1)}"
          - "${source::monitors.temperature.collect.sources.source(2)}"
          computes:
          # tableID;ID;DisplayName;objectType;currentTemperature;location;lowerCriticalThreshold;lowerWarningThreshold;upperNormalThreshold;upperWarningThresholdD
          - type: awk
            script: "${file::embeddedFile-5}"
      mapping:
        # ValueTable = Source(1)
        # tableID;ID;DisplayName;objectType;currentTemperature;location;lowerCriticalThreshold;lowerWarningThreshold;upperNormalThreshold;upperWarningThresholdD
        source: "${source::monitors.temperature.collect.sources.source(3)}"
        attributes:
          id: $2
        metrics:
          hw.temperature: $5
  voltage:
    discovery:
      sources:
        source(1):
          # Now we have the token let's perform the Volage sensors' Discovery
          # source 1 is the controllers voltage sensors
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScControllerVoltageSensor
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # convert from json to Json2Csv
            # tableID;instanceId;name;objectType;currentVoltage;status;upperNormalThreshold;lowerNormalThreshold
          - type: json2csv
            entryKey: /
            properties: instanceId;name;objectType;currentVoltage;status;upperNormalThreshold;lowerNormalThreshold
            separator: ;
            # awk everything to have status activated if sensors!=null and deduct controller id
            # tableID;instanceId;name;objectType;currentVoltage;status;upperNormalThreshold;lowerCriticalThreshold;controllerID;devicetype
          - type: awk
            script: "${file::embeddedFile-6}"
            # remove empty output
            # tableID;instanceId;name;objectType;currentVoltage;status;upperNormalThreshold;lowerCriticalThreshold;controllerID;devicetype
          - type: excludeMatchingLines
            column: 1
            valueList: /
      mapping:
        # tableID;instanceId;name;objectType;currentVoltage;status;upperNormalThreshold;lowerNormalThreshold;controllerID;devicetype
        source: "${source::monitors.voltage.discovery.sources.source(1)}"
        attributes:
          id: $2
          __display_id: $3
          hw.parent.type: $10
          hw.parent.id: $9
          name: $3
        metrics:
          hw.voltage.limit{limit_type="low.critical"}: $8
          hw.voltage.limit{limit_type="high.degraded"}: $7
        conditionalCollection:
          hw.voltage: $5
          hw.status{hw.type="voltage"}: $6
    collect:
      # Collect type = multi-instance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # source 1 is controller voltage sensors
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScControllerVoltageSensor
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # convert from json to Json2Csv
            # tableID;instanceId;status;status;currentVoltage
          - type: json2csv
            entryKey: /
            properties: instanceId;status;status;currentVoltage
            separator: ;
          # tableid;ID;PatrolStatus;Value;currentVoltage
          - type: translate
            column: 3
            translationTable: "${translation::statusTranslationTable}"
            # pass the value from volt to mv
            # tableid;ID;PatrolStatus;Value;currentVoltage
          - type: multiply
            column: 5
            value: 1000
      mapping:
        # ValueTable = Source(1)
        # tableid;ID;PatrolStatus;Value;currentVoltage
        source: "${source::monitors.voltage.collect.sources.source(1)}"
        attributes:
          id: $2
        metrics:
          hw.status{hw.type="voltage"}: $3
          hw.voltage: $5
        legacyTextParameters:
          StatusInformation: $4
  other_device:
    discovery:
      sources:
        source(1):
          # Now we have the token let's perform the Cache cards and IoModules Discovery
          # source 1 is the enclosure IO Modules
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScEnclosureIoModule
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # convert from json to Json2Csv
            # tableID;ID;DisplayName;objectType
          - type: json2csv
            entryKey: /
            properties: instanceId;name;objectType
            separator: ;
        source(2):
          # source 2 is the controllers cache cards
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScControllerCacheCard
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # convert from json to Json2Csv
            # tableID;ID;DisplayName;objectType
          - type: json2csv
            entryKey: /
            properties: instanceId;name;objectType
            separator: ;
        source(3):
          # source 2 is the enclosure audible alarms
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScEnclosureAudibleAlarm
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # convert from json to Json2Csv
            # tableID;ID;DisplayName;objectType
          - type: json2csv
            entryKey: /
            properties: instanceId;name;objectType
            separator: ;
        source(4):
          # Source(3) = Union of Source(1) and Source(2)
          # tableID;ID;DisplayName;objectType
          type: tableUnion
          tables:
          - "${source::monitors.other_device.discovery.sources.source(1)}"
          - "${source::monitors.other_device.discovery.sources.source(2)}"
          - "${source::monitors.other_device.discovery.sources.source(3)}"
          computes:
            # Now pass everything through an awk to attach theOtherDevice to the correct device
            # tableID;ID;DisplayName;objectType;enclosure/controllerID;devicetype
          - type: awk
            script: "${file::embeddedFile-4}"
            # remove empty output
            # tableID;ID;DisplayName;objectType;enclosure/controllerID;devicetype
          - type: excludeMatchingLines
            column: 1
            valueList: /
      mapping:
        # OtherDevice
        # tableID;ID;DisplayName;objectType;enclosure/controllerID;deviceType
        source: "${source::monitors.other_device.discovery.sources.source(4)}"
        attributes:
          id: $2
          __display_id: $3
          device_type: $4
          hw.parent.type: $6
          hw.parent.id: $5
          name: "${awk::sprintf(\"%s: %s\", $4, $3)}"
    collect:
      # Collect type = multi-instance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # collect enclosure's IoModules
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScEnclosureIoModule
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # JSON Status
            # tableID;ID;status;status
          - type: json2csv
            entryKey: /
            properties: instanceId;status;status
            separator: ;
        source(2):
          # collect controllers' Cache cards
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScControllerCacheCard
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # JSON Status
            # tableID;ID;status;status
          - type: json2csv
            entryKey: /
            properties: instanceId;status;status
            separator: ;
        source(3):
          # collect audible alarms
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScEnclosureAudibleAlarm
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # JSON Status
            # tableID;ID;status;status;mutedvalue
          - type: json2csv
            entryKey: /
            properties: instanceId;status;status;muted
            separator: ;
            # add the device type to make sure we have a unique ID
            # tableID;ID;status;status;mutedvalue
          - type: leftConcat
            column: 2
            value: ScEnclosureAudibleAlarm
            # add the muted state to the status information
            # tableID;ID;status;status;mutedvalue
          - type: rightConcat
            column: 4
            value: '-'
          # tableID;ID;status;status;mutedvalue
          - type: rightConcat
            column: 4
            value: $5
        source(4):
          # now join 3 sources
          type: tableUnion
          tables:
          - "${source::monitors.other_device.collect.sources.source(1)}"
          - "${source::monitors.other_device.collect.sources.source(2)}"
          - "${source::monitors.other_device.collect.sources.source(3)}"
          computes:
          # tableid;ID;PatrolStatus;Value;
          - type: translate
            column: 3
            translationTable: "${translation::statusTranslationTable}"
      mapping:
        # ValueTable = Source(4)
        # tableID;ID;PatrolStatus;Value;
        source: "${source::monitors.other_device.collect.sources.source(4)}"
        attributes:
          id: $2
        metrics:
          hw.status{hw.type="other_device"}: $3
        legacyTextParameters:
          StatusInformation: $4
  network:
    discovery:
      sources:
        source(1):
          # Now we have the token let's perform the Networkcards' Discovery
          # source 1 is the controllers ports
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScControllerPort
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # convert from json to Json2Csv
            # tableID;instanceId;name;transportType;virtual;wwn;cabled;controller/instanceId;
          - type: json2csv
            entryKey: /
            properties: instanceId;name;transportType;virtual;wwn;cabled;controller/instanceId
            separator: ;
        source(2):
          # Now we have the token let's perform the Networkcards' Discovery
          # source 1 is the controllers ports
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScControllerPortConfiguration
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # convert from json to Json2Csv
            # tableID;instanceId;speed;description;objectType
          - type: json2csv
            entryKey: /
            properties: instanceId;speed;description;objectType
            separator: ;
            # Now pass everything through an awk to determine the port speed.
            # tableID;instanceId;speed;description;
          - type: awk
            script: "${file::embeddedFile-7}"
        source(3):
          # Source(3) = TableJoint of Source(1) and Source(2)
          # /tableID;instanceId;name;transportType;virtual;wwn;cabled;controller/instanceId;tableID;instanceId;speed
          type: tableJoin
          leftTable: "${source::monitors.network.discovery.sources.source(1)}"
          rightTable: "${source::monitors.network.discovery.sources.source(2)}"
          leftKeyColumn: 2
          rightKeyColumn: 2
          defaultRightLine: ;;;;
          computes:
            # Exclude virtual cards
            # /tableID;instanceId;name;transportType;virtual;wwn;cabled;controller/instanceId;tableID;instanceId;speed
          - type: excludeMatchingLines
            column: 5
            valueList: "TRUE"
            # Exclude empty outputs
            # /tableID;instanceId;name;transportType;virtual;wwn;cabled;controller/instanceId;tableID;instanceId;speed
          - type: excludeMatchingLines
            column: 1
            valueList: /
      mapping:
        # tableID;instanceId;name;transportType;virtual;wwn;cabled;controller/instanceId;tableID;instanceId;speed;description
        source: "${source::monitors.network.discovery.sources.source(3)}"
        attributes:
          id: $2
          __display_id: $3
          device_type: $4
          model: $12
          physical_address: $6
          physical_address_type: WWN
          hw.parent.type: blade
          hw.parent.id: $8
          name: "${awk::sprintf(\"%s (%s - %s)\", $3, $4, $12)}"
    collect:
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScControllerPort
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # convert from json to Json2Csv
            # tableID;instanceId;cabled;status;statusMessage;
          - type: json2csv
            entryKey: /
            properties: instanceId;cabled;status;statusMessage
            separator: ;
        source(2):
          # Now we have the token let's perform the Networkcards' Collect
          # source 1 is the controllers ports
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScControllerPortConfiguration
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # convert from json to Json2Csv
            # tableID;instanceId;speed;description;objectType
          - type: json2csv
            entryKey: /
            properties: instanceId;speed;description;objectType
            separator: ;
            # Now pass everything through an awk to determine the port speed.
            # tableID;instanceId;speed;description;
          - type: awk
            script: "${file::embeddedFile-7}"
        source(3):
          # Source(3) = Union of Source(1) and Source(2)
          # tableID;instanceId;cabled;status;statusMessage;tableID;instanceId;speed;description;
          type: tableJoin
          leftTable: "${source::monitors.network.collect.sources.source(1)}"
          rightTable: "${source::monitors.network.collect.sources.source(2)}"
          leftKeyColumn: 2
          rightKeyColumn: 2
          defaultRightLine: ;;;;
          computes:
            # now translate cabled from a boolean to a readable linkstatus
            # tableID;instanceId;cabled;status;statusMessage;tableID;instanceId;speed;description;
          - type: replace
            column: 3
            existingValue: "TRUE"
            newValue: OK
          - type: replace
            column: 3
            existingValue: "FALSE"
            newValue: WARN
            # translate the status
            # tableID;instanceId;cabled;status;statusMessage;tableID;instanceId;speed;description;
          - type: translate
            column: 4
            translationTable: "${translation::statusTranslationTable}"
        source(4):
          type: copy
          from: "${source::monitors.network.collect.sources.source(3)}"
          computes:
          # tableID;instanceId;cabled;status;statusMessage;tableID;instanceId;speed;description;
          - type: keepOnlyMatchingLines
            column: 3
            valueList: WARN
          - type: replace
            column: 4
            existingValue: $4
            newValue: OK
        source(5):
          type: copy
          from: "${source::monitors.network.collect.sources.source(3)}"
          computes:
          # tableID;instanceId;cabled;status;statusMessage;tableID;instanceId;speed;description;
          - type: keepOnlyMatchingLines
            column: 3
            valueList: OK
        source(6):
          type: tableUnion
          tables:
          - "${source::monitors.network.collect.sources.source(4)}"
          - "${source::monitors.network.collect.sources.source(5)}"
      mapping:
        # ValueTable = Source(1)
        # tableID;instanceId;cabled;status;statusMessage;tableID;instanceId;speed;description;
        source: "${source::monitors.network.collect.sources.source(6)}"
        attributes:
          id: $2
        metrics:
          hw.status{hw.type="network"}: $4
          hw.network.bandwidth.limit: megaBit2Bit($8)
          hw.network.up: legacyLinkStatus($3)
        legacyTextParameters:
          StatusInformation: $5
  battery:
    discovery:
      sources:
        source(1):
          # Now we have the token let's perform the UPS' Discovery
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScUps
          header: "${file::embeddedFile-3}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # convert from json to Json2Csv
            # tableID;ID;DisplayName;objectType;enclosure/controllerID;
          - type: json2csv
            entryKey: /
            properties: instanceId;name;Type;scSerialNumber
            separator: ;
            # add device type
            # tableID;ID;DisplayName;objectType;enclosure/controllerID;deviceType
          - type: rightConcat
            column: 5
            value: enclosure
          # Exclude Empty IDs
          - type: excludeMatchingLines
            column: 1
            valueList: /
      mapping:
        # PowerSupply
        # tableID;ID;DisplayName;objectType;enclosure/controllerID;deviceType
        source: "${source::monitors.battery.discovery.sources.source(1)}"
        attributes:
          id: $2
          __display_id: $3
          hw.parent.type: $6
          hw.parent.id: $5
          name: $3
    collect:
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # collect UPS
          type: http
          method: GET
          url: /api/rest/StorageCenter/ScUps
          header: "${file::embeddedFile-1}"
          resultContent: body
          authenticationToken: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # JSON Status
            # tableID;ID;status;status;BatteryLife
          - type: json2csv
            entryKey: /
            properties: instanceId;status;status;BatteryLife
            separator: ;
      mapping:
        # ValueTable = Source(1)
        # tableID;ID;PatrolStatus;Value;BatteryLife
        source: "${source::monitors.battery.collect.sources.source(3)}"
        attributes:
          id: $2
        metrics:
          hw.status{hw.type="battery"}: $3
          hw.battery.time_left: $5
        legacyTextParameters:
          StatusInformation: $4
translations:
  statusTranslationTable:
    Down: failed
    Degraded: degraded
    Up: ok
    Default: UNKNOWN
