---
embedded:
  EmbeddedFile(1): |-
    # Awk (or nawk)
    if [ -f /usr/xpg4/bin/awk ]; then
        AWK="/usr/xpg4/bin/awk";
    elif [ -f /usr/bin/nawk ]; then
        AWK="/usr/bin/nawk";
    else
        AWK="awk";
    fi
    if [ -f /opt/StorMan/arcconf ]; then
           STORMAN="/opt/StorMan";
    elif [ -f /usr/StorMan/arcconf ]; then
           STORMAN="/usr/StorMan";
    else
        echo No Storman Installed; exit;
    fi
    DEVICES=`%{SUDO:/[opt|usr]/StorMan/arcconf} $STORMAN/arcconf getversion | $AWK '($1 ~ /Controller/ && $2 ~ /#[0-9]/) {controller=$2;gsub(/#/,"",controller);print(controller)}'`
    for CTRL in $DEVICES
                    do
                    echo MSHWController $CTRL
                    %{SUDO:/[opt|usr]/StorMan/arcconf} $STORMAN/arcconf getconfig $CTRL PD
                    done
  EmbeddedFile(3): |-
    # Awk (or nawk)
    if [ -f /usr/xpg4/bin/awk ]; then
        AWK="/usr/xpg4/bin/awk";
    elif [ -f /usr/bin/nawk ]; then
        AWK="/usr/bin/nawk";
    else
        AWK="awk";
    fi
    if [ -f /opt/StorMan/arcconf ]; then
           STORMAN="/opt/StorMan";
    elif [ -f /usr/StorMan/arcconf ]; then
           STORMAN="/usr/StorMan";
    else
        echo No Storman Installed; exit;
    fi
    DEVICES=`%{SUDO:/[opt|usr]/StorMan/arcconf} $STORMAN/arcconf getversion | $AWK '($1 ~ /Controller/ && $2 ~ /#[0-9]/) {controller=$2;gsub(/#/,"",controller);print(controller)}'`
    for CTRL in $DEVICES
                    do
                    echo MSHWController $CTRL
                    %{SUDO:/[opt|usr]/StorMan/arcconf} $STORMAN/arcconf getconfig $CTRL AD
                    done
  EmbeddedFile(2): |-
    BEGIN {controllerID="";deviceID="";hardDriveID="";status="";location="";vendor="";model="";firmware="";serialNumber="";size="";channel="";}
     $1 ~ /MSHWController/ {controllerID=$2};

    $1 ~/[Dd]evice/ && $2 ~ /#[0-9]/ {deviceID=(controllerID"-"$2);gsub(/#/,"",deviceID);
                                        getline;
                                        if ( $(NF-1) ~ /[Hh]ard/ && $NF ~ /[Dd]rive/ ) {hardDriveID = deviceID};
                                       }

    $1 ~ /[Ss]tate/ && hardDriveID != "" {status=tolower($3)}

    $1 ~ /[Ss]upported/ && hardDriveID != "" && $NF ~ /[Nn]o/ {status="Unsupported"}

    $1 ~ /[Rr]eported/ && $2 ~ /[Ll]ocation/ {colonIndex = index($0, ":") ;
                                                location = ("Controller: "controllerID","substr($0, colonIndex + 1)) ;
                                               }

    $1 ~ /[Rr]eported/ && $2 ~ /[Ee]nclosure/ {colonIndex = index($0, ":") ;
                                                 enclosureSlot = substr($0, colonIndex + 2) ;
                                                 commaIndex = index(enclosureSlot, ",") ;
                                                 enclosure = substr(enclosureSlot,1,commaIndex-1) ;
                                                 slot = substr(enclosureSlot,commaIndex + 1) ;
                                                 location = ("Enclosure: " enclosure " - Location: " slot) ;
                                                }

    $1 ~ /[Rr]eported/ && $2 ~ /[Cc]hannel/ {  fullLine=$0 ;
                                               gsub("\(T:L\)","",fullLine);
                                                colonIndex = index(fullLine, ":") ;
                                                channelDevice = substr(fullLine, colonIndex + 2) ;
                                                commaIndex = index(channelDevice, ",") ;
                                                channel = substr(channelDevice,1,commaIndex-1) ;
                                                device = substr(channelDevice,commaIndex + 1) ;
                                                channel = ("Channel: " channel " - Device: " device) ;
                                               }

    $1 ~ /[Vv]endor/ {colonIndex = index($0, ":") ;
                        vendor = substr($0, colonIndex + 2) ;
                       }

    $1 ~ /[Mm]odel/  {colonIndex = index($0, ":") ;
                        model = substr($0, colonIndex + 2) ;
                       }

    $1 ~ /[Ff]irmware/  {colonIndex = index($0, ":") ;
                           firmware = substr($0, colonIndex + 2) ;
                          }

    $1 ~ /[Ss]erial/ && $2 ~ /[Nn]umber/ {colonIndex = index($0, ":") ;
                                            serialNumber = substr($0, colonIndex + 2) ;
                                           }

    ($1 ~ /^[Ss]ize/ || $1 ~ /^Total/) && $NF ~ /[TtGgMm][Bb]/ && hardDriveID != "" {size=$(NF-1);
        if ($NF ~ /[Mm][Bb]/) {size = size / 1024};
      if ($NF ~ /[Tt][Bb]/) {size = size * 1024};
        print("MSHW;"controllerID";"hardDriveID";"status";"location";"vendor";"model";"firmware";"serialNumber";"size";"channel";");
        deviceID="";hardDriveID="";status="";location="";vendor="";model="";firmware="";serialNumber="";size="";channel="";
                                                                   }
  EmbeddedFile(5): |-
    # Awk (or nawk)
    if [ -f /usr/xpg4/bin/awk ]; then
        AWK="/usr/xpg4/bin/awk";
    elif [ -f /usr/bin/nawk ]; then
        AWK="/usr/bin/nawk";
    else
        AWK="awk";
    fi
    if [ -f /opt/StorMan/arcconf ]; then
           STORMAN="/opt/StorMan";
    elif [ -f /usr/StorMan/arcconf ]; then
           STORMAN="/usr/StorMan";
    else
        echo No Storman Installed; exit;
    fi
    DEVICES=`%{SUDO:/[opt|usr]/StorMan/arcconf} $STORMAN/arcconf getversion | $AWK '($1 ~ /Controller/ && $2 ~ /#[0-9]/) {controller=$2;gsub(/#/,"",controller);print(controller)}'`
    for CTRL in $DEVICES
                    do
                    echo MSHWController $CTRL
                    %{SUDO:/[opt|usr]/StorMan/arcconf} $STORMAN/arcconf getconfig $CTRL LD
                    done
  EmbeddedFile(4): |-
    BEGIN {controllerID="";status="";model="";serial="";memory="";firmware="";driver="";batteryStatus="";}
    $1 ~ /MSHWController/ {if (controllerID != "") {print ("MSHW;"controllerID";"status";"model";"serial";"slot";"memory";"firmware";"driver";"batteryStatus";");
                                                      controllerID="";status="";model="";serial="";memory="";firmware="";driver="";batteryStatus="";
                                                     }
                             controllerID=$2};

    $1 ~ /[Cc]ontroller/ && $2 ~ /[Ss]tatus/ {status=tolower($4);if (NF > 4) {status=status " " tolower($5) }}

    $1 ~ /[Cc]ontroller/ && $2 ~ /[Mm]odel/  {colonIndex = index($0, ":") ;
                                                model = substr($0, colonIndex + 2) ;
                                               }

    $1 ~ /[Cc]ontroller/ && $2 ~ /[Ss]erial/ {colonIndex = index($0, ":") ;
                                                serial = substr($0, colonIndex + 2) ;
                                               }

    $1 ~ /[Pp]hysical/ && $2 ~ /[Ss]lot/     {slot = "Location: " $NF}

    $1 ~ /[Ii]nstalled/ && $2 ~ /[Mm]emory/  {colonIndex = index($0, ":") ;
                                                memory = "Memory: " substr($0, colonIndex + 2) ;
                                               }

    $1 ~ /[Ff]irmware/ {colonIndex = index($0, ":") ;
                          firmware = substr($0, colonIndex + 2) ;
                         }

    $1 ~ /[Dd]river/   {colonIndex = index($0, ":") ;
                          driver = substr($0, colonIndex + 2) ;
                         }

    $1 ~ /[Ss]tatus/   {batteryStatus=tolower($3);
                          if (NF > 3) {batteryStatus=batteryStatus " " tolower($4) };
                          if (batteryStatus ~ /not installed/) {batteryStatus=""};
                          getline;
                          if ($1 ~ /[Oo]ver/ && $2 ~ /[Tt]emperature/ && $NF ~ /[Yy]es/ && batteryStatus!="") {batteryStatus="over temperature";}
                         }

    END {print ("MSHW;"controllerID";"status";"model";"serial";"slot";"memory";"firmware";"driver";"batteryStatus";");}
  EmbeddedFile(6): |-
    BEGIN {controllerID="";logicaldriveID="";logicaldriveName="";status="";size="";raidLevel="";statusInfo="";
            }
    $1 ~ /MSHWController/ {controllerID=$2};

    $1 ~ /[Ll]ogical/ && $2 ~ /([Dd]evice)|([Dd]rive)/ && $3 ~ /[Nn]umber/ {logicaldriveID=controllerID "-" $NF}

    $1 ~ /[Ll]ogical/ && $2 ~ /[Dd]evice|([Dd]rive)/ && $3 ~ /[Nn]ame/   {logicaldriveName=$NF}

    tolower($1) ~ /raid/ && $2 ~ /[Ll]evel/ {raidLevel=$NF}

    $1 ~/[Ss]tatus/ && $3 ~ /[Ll]ogical/ && $4 ~ /[Dd]evice|([Dd]rive)/ {status=tolower($6); gsub(/,/,"",status);
                                                                           colonIndex = index($0, ":") ;
                                                                           statusInfo = substr($0, colonIndex + 2) ;
                                                                          }

    $1 ~ /[Ss]ize/ && $NF ~ /[TtGgMm][Bb]/ {size=$(NF-1);
                                              if ($NF ~ /[Mm][Bb]/) {size = size / 1024};
                                            if ($NF ~ /[Tt][Bb]/) {size = size * 1024};
                                            print ("MSHW;"controllerID";"logicaldriveID";"logicaldriveName";"status";"size";"raidLevel";"statusInfo";");
                                            logicaldriveID="";logicaldriveName="";status="";size="";raidLevel="";statusInfo="";
                                           }
translations:
  DiskStatusTranslationTable:
    okay: ok
    inaccessible: failed
    raw: ok
    rebuilding: degraded
    failed: failed
    down: failed
    offline: failed
    device-error: failed
    default: UNKNOWN
    unsupported: failed
    removed: failed
    ready: ok
    online: ok
    spare: ok
  ControllerBatteryStatusTranslationTable:
    default: UNKNOWN
    discharging: ok
    maintenance mode: degraded
    optimal: ok
    over temperature: failed
    charging: ok
    charging disabled: ok
    failed: failed
    ok: ok
    degraded: degraded
  DiskControllerStatusTranslationTable:
    default: UNKNOWN
    optimal: ok
    warning: degraded
    failed: failed
    ok: ok
    degraded: degraded
  LogicalDiskStatusTranslationTable:
    okay: ok
    inaccessible: failed
    impacted: degraded
    optimal: ok
    standby: ok
    rebuilding: degraded
    partitioned: ok
    failed: failed
    degraded: degraded
    hot: ok
    logical: degraded
    default: UNKNOWN
    ready: ok
    online: ok
    suboptimal: degraded
    uninitialized: ok
connector:
  displayName: Adaptec - StorMan - RAID
  platforms: Any system with Adaptec
  reliesOn: arcconf
  information: Gives information about physical disks and volumes of Adaptec SAS RAID controllers through the arcconf utility.
  version: 1.0
  detection:
    connectionTypes:
    - remote
    appliesTo:
    - Solaris
    - Linux
    criteria:
    - type: deviceType
      keep:
      - Solaris
      - SunOS
      - Linux
    # We should find disks attached to one controller
    - type: osCommand
      commandLine: /bin/sh %EmbeddedFile(1)%
      expectedResult: Hard drive
      errorMessage: No Adaptec Controller with Physical Disks attached or not enough rights to execute arcconf.
sudoCommands:
- "/[opt|usr]/StorMan/arcconf"
monitors:
  disk_controller:
    discovery:
      sources:
        source(1):
          type: osCommand
          commandLine: /bin/sh %EmbeddedFile(3)%
          computes:
            # Reformat Source(1) output via EmbeddedFile(4)
            # MSHW;controllerID;status;model;serial;slot;memory;firmware;driver;batteryStatus;
          - type: awk
            script: EmbeddedFile(4)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,4,5,6,7,8,9,10"
      mapping:
        # The InstanceTable
        # controllerID;model;serial;slot;memory;firmware;driver;batteryStatus;
        source: $monitors.disk_controller.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          controller_number: $column(1)
          model: $column(2)
          serial_number: $column(3)
          firmware_version: $column(6)
          driver_version: $column(7)
          info: "join($column(4), $column(5), \" \")"
          hw.parent.type: enclosure
          name: "sprintf(\"Disk Controller: %s (%s)\", $column(1), $column(2))"
    collect:
      # Collect type is "all instances in one shot
      type: multiInstance
      sources:
        source(1):
          # Source(1) = EF4
          type: osCommand
          commandLine: /bin/sh %EmbeddedFile(3)%
          computes:
            # Reformat Source(1) output via EmbeddedFile(4)
            # MSHW;controllerID;status;model;serial;slot;memory;firmware;driver;batteryStatus;
          - type: awk
            script: EmbeddedFile(4)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,10"
            # Translate the Status into a PATROL status
            # controllerID;Patrolstatus;batteryStatus;
          - type: translate
            column: 2
            translationTable: DiskControllerStatusTranslationTable
            # Translate the Status into a PATROL status
            # controllerID;Patrolstatus;PatrolBatteryStatus;
          - type: translate
            column: 3
            translationTable: ControllerBatteryStatusTranslationTable
      mapping:
        # ValueTable = Source(1)
        # controllerID;Patrolstatus;status;PatrolBatteryStatus;batteryStatus;
        source: $monitors.disk_controller.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="disk_controller"}: $column(2)
  physical_disk:
    discovery:
      sources:
        source(1):
          type: osCommand
          commandLine: /bin/sh %EmbeddedFile(1)%
          computes:
            # Reformat Source(1) output via EmbeddedFile(2)
            # MSHW;controllerID;hardDriveID;status;location;vendor;model;firmware;serialNumber;sizeGB;channel;
          - type: awk
            script: EmbeddedFile(2)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,5,6,7,8,9,10,11"
            # Multiply to get Bytes
            # controllerID;hardDriveID;location;vendor;model;firmware;serialNumber;sizeB;channel;
          - type: multiply
            column: 8
            value: 1073741824
      mapping:
        # The InstanceTable
        # controllerID;hardDriveID;location;vendor;model;firmware;serialNumber;sizeB;channel;
        source: $monitors.physical_disk.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          vendor: $column(4)
          model: $column(5)
          serial_number: $column(7)
          info: "join($column(3), $column(9), \" \")"
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $column(1))"
          name: "sprintf(\"%s (%s - %s)\", $column(2), $column(5), $column(8))"
        metrics:
          hw.physical_disk.size: $column(8)
    collect:
      # Collect type is "all instances in one shot
      type: multiInstance
      sources:
        source(1):
          # Source(1) = EF1
          type: osCommand
          commandLine: /bin/sh %EmbeddedFile(1)%
          computes:
            # Reformat Source(1) output via EmbeddedFile(2)
            # MSHW;controllerID;hardDriveID;status;location;vendor;model;firmware;serialNumber;sizeGB;Channel;
          - type: awk
            script: EmbeddedFile(2)
            keep: ^MSHW;
            separators: ;
            selectColumns: "3,4"
            # Duplicate the Status column
            # hardDriveID;Status;Status
          - type: duplicateColumn
            column: 2
            # Remove spaces in the Statys column
            # hardDriveID;Status;Status
          - type: replace
            column: 2
            existingValue: ' '
            newValue: ""
            # Translate the Status into a PATROL status
            # hardDriveID;PATROLStatus;Status
          - type: translate
            column: 2
            translationTable: DiskStatusTranslationTable
      mapping:
        # ValueTable = Source(1)
        source: $monitors.physical_disk.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="physical_disk"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
  logical_disk:
    discovery:
      sources:
        source(1):
          type: osCommand
          commandLine: /bin/sh %EmbeddedFile(5)%
          computes:
            # Reformat Source(1) output via EmbeddedFile(6)
            # MSHW;controllerID;logicaldriveID;logicaldriveName;status;size;raidLevel;statusInfo;
          - type: awk
            script: EmbeddedFile(6)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,6,7"
            # Multiply to get Bytes
            # controllerID;logicaldriveID;logicaldriveName;size;raidLevel;
          - type: multiply
            column: 4
            value: 1073741824
      mapping:
        # The InstanceTable
        # controllerID;logicaldriveID;logicaldriveName;size;raidLevel;
        source: $monitors.logical_disk.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          hw.logical_disk.limit: $column(4)
          raid_level: $column(5)
          __display_id: $column(3)
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $column(1))"
          name: "sprintf(\"%s (%s - %s)\", $column(3), $column(5), $column(4))"
    collect:
      # Collect type is "all instances in one shot
      type: multiInstance
      sources:
        source(1):
          # Source(1) = EF5
          type: osCommand
          commandLine: /bin/sh %EmbeddedFile(5)%
          computes:
            # Reformat Source(1) output via EmbeddedFile(6)
            # MSHW;controllerID;logicaldriveID;logicaldriveName;status;size;raidLevel;statusInfo;
          - type: awk
            script: EmbeddedFile(6)
            keep: ^MSHW;
            separators: ;
            selectColumns: "3,5,8"
            # Translate the Status into a PATROL status
            # logicaldriveID;Patrolstatus;statusInfo;
          - type: translate
            column: 2
            translationTable: LogicalDiskStatusTranslationTable
      mapping:
        # ValueTable = Source(1)
        # logicaldriveID;Patrolstatus;status;
        source: $monitors.logical_disk.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="logical_disk"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
