---
embedded:
  EmbeddedFile(1): "# Awk (or nawk)\nif [ -f /usr/xpg4/bin/awk ]; then\n\tAWK=\"/usr/xpg4/bin/awk\";\nelif [ -f /usr/bin/nawk ]; then\n\tAWK=\"/usr/bin/nawk\";\nelse\n\tAWK=\"awk\";\nfi\nif [ -f /opt/StorMan/arcconf ]; then\n       STORMAN=\"/opt/StorMan\";\nelif [ -f /usr/StorMan/arcconf ]; then\n       STORMAN=\"/usr/StorMan\";\nelse\n\techo No Storman Installed; exit;\nfi\nDEVICES=`%{SUDO:/[opt|usr]/StorMan/arcconf} $STORMAN/arcconf getversion | $AWK '($1 ~ /Controller/ && $2 ~ /#[0-9]/) {controller=$2;gsub(/#/,\"\",controller);print(controller)}'`\nfor CTRL in $DEVICES\n                do\n                echo MSHWController $CTRL\n                %{SUDO:/[opt|usr]/StorMan/arcconf} $STORMAN/arcconf getconfig $CTRL PD\n                done"
  EmbeddedFile(3): "# Awk (or nawk)\nif [ -f /usr/xpg4/bin/awk ]; then\n\tAWK=\"/usr/xpg4/bin/awk\";\nelif [ -f /usr/bin/nawk ]; then\n\tAWK=\"/usr/bin/nawk\";\nelse\n\tAWK=\"awk\";\nfi\nif [ -f /opt/StorMan/arcconf ]; then\n       STORMAN=\"/opt/StorMan\";\nelif [ -f /usr/StorMan/arcconf ]; then\n       STORMAN=\"/usr/StorMan\";\nelse\n\techo No Storman Installed; exit;\nfi\nDEVICES=`%{SUDO:/[opt|usr]/StorMan/arcconf} $STORMAN/arcconf getversion | $AWK '($1 ~ /Controller/ && $2 ~ /#[0-9]/) {controller=$2;gsub(/#/,\"\",controller);print(controller)}'`\nfor CTRL in $DEVICES\n                do\n                echo MSHWController $CTRL\n                %{SUDO:/[opt|usr]/StorMan/arcconf} $STORMAN/arcconf getconfig $CTRL AD\n                done"
  EmbeddedFile(2): "BEGIN {controllerID=\"\";deviceID=\"\";hardDriveID=\"\";status=\"\";location=\"\";vendor=\"\";model=\"\";firmware=\"\";serialNumber=\"\";size=\"\";channel=\"\";}\n $1 ~ /MSHWController/ {controllerID=$2};\n\n$1 ~/[Dd]evice/ && $2 ~ /#[0-9]/ {deviceID=(controllerID\"-\"$2);gsub(/#/,\"\",deviceID);\n\t                                getline;\n\t                                if ( $(NF-1) ~ /[Hh]ard/ && $NF ~ /[Dd]rive/ ) {hardDriveID = deviceID};\n\t                               }\n\n$1 ~ /[Ss]tate/ && hardDriveID != \"\" {status=tolower($3)}\n\n$1 ~ /[Ss]upported/ && hardDriveID != \"\" && $NF ~ /[Nn]o/ {status=\"Unsupported\"}\n\n$1 ~ /[Rr]eported/ && $2 ~ /[Ll]ocation/ {colonIndex = index($0, \":\") ;\n\t                                        location = (\"Controller: \"controllerID\",\"substr($0, colonIndex + 1)) ;\n\t                                       }\n\n$1 ~ /[Rr]eported/ && $2 ~ /[Ee]nclosure/ {colonIndex = index($0, \":\") ;\n\t                                         enclosureSlot = substr($0, colonIndex + 2) ;\n\t                                         commaIndex = index(enclosureSlot, \",\") ;\n\t                                         enclosure = substr(enclosureSlot,1,commaIndex-1) ;\n\t                                         slot = substr(enclosureSlot,commaIndex + 1) ;\n\t                                         location = (\"Enclosure: \" enclosure \" - Location: \" slot) ;\n\t                                        }\n\n$1 ~ /[Rr]eported/ && $2 ~ /[Cc]hannel/ {  fullLine=$0 ;\n                                           gsub(\"\\(T:L\\)\",\"\",fullLine);\n                                            colonIndex = index(fullLine, \":\") ;\n\t                                        channelDevice = substr(fullLine, colonIndex + 2) ;\n\t                                        commaIndex = index(channelDevice, \",\") ;\n\t                                        channel = substr(channelDevice,1,commaIndex-1) ;\n\t                                        device = substr(channelDevice,commaIndex + 1) ;\n\t                                        channel = (\"Channel: \" channel \" - Device: \" device) ;\n\t                                       }\n\n$1 ~ /[Vv]endor/ {colonIndex = index($0, \":\") ;\n\t                vendor = substr($0, colonIndex + 2) ;\n\t               }\n\n$1 ~ /[Mm]odel/  {colonIndex = index($0, \":\") ;\n\t                model = substr($0, colonIndex + 2) ;\n\t               }\n\n$1 ~ /[Ff]irmware/  {colonIndex = index($0, \":\") ;\n\t                   firmware = substr($0, colonIndex + 2) ;\n\t                  }\n\n$1 ~ /[Ss]erial/ && $2 ~ /[Nn]umber/ {colonIndex = index($0, \":\") ;\n\t                                    serialNumber = substr($0, colonIndex + 2) ;\n\t                                   }\n\n($1 ~ /^[Ss]ize/ || $1 ~ /^Total/) && $NF ~ /[TtGgMm][Bb]/ && hardDriveID != \"\" {size=$(NF-1);\n\tif ($NF ~ /[Mm][Bb]/) {size = size / 1024};\n  if ($NF ~ /[Tt][Bb]/) {size = size * 1024};\n\tprint(\"MSHW;\"controllerID\";\"hardDriveID\";\"status\";\"location\";\"vendor\";\"model\";\"firmware\";\"serialNumber\";\"size\";\"channel\";\");\n\tdeviceID=\"\";hardDriveID=\"\";status=\"\";location=\"\";vendor=\"\";model=\"\";firmware=\"\";serialNumber=\"\";size=\"\";channel=\"\";\n\t                                                           }"
  EmbeddedFile(5): "# Awk (or nawk)\nif [ -f /usr/xpg4/bin/awk ]; then\n\tAWK=\"/usr/xpg4/bin/awk\";\nelif [ -f /usr/bin/nawk ]; then\n\tAWK=\"/usr/bin/nawk\";\nelse\n\tAWK=\"awk\";\nfi\nif [ -f /opt/StorMan/arcconf ]; then\n       STORMAN=\"/opt/StorMan\";\nelif [ -f /usr/StorMan/arcconf ]; then\n       STORMAN=\"/usr/StorMan\";\nelse\n\techo No Storman Installed; exit;\nfi\nDEVICES=`%{SUDO:/[opt|usr]/StorMan/arcconf} $STORMAN/arcconf getversion | $AWK '($1 ~ /Controller/ && $2 ~ /#[0-9]/) {controller=$2;gsub(/#/,\"\",controller);print(controller)}'`\nfor CTRL in $DEVICES\n                do\n                echo MSHWController $CTRL\n                %{SUDO:/[opt|usr]/StorMan/arcconf} $STORMAN/arcconf getconfig $CTRL LD\n                done"
  EmbeddedFile(4): "BEGIN {controllerID=\"\";status=\"\";model=\"\";serial=\"\";memory=\"\";firmware=\"\";driver=\"\";batteryStatus=\"\";}\n$1 ~ /MSHWController/ {if (controllerID != \"\") {print (\"MSHW;\"controllerID\";\"status\";\"model\";\"serial\";\"slot\";\"memory\";\"firmware\";\"driver\";\"batteryStatus\";\");\n\t                                              controllerID=\"\";status=\"\";model=\"\";serial=\"\";memory=\"\";firmware=\"\";driver=\"\";batteryStatus=\"\";\n\t                                             }\n\t                     controllerID=$2};\n\n$1 ~ /[Cc]ontroller/ && $2 ~ /[Ss]tatus/ {status=tolower($4);if (NF > 4) {status=status \" \" tolower($5) }}\n\n$1 ~ /[Cc]ontroller/ && $2 ~ /[Mm]odel/  {colonIndex = index($0, \":\") ;\n\t                                        model = substr($0, colonIndex + 2) ;\n\t                                       }\n\n$1 ~ /[Cc]ontroller/ && $2 ~ /[Ss]erial/ {colonIndex = index($0, \":\") ;\n\t                                        serial = substr($0, colonIndex + 2) ;\n\t                                       }\n\n$1 ~ /[Pp]hysical/ && $2 ~ /[Ss]lot/     {slot = \"Location: \" $NF}\n\n$1 ~ /[Ii]nstalled/ && $2 ~ /[Mm]emory/  {colonIndex = index($0, \":\") ;\n\t                                        memory = \"Memory: \" substr($0, colonIndex + 2) ;\n\t                                       }\n\n$1 ~ /[Ff]irmware/ {colonIndex = index($0, \":\") ;\n\t                  firmware = substr($0, colonIndex + 2) ;\n\t                 }\n\n$1 ~ /[Dd]river/   {colonIndex = index($0, \":\") ;\n\t                  driver = substr($0, colonIndex + 2) ;\n\t                 }\n\n$1 ~ /[Ss]tatus/   {batteryStatus=tolower($3);\n\t                  if (NF > 3) {batteryStatus=batteryStatus \" \" tolower($4) };\n\t                  if (batteryStatus ~ /not installed/) {batteryStatus=\"\"};\n\t                  getline;\n\t                  if ($1 ~ /[Oo]ver/ && $2 ~ /[Tt]emperature/ && $NF ~ /[Yy]es/ && batteryStatus!=\"\") {batteryStatus=\"over temperature\";}\n\t                 }\n\nEND {print (\"MSHW;\"controllerID\";\"status\";\"model\";\"serial\";\"slot\";\"memory\";\"firmware\";\"driver\";\"batteryStatus\";\");}"
  EmbeddedFile(6): "BEGIN {controllerID=\"\";logicaldriveID=\"\";logicaldriveName=\"\";status=\"\";size=\"\";raidLevel=\"\";statusInfo=\"\";\n\t    }\n$1 ~ /MSHWController/ {controllerID=$2};\n\n$1 ~ /[Ll]ogical/ && $2 ~ /([Dd]evice)|([Dd]rive)/ && $3 ~ /[Nn]umber/ {logicaldriveID=controllerID \"-\" $NF}\n\n$1 ~ /[Ll]ogical/ && $2 ~ /[Dd]evice|([Dd]rive)/ && $3 ~ /[Nn]ame/   {logicaldriveName=$NF}\n\ntolower($1) ~ /raid/ && $2 ~ /[Ll]evel/ {raidLevel=$NF}\n\n$1 ~/[Ss]tatus/ && $3 ~ /[Ll]ogical/ && $4 ~ /[Dd]evice|([Dd]rive)/ {status=tolower($6); gsub(/,/,\"\",status);\n\t                                                                   colonIndex = index($0, \":\") ;\n\t                                                                   statusInfo = substr($0, colonIndex + 2) ;\n\t                                                                  }\n\n$1 ~ /[Ss]ize/ && $NF ~ /[TtGgMm][Bb]/ {size=$(NF-1);\n\t                                      if ($NF ~ /[Mm][Bb]/) {size = size / 1024};\n                                        if ($NF ~ /[Tt][Bb]/) {size = size * 1024};\n                                        print (\"MSHW;\"controllerID\";\"logicaldriveID\";\"logicaldriveName\";\"status\";\"size\";\"raidLevel\";\"statusInfo\";\");\n                                        logicaldriveID=\"\";logicaldriveName=\"\";status=\"\";size=\"\";raidLevel=\"\";statusInfo=\"\";\n                                       }"
translations:
  DiskStatusTranslationTable:
    okay: "ok"
    inaccessible: "failed"
    raw: "ok"
    rebuilding: "degraded"
    failed: "failed"
    down: "failed"
    offline: "failed"
    device-error: "failed"
    default: "UNKNOWN"
    unsupported: "failed"
    removed: "failed"
    ready: "ok"
    online: "ok"
    spare: "ok"
  ControllerBatteryStatusTranslationTable:
    default: "UNKNOWN"
    discharging: "ok"
    maintenance mode: "degraded"
    optimal: "ok"
    over temperature: "failed"
    charging: "ok"
    charging disabled: "ok"
    failed: "failed"
    ok: "ok"
    degraded: "degraded"
  DiskControllerStatusTranslationTable:
    default: "UNKNOWN"
    optimal: "ok"
    warning: "degraded"
    failed: "failed"
    ok: "ok"
    degraded: "degraded"
  LogicalDiskStatusTranslationTable:
    okay: "ok"
    inaccessible: "failed"
    impacted: "degraded"
    optimal: "ok"
    standby: "ok"
    rebuilding: "degraded"
    partitioned: "ok"
    failed: "failed"
    degraded: "degraded"
    hot: "ok"
    logical: "degraded"
    default: "UNKNOWN"
    ready: "ok"
    online: "ok"
    suboptimal: "degraded"
    uninitialized: "ok"
connector:
  displayName: "Adaptec - StorMan - RAID"
  platforms: "Any system with Adaptec"
  reliesOn: "arcconf"
  information: "Gives information about physical disks and volumes of Adaptec SAS RAID controllers through the arcconf utility."
  version: "1.0"
  detection:
    connectionTypes:
    - "remote"
    appliesTo:
    - "Solaris"
    - "Linux"
    criteria:
    - type: "deviceType"
      keep:
      - "Solaris"
      - "SunOS"
      - "Linux"
      # We should find disks attached to one controller
    - type: "osCommand"
      commandLine: "/bin/sh %EmbeddedFile(1)%"
      expectedResult: "Hard drive"
      errorMessage: "No Adaptec Controller with Physical Disks attached or not enough rights to execute arcconf."
sudoCommands:
- "/[opt|usr]/StorMan/arcconf"
monitors:
  disk_controller:
    discovery:
      sources:
        source(1):
          type: "osCommand"
          commandLine: "/bin/sh %EmbeddedFile(3)%"
          computes:
            # Reformat Source(1) output via EmbeddedFile(4)
            # MSHW;controllerID;status;model;serial;slot;memory;firmware;driver;batteryStatus;
          - type: "awk"
            script: "EmbeddedFile(4)"
            keep: "^MSHW;"
            separators: ";"
            selectColumns: "2,4,5,6,7,8,9,10"
      mapping:
        # The InstanceTable
        # controllerID;model;serial;slot;memory;firmware;driver;batteryStatus;
        source: "$monitors.disk_controller.discovery.sources.source(1)$"
        attributes:
          id: "$column(1)"
          controller_number: "$column(1)"
          model: "$column(2)"
          serial_number: "$column(3)"
          firmware_version: "$column(6)"
          driver_version: "$column(7)"
          info: "join($column(4), $column(5), \" \")"
          hw.parent.type: "enclosure"
          name: "sprintf(\"%s %s (%s)\"), \"Disk Controller\", $column(1), $column(2))"
    collect:
      # Collect type is \"all instances in one shot\"
      type: "multiInstance"
      sources:
        source(1):
          # Source(1) = EF4
          type: "osCommand"
          commandLine: "/bin/sh %EmbeddedFile(3)%"
          computes:
            # Reformat Source(1) output via EmbeddedFile(4)
            # MSHW;controllerID;status;model;serial;slot;memory;firmware;driver;batteryStatus;
          - type: "awk"
            script: "EmbeddedFile(4)"
            keep: "^MSHW;"
            separators: ";"
            selectColumns: "2,3,10"
            # Translate the Status into a PATROL status
            # controllerID;Patrolstatus;batteryStatus;
          - type: "translate"
            column: 2
            translationTable: "DiskControllerStatusTranslationTable"
            # Translate the Status into a PATROL status
            # controllerID;Patrolstatus;PatrolBatteryStatus;
          - type: "translate"
            column: 3
            translationTable: "ControllerBatteryStatusTranslationTable"
      mapping:
        # ValueTable = Source(1)
        # controllerID;Patrolstatus;status;PatrolBatteryStatus;batteryStatus;
        source: "$monitors.disk_controller.collect.sources.source(1)$"
        deviceId: "$column(1)"
        metrics:
          hw.status{hw.type="disk_controller"}: "$column(2)"
  physical_disk:
    discovery:
      sources:
        source(1):
          type: "osCommand"
          commandLine: "/bin/sh %EmbeddedFile(1)%"
          computes:
            # Reformat Source(1) output via EmbeddedFile(2)
            # MSHW;controllerID;hardDriveID;status;location;vendor;model;firmware;serialNumber;sizeGB;channel;
          - type: "awk"
            script: "EmbeddedFile(2)"
            keep: "^MSHW;"
            separators: ";"
            selectColumns: "2,3,5,6,7,8,9,10,11"
            # Multiply to get Bytes
            # controllerID;hardDriveID;location;vendor;model;firmware;serialNumber;sizeB;channel;
          - type: "multiply"
            column: 8
            value: "1073741824"
      mapping:
        # The InstanceTable
        # controllerID;hardDriveID;location;vendor;model;firmware;serialNumber;sizeB;channel;
        source: "$monitors.physical_disk.discovery.sources.source(1)$"
        attributes:
          id: "$column(2)"
          vendor: "$column(4)"
          model: "$column(5)"
          serial_number: "$column(7)"
          info: "join($column(3), $column(9), \" \")"
          hw.parent.type: "disk_controller"
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $column(1))"
          name: "sprintf(\"%s (%s - %s)\", $column(2), $column(5), $column(8))"
        metrics:
          hw.physical_disk.size: "$column(8)"
    collect:
      # Collect type is \"all instances in one shot\"
      type: "multiInstance"
      sources:
        source(1):
          # Source(1) = EF1
          type: "osCommand"
          commandLine: "/bin/sh %EmbeddedFile(1)%"
          computes:
            # Reformat Source(1) output via EmbeddedFile(2)
            # MSHW;controllerID;hardDriveID;status;location;vendor;model;firmware;serialNumber;sizeGB;Channel;
          - type: "awk"
            script: "EmbeddedFile(2)"
            keep: "^MSHW;"
            separators: ";"
            selectColumns: "3,4"
            # Duplicate the Status column
            # hardDriveID;Status;Status
          - type: "duplicateColumn"
            column: 2
            # Remove spaces in the Statys column
            # hardDriveID;Status;Status
          - type: "replace"
            column: 2
            existingValue: " "
            newValue: ""
            # Translate the Status into a PATROL status
            # hardDriveID;PATROLStatus;Status
          - type: "translate"
            column: 2
            translationTable: "DiskStatusTranslationTable"
      mapping:
        # ValueTable = Source(1)
        source: "$monitors.physical_disk.collect.sources.source(1)$"
        deviceId: "$column(1)"
        metrics:
          hw.status{hw.type="physical_disk"}: "$column(2)"
        legacyTextParameters:
          StatusInformation: "$column(3)"
  logical_disk:
    discovery:
      sources:
        source(1):
          type: "osCommand"
          commandLine: "/bin/sh %EmbeddedFile(5)%"
          computes:
            # Reformat Source(1) output via EmbeddedFile(6)
            # MSHW;controllerID;logicaldriveID;logicaldriveName;status;size;raidLevel;statusInfo;
          - type: "awk"
            script: "EmbeddedFile(6)"
            keep: "^MSHW;"
            separators: ";"
            selectColumns: "2,3,4,6,7"
            # Multiply to get Bytes
            # controllerID;logicaldriveID;logicaldriveName;size;raidLevel;
          - type: "multiply"
            column: 4
            value: "1073741824"
      mapping:
        # The InstanceTable
        # controllerID;logicaldriveID;logicaldriveName;size;raidLevel;
        source: "$monitors.logical_disk.discovery.sources.source(1)$"
        attributes:
          id: "$column(2)"
          hw.logical_disk.limit: "$column(4)"
          raid_level: "$column(5)"
          __display_id: "$column(3)"
          hw.parent.type: "disk_controller"
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $column(1))"
          name: "sprintf(\"%s (%s - %s)\", $column(3), $column(5), $column(4))"
    collect:
      # Collect type is \"all instances in one shot\"
      type: "multiInstance"
      sources:
        source(1):
          # Source(1) = EF5
          type: "osCommand"
          commandLine: "/bin/sh %EmbeddedFile(5)%"
          computes:
            # Reformat Source(1) output via EmbeddedFile(6)
            # MSHW;controllerID;logicaldriveID;logicaldriveName;status;size;raidLevel;statusInfo;
          - type: "awk"
            script: "EmbeddedFile(6)"
            keep: "^MSHW;"
            separators: ";"
            selectColumns: "3,5,8"
            # Translate the Status into a PATROL status
            # logicaldriveID;Patrolstatus;statusInfo;
          - type: "translate"
            column: 2
            translationTable: "LogicalDiskStatusTranslationTable"
      mapping:
        # ValueTable = Source(1)
        # logicaldriveID;Patrolstatus;status;
        source: "$monitors.logical_disk.collect.sources.source(1)$"
        deviceId: "$column(1)"
        metrics:
          hw.status{hw.type="logical_disk"}: "$column(2)"
        legacyTextParameters:
          StatusInformation: "$column(3)"
