---
connector:
  displayName: Oracle/Sun ILOM (SNMP)
  platforms: Oracle/Sun
  reliesOn: Sun/Oracle ILOM SNMP Agent
  version: 1.0
  information: This connector provides hardware monitoring for the Sun/Oracle Blade servers with ILOM cards via SNMP
  detection:
    connectionTypes:
    - remote
    appliesTo:
    - OOB
    - Storage
    supersedes:
    - SunILOMSSH
    criteria:
    - type: snmpGet
      oid: 1.3.6.1.4.1.42.2.70.101.1.1.2.1.5.1
      forceSerialization: true
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Get the Sensor Type table.
          # SensorID;SensorType;SensorClass;
          type: snmpTable
          oid: 1.3.6.1.4.1.42.2.70.101.1.1.6.1
          selectColumns: "ID,1,2"
          forceSerialization: true
        source(2):
          # Get the Sensor Status table.
          # SensorID;Status;
          type: snmpTable
          oid: 1.3.6.1.4.1.42.2.70.101.1.1.2.1
          selectColumns: "ID,3"
          forceSerialization: true
        source(3):
          # Get the LED Status table.
          # SensorID;LEDState;
          type: snmpTable
          oid: 1.3.6.1.4.1.42.2.70.101.1.1.12.1
          selectColumns: "ID,2"
          forceSerialization: true
          computes:
            # Translate the LEDStatus into a Normal Status
            # SensorID;LEDState;
          - type: translate
            column: 2
            translationTable: "${translation::LEDStatusTranslationTable}"
            # Add Columns to match Sensor table (5)
            # SensorID;SensorType;SensorClass;SensorID;LEDState;
          - type: rightConcat
            column: 1
            value: ;;LED;
        source(4):
          # Get the Numeric Sensors table.
          # SensorID;CurrentValue;LowerNC;UpperNC;LowerC;UpperC;Exponent;
          type: snmpTable
          oid: 1.3.6.1.4.1.42.2.70.101.1.1.8.1
          selectColumns: "ID,4,8,9,10,11,2"
          forceSerialization: true
        source(5):
          # Let's build up tables 2,3 and 4 into a single sensor table
          # SensorID;SensorType;SensorClass;SensorID;Status;
          type: tableJoin
          leftTable: "${source::monitors.enclosure.discovery.sources.source(1)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(2)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          defaultRightLine: ;;
        source(6):
          # Combine the Status and LEDStatus tables (Sensors should only be in one, with priority to the LED table)
          # SensorID;SensorType;SensorClass;SensorID;Status;
          type: tableUnion
          tables:
          - "${source::monitors.enclosure.discovery.sources.source(3)}"
          - "${source::monitors.enclosure.discovery.sources.source(5)}"
        source(7):
          # SensorID;SensorType;SensorClass;SensorID;Status;SensorID;CurrentValue;LowerNC;UpperNC;LowerC;UpperC;
          type: tableJoin
          leftTable: "${source::monitors.enclosure.discovery.sources.source(6)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(4)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          defaultRightLine: ;;;;;;;
          computes:
            # Remove extra SensorId
            #      1        2          3         5      7           8       9       10     11     12
            # SensorID;SensorType;SensorClass;Status;CurrentValue;LowerNC;UpperNC;LowerC;UpperC;Exponent;
          - type: keepColumns
            columnNumbers: "1,2,3,5,7,8,9,10,11,12"
        source(8):
          # Get the Sensor FRU list table.
          # SensorID;PhysDesc;ParentID;Class;Name;Firmware;SerialNumber;Manufacturer;Model;
          type: snmpTable
          oid: 1.3.6.1.2.1.47.1.1.1.1
          selectColumns: "ID,2,4,5,7,9,11,12,13"
          forceSerialization: true
        source(9):
          # Now Attach Each Sensor to the FRU info
          # SensorID;PhysDesc;ParentID;Class;Name;Firmware;SerialNumber;Manufacturer;Model;SensorID;SensorType;SensorClass;Status;CurrentValue;LowerNC;UpperNC;LowerC;UpperC;Exponent;
          type: tableJoin
          leftTable: "${source::monitors.enclosure.discovery.sources.source(8)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(7)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          defaultRightLine: ;;;;;;;;;
          computes:
            # Awk the table to process the Sensors
            # MSHW_CLASS;.....
          - type: awk
            script: "${file::embeddedFile-1}"
            keep: ^MSHW
        source(10):
          # Make a copy for Enclosure Discovery
          # MSHW_CLASS;.....
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(9)}"
          computes:
            # Keep Only Enclosure
            # MSHW_ENC;SensorID;Name;Firmware;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;ChassisConsumedPower;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: MSHW_ENC
          - type: leftConcat
            column: 4
            value: "Firmware Version: "
      mapping:
        # Instance Table
        # MSHW_ENC;SensorID;Name;Firmware;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;ChassisConsumedPower;
        source: "${source::monitors.enclosure.discovery.sources.source(10)}"
        attributes:
          id: $2
          __display_id: $3
          vendor: $6
          model: $7
          serial_number: $5
          info: "${awk::join(\" \", $10, $4)}"
          name: "${awk::sprintf(\"Enclosure: %s (%s %s)\", $3, $6, $7)}"
        conditionalCollection:
          hw.status{hw.type="enclosure"}: $8
          hw.enclosure.power: $12
    collect:
      # Collect type is mono-instance
      type: multiInstance
      sources:
        source(1):
          # Get the Sensor Type table.
          # SensorID;SensorType;SensorClass;
          type: snmpTable
          oid: 1.3.6.1.4.1.42.2.70.101.1.1.6.1
          selectColumns: "ID,1,2"
          forceSerialization: true
        source(2):
          # Get the Sensor Status table.
          # SensorID;Status;
          type: snmpTable
          oid: 1.3.6.1.4.1.42.2.70.101.1.1.2.1
          selectColumns: "ID,3"
          forceSerialization: true
        source(3):
          # Get the LED Status table.
          # SensorID;State;
          type: snmpTable
          oid: 1.3.6.1.4.1.42.2.70.101.1.1.12.1
          selectColumns: "ID,2"
          forceSerialization: true
          computes:
            # Translate the LEDStatus into a Normal Status
            # SensorID;State;
          - type: translate
            column: 2
            translationTable: "${translation::LEDStatusTranslationTable}"
            # Add Columns to match Sensor table (5)
            # SensorID;SensorType;SensorClass;SensorID;State;
          - type: rightConcat
            column: 1
            value: ;;LED;
        source(4):
          # Get the Numeric Sensors table.
          # SensorID;CurrentValue;LowerNC;UpperNC;LowerC;UpperC;Exponent;
          type: snmpTable
          oid: 1.3.6.1.4.1.42.2.70.101.1.1.8.1
          selectColumns: "ID,4,8,9,10,11,2"
          forceSerialization: true
        source(5):
          # Let's build up tables 2,3 and 4 into a single sensor table
          # SensorID;SensorType;SensorClass;SensorID;Status;
          type: tableJoin
          leftTable: "${source::monitors.enclosure.collect.sources.source(1)}"
          rightTable: "${source::monitors.enclosure.collect.sources.source(2)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          defaultRightLine: ;;
        source(6):
          # Combine the Status and LEDStatus tables (Sensors should only be in one, with priority to the LED table)
          # SensorID;SensorType;SensorClass;SensorID;Status;
          type: tableUnion
          tables:
          - "${source::monitors.enclosure.collect.sources.source(3)}"
          - "${source::monitors.enclosure.collect.sources.source(5)}"
        source(7):
          # SensorID;SensorType;SensorClass;SensorID;Status;SensorID;CurrentValue;LowerNC;UpperNC;LowerC;UpperC;Exponent;
          type: tableJoin
          leftTable: "${source::monitors.enclosure.collect.sources.source(6)}"
          rightTable: "${source::monitors.enclosure.collect.sources.source(4)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          defaultRightLine: ;;;;;;;
          computes:
            # Remove extra SensorId
            #      1        2          3         5      7           8       9       10     11      12
            # SensorID;SensorType;SensorClass;Status;CurrentValue;LowerNC;UpperNC;LowerC;UpperC;Exponent;
          - type: keepColumns
            columnNumbers: "1,2,3,5,7,8,9,10,11,12"
        source(8):
          # Get the Sensor FRU list table.
          # SensorID;PhysDesc;ParentID;Class;Name;Firmware;SerialNumber;Manufacturer;Model;
          type: snmpTable
          oid: 1.3.6.1.2.1.47.1.1.1.1
          selectColumns: "ID,2,4,5,7,9,11,12,13"
          forceSerialization: true
        source(9):
          # Now Attach Each Sensor to the FRU info
          # SensorID;PhysDesc;ParentID;Class;Name;Firmware;SerialNumber;Manufacturer;Model;SensorID;SensorType;SensorClass;Status;CurrentValue;LowerNC;UpperNC;LowerC;UpperC;Exponent;
          type: tableJoin
          leftTable: "${source::monitors.enclosure.collect.sources.source(8)}"
          rightTable: "${source::monitors.enclosure.collect.sources.source(7)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          defaultRightLine: ;;;;;;;;;
          computes:
            # Awk the table to process the Sensors
            # MSHW_CLASS;.....
          - type: awk
            script: "${file::embeddedFile-1}"
            keep: ^MSHW
        source(10):
          # Make a copy for Enclosure Discovery
          # MSHW_CLASS;.....
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(9)}"
          computes:
            # Keep Only Enclosure
            # MSHW_ENC;SensorID;Name;Firmware;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;MSHWNUMERIC[ID];PowerConsumption;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: MSHW_ENC
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # MSHW_ENC;SensorID;Name;Firmware;SerialNumber;Manufacturer;Model;PatrolStatus;StatusInformation;SensorList;MSHWNUMERIC[ID];PowerConsumption;
          - type: arrayTranslate
            column: 8
            translationTable: "${translation::StatusTranslationTable}"
            # Then we consolodate the Status Codes into a Single Status
            # MSHW_ENC;SensorID;Name;Firmware;SerialNumber;Manufacturer;Model;PatrolStatus;StatusInformation;SensorList;MSHWNUMERIC[ID];PowerConsumption;
          - type: convert
            column: 8
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # MSHW_ENC;SensorID;Name;Firmware;SerialNumber;Manufacturer;Model;PatrolStatus;StatusInformation;SensorList;MSHWNUMERIC[ID];PowerConsumption;
        source: "${source::monitors.enclosure.collect.sources.source(10)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="enclosure"}: $8
          hw.enclosure.power: $12
          hw.enclosure.energy: fakeCounter($12)
        legacyTextParameters:
          StatusInformation: $9
  temperature:
    discovery:
      sources:
        source(1):
          # Discovery
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(9)}"
          computes:
            # Keep Only Temperature Sensors
            # MSHW_TEMP;SensorID;Name;CurrentValue;UpperNC;UpperC;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_TEMP
      mapping:
        # InstanceTable = Source(1)
        # MSHW_TEMP;SensorID;Name;CurrentValue;UpperNC;UpperC;Status;StatusInformation;SensorList;
        source: "${source::monitors.temperature.discovery.sources.source(1)}"
        attributes:
          id: $2
          __display_id: $3
          info: $9
          hw.parent.type: enclosure
          name: $3
        metrics:
          hw.temperature.limit{limit_type="high.degraded"}: $5
          hw.temperature.limit{limit_type="high.critical"}: $6
        conditionalCollection:
          hw.temperature: $4
          hw.status{hw.type="temperature"}: $7
    collect:
      # Collect type is mono-instance
      type: multiInstance
      sources:
        source(1):
          # Make a copy for Enclosure Collect
          # MSHW_CLASS;.....
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(9)}"
          computes:
            # Keep Only Enclosure
            # MSHW_TEMP;SensorID;Name;CurrentValue;UpperNC;UpperC;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_TEMP
            # Then we translate Status code into OK/WARN/ALARM (for the Status parameter)
            # MSHW_TEMP;SensorID;Name;CurrentValue;UpperNC;UpperC;Status;StatusInformation;SensorList;
          - type: arrayTranslate
            column: 7
            translationTable: "${translation::StatusTranslationTable}"
            # Then we consolodate the Status Codes into a Single Status
            # MSHW_TEMP;SensorID;Name;CurrentValue;UpperNC;UpperC;Status;StatusInformation;SensorList;
          - type: convert
            column: 7
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # MSHW_TEMP;SensorID;Name;CurrentValue;UpperNC;UpperC;Status;StatusInformation;SensorList;
        source: "${source::monitors.temperature.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.temperature: $4
          hw.status{hw.type="temperature"}: $7
        legacyTextParameters:
          StatusInformation: $8
  fan:
    discovery:
      sources:
        source(1):
          # Discovery
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(9)}"
          computes:
            # Keep Only Fan Sensors
            # MSHW_FAN;SensorID;Name;Status;StatusInformation;SensorList;CurrentValue;LowerNC;LowerC;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_FAN
      mapping:
        # InstanceTable = Source(1)
        # MSHW_FAN;SensorID;Name;Status;StatusInformation;SensorList;CurrentValue;LowerNC;LowerC;
        source: "${source::monitors.fan.discovery.sources.source(1)}"
        attributes:
          id: $2
          __display_id: $3
          info: $6
          hw.parent.type: enclosure
          name: $3
        metrics:
          hw.fan.speed.limit{limit_type="low.degraded"}: $8
          hw.fan.speed.limit{limit_type="low.critical"}: $9
        conditionalCollection:
          hw.fan.speed: $7
          hw.status{hw.type="fan"}: $4
    collect:
      # Collect type is mono-instance
      type: multiInstance
      sources:
        source(1):
          # Make a copy for Enclosure Collect
          # MSHW_CLASS;.....
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(9)}"
          computes:
            # Keep Only Enclosure
            # MSHW_FAN;SensorID;Name;Status;StatusInformation;SensorList;CurrentValue;LowerNC;LowerC;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_FAN
            # Then we translate Status code into OK/WARN/ALARM (for the Status parameter)
            # MSHW_FAN;SensorID;Name;Status;StatusInformation;SensorList;CurrentValue;LowerNC;LowerC;
          - type: arrayTranslate
            column: 4
            translationTable: "${translation::StatusTranslationTable}"
            # Then we consolodate the Status Codes into a Single Status
            # MSHW_FAN;SensorID;Name;Status;StatusInformation;SensorList;CurrentValue;LowerNC;LowerC;
          - type: convert
            column: 4
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # MSHW_FAN;SensorID;Name;Status;StatusInformation;SensorList;CurrentValue;LowerNC;LowerC;
        source: "${source::monitors.fan.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.fan.speed: $7
          hw.status{hw.type="fan"}: $4
        legacyTextParameters:
          StatusInformation: $5
  power_supply:
    discovery:
      sources:
        source(1):
          # Discovery
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(9)}"
          computes:
            # Keep Only PowerSupply Sensors
            # MSHW_PSU;SensorID;Name;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_PSU
          # MSHW_PSU;SensorID;Name;SerialNumber: <serialNumber>;Manufacturer;Model;Status;StatusInformation;SensorList;
          - type: leftConcat
            column: 4
            value: "Serial Number: "
          # MSHW_PSU;SensorID;Name;SerialNumber: <serialNumber>;Manufacturer;Model: <Model>;Status;StatusInformation;SensorList;
          - type: leftConcat
            column: 6
            value: "Model: "
      mapping:
        # InstanceTable = Source(1)
        # MSHW_PSU;SensorID;Name;SerialNumber: <serialNumber>;Manufacturer;Model: <Model>;Status;StatusInformation;Sensor List: <SensorList>;
        source: "${source::monitors.power_supply.discovery.sources.source(1)}"
        attributes:
          id: $2
          __display_id: $3
          info: "${awk::join(\" \", $4, $6, $9)}"
          hw.parent.type: enclosure
          name: $3
    collect:
      # Collect type is mono-instance
      type: multiInstance
      sources:
        source(1):
          # Make a copy for Enclosure Collect
          # MSHW_CLASS;.....
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(9)}"
          computes:
            # Keep Only Enclosure
            # MSHW_PSU;SensorID;Name;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_PSU
            # Then we translate Status code into OK/WARN/ALARM (for the Status parameter)
            # MSHW_PSU;SensorID;Name;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
          - type: arrayTranslate
            column: 7
            translationTable: "${translation::StatusTranslationTable}"
            # Then we consolodate the Status Codes into a Single Status
            # MSHW_PSU;SensorID;Name;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
          - type: convert
            column: 7
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # MSHW_PSU;SensorID;Name;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
        source: "${source::monitors.power_supply.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="power_supply"}: $7
        legacyTextParameters:
          StatusInformation: $8
  voltage:
    discovery:
      sources:
        source(1):
          # Discovery
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(9)}"
          computes:
            # Keep Only Voltage Sensors
            # MSHW_VOLT;SensorID;Name;CurrentValue;LowerNC;UpperNC;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_VOLT
      mapping:
        # InstanceTable = Source(1)
        # MSHW_VOLT;SensorID;Name;CurrentValue;LowerNC;UpperNC;Status;StatusInformation;SensorList;
        source: "${source::monitors.voltage.discovery.sources.source(1)}"
        attributes:
          id: $2
          __display_id: $3
          info: $9
          hw.parent.type: enclosure
          name: $3
        metrics:
          hw.voltage.limit{limit_type="high.degraded"}: $6
          hw.voltage.limit{limit_type="low.critical"}: $5
        conditionalCollection:
          hw.voltage: $4
          hw.status{hw.type="voltage"}: $7
    collect:
      # Collect type is mono-instance
      type: multiInstance
      sources:
        source(1):
          # Make a copy for Enclosure Collect
          # MSHW_CLASS;.....
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(9)}"
          computes:
            # Keep Only Enclosure
            # MSHW_VOLT;SensorID;Name;CurrentValue;LowerNC;UpperNC;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_VOLT
            # Then we translate Status code into OK/WARN/ALARM (for the Status parameter)
            # MSHW_VOLT;SensorID;Name;CurrentValue;LowerNC;UpperNC;Status;StatusInformation;SensorList;
          - type: arrayTranslate
            column: 7
            translationTable: "${translation::StatusTranslationTable}"
            # Then we consolodate the Status Codes into a Single Status
            # MSHW_VOLT;SensorID;Name;CurrentValue;LowerNC;UpperNC;Status;StatusInformation;SensorList;
          - type: convert
            column: 7
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # MSHW_VOLT;SensorID;Name;CurrentValue;LowerNC;UpperNC;Status;StatusInformation;SensorList;
        source: "${source::monitors.voltage.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.voltage: $4
          hw.status{hw.type="voltage"}: $7
        legacyTextParameters:
          StatusInformation: $8
  memory:
    discovery:
      sources:
        source(1):
          # Discovery
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(9)}"
          computes:
            # Keep Only Memory Sensors
            # MSHW_MEM;SensorID;Name;Size;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_MEM
      mapping:
        # InstanceTable = Source(1)
        # MSHW_MEM;SensorID;Name;Size;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
        source: "${source::monitors.memory.discovery.sources.source(1)}"
        attributes:
          id: $2
          __display_id: $3
          vendor: $6
          serial_number: $5
          model: $7
          info: $10
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s - %s MB)\", $3, $6, $4)}"
        metrics:
          hw.memory.limit: mebiByte2Byte($4)
    collect:
      # Collect type is mono-instance
      type: multiInstance
      sources:
        source(1):
          # Make a copy for Enclosure Collect
          # MSHW_CLASS;.....
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(9)}"
          computes:
            # Keep Only Enclosure
            # MSHW_MEM;SensorID;Name;Size;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_MEM
            # Then we translate Status code into OK/WARN/ALARM (for the Status parameter)
            # MSHW_MEM;SensorID;Name;Size;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
          - type: arrayTranslate
            column: 8
            translationTable: "${translation::StatusTranslationTable}"
            # Then we consolodate the Status Codes into a Single Status
            # MSHW_MEM;SensorID;Name;Size;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
          - type: convert
            column: 8
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # MSHW_MEM;SensorID;Name;Size;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
        source: "${source::monitors.memory.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="memory"}: $8
        legacyTextParameters:
          StatusInformation: $9
  cpu:
    discovery:
      sources:
        source(1):
          # Discovery
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(9)}"
          computes:
            # Keep Only CPU Sensors
            # MSHW_CPU;SensorID;Name;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_CPU
      mapping:
        # InstanceTable = Source(1)
        # MSHW_CPU;SensorID;Name;Status;StatusInformation;SensorList;
        source: "${source::monitors.cpu.discovery.sources.source(1)}"
        attributes:
          id: $2
          __display_id: $3
          info: $6
          hw.parent.type: enclosure
          name: $3
    collect:
      # Collect type is mono-instance
      type: multiInstance
      sources:
        source(1):
          # Make a copy for Enclosure Collect
          # MSHW_CLASS;.....
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(9)}"
          computes:
            # Keep Only Enclosure
            # MSHW_CPU;SensorID;Name;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_CPU
            # Then we translate Status code into OK/WARN/ALARM (for the Status parameter)
            # MSHW_CPU;SensorID;Name;Status;StatusInformation;SensorList;
          - type: arrayTranslate
            column: 4
            translationTable: "${translation::StatusTranslationTable}"
            # Then we consolodate the Status Codes into a Single Status
            # MSHW_CPU;SensorID;Name;Status;StatusInformation;SensorList;
          - type: convert
            column: 4
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # MSHW_CPU;SensorID;Name;Status;StatusInformation;SensorList;
        source: "${source::monitors.cpu.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="cpu"}: $4
        legacyTextParameters:
          StatusInformation: $5
  other_device:
    discovery:
      sources:
        source(1):
          # Discovery
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(9)}"
          computes:
            # Keep Only OtherDevice Sensors
            # MSHW_OTHER;PhysDesc;SensorID;Name;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_OTHER
      mapping:
        # InstanceTable = Source(1)
        # MSHW_OTHER;PhysDesc;SensorID;Name;Status;StatusInformation;SensorList;
        source: "${source::monitors.other_device.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          device_type: $2
          info: $7
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s: %s\", $2, $4)}"
    collect:
      # Collect type is mono-instance
      type: multiInstance
      sources:
        source(1):
          # Make a copy for Enclosure Collect
          # MSHW_CLASS;.....
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(9)}"
          computes:
            # Keep Only Enclosure
            # MSHW_OTHER;PhysDesc;SensorID;Name;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_OTHER
            # Then we translate Status code into OK/WARN/ALARM (for the Status parameter)
            # MSHW_OTHER;PhysDesc;SensorID;Name;Status;StatusInformation;SensorList;
          - type: arrayTranslate
            column: 5
            translationTable: "${translation::StatusTranslationTable}"
            # Then we consolodate the Status Codes into a Single Status
            # MSHW_OTHER;PhysDesc;SensorID;Name;Status;StatusInformation;SensorList;
          - type: convert
            column: 5
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # MSHW_OTHER;PhysDesc;SensorID;Name;Status;StatusInformation;SensorList;
        source: "${source::monitors.other_device.collect.sources.source(1)}"
        deviceId: $3
        metrics:
          hw.status{hw.type="other_device"}: $5
        legacyTextParameters:
          StatusInformation: $6
  physical_disk:
    discovery:
      sources:
        source(1):
          # Discovery
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(9)}"
          computes:
            # Keep Only PhysicalDisk Sensors
            # MSHW_PHYDISK;SensorID;Name;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_PHYDISK
      mapping:
        # InstanceTable = Source(1)
        # MSHW_PHYDISK;SensorID;Name;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
        source: "${source::monitors.physical_disk.discovery.sources.source(1)}"
        attributes:
          id: $2
          __display_id: $3
          vendor: $5
          model: $6
          info: $9
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s)\", $3, $5)}"
    collect:
      # Collect type is mono-instance
      type: multiInstance
      sources:
        source(1):
          # Make a copy for Enclosure Collect
          # MSHW_CLASS;.....
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(9)}"
          computes:
            # Keep Only Enclosure
            # MSHW_PHYDISK;SensorID;Name;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_PHYDISK
            # Then we translate Status code into OK/WARN/ALARM (for the Status parameter)
            # MSHW_PHYDISK;SensorID;Name;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
          - type: arrayTranslate
            column: 7
            translationTable: "${translation::StatusTranslationTable}"
            # Then we consolodate the Status Codes into a Single Status
            # MSHW_PHYDISK;SensorID;Name;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
          - type: convert
            column: 7
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # MSHW_PHYDISK;SensorID;Name;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
        source: "${source::monitors.physical_disk.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="physical_disk"}: $7
        legacyTextParameters:
          StatusInformation: $8
translations:
  StatusTranslationTable:
    "1": failed
    "2": failed
    "3": degraded
    "4": failed
    "5": degraded
    "6": degraded
    "7": ok
    Default: UNKNOWN
  LEDStatusTranslationTable:
    "1": ""
    "2": 8
    "3": 9
    "4": 10
    Default: ""
