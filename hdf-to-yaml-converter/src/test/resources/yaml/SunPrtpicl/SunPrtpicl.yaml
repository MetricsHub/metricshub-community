---
connector:
  displayName: Oracle/Sun Solaris - Environment (prtpicl)
  platforms: Oracle/Sun
  reliesOn: "Sun Solaris system commands (prtpicl, etc.)"
  information: "Gives environmental information (temperatures, fans, etc.) on several Sun platforms through the prtpicl utility. This connector is mainly to be used on Solaris 10 systems."
  version: 1.4
  detection:
    connectionTypes:
    - remote
    - local
    appliesTo:
    - Solaris
    supersedes:
    - SunScSnapshot
    - IpmiTool
    criteria:
    # OS should be SunOS or Solaris
    - type: deviceType
      keep:
      - SunOS
      - Solaris
    # we should find the prtpicl utility
    - type: osCommand
      commandLine: /bin/ls /usr/sbin/prtpicl
      expectedResult: ^/usr/sbin/prtpicl$
    # prtpicl should return something when asked for temperatures
    - type: osCommand
      commandLine: /usr/sbin/prtpicl -v -c temperature-sensor;/usr/sbin/prtpicl -v -c temperature-indicator
      expectedResult: "\\(Temperature[ \t]+[0-9]\\)\\|\\(Condition[ \t]+[A-Za-z]\\)"
    # check that prtld hasn't failed
    - type: osCommand
      commandLine: PRTPICLCOUNT=`pgrep prtpicl|wc -l` ; if /bin/test $PRTPICLCOUNT -lt 30; then echo MSHW_prtld_OK; else echo $PRTPICLCOUNT prtpicl processes running - suspect prtld service failure; fi
      expectedResult: MSHW_prtld_OK
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Source(1) = the output of /usr/sbin/prtpicl -v|awk '/:PlatformName/ { print $0; exit; }'
          # ModelString
          type: osCommand
          commandLine: "/usr/sbin/prtpicl -v|/usr/bin/awk '/:PlatformName/ { print $0; exit; }'"
          timeout: 90
          keep: :PlatformName
          separators: ' '
          selectColumns: 2
          computes:
            # Extract what is after the comma
            # ModelString is originally like SUNW,Sun-Fire-240
            # We just want Sun-Fire-240
          - type: extract
            column: 1
            subSeparators: ","
            subColumn: 2
          # Replace dashes with spaces
          - type: replace
            column: 1
            existingValue: '-'
            newValue: ' '
          # Replace GPUS with "Fujitsu PRIMEPOWER
          - type: replace
            column: 1
            existingValue: GPUS
            newValue: Fujitsu PRIMEPOWER
        source(2):
          # Source(2) = output of prtpicl
          type: osCommand
          commandLine: /usr/sbin/prtpicl
          computes:
            # Parse the output of prtpicl with an AWK script to get the path of each devices
            # DeviceID;Class;DevicePath;DisplayID;
          - type: awk
            script: "${file::embeddedFile-6}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5"
      mapping:
        # The discovery table
        source: "${source::monitors.enclosure.discovery.sources.source(1)}"
        attributes:
          id: SUN
          model: $1
          type: Computer
          name: "${awk::sprintf(\"Computer: (%s)\", $1)}"
  fan:
    discovery:
      sources:
        source(1):
          # Source(1) = the output of "/usr/sbin/prtpicl -v -c fan;/usr/sbin/prtpicl -v -c rpm-sensor"
          # prtpicl line
          type: osCommand
          commandLine: /usr/sbin/prtpicl -v -c fan;/usr/sbin/prtpicl -v -c rpm-sensor
          computes:
            # Send prtpicl's output to awk and get a beautiful table of fans
            # DeviceID;Description;WarningThreshold;Speed;SpeedPercent;Status;SpeedHex;SpeedPercentHex;WarningThresholdHex;
          - type: awk
            script: "${file::embeddedFile-1}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5,6,7,8,9,10"
            # Convert WarningThresholdHex from hex2dec
            # DeviceID;Description;WarningThreshold;Speed;SpeedPercent;Status;SpeedHex;SpeedPercentHex;WarningThresholdHex;
          - type: convert
            column: 9
            conversion: hex2Dec
            # Left Concat the Hex Value to the Dec Value (One of the two should be empty) for all three values
            # DeviceID;Description;WarningThreshold;Speed;SpeedPercent;Status;SpeedHex;SpeedPercentHex;WarningThresholdHex;
          - type: leftConcat
            column: 3
            value: $9
          - type: leftConcat
            column: 4
            value: $7
          - type: leftConcat
            column: 5
            value: $8
        source(2):
          # Table joint with Enclosure.discovery.source(2)
          # DeviceID;Description;WarningThreshold;Speed;SpeedPercent;Status;SpeedHex;SpeedPercentHex;WarningThresholdHex;DeviceID;Class;DevicePath;DisplayID;
          type: tableJoin
          leftTable: "${source::monitors.fan.discovery.sources.source(1)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(2)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          computes:
          - type: duplicateColumn
            column: 12
          - type: leftConcat
            column: 13
            value: "Device Path: "
      mapping:
        # The instance table
        # DeviceID;Description;WarningThreshold;Speed;SpeedPercent;Status;SpeedHex;SpeedPercentHex;WarningThresholdHex;DeviceID;Class;DevicePath;DisplayID;
        source: "${source::monitors.fan.discovery.sources.source(2)}"
        attributes:
          id: $12
          __display_id: $14
          info: $13
          hw.parent.type: enclosure
          name: $14
        metrics:
          hw.fan.speed.limit{limit_type="low.degraded"}: $3
          hw.fan.speed_ratio.limit{limit_type="low.degraded"}: percent2Ratio("10")
    collect:
      # Collect type is "all instances in one shot
      type: multiInstance
      sources:
        source(1):
          # Source(1) = the output of "/usr/sbin/prtpicl -v -c fan;/usr/sbin/prtpicl -v -c rpm-sensor"
          # prtpicl line
          type: osCommand
          commandLine: /usr/sbin/prtpicl -v -c fan;/usr/sbin/prtpicl -v -c rpm-sensor
          computes:
            # Send prtpicl's output to awk and get a beautiful table of fans
            # DeviceID;Speed;SpeedPercent;Status;SpeedHex;SpeedPercentHex;
          - type: awk
            script: "${file::embeddedFile-1}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,5,6,7,8,9"
            # Convert SpeedHex from hex2dec
            # DeviceID;Speed;SpeedPercent;Status;SpeedHex;SpeedPercentHex;
          - type: convert
            column: 5
            conversion: hex2Dec
            # Convert SpeedPercentHex from hex2dec
            # DeviceID;Speed;SpeedPercent;Status;SpeedHex;SpeedPercentHex;
          - type: convert
            column: 6
            conversion: hex2Dec
            # Left Concat the Hex Value to the Dec Value (One of the two should be empty) for all three values
            # DeviceID;Speed;SpeedPercent;Status;SpeedHex;SpeedPercentHex;
          - type: leftConcat
            column: 2
            value: $5
          - type: leftConcat
            column: 3
            value: $6
            # Duplicate the status column
            # DeviceID;Speed;SpeedPercent;Status;StatusInformation;SpeedHex;SpeedPercentHex;
          - type: duplicateColumn
            column: 4
            # Translate the status
            # DeviceID;Speed;SpeedPercent;PATROLStatus;StatusInformation;SpeedHex;SpeedPercentHex;
          - type: translate
            column: 4
            translationTable: "${translation::PrtDiagStatusTranslationTable}"
        source(2):
          # Table joint with Enclosure.discovery.source(2)
          # DeviceID;Speed;SpeedPercent;PATROLStatus;StatusInformation;SpeedHex;SpeedPercentHex;DeviceID;Class;DevicePath;
          type: tableJoin
          leftTable: "${source::monitors.fan.collect.sources.source(1)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(2)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
      mapping:
        # CollectTable = Source(1)
        # DeviceID;Speed;SpeedPercent;PATROLStatus;StatusInformation;SpeedHex;SpeedPercentHex;DeviceID;Class;DevicePath;
        source: "${source::monitors.fan.collect.sources.source(2)}"
        deviceId: $10
        metrics:
          hw.fan.speed: $2
          hw.fan.speed_ratio: percent2Ratio($3)
          hw.status{hw.type="fan"}: $4
        legacyTextParameters:
          StatusInformation: $5
  temperature:
    discovery:
      sources:
        source(1):
          # Source(1) = the output of "/usr/sbin/prtpicl -v -c temperature-sensor"
          # prtpicl line
          type: osCommand
          commandLine: /usr/sbin/prtpicl -v -c temperature-sensor
          computes:
            # Send prtpicl's output to awk and get a beautiful table of Temperatures
            # DeviceID;Location;WarningThreshold;Temperature;EmptyStatus;
          - type: awk
            script: "${file::embeddedFile-2}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5,6"
        source(2):
          # Source(2) = the output of "/usr/sbin/prtpicl -v -c temperature-indicator"
          # prtpicl line
          type: osCommand
          commandLine: /usr/sbin/prtpicl -v -c temperature-indicator
          computes:
            # Send prtpicl's output to awk and get a beautiful table of Temperatures
            # DeviceID;Location;WarningThreshold;Temperature;EmptyStatus;
          - type: awk
            script: "${file::embeddedFile-3}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5,6"
        source(3):
          # Source(3) = Table union of Source(1) and Source(2)
          # DeviceID;Location;WarningThreshold;Temperature;EmptyStatus;
          type: tableUnion
          tables:
          - "${source::monitors.temperature.discovery.sources.source(1)}"
          - "${source::monitors.temperature.discovery.sources.source(2)}"
        source(4):
          # Table joint with Enclosure.discovery.source(2)
          # DeviceID;Location;WarningThreshold;Temperature;EmptyStatus;DeviceID;Class;DevicePath;DisplayID;
          type: tableJoin
          leftTable: "${source::monitors.temperature.discovery.sources.source(3)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(2)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          computes:
          - type: duplicateColumn
            column: 8
          - type: leftConcat
            column: 9
            value: "Device Path: "
      mapping:
        # InstanceTable = Source(4)
        # DeviceID;Location;WarningThreshold;Temperature;EmptyStatus;DeviceID;Class;DevicePath;DisplayID;
        source: "${source::monitors.temperature.discovery.sources.source(4)}"
        attributes:
          id: $8
          __display_id: $10
          info: $9
          hw.parent.type: enclosure
          name: $10
        metrics:
          hw.temperature.limit{limit_type="high.degraded"}: $3
    collect:
      # Collect type is all instances in one single shot
      type: multiInstance
      sources:
        source(1):
          # Source(1) = the output of "/usr/sbin/prtpicl -v -c temperature-sensor"
          # prtpicl line
          type: osCommand
          commandLine: /usr/sbin/prtpicl -v -c temperature-sensor
          computes:
            # Send prtpicl's output to awk and get a beautiful table of Temperatures
            # DeviceID;Temperature;EmptyStatus
          - type: awk
            script: "${file::embeddedFile-2}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,5,6"
        source(2):
          # Source(2) = the output of "/usr/sbin/prtpicl -v -c temperature-indicator"
          # prtpicl line
          type: osCommand
          commandLine: /usr/sbin/prtpicl -v -c temperature-indicator
          computes:
            # Send prtpicl's output to awk and get a beautiful table of Temperatures
            # DeviceID;EmptyTemperature;Status
          - type: awk
            script: "${file::embeddedFile-3}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,5,6"
        source(3):
          # Source(3) = Table union of Source(1) and Source(2)
          # DeviceID;Temperature;Status
          type: tableUnion
          tables:
          - "${source::monitors.temperature.collect.sources.source(1)}"
          - "${source::monitors.temperature.collect.sources.source(2)}"
          computes:
            # Duplicate the Status column
            # DeviceID;Temperature;Status;StatusInformation
          - type: duplicateColumn
            column: 3
            # Translate the first Status column into a PATROL Status
            # DeviceID;CurrentValue;PATROLStatus;StatusInformation
          - type: translate
            column: 3
            translationTable: "${translation::PrtDiagStatusTranslationTable}"
        source(4):
          # Table joint with Enclosure.discovery.source(2)
          # DeviceID;CurrentValue;PATROLStatus;StatusInformation;DeviceID;Class;DevicePath;
          type: tableJoin
          leftTable: "${source::monitors.temperature.collect.sources.source(3)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(2)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
      mapping:
        # Collect table = Source(1)
        source: "${source::monitors.temperature.collect.sources.source(4)}"
        deviceId: $7
        metrics:
          hw.temperature: $2
          hw.status{hw.type="temperature"}: $3
        legacyTextParameters:
          StatusInformation: $4
  voltage:
    discovery:
      sources:
        source(1):
          # Source(1) = the output of "/usr/sbin/prtpicl -v -c voltage-sensor"
          # prtpicl line
          type: osCommand
          commandLine: /usr/sbin/prtpicl -v -c voltage-sensor
          computes:
            # Send prtpicl's output to awk and get a beautiful table of Voltages
            # DeviceID;VoltageName;LowerThreshold;UpperThreshold;Voltage;Status;
          - type: awk
            script: "${file::embeddedFile-4}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5,6,7"
            # Convert LowerThreshold from V to mV
            # DeviceID;VoltageName;LowerThresholdmV;UpperThreshold;Voltage;Status;
          - type: multiply
            column: 3
            value: 1000
            # Convert UpperThreshold from V to mV
            # DeviceID;VoltageName;LowerThresholdmV;UpperThresholdmV;Voltage;Status;
          - type: multiply
            column: 4
            value: 1000
        source(2):
          # Source(2) = the output of "/usr/sbin/prtpicl -v -c voltage-indicator"
          # prtpicl line
          type: osCommand
          commandLine: /usr/sbin/prtpicl -v -c voltage-indicator
          computes:
            # Send prtpicl's output to awk and get a beautiful table of Voltages
            # DeviceID;VoltageName;EmptyLowerThreshold;EmptyUpperThreshold;Voltage;Status;
          - type: awk
            script: "${file::embeddedFile-5}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5,6,7"
        source(3):
          # Source(3) = Table union of Source(1) and Source(2)
          # DeviceID;VoltageName;LowerThreshold;UpperThreshold;Voltage;Status;
          type: tableUnion
          tables:
          - "${source::monitors.voltage.discovery.sources.source(1)}"
          - "${source::monitors.voltage.discovery.sources.source(2)}"
        source(4):
          # Table joint with Enclosure.discovery.source(2)
          # DeviceID;VoltageName;LowerThreshold;UpperThreshold;Voltage;Status;DeviceID;Class;DevicePath;DisplayID;
          type: tableJoin
          leftTable: "${source::monitors.voltage.discovery.sources.source(3)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(2)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          computes:
          - type: duplicateColumn
            column: 9
          - type: leftConcat
            column: 10
            value: "Device Path: "
      mapping:
        # InstanceTable = Source(3)
        # DeviceID;VoltageName;LowerThreshold;UpperThreshold;Voltage;Status;DeviceID;Class;DevicePath;DisplayID;
        source: "${source::monitors.voltage.discovery.sources.source(4)}"
        attributes:
          id: $9
          __display_id: $11
          info: $10
          hw.parent.type: enclosure
          name: $11
        metrics:
          hw.voltage.limit{limit_type="low.critical"}: $3
          hw.voltage.limit{limit_type="high.degraded"}: $4
    collect:
      # Collect type is all instances in one single shot
      type: multiInstance
      sources:
        source(1):
          # Source(1) = the output of "/usr/sbin/prtpicl -v -c voltage-sensor"
          # prtpicl line
          type: osCommand
          commandLine: /usr/sbin/prtpicl -v -c voltage-sensor
          computes:
            # Send prtpicl's output to awk and get a beautiful table of Voltages
            # DeviceID;Voltage;EmptyStatus
          - type: awk
            script: "${file::embeddedFile-4}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,6,7"
            # Convert LowerThreshold from V to mV
            # DeviceID;VoltagemV;EmptyStatus
          - type: multiply
            column: 2
            value: 1000
        source(2):
          # Source(2) = the output of "/usr/sbin/prtpicl -v -c voltage-indicator"
          # prtpicl line
          type: osCommand
          commandLine: /usr/sbin/prtpicl -v -c voltage-indicator
          computes:
            # Send prtpicl's output to awk and get a beautiful table of Temperatures
            # DeviceID;EmptyVoltage;Status
          - type: awk
            script: "${file::embeddedFile-5}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,6,7"
        source(3):
          # Source(3) = Table union of Source(1) and Source(2)
          # DeviceID;Voltage;Status
          type: tableUnion
          tables:
          - "${source::monitors.voltage.collect.sources.source(1)}"
          - "${source::monitors.voltage.collect.sources.source(2)}"
          computes:
            # Duplicate the Status column
            # DeviceID;Voltage;Status;StatusInformation
          - type: duplicateColumn
            column: 3
            # Translate the first Status column into a PATROL Status
            # DeviceID;Voltage;PATROLStatus;StatusInformation
          - type: translate
            column: 3
            translationTable: "${translation::PrtDiagStatusTranslationTable}"
        source(4):
          # Table joint with Enclosure.discovery.source(2)
          # DeviceID;Voltage;PATROLStatus;StatusInformation;DeviceID;Class;DevicePath;
          type: tableJoin
          leftTable: "${source::monitors.voltage.collect.sources.source(3)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(2)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
      mapping:
        # Collect table = Source(1)
        source: "${source::monitors.voltage.collect.sources.source(4)}"
        deviceId: $7
        metrics:
          hw.voltage: $2
          hw.status{hw.type="voltage"}: $3
        legacyTextParameters:
          StatusInformation: $4
  led:
    discovery:
      sources:
        source(1):
          # Source(1) = the output of "/usr/sbin/prtpicl -v -c led"
          # prtpicl line
          type: osCommand
          commandLine: /usr/sbin/prtpicl -v -c led
          computes:
            # Send prtpicl's output to awk and get a beautiful table of LEDs
            # DeviceID;Description;Color/Name;
          - type: awk
            script: "${file::embeddedFile-7}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4"
            # Duplicate the Color column
            # DeviceID;Description;Color/Name;Color/Name;Color/Name;Color/Name;
          - type: duplicateColumn
            column: 3
          - type: duplicateColumn
            column: 3
          - type: duplicateColumn
            column: 3
            # Translate the second Color column into a OnStatus
            # DeviceID;Description;Color/Name;OnStatus;Color/Name;Color/Name;
          - type: translate
            column: 4
            translationTable: "${translation::LEDColor2OnStatusTranslationTable}"
            # Translate the third Color column into a BlinkingStatus
            # DeviceID;Description;Color/Name;OnStatus;BlinkingStatus;Color/Name;
          - type: translate
            column: 5
            translationTable: "${translation::LEDColor2BlinkingStatusTranslationTable}"
            # Translate the fourth Color column into a OffStatus
            # DeviceID;Description;Color/Name;OnStatus;BlinkingStatus;OffStatus;
          - type: translate
            column: 6
            translationTable: "${translation::LEDColor2OffStatusTranslationTable}"
        source(2):
          # Table joint with Enclosure.discovery.source(2)
          # DeviceID;Description;Color;OnStatus;BlinkingStatus;OffStatus;DeviceID;Class;DevicePath;DisplayID;
          type: tableJoin
          leftTable: "${source::monitors.led.discovery.sources.source(1)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(2)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          computes:
          - type: duplicateColumn
            column: 9
          - type: leftConcat
            column: 10
            value: "Device Path: "
      mapping:
        # The instance table
        # DeviceID;Description;Color;OnStatus;BlinkingStatus;OffStatus;DeviceID;Class;DevicePath;DisplayID;
        source: "${source::monitors.led.discovery.sources.source(2)}"
        attributes:
          id: $9
          __display_id: $11
          color: $3
          __on_status: $4
          __blinking_status: $5
          __off_status: $6
          info: $10
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s)\", $11, $3)}"
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = the output of "/usr/sbin/prtpicl -v -c led"
          # prtpicl line
          type: osCommand
          commandLine: /usr/sbin/prtpicl -v -c led
          computes:
            # Send prtpicl's output to awk and get a beautiful table of fans
            # DeviceID;State;
          - type: awk
            script: "${file::embeddedFile-7}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,5"
            # Duplicate State column
            # DeviceID;State;State;
          - type: duplicateColumn
            column: 2
            # Translate first State column into 0 (for Off), 1 (for Blinking) and 2 (for On)
            # DeviceID;Status;State;
          - type: translate
            column: 2
            translationTable: "${translation::LEDStateTranslationTable}"
        source(2):
          # Table joint with Enclosure.discovery.source(2)
          # DeviceID;Status;State;DeviceID;Class;DevicePath;
          type: tableJoin
          leftTable: "${source::monitors.led.collect.sources.source(1)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(2)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
      mapping:
        # ValueTable = Source(1)
        source: "${source::monitors.led.collect.sources.source(2)}"
        deviceId: $6
        metrics:
          hw.status{hw.type="led"}: legacyLedStatus($2)
        legacyTextParameters:
          StatusInformation: $3
translations:
  LEDColor2OffStatusTranslationTable:
    red: ok
    orange: ok
    green: ok
    blue: ok
    white: ok
    amber: ok
    SERVICE: ok
    FAULT: ok
    LOCATE: ok
    OK: ok
    Default: ok
    ACTIVITY: ok
  LEDColor2OnStatusTranslationTable:
    red: failed
    orange: ok
    green: ok
    blue: ok
    white: ok
    amber: failed
    SERVICE: failed
    FAULT: failed
    LOCATE: ok
    OK: ok
    Default: ok
    ACTIVITY: ok
  LEDStateTranslationTable:
    flashing: Blinking
    blinking: Blinking
    steady: "On"
    "off": "Off"
    "on": "On"
  LEDColor2BlinkingStatusTranslationTable:
    red: degraded
    orange: ok
    green: ok
    blue: ok
    white: ok
    amber: degraded
    SERVICE: failed
    FAULT: failed
    LOCATE: ok
    OK: ok
    Default: degraded
    ACTIVITY: ok
  PrtDiagStatusTranslationTable:
    okay: ok
    ? ""
    : ok
    pass: ok
    Normal: ok
    Default: failed
    TooSlow: degraded
    '[NO_FAULT]': ok
    '[NO_FAULT': ok
    unknown: UNKNOWN
    (OK): ok
    '[OK': ok
    self-regulating: ok
    no_status: ok
    NO_FAULT: ok
    self: ok
    UNPLUGGED: ok
    OK: ok
    GOOD: ok
    Green: ok
