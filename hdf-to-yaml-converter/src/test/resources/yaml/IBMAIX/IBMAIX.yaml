---
extends:
- ../IBMAIXModels-header/IBMAIXModels-header
connector:
  displayName: IBM AIX - Common
  platforms: IBM POWER
  reliesOn: "IBM AIX system commands (lsdev, entstat, etc.)"
  information: "Provides hardware status information (processors, memory modules, network interfaces) on IBM AIX systems."
  version: 1.3
  detection:
    connectionTypes:
    - remote
    - local
    appliesTo:
    - RS6000
    criteria:
    # OS should be AIX (whatever version)
    - type: deviceType
      keep:
      - RS6000
    # Check for the ability to run lsdev, at least
    - type: osCommand
      commandLine: /usr/bin/ls /usr/sbin/lsdev
      expectedResult: ^/usr/sbin/lsdev$
sudoCommands:
- /usr/sbin/netstat -D
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Source(1) = the output of uname -M
          # MachineIDNumber;ModelCode;SystemID;LPARSystemID;
          type: osCommand
          commandLine: /usr/bin/uname -mMfF
          keep: " IBM,"
          separators: ' '
          selectColumns: "1,2,3,4"
          computes:
            # Remove the IBM,  (We, unfortunately, already know it's an IBM)
            # MachineIDNumber;ModelCode;LPARSystemID;SystemID;
          - type: replace
            column: 2
            existingValue: "IBM,"
            newValue: ""
            # Add descriptive prefixes to the different IDs
            # MachineIDNumber;ModelCode;LPARSystemID;SystemID;
          - type: leftConcat
            column: 1
            value: "Machine ID: "
          - type: leftConcat
            column: 3
            value: "LPAR System ID: "
          - type: leftConcat
            column: 4
            value: "System ID: "
            # Duplicate the ModelCode
            # MachineIDNumber;ModelCode;ModelCode;LPARSystemID;SystemID;
          - type: duplicateColumn
            column: 2
            # Translate the 2nd Model Code into a Model Name
            # The translation table will need to be regularly updated
            # MachineIDNumber;ModelCode;ModelName;LPARSystemID;SystemID;
          - type: translate
            column: 3
            translationTable: "${translation::ModelTranslationTable}"
            # Concatenate ModelCode and ModelName
            # MachineIDNumber;ModelCode;ModelCode, ModelName;LPARSystemID;SystemID;
          - type: leftConcat
            column: 3
            value: ", "
          - type: leftConcat
            column: 3
            value: $2
        source(2):
          # Source(2) = the output of lsattr -E -l sys0 -O -a modelname -a systemid -a fwversion
          # ModelCode;SystemID;FirmwareVersion;
          type: osCommand
          commandLine: /usr/sbin/lsattr -E -l sys0 -O -a modelname -a systemid -a fwversion
          keep: "^IBM,"
          separators: ':'
          selectColumns: "1,2,3"
          computes:
            # Remove mentions to "IBM," in the different fields
            # ModelCode;SystemID;FirmwareVersion;
          - type: replace
            column: 1
            existingValue: "IBM,"
            newValue: ""
          - type: replace
            column: 2
            existingValue: "IBM,"
            newValue: ""
          - type: replace
            column: 3
            existingValue: "IBM,"
            newValue: ""
        source(3):
          # Source(3) = Table Join of Source(1) and Source(2)
          # MachineIDNumber;ModelCode;ModelCode, ModelName;LPARSystemID;SystemID;ModelCode;SystemID;FirmwareVersion;
          type: tableJoin
          leftTable: "${source::monitors.enclosure.discovery.sources.source(1)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(2)}"
          leftKeyColumn: 2
          rightKeyColumn: 1
          defaultRightLine: ;;;
      mapping:
        # The discovery table
        # MachineIDNumber;ModelCode;ModelCode, ModelName;LPARSystemID;SystemID;ModelCode;SystemID;FirmwareVersion;
        source: "${source::monitors.enclosure.discovery.sources.source(3)}"
        attributes:
          id: $7
          __display_id: $7
          vendor: IBM
          model: $3
          type: Computer
          serial_number: $7
          bios_version: $8
          info: "${awk::join(\" \", $1, $5, $4)}"
          name: "${awk::sprintf(\"Computer: %s (%s %s)\", $7, \"IBM\", $3)}"
    collect:
      # Collect type is mono-instance (as there is only one instance anyway)
      type: monoInstance
      sources:
        source(1):
          # Source(1) = Number of events reported by errpt of type "SCAN_ERROR_CHRP" on sysplanar0
          # Please note that we're echoing ERRPT_BEGIN to make sure the result is not empty, else the computing is not done and the awk script is not executed
          # ErrorCount
          type: osCommand
          commandLine: echo ERRPT_BEGIN;/usr/bin/errpt -d H -N sysplanar0 -s `/bin/date +%%m%%d0000%%y` -J SCAN_ERROR_CHRP
          computes:
            # Process the output of errpt through awk EmbeddedFile(5)
            # Status;StatusInformation;
          - type: awk
            script: "${file::embeddedFile-5}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3"
      mapping:
        # ValueTable = source(1)
        source: "${source::monitors.enclosure.collect.sources.source(1)}"
        metrics:
          hw.status{hw.type="enclosure"}: $1
        legacyTextParameters:
          StatusInformation: $2
  cpu:
    discovery:
      sources:
        source(1):
          # Source(1) = sh -${file::embeddedFile-1}
          # cpuID;HzSpeed;Model
          type: osCommand
          commandLine: "/bin/sh ${file::embeddedFile-1}"
          keep: '^MSHW:'
          separators: ':'
          selectColumns: "2,3,4"
          computes:
            # Remove the "PowerPC_" prefix in the model column
            # cpuID;HzSpeed;Model
          - type: replace
            column: 3
            existingValue: PowerPC_
            newValue: ""
            # Convert Hz to MHz
            # cpuID;MHzSpeed;Model
          - type: divide
            column: 2
            value: 1000000
      mapping:
        # Instance table = source(1)
        source: "${source::monitors.cpu.discovery.sources.source(1)}"
        attributes:
          id: $1
          model: $3
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s - %s)\", $1, $3, megaHertz2HumanFormat($2))}"
        metrics:
          hw.cpu.speed.limit{limit_type="max"}: megaHertz2Hertz($2)
    collect:
      # Collect type = multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = lsdev -c processor
          # cpuID;cpuStatus
          type: osCommand
          commandLine: /usr/sbin/lsdev -C -c processor -F 'class;name;status'
          keep: ^processor;
          separators: ;
          selectColumns: "2,3"
          computes:
            # Duplicate the status column
            # cpuID;cpuStatus;cpuStatus
          - type: duplicateColumn
            column: 2
            # Translate the first status column into a PATROL status
            # cpuID;PATROLStatus;cpuStatus
          - type: translate
            column: 2
            translationTable: "${translation::cpuStatusTranslationTable}"
            # Translate the second status column into a more readable string
            # cpuID;PATROLStatus;statusInformation
          - type: translate
            column: 3
            translationTable: "${translation::cpuStatusInformationTranslationTable}"
      mapping:
        # ValueTable = source(1)
        source: "${source::monitors.cpu.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="cpu"}: $2
        legacyTextParameters:
          StatusInformation: $3
  network:
    discovery:
      sources:
        source(1):
          # Source(1) = output of EmbeddedFile(6) (mix of lsdev and lscfg)
          type: osCommand
          commandLine: "/bin/sh ${file::embeddedFile-6}"
          computes:
            # Process the output of lscfg through awk EmbeddedFile(7)
            # DeviceID;Model;NicType;MACAddress;HWLocationCode;
          - type: awk
            script: "${file::embeddedFile-7}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5,6"
        source(2):
          # Source(2) = output of embedded script 3
          type: osCommand
          commandLine: "/bin/sh ${file::embeddedFile-2}"
          computes:
            # Process the output of entstat through awk EmbeddedFile(3)
            # DeviceID;Status;LinkStatus;ErrorCount;TransmitPackets;ReceivePackets;TransmitBytes;ReceiveBytes;LinkSpeed;DuplexMode;
          - type: awk
            script: "${file::embeddedFile-3}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5,6,7,8,9,10,11"
        source(3):
          # Source(3) = joint of Source(1) and Source(2)
          # DeviceID;Model;NicType;MACAddress;HWLocationCode;DeviceID;Status;LinkStatus;ErrorCount;TransmitPackets;ReceivePackets;TransmitBytes;ReceiveBytes;LinkSpeed;DuplexMode;
          type: tableJoin
          leftTable: "${source::monitors.network.discovery.sources.source(1)}"
          rightTable: "${source::monitors.network.discovery.sources.source(2)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          defaultRightLine: ;OK;WARN;0;0;0;0;0;;;
      mapping:
        # InstanceTable = Source(1)
        # DeviceID;Model;NicType;MACAddress;HWLocationCode;DeviceID;Status;LinkStatus;ErrorCount;TransmitPackets;ReceivePackets;TransmitBytes;ReceiveBytes;LinkSpeed;DuplexMode;
        source: "${source::monitors.network.discovery.sources.source(3)}"
        attributes:
          id: $1
          model: $2
          physical_address: $4
          physical_address_type: MAC
          device_type: $3
          info: $5
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s - %s)\", $1, $3, $2)}"
        conditionalCollection:
          hw.network.bandwidth.limit: megaBit2Bit($14)
          hw.network.full_duplex: legacyFullDuplex($15)
          hw.network.up: legacyLinkStatus($8)
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = output of entstat -d for each card
          type: osCommand
          commandLine: "/bin/sh ${file::embeddedFile-2}"
          computes:
            # Process the output of entstat through awk EmbeddedFile(3)
            # DeviceID;Status;LinkStatus;ErrorCount;TransmitPackets;ReceivePackets;TransmitBytes;ReceiveBytes;LinkSpeed;DuplexMode;
          - type: awk
            script: "${file::embeddedFile-3}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5,6,7,8,9,10,11"
        source(2):
          # Source(2) = joint of ${source::monitors.network.discovery.sources.source(1)} and NetworkCard.Collect.Source(1)
          # DeviceID;Model;NicType;MACAddress;HWLocationCode;DeviceID;Status;LinkStatus;ErrorCount;TransmitPackets;ReceivePackets;TransmitBytes;ReceiveBytes;LinkSpeed;DuplexMode;
          type: tableJoin
          leftTable: "${source::monitors.network.discovery.sources.source(1)}"
          rightTable: "${source::monitors.network.collect.sources.source(1)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          defaultRightLine: ;OK;WARN;0;0;0;0;0;;;
      mapping:
        # Value table = Source(1)
        # DeviceID;Model;NicType;MACAddress;HWLocationCode;DeviceID;Status;LinkStatus;ErrorCount;TransmitPackets;ReceivePackets;TransmitBytes;ReceiveBytes;LinkSpeed;DuplexMode;
        source: "${source::monitors.network.collect.sources.source(2)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="network"}: $7
          hw.network.up: legacyLinkStatus($8)
          hw.errors{hw.type="network"}: $9
          hw.network.packets{direction="transmit"}: $10
          hw.network.packets{direction="receive"}: $11
          hw.network.io{direction="transmit"}: $12
          hw.network.io{direction="receive"}: $13
          hw.network.bandwidth.limit: megaBit2Bit($14)
          hw.network.full_duplex: legacyFullDuplex($15)
  memory:
    discovery:
      sources:
        source(1):
          # Source(1) = output of lscfg -vp -l sysplanar0
          type: osCommand
          commandLine: /usr/sbin/lscfg -vp -l sysplanar0
          computes:
            # Reformat lscfg's output through awk (see EmbeddedFile(4))
            # DeviceID;Size;SerialNumber
          - type: awk
            script: "${file::embeddedFile-4}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4"
            # Duplicate the DeviceID column (which is actually phys location code)
            # DeviceID;DeviceID;Size;SerialNumber
          - type: duplicateColumn
            column: 1
            # Add "Hardware Location Code: " to the second DeviceID, to show it in the identifying information
            # DeviceID;HardwareLocationCode;Size;SerialNumber
          - type: leftConcat
            column: 2
            value: "Location: "
            # Add ";1;" to the HardwareLocationCode that will correspond to the Status and ErrorCount ParameterActivation values
            # DeviceID;HardwareLocationCode;StatusActivation;ErrorCountActivation;Size;SerialNumber
          - type: rightConcat
            column: 2
            value: ;1;
        source(2):
          # Source(2) = Static table to represent the global memory stuff
          type: static
          value: Memory Controller;;;1;;;
        source(3):
          # Source(3) = Union of Source(1) and Source(2)
          # DeviceID;HardwareLocationCode;StatusActivation;ErrorCountActivation;Size;SerialNumber
          type: tableUnion
          tables:
          - "${source::monitors.memory.discovery.sources.source(1)}"
          - "${source::monitors.memory.discovery.sources.source(2)}"
      mapping:
        # InstanceTable = Source(1)
        source: "${source::monitors.memory.discovery.sources.source(3)}"
        attributes:
          id: $1
          serial_number: $6
          info: $2
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s MB)\", $1, $5)}"
        metrics:
          hw.memory.limit: mebiByte2Byte($5)
        conditionalCollection:
          hw.status{hw.type="memory"}: $3
          hw.errors{hw.type="memory"}: $4
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = output of lscfg -vp -l sysplanar0
          type: osCommand
          commandLine: /usr/sbin/lscfg -vp -l sysplanar0
          computes:
            # Reformat lscfg's output through awk (see EmbeddedFile(4))
            # DeviceID;Status;StatusInformation;
          - type: awk
            script: "${file::embeddedFile-4}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,5,6"
            # Add ";" to the right, as an empty ErrorCount column
            # DeviceID;Status;StatusInformation;ErrorCount
          - type: rightConcat
            column: 3
            value: ;
        source(2):
          # Source(2) = Number of events reported by errpt of type "memory"
          # MemoryErrorCount
          type: osCommand
          commandLine: "/usr/bin/errpt -d H -s `/bin/date +%%m%%d0000%%y` -J CORRECTED_SCRUB,MEM1,MEM2,MEM3,MEMORY,RECOV_ECC_ERR,UNRECOV_ECC_ERR|/bin/wc -l"
          keep: "^ *[0-9]+$"
          separators: ' '
          selectColumns: 1
          computes:
            # Add "Memory Controller;;;" as the device ID;Status;StatusInformation
            # DeviceID;Status;StatusInformation;MemoryErrorCount
          - type: leftConcat
            column: 1
            value: Memory Controller;;;
        source(3):
          # Source(3) = Union of Source(1) and Source(2)
          type: tableUnion
          tables:
          - "${source::monitors.memory.collect.sources.source(1)}"
          - "${source::monitors.memory.collect.sources.source(2)}"
      mapping:
        # Value table = Source(1)
        source: "${source::monitors.memory.collect.sources.source(3)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="memory"}: $2
          hw.errors{hw.type="memory"}: $4
        legacyTextParameters:
          StatusInformation: $3
translations:
  cpuStatusInformationTranslationTable:
    Stopped: Stopped
    Defined: Defined
    Available: Available
    Default: Unknown Status
  cpuStatusTranslationTable:
    Stopped: degraded
    Defined: ok
    Available: ok
    Default: UNKNOWN
