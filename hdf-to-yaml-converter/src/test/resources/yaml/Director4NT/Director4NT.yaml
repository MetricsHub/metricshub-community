---
connector:
  displayName: IBM Director Agent 4.x - Windows
  platforms: IBM xSeries
  reliesOn: IBM Director Agent 4.x
  version: 1.0
  information: This connector provides hardware monitoring through the IBM Director Agent version 4.x which supports almost all IBM Netfinity and xSeries servers.
  detection:
    connectionTypes:
    - remote
    - local
    appliesTo:
    - NT
    supersedes:
    - IpmiTool
    criteria:
    # OS must be Windows
    - type: deviceType
      keep:
      - NT
    # The IBM Director Agent Service must be running (service name is TWGIPC)
    - type: service
      name: TWGIPC
    # Verify that the root/ibmsd WBEM namespace actually exists
    - type: wmi
      namespace: \root
      query: SELECT Name FROM __NAMESPACE
      expectedResult: ^ibmsd;$
    # The IBM Director Agent must be in version 4.x
    - type: wmi
      query: SELECT Version FROM IBMPSG_DirectorAgent
      namespace: root\ibmsd
      expectedResult: ^4.*
    # The IBMPSG_ComputerSystemDetails WBEM class must be instanciated
    - type: wmi
      query: SELECT ProductName FROM IBMPSG_ComputerSystemDetails
      namespace: root\ibmsd
      errorMessage: The IBM Director Agent seems to not be working properly. Please reinstall the IBM Director Agent.
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Source(1) = the IBMPSG_ComputerSystemDetails WBEM class
          type: wmi
          query: "SELECT IdentifyingNumber,Name,ProductName FROM IBMPSG_ComputerSystemDetails"
          namespace: root\ibmsd
          computes:
          # Concatenate ProductName and Name
          - type: rightConcat
            column: 3
            value: ' ('
          - type: rightConcat
            column: 3
            value: $2
          - type: rightConcat
            column: 3
            value: )
      mapping:
        # InstanceTable = Source(1)
        # Note: InstanceTable must contain only one line!
        source: "${source::monitors.enclosure.discovery.sources.source(1)}"
        attributes:
          id: DIR4
          vendor: IBM
          model: $3
          type: Computer
          name: "${awk::sprintf(\"Computer: (%s %s)\", \"IBM\", $3)}"
    collect:
      type: monoInstance
      sources:
        source(1):
          # Source(1) = The IBMPSG_SystemEnclosure WBEM class
          type: wmi
          query: "SELECT IntrusionStatus,Tag FROM IBMPSG_SystemEnclosure"
          namespace: root\ibmsd
          computes:
          - type: keepOnlyMatchingLines
            column: 2
            regExp: 0$
          - type: translate
            column: 1
            translationTable: "${translation::enclosureIntrusionStatusTranslationTable}"
      mapping:
        source: "${source::monitors.enclosure.collect.sources.source(1)}"
        metrics:
          hw.status{hw.type="enclosure", state="open"}: legacyIntrusionStatus($1)
  cpu:
    discovery:
      sources:
        source(1):
          type: wmi
          query: "SELECT CurrentClockSpeed,DeviceID,Manufacturer,Name FROM IBMPSG_Processor"
          namespace: root\ibmsd
      mapping:
        # InstanceTable = Source(1)
        source: "${source::monitors.cpu.discovery.sources.source(1)}"
        attributes:
          id: $2
          vendor: $3
          model: $4
          hw.parent.type: enclosure
          hw.parent.id: DIR4
          name: "${awk::sprintf(\"%s (%s - %s - %s)\", $2, $3, $4, megaHertz2HumanFormat($1))}"
        metrics:
          hw.cpu.speed.limit{limit_type="max"}: megaHertz2Hertz($1)
    collect:
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = The IBMPSG_Processor WBEM class
          type: wmi
          query: "SELECT DeviceID,Status FROM IBMPSG_Processor"
          namespace: root\ibmsd
          computes:
          - type: duplicateColumn
            column: 2
          - type: translate
            column: 2
            translationTable: "${translation::cpuStatusTranslationTable}"
          - type: translate
            column: 3
            translationTable: "${translation::cpuStatusInformationTranslationTable}"
      mapping:
        source: "${source::monitors.cpu.collect.sources.source(1)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="cpu"}: $2
        legacyTextParameters:
          StatusInformation: $3
  memory:
    discovery:
      sources:
        source(1):
          # Discovery
          type: wmi
          query: "SELECT Capacity,Manufacturer,SerialNumber,Tag,TypeDetail FROM IBMPSG_PhysicalMemory"
          namespace: root\ibmsd
          computes:
          # Convert size to MB
          - type: divide
            column: 1
            value: 1048576
          # Translate memory type
          - type: perBitTranslation
            column: 5
            bitList: "1,2,3,4,5,6,7,8,9,10,11,12,13"
            translationTable: "${translation::MemoryBitTranslationTable}"
      mapping:
        # InstanceTable = Source(1)
        source: "${source::monitors.memory.discovery.sources.source(1)}"
        attributes:
          id: $4
          vendor: $2
          serial_number: $3
          type: $5
          hw.parent.type: enclosure
          hw.parent.id: DIR4
          name: "${awk::sprintf(\"%s (%s - %s - %s MB)\", $4, $2, $5, $1)}"
        metrics:
          hw.memory.limit: mebiByte2Byte($1)
    collect:
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = The IBMPSG_Processor WBEM class
          type: wmi
          query: "SELECT HasError,Tag FROM IBMPSG_PhysicalMemory"
          namespace: root\ibmsd
          computes:
          - type: translate
            column: 1
            translationTable: "${translation::memoryStatusTranslationTable}"
      mapping:
        source: "${source::monitors.memory.collect.sources.source(1)}"
        attributes:
          id: $2
        metrics:
          hw.status{hw.type="memory"}: $1
  fan:
    discovery:
      sources:
        source(1):
          # Source(1) = the IBMPSG_Fan WBEM class
          type: wmi
          query: "SELECT DeviceID, FanType, UpperThresholdCritical FROM IBMPSG_Tachometer"
          namespace: root\ibmsd
          computes:
          - type: translate
            column: 2
            translationTable: "${translation::FanTypeTranslationTable}"
      mapping:
        # InstanceTable = Source(1)
        source: "${source::monitors.fan.discovery.sources.source(1)}"
        attributes:
          id: $1
          sensor_location: $2
          hw.parent.type: enclosure
          hw.parent.id: DIR4
          name: "${awk::sprintf(\"%s (%s)\", $1, $2)}"
        metrics:
          hw.fan.speed.limit{limit_type="low.degraded"}: $3
          hw.fan.speed.limit{limit_type="low.critical"}: 0
    collect:
      # The collect (as all WBEM-based collects) is "MultiInstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = The IBMPSG_Tachometer WBEM class
          type: wmi
          query: "SELECT CurrentReading,DeviceID FROM IBMPSG_Tachometer"
          namespace: root\ibmsd
      mapping:
        # ValueTable = Source(1)
        source: "${source::monitors.fan.collect.sources.source(1)}"
        attributes:
          id: $2
        metrics:
          hw.fan.speed: $1
  temperature:
    discovery:
      sources:
        source(1):
          # Source(1) = The IBMPSG_TemperatureSensor WBEM class
          type: wmi
          query: "SELECT DeviceID, LowerThresholdCritical, LowerThresholdNonCritical, TempLocation FROM IBMPSG_TemperatureSensor"
          namespace: root\ibmsd
          computes:
          - type: translate
            column: 4
            translationTable: "${translation::TemperatureTypeTranslationTable}"
      mapping:
        # InstanceTable = Source(1)
        source: "${source::monitors.temperature.discovery.sources.source(1)}"
        attributes:
          id: $1
          sensor_location: $4
          hw.parent.type: enclosure
          hw.parent.id: DIR4
          name: "${awk::sprintf(\"%s (%s)\", $1, $4)}"
        metrics:
          hw.temperature.limit{limit_type="high.degraded"}: $3
          hw.temperature.limit{limit_type="high.critical"}: $2
    collect:
      # Like all WBEM collects, this one is \"MultiInstance\"
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = the IBMPSG_TemperatureSensor WBEM class
          type: wmi
          query: "SELECT CurrentReading,DeviceID FROM IBMPSG_TemperatureSensor"
          namespace: root\ibmsd
      mapping:
        # ValueTable = Source(1)
        source: "${source::monitors.temperature.collect.sources.source(1)}"
        attributes:
          id: $2
        metrics:
          hw.temperature: $1
  voltage:
    discovery:
      sources:
        source(1):
          # Source(1) = all the instances of the IBMPSG_VoltageSensor class
          type: wmi
          query: "SELECT DeviceID,LowerThresholdNonCritical,UpperThresholdNonCritical,VoltageType FROM IBMPSG_VoltageSensor"
          namespace: root\ibmsd
          computes:
          # Translate the voltage type into a more readable string
          - type: translate
            column: 4
            translationTable: "${translation::VoltageTypeTranslationTable}"
      mapping:
        # Here is the instance table = source(1)
        source: "${source::monitors.voltage.discovery.sources.source(1)}"
        attributes:
          id: $1
          sensor_location: $4
          hw.parent.type: enclosure
          hw.parent.id: DIR4
          name: "${awk::sprintf(\"%s (%s)\", $1, $4)}"
        metrics:
          hw.voltage.limit{limit_type="high.degraded"}: $3
          hw.voltage.limit{limit_type="low.critical"}: $2
    collect:
      # It's a "MultiInstance" collect
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = the IBMPSG_VoltageSensor class
          type: wmi
          query: "SELECT CurrentReading,DeviceID FROM IBMPSG_VoltageSensor"
          namespace: root\ibmsd
      mapping:
        # ValueTable = Source(1)
        source: "${source::monitors.voltage.collect.sources.source(1)}"
        attributes:
          id: $2
        metrics:
          hw.voltage: $1
  power_supply:
    discovery:
      sources:
        source(1):
          # Source(1) = The IBMPSG_PowerSupply table
          type: wmi
          query: SELECT DeviceID FROM IBMPSG_PowerSupply
          namespace: root\ibmsd
      mapping:
        # 'The instance table:'
        source: "${source::monitors.power_supply.discovery.sources.source(1)}"
        attributes:
          id: $1
          hw.parent.type: enclosure
          hw.parent.id: DIR4
          name: $1
    collect:
      # Collect type : multi instance (one source for several instances)
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = the simple IBMPSG_PowerSupply table/class
          # DeviceID;WBEMStatus
          type: wmi
          query: "SELECT DeviceID,Status FROM IBMPSG_PowerSupply"
          namespace: root\ibmsd
          computes:
            # Duplicate the status column
            # DeviceID;WBEMStatus;WBEMStatus
          - type: duplicateColumn
            column: 2
            # Translate the first WBEM status column into a PATROL status
            # DeviceID;PatrolStatus;WBEMStatus
          - type: translate
            column: 2
            translationTable: "${translation::PowerSupplyStatusTranslationTable}"
            # Translate the second WBEM status column into a PATROL status
            # DeviceID;PatrolStatus;StatusInformation
          - type: translate
            column: 3
            translationTable: "${translation::PowerSupplyStatusInformationTranslationTable}"
      mapping:
        # The ValueTable = Source(1)
        source: "${source::monitors.power_supply.collect.sources.source(1)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="power_supply"}: $2
        legacyTextParameters:
          StatusInformation: $3
  disk_controller:
    discovery:
      sources:
        source(1):
          # Based on the IBMPSG_RAIDController WBEM class
          # This class includes all RAID controllers  and the more specific IBM ServerRAID controllers
          # The ControllerID property will be used to identify the controller in the PhysicalDisk and
          # LogicalDisk discoveries
          type: wmi
          query: "SELECT BIOSVersion, ControllerID, DeviceID, DriverVersion, FirmwareVersion, Manufacturer, Model FROM IBMPSG_RAIDController"
          namespace: root\ibmsd
      mapping:
        source: "${source::monitors.disk_controller.discovery.sources.source(1)}"
        attributes:
          vendor: $6
          model: $7
          id: $3
          bios_version: $1
          driver_version: $4
          controller_number: $2
          hw.parent.type: enclosure
          hw.parent.id: DIR4
          name: "${awk::sprintf(\"Disk Controller: %s (%s %s)\", $2, $6, $7)}"
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = IBMPSG_RAIDDiskDrive table
          type: wmi
          query: "SELECT ControllerID,DeviceID,DiskDriveID FROM IBMPSG_RAIDDiskDrive"
          namespace: root\ibmsd
          computes:
          # Replace :DiskDriveID: by :DeviceID: in the IBMPSG_RAIDDiskDrive table
          - type: replace
            column: 2
            existingValue: ':DeviceID:'
            newValue: ':DiskDriveID:'
        source(2):
          # Source(2) = IBMPSG_PhysicalDiskDrive table
          type: wmi
          query: "SELECT Capacity,Manufacturer,Model,SerialNumber,Tag FROM IBMPSG_PhysicalDiskDrive"
          namespace: root\ibmsd
          computes:
            # Replace :DiskDriveID: by :DeviceID: in the IBMPSG_PhysicalDiskDrive table
            # (yes, normally it is already done, but in fact, we cannot trust the IBM Director
            # development team... ;-)
          - type: replace
            column: 5
            existingValue: ':DeviceID:'
            newValue: ':DiskDriveID:'
        source(3):
          # Source(3) = The jointure
          type: tableJoin
          leftTable: "${source::monitors.physical_disk.discovery.sources.source(1)}"
          rightTable: "${source::monitors.physical_disk.discovery.sources.source(2)}"
          leftKeyColumn: 2
          rightKeyColumn: 5
      mapping:
        # Finally here is the instance table...
        # InstanceTable = ControllerID,DeviceID,DiskDriveID,Capacity,Manufacturer,Model,SerialNumber,Tag
        source: "${source::monitors.physical_disk.discovery.sources.source(3)}"
        attributes:
          id: $2
          vendor: $5
          model: $6
          serial_number: $7
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $1)"
          name: "${awk::sprintf(\"%s (%s - %s)\", $2, $5, bytes2HumanFormatBase10($4))}"
        metrics:
          hw.physical_disk.size: $4
    collect:
      # The physical disk collect is a "MultiInstance" collect
      # Only ONE WBEM query will be done in order to get the information for all physical disks
      # Less WBEM queries gives faster results
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = the only source = the IBMPSG_RAIDDiskDrive table
          type: wmi
          query: "SELECT DeviceID,State FROM IBMPSG_RAIDDiskDrive"
          namespace: root\ibmsd
          computes:
          # We must duplicate the "State" column
          - type: duplicateColumn
            column: 2
          # Then we translate the IBMPSG status code into OK/WARN/ALARM (for the Status parameter)
          - type: translate
            column: 2
            translationTable: "${translation::PhysicalDiskStatusTranslationTable}"
          # And finally, we translate the IBMPSG status code into a more readable status string
          - type: translate
            column: 3
            translationTable: "${translation::PhysicalDiskStatusInformationTranslationTable}"
      mapping:
        # Now, here is the ValueTable: DeviceID;OK/WARN/ALARM;Status information
        source: "${source::monitors.physical_disk.collect.sources.source(1)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="physical_disk"}: $2
        legacyTextParameters:
          StatusInformation: $3
  logical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = the only source = the IBMPSG_RAIDLogicalDrive table
          type: wmi
          query: "SELECT ControllerID,DataSpace,DeviceID,RAIDLevel FROM IBMPSG_RAIDLogicalDrive"
          namespace: root\ibmsd
          computes:
          # Convert the DataSpace column (MB) in bytes
          - type: multiply
            column: 2
            value: 1048576
      mapping:
        # Here is the instance table
        source: "${source::monitors.logical_disk.discovery.sources.source(1)}"
        attributes:
          id: $3
          raid_level: $4
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $1)"
          name: "${awk::sprintf(\"%s (%s - %s)\", $3, $4, bytes2HumanFormatBase2($2))}"
        metrics:
          hw.logical_disk.limit: $2
    collect:
      # It's a "MultiInstance" collect
      # One WBEM query will be executed in order to get the info for all the logical drives
      # Much faster!
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = the only source = the IBMPSG_RAIDLogicalDrive table
          type: wmi
          query: "SELECT DeviceID,State FROM IBMPSG_RAIDLogicalDrive"
          namespace: root\ibmsd
          computes:
          # Duplicate the State column (because it'll be translated two times)
          - type: duplicateColumn
            column: 2
          # Translate the IBMPSG State column (the first one) into OK/WARN/ALARM
          - type: translate
            column: 2
            translationTable: "${translation::LogicalDiskStatusTranslationTable}"
          # Translate the IBMPSG State column (the second one) into a more readable status information string
          - type: translate
            column: 3
            translationTable: "${translation::LogicalDiskStatusInformationTranslationTable}"
      mapping:
        # Now, here is the ValueTable: DeviceID;OK/WARN/ALARM;Status information
        source: "${source::monitors.logical_disk.collect.sources.source(1)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="logical_disk"}: $2
        legacyTextParameters:
          StatusInformation: $3
translations:
  VoltageTypeTranslationTable:
    "22": Remote +18 V
    "23": Remote +1.8 V
    "10": Bus
    "11": +1.25 V
    "12": +1.5 V
    "13": +18 V
    "14": +1.8 V
    "15": Remote +12 V
    "16": Remote -12 V
    "17": Remote +5 V
    "18": Remote +3.3 V
    "19": Remote +2.5 V
    Default: ""
    "0": ""
    "1": +2.5a V
    "2": +2.5b V
    "3": +3.3 V
    "4": +5 V
    "5": +12 V
    "6": -12 V
    "7": -5 V
    "8": VIO
    "9": Vcore
    "20": Remote +1.25 V
    "21": Remote +1.5 V
  cpuStatusInformationTranslationTable:
    No Contact: No Contact
    CPU Is Idle: ""
    Stopped: Stopped
    Error: Error
    Stopping: Stopping
    Service: Service
    Default: Unknown Status
    Stressed: Stressed
    Degraded: Degraded
    Starting: Starting
    NonRecover: Non Recover
    Pred Fail: Predicted Failure
    OK: ""
    CPU Disabled by User via BIOS Setup: Disabled by user
    Lost Comm: Lost Communication
    CPU Enabled: ""
    CPU Disabled By BIOS (POST Error): Disabled by BIOS
  PowerSupplyStatusTranslationTable:
    No Contact: degraded
    Stopped: ok
    Error: failed
    Stopping: degraded
    Service: degraded
    Default: UNKNOWN
    Stressed: degraded
    Degraded: degraded
    Starting: degraded
    NonRecover: failed
    Pred Fail: degraded
    OK: ok
    Lost Comm: degraded
  MemoryBitTranslationTable:
    "13,1": Non-volatile
    "12,1": Cache DRAM
    "10,1": EDO
    "11,1": DRAM
    "1,1": Reserved
    "2,1": Other type
    "3,1": Unknown type
    "4,1": Fast-paged
    "5,1": Static column
    "6,1": Pseudo-static
    "7,1": RAMBUS
    "8,1": Synchronous
    "9,1": CMOS
  TemperatureTypeTranslationTable:
    "1": Motherboard
    "2": CPU
    default: ""
    "3": Power Supply
    "4": DASD
  FanTypeTranslationTable:
    "1": System
    "2": Power-Supply
    default: ""
    "3": CPU
  memoryStatusTranslationTable:
    "TRUE": failed
    "FALSE": ok
  LogicalDiskStatusTranslationTable:
    "0": ok
    "2": failed
    "3": ok
    "36": degraded
    "4": degraded
    "5": ok
    "6": ok
    Default: UNKNOWN
    "20": degraded
  PhysicalDiskStatusTranslationTable:
    "0": ok
    "1": ok
    "133": ok
    "254": ok
    "4": degraded
    "5": ok
    "137": ok
    "139": degraded
    "8": failed
    "129": ok
    Default: UNKNOWN
  PowerSupplyStatusInformationTranslationTable:
    No Contact: No Contact
    Stopped: Stopped
    Error: Error
    Stopping: Stopping
    Service: Service
    Default: Unknown Status
    Stressed: Stressed
    Degraded: Degraded
    Starting: Starting
    NonRecover: Non Recover
    Pred Fail: Predicted Failure
    OK: ""
    Lost Comm: Lost Communication
  PhysicalDiskStatusInformationTranslationTable:
    "0": Empty
    "1": Standby
    "133": Hot Spare
    "254": Reserved
    "4": Defunct Hot Spare
    "5": Standby Hot Spare
    "137": Online
    "139": Rebuild
    "8": Defunct
    "129": Ready
    Default: Unknown Status
  LogicalDiskStatusInformationTranslationTable:
    "0": Free
    "2": Offline
    "3": ""
    "36": Critical System
    "4": Critical
    "5": Migration
    "6": System
    Default: Unknown Status
    "20": Critical Migration
  cpuStatusTranslationTable:
    No Contact: degraded
    CPU Is Idle: ok
    Stopped: ok
    Error: failed
    Stopping: degraded
    Service: degraded
    Default: UNKNOWN
    Stressed: degraded
    Degraded: degraded
    Starting: degraded
    NonRecover: failed
    Pred Fail: degraded
    OK: ok
    CPU Disabled by User via BIOS Setup: ok
    Lost Comm: degraded
    CPU Enabled: ok
    CPU Disabled By BIOS (POST Error): failed
  enclosureIntrusionStatusTranslationTable:
    "0": ok
    "1": ok
    "2": failed
