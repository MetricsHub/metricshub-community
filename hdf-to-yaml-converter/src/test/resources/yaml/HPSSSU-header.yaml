---
embedded:
  EmbeddedFile(2): |-
    BEGIN { level=0;Enclosure="" }

    function setValue(value) {
        value=$0;
        gsub("^ *<[^<>]+>","",value);
        gsub("</[^<>]+>$","",value);
        gsub(/ *$/,"",value);
        return value
    }

    function clearArray(level) {
        class[level]="";

        objectid[level]="";
        objectname[level]="";
        objecttype[level]="";
        controllername[level]="";
        operationalstate[level]="";

        operationalstatedetail[level]="";
        objectparentid[level]="";
        modelnumber[level]="";
        serialnumber[level]="";
        cachecondition[level]="";

        wwnodename[level]="";
        portname[level]="";
        wwid[level]="";
        speed[level]="";
        portcondition[level]="";

        topology[level]="";
        fanname[level]="";
        status[level]="";
        speed[level]="";
        name[level]="";

        tempc[level]="";
        type[level]="";
        state[level]="";
        cachebattery[level]="";
        statedetails[level]="";

        diskname[level]="";
        diskbaynumber[level]="";
        shelfnumber[level]="";
        diskgroupname[level]="";
        formattedcapacity[level]="";

        failurepredicted[level]="";
        manufacturer[level]="";
        modelnumber[level]="";
        firmwareversion[level]="";
        disktype[level]="";

        serialnumber[level]="";
        diskgroupname[level]="";
        srclevelactual[level]="";
        diskgrouptype[level]="";
        totalstoragespacegb[level]="";

        usedstoragespacegb[level]="";
        familyname[level]="";
        allocatedcapacity[level]="";
        virtualdisktype[level]="";
        installstatus[level]="";

        failprediction[level]="";
        outputlink[level]="";
        inputlink[level]="";
        diskshelfname[level]="";
        shelfnumber[level]="";

        XXXXX[level]="";
        XXXXX[level]="";
        XXXXX[level]="";
        XXXXX[level]="";
        XXXXX[level]="";
    }

    function printPrimordial (Enclosure,primordialSize,primordialUnallocated) {
        if (primordialSize > 0 && Enclosure!="" ) {
    #           MSHW_LOGICALDISK; Enclosure ;Disk Group;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type) ;
            print ("MSHW_LOGICALDISK;"Enclosure";Primordial;"Enclosure" - Primordial;"";"";"";"primordialSize";"primordialUnallocated";"";0;")
        }
    }

    $0 ~ /.*. LS CONTROLLER FULL XML$/ || $0 ~ /.*. LS VDISK FULL XML$/ {
    #  Print Existing Primordials and Zero variables
        printPrimordial(Enclosure,primordialSize,primordialUnallocated)
        primordialSize=0
        primordialUnallocated=0
    #  Set the Enclosure
        Enclosure=$0
        gsub (/> LS CONTROLLER FULL XML$/,"",Enclosure)
        gsub (/> LS VDISK FULL XML$/,"",Enclosure)
        print ("MSHW_ENCLOSURE;"Enclosure";")
    #  Clear the defaultController
        defaultController=""
    }

    #  Set the BlockSize for the Enclosure
    $0 ~ /<datablocksize>/ { datablocksize[enclosure]=setValue($0) }

    #  Go up a level
    $0 ~ "^ *<[^/][^<>]+>$" {
        greatGrandParentLevel=level-2;
        grandParentLevel=level-1;
        parentLevel=level;
        level=level+1;
        childLevel=level+1;
        class[level]=$0;
        gsub(/(^ *<)|(> *$)/,"",class[level]) ;
    }

    $0 ~ /<objectid>/ { objectid[level]=setValue($0) }
    $0 ~ /<objectname>/ { objectname[level]=setValue($0) }
    $0 ~ /<objecttype>/ {
        objecttype[level]=setValue($0);
        if (objecttype[level] ~ /^diskshelf$/) {
            controllername[1]=objectname[level];
            gsub (/.Hardware./,"",controllername[1])
        }
    }

    $0 ~ /<controllername>/ {
        controllername[level]=setValue($0);
        if (defaultController == "") {
            defaultController=setValue($0)
        }
    }

    $0 ~ /<operationalstate>/ { operationalstate[level]=setValue($0) }

    $0 ~ /<operationalstatedetail>/ { operationalstatedetail[level]=setValue($0) }
    $0 ~ /<objectparentid>/ { objectparentid[level]=setValue($0) }
    $0 ~ /<modelnumber>/ { modelnumber[level]=setValue($0) }
    $0 ~ /<serialnumber>/ { serialnumber[level]=setValue($0) }
    $0 ~ /<cachecondition>/ { cachecondition[level]=setValue($0) }

    $0 ~ /<wwnodename>/ { wwnodename[level]=setValue($0) }
    $0 ~ /<portname>/ { portname[level]=setValue($0) }
    $0 ~ /<wwid>/ {
        wwid[level]=setValue($0);
        gsub(/[^A-Fa-f0-9]/,"",wwid[level])
    }
    $0 ~ /<speed>/ { speed[level]=setValue($0) }
    $0 ~ /<portcondition>/ { portcondition[level]=setValue($0) }

    $0 ~ /<topology>/ { topology[level]=setValue($0) }
    $0 ~ /<fanname>/ { fanname[level]=setValue($0) }
    $0 ~ /<status>/ { status[level]=setValue($0) }
    $0 ~ /<name>/ { name[level]=setValue($0) }

    $0 ~ /<tempc>/ { tempc[level]=setValue($0) }
    $0 ~ /<type>/ { type[level]=setValue($0) }
    $0 ~ /<state>/ { state[level]=setValue($0) }
    $0 ~ /<cachebattery>/ { cachebattery[level]=setValue($0) }
    $0 ~ /<statedetails>/ { statedetails[level]=setValue($0) }

    $0 ~ /<diskname>/ { diskname[level]=setValue($0) }
    $0 ~ /<diskbaynumber>/ { diskbaynumber[level]=setValue($0) }
    $0 ~ /<shelfnumber>/ { shelfnumber[level]=setValue($0) }
    $0 ~ /<diskgroupname>/ { diskgroupname[level]=setValue($0) }
    $0 ~ /<formattedcapacity>/ {
        formattedcapacity[level]=setValue($0);
        formattedcapacity[level]=formattedcapacity[level] * datablocksize[enclosure] / 1000000000
    }

    $0 ~ /<failurepredicted>/ { failurepredicted[level]=setValue($0) }
    $0 ~ /<manufacturer>/ { manufacturer[level]=setValue($0) }
    $0 ~ /<modelnumber>/ { modelnumber[level]=setValue($0) }
    $0 ~ /<firmwareversion>/ { firmwareversion[level]=setValue($0) }
    $0 ~ /<disktype>/ { disktype[level]=setValue($0) }

    $0 ~ /<serialnumber>/ { serialnumber[level]=setValue($0) }
    $0 ~ /<diskgroupname>/ { diskgroupname[level]=setValue($0) }
    $0 ~ /<srclevelactual>/ {
        srclevelactual[level]=setValue($0)
        srclevelactual[level]=gsub(/[^0-9]/,"",srclevelactual[level])
    }
    $0 ~ /<diskgrouptype>/ { diskgrouptype[level]=setValue($0) }
    $0 ~ /<totalstoragespacegb>/ { totalstoragespacegb[level]=setValue($0) }

    $0 ~ /<usedstoragespacegb>/ { usedstoragespacegb[level]=setValue($0) }
    $0 ~ /<familyname>/ { familyname[level]=setValue($0) }
    $0 ~ /<allocatedcapacity>/ { allocatedcapacity[level]=setValue($0) }
    $0 ~ /<virtualdisktype>/ { virtualdisktype[level]=setValue($0) }
    $0 ~ /<installstatus>/ { installstatus[level]=setValue($0) }

    $0 ~ /<failprediction>/ { failprediction[level]=setValue($0) }
    $0 ~ /<outputlink>/ { outputlink[level]=setValue($0) }
    $0 ~ /<inputlink>/ { inputlink[level]=setValue($0) }
    $0 ~ /<diskshelfname>/ { diskshelfname[level]=setValue($0) }
    $0 ~ /<shelfnumber>/ { shelfnumber[level]=setValue($0) }

    $0 ~ /<XXXXXXXX>/ { XXXXXXXX[level]=setValue($0) }
    $0 ~ /<XXXXXXXX>/ { XXXXXXXX[level]=setValue($0) }
    $0 ~ /<XXXXXXXX>/ { XXXXXXXX[level]=setValue($0) }
    $0 ~ /<XXXXXXXX>/ { XXXXXXXX[level]=setValue($0) }
    $0 ~ /<XXXXXXXX>/ { XXXXXXXX[level]=setValue($0) }


    #  Printing Section

    #  Exceptions

    $0 ~ /<controllertemperaturestatus>/ {
        controllertemperaturestatus=setValue($0)
    #           MSHW_TEMP;Enclosure;Name - (Controller Name - TempSensor Name);Temperature;Status;
        print ("MSHW_TEMP;"Enclosure"-"controllername[1]";" controllername[1] " - Temperature Status;"";"controllertemperaturestatus ";"Enclosure";")
    }

    #  Properly formatted sensors & go down a level
    $0 ~ "^ *</[^<>]+>$" {

    #  LS CONTROLLER SECTION
    # if (class[level] ~ /^object$/ && objecttype[level] ~ /^controller$/) {
    #           MSHW_CONTROLLER;Enclosure;Location;Name;Status;Status Information;Model Number;Serial Number;WWN;
    #        print ("MSHW_CONTROLLER;"Enclosure";"Enclosure objectname[level]";"controllername[level]";"operationalstate[level]";"operationalstatedetail[level]";"modelnumber[level]";"serialnumber[level]";"wwnodename[level]";"Enclosure";")
    #    }

        if (class[level] ~ /^object$/ && objecttype[level] ~ /^controller$/) {
            #       MSHW_BLADE;Enclosure;Location;Name;Status;Status Information;Model Number;Serial Number;WWN;
            print ("MSHW_BLADE;"Enclosure";"Enclosure"-"controllername[level]";"controllername[level]";"operationalstate[level]";"operationalstatedetail[level]";"modelnumber[level]";"serialnumber[level]";WWN: "wwnodename[level]";Location: "Enclosure"-"controllername[level])
        }

        if (class[level] ~ /^cachememory$/) {
            #       MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;
            print ("MSHW_MEMORY;"Enclosure"-"controllername[1]";"class[level]";"Enclosure" - "controllername[1]";"cachecondition[level]";"Enclosure";")
        }

        if (class[level] ~ /^hostport$/ || class[level] ~ /^deviceport$/) {
    #           MSHW_NETWORKCARD;Enclosure;NcType(hostport);Name - (Controller Name - Port Name);WWN;Status;Speed Mbit;LinkStatus;
            print ("MSHW_NETWORKCARD;"Enclosure"-"controllername[1]";"class[level]";"Enclosure" - "controllername[1]" - "portname[level]";"wwid[level]";"operationalstate[level]";"speed[level]*1000";"portcondition[level]";"Enclosure";" )
        }

        if (class[level] ~ /^fan$/ && status[level] != "") {
            if ( controllername[1] ~ /./ ) {
                printID = Enclosure" - "controllername[1]" - "fanname[level];
                printEnclosure = Enclosure" - "controllername[1]
            }
            else {
                printID = Enclosure " - " fanname[level];
                printEnclosure = Enclosure"-"defaultController
            }
    #         MSHW_FAN;Enclosure;Name - (Controller Name - Fan Name);Status;Speed;DeviceID;installstatus;
            print ("MSHW_FAN;"printEnclosure";"printID";"status[level]";"speed[level]";"Enclosure"-"controllername[1]"-"fanname[level]";"installstatus[level]";"Enclosure";")
        }

        if (class[level] ~ /^sensor$/ && tempc[level] != "") {
            if ( controllername[1] ~ /./ ) {
                printID = Enclosure" - "controllername[1]" - "name[level];
                printEnclosure = Enclosure" - "controllername[1]
            }
            else {
                printID = Enclosure" - " name[level];
                printEnclosure = Enclosure"-"defaultController
            }
    #         MSHW_TEMP;Enclosure;Name - (Controller Name - TempSensor Name);Temperature;Status;
            print ("MSHW_TEMP;"printEnclosure";" printID ";" tempc[level] ";;"Enclosure";")
        }

        if (class[level] ~ /^source$/ && state[level] != "") {
            if ( controllername[1] ~ /./ ) {
                printID = Enclosure" - "controllername[1]" - "type[level];
                printEnclosure = Enclosure" - "controllername[1]
            }
            else {
                printID = Enclosure" - " type[level];
                printEnclosure = Enclosure"-"defaultController
            }
    #         MSHW_PSU;Enclosure;Name - (Controller Name - PSU Name);Status;
            print ("MSHW_PSU;" printEnclosure ";" printID ";" state[level] ";"Enclosure";")
        }


        if (class[level] ~ /^cachebattery$/ && status[level] != "" ) {
    #                        MSHW_BATTERY; Enclosure ;Name - (Controller Name - Battery Name);   Status       ;Status Information;
            print ("MSHW_BATTERY;"Enclosure"-"controllername[1]";"Enclosure" - "controllername[1]" - CacheBattery;" operationalstate[level] ";;Battery System;"Enclosure";")
        }

        if (class[level] ~ /^module$/ && (class[grandParentLevel] ~ /^cachebattery$/ || class[greatGrandParentLevel] ~ /^cachebattery$/ ) ) {
            if ( controllername[1] ~ /./ ) {
                printID = Enclosure" - " controllername[1] " - " name[level];
                printEnclosure = Enclosure" - "controllername[1]
            }
            else {
                printID = Enclosure " - " name[level];
                printEnclosure = Enclosure " - " defaultController;
            }
    #                        MSHW_BATTERY; Enclosure ;Name - (Controller Name - Battery Name);Status      ;  Status Information ;
            print ("MSHW_BATTERY;" printEnclosure ";" printID ";" operationalstate[level] ";"statedetails[level]";Battery Module;"Enclosure";")
        }

    #  LS DISK SECTION
    #                        MSHW_DISK; Enclosure ;    Location       ;      Name             ;    Status               ;   Status Information    ;    Shelf, Disk Bay                                    ;    Disk Group        ;  Size GB                   ; failurepredicted          ;  Vendor               ;    Model             ; firmwareversion          ;  disktype       ; Serial Number       ;  diskgroupname                    ;
        if (class[level] ~ /^object$/ && objecttype[level] ~ /^disk$/) {
    #     String is too long for one line. Editor failed to highligh syntax error.
            part1 = "MSHW_DISK;"Enclosure"-Shelf"shelfnumber[level]";"Enclosure objectname[level]";"diskname[level]";"operationalstate[level]";"operationalstatedetail[level];
            part2 = ";Shelf "shelfnumber[level]" - Disk "diskbaynumber[level]";"diskgroupname[level]";" formattedcapacity[level] ";" failurepredicted[level] ";" manufacturer[level];
            part3 = ";" modelnumber[level] ";" firmwareversion[level] ";Disk Type: "disktype[level]";"serialnumber[level]";Disk Group: "diskgroupname[level]";" Enclosure";Location: Shelf "shelfnumber[level]", Disk "diskbaynumber[level]";";
            print (part1 part2 part3)
            primordialSize = primordialSize + formattedcapacity[level];
            if (diskgroupname[level] ~ /^Ungrouped Disks$/) {
                primordialUnallocated = primordialUnallocated + formattedcapacity[level]
            }
        }

    #  LS DISK_GROUP SECTION
        if (class[level] ~ /^object$/ && objecttype[level] ~ /^diskgroupfolder$/) {
    #                      MSHW_LOGICALDISK; Enclosure ;Disk Group;    Location       ;      Name             ;    Status               ;   Status Information         ; Size GB                    ;  Unallocated Space                                     ; AddInfo2 (Disk Group Type) ;
            print ("MSHW_LOGICALDISK;"Enclosure";Disk Group;"Enclosure objectname[level]";"diskgroupname[level]";"operationalstate[level]";"operationalstatedetail[level]";"totalstoragespacegb[level]";"totalstoragespacegb[level] - usedstoragespacegb[level]";Disk Group Type: " diskgrouptype[level]";1;")
        }

    #  LS VDISK SECTION
        if (class[level] ~ /^object$/ && objecttype[level] ~ /^virtualdisk$/) {
    #                        MSHW_LOGICALDISK; Enclosure ;Virtual Disk;    Location       ;      Name         ;    Status               ;   Status Information          ; Size GB                  ;  (Unallocated Space)  ; AddInfo2 (Disk Group Type) ;
            print ("MSHW_LOGICALDISK;"Enclosure";Virtual Disk;"Enclosure objectname[level]";"familyname[level]";"operationalstate[level]";"operationalstatedetail[level]";"allocatedcapacity[level]";"                     ";Type " virtualdisktype[level]";0;")
        }

    #  LS DISK SHELF SECTION
        if (class[level] ~ /^bus$/) {
            if (failprediction[level] ~ /[Yy]es/ && operationalstate[level] ~ /[Gg]ood/) {
                operationalstate[level] = "bad"
            }
    #           MSHW_OTHERDEVICE ; Enclosure ;Type;   Name                                          ;   OpState               ;
            print ("MSHW_OTHERDEVICE;"Enclosure" - "controllername[1]";Bus;"Enclosure" - " controllername[1] " - " name[level] ";"operationalstate[level] ";"Enclosure";")
        }

        if (class[level] ~ /^module$/ && class[parentLevel] ~ /^iomodules$/ && name[level] != "" ) {
            if (failprediction[level] ~ /[Yy]es/ && operationalstate[level] ~ /[Gg]ood/) {
                operationalstate[level] = "bad"
            }
     #                     MSWH_OTHERDEVICE ; Enclosure ;Type;Name;OpState;
            print ("MSWH_OTHERDEVICE;"Enclosure " - " controllername[1]";IO Module;"Enclosure" - " controllername[1] " - " name[level] ";"operationalstate[level] ";"Enclosure";")
        }

        if (class[level] ~ /^port$/) {
            if (failprediction[level] ~ /[Yy]es/ && operationalstate[level] ~ /[Gg]ood/) {
                operationalstate[level] = "bad"
            }
    #                        MSHW_NETWORKCARD; Enclosure ; NcType(hostport)   ; Name - (Controller Name - Port Name); WWN  ;  Status          ;  Speed Mbit; LinkStatus    ;
            print ("MSHW_NETWORKCARD;"Enclosure"-"controllername[1]";"class[level]";"Enclosure" - "controllername[1]" - "name[level]" Input Link;;"operationalstate[level]";;"inputlink[level]";" Enclosure";" )
            print ("MSHW_NETWORKCARD;"Enclosure"-"controllername[1]";"class[level]";"Enclosure" - "controllername[1]" - "name[level]" Output Link;;"operationalstate[level]";;"outputlink[level]";" Enclosure";")
        }

        if (class[level] ~ /^emu$/) {
            if (failprediction[level] ~ /[Yy]es/ && operationalstate[level] ~ /[Gg]ood/) {
                operationalstate[level] = "bad"
            }
     #                    MSHW_OTHERDEVICE;Enclosure;Type;Name;OpState;
            print ("MSHW_OTHERDEVICE;"Enclosure" - "controllername[1]";EMU;"Enclosure" - " controllername[1] " - EMU;"operationalstate[level] ";"Enclosure";")
        }

        if (class[level] ~ /^fan$/ && operationalstate[level] ~ /^[Nn]ot*[Ii]ns*/) {
            operationalstate[level] = "DiskenclosureWarn"
        }
        if (class[level] ~ /^fan$/ && name[level] != "" && operationalstate[level] != "" ) {
            if ( controllername[1] ~ /./ ) {
                printID = Enclosure" - "controllername[1]" - "name[level]
            }
            else {
                printID = Enclosure " - " name[level];
                printEnclosure = Enclosure"-"defaultController
            }
    #                        MSHW_FAN; Enclosure;Name - (Controller Name - Fan Name);Status;Speed;DeviceID;installstatus;
            print ("MSHW_FAN;" printEnclosure ";" printID ";"operationalstate[level]";;"Enclosure"-"controllername[1]"-"name[level]";;"Enclosure";")
        }

        if (class[level] ~ /^powersupply$/ && operationalstate[level] ~ /^[Nn]ot*[Ii]ns*/) {
            operationalstate[level] = "DiskenclosureWarn"
        }
        if (class[level] ~ /^powersupply$/ && operationalstate[level] != "") {
            #                MSHW_PSU; Enclosure ;Name - (Controller Name - PSU Name);   Status       ;
            print ("MSHW_PSU;"Enclosure"-"controllername[1]";"Enclosure" - "controllername[1]" - "name[level]";" operationalstate[level] ";"Enclosure";")
        }

        if (class[level] ~ /^object$/ && objecttype[level] ~ /^diskshelf$/) {
            #       MSHW_BLADE; Enclosure ;    Location                    ;      Name             ;    Status               ;   Status Information          ;    (Model Number)  ;    (Serial Number)  ; (WWN)     ;
            print ("MSHW_BLADE;"Enclosure";"Enclosure"-"controllername[level]";"diskshelfname[level]";"operationalstate[level]";"operationalstatedetail[level]";Disk Shelf"       ";"                   ";"         ";")
            print ("MSHW_DISK_TO_BLADE_TABLE;"Enclosure"-"controllername[level]";"Enclosure"-Shelf"shelfnumber[level]";")
        }

        clearArray(level)
        level=level-1 ;
    }

    level < 0 {
        print "Error:  Level is negative";
        exit
    }

    END {
        printPrimordial(Enclosure,primordialSize,primordialUnallocated)
    }
translations:
  linkStatusTT:
    fabric_login: ok
    bad: degraded
    good: ok
    link_up: ok
    link_down: degraded
  opStatusInfoTT:
    sc_locked: SC Locked
    emu_unknown: Environmental Monitoring Unit Unknow Error
    notinstalled: Not installed
    contains_ilf_disk: 'Contains '
    initialized_ok: ""
    emu_critical: Environmental Monitoring Unit Critical
    initialized_unknown: ""
    non_member_attention: Non Member Error
    uninitialized_attention: Uninitialized
    uninitialized_ok: Unintialized
    emu_ok: ""
    emu_information: ""
    member_ok: ""
    not present: Not Present
    suspended_ok: Suspended
    not_redundant_attention: Not Redundant
    not_available: Not Available
    member_failed: Member Failed
    not installed: Not installed
    initialized_attention: Initialization Error
    not_redundant_failed: Not Redundant
    diskenclosurewarn: Not Present
    restoring_ok: Restoring
    restoring_failed: Restoring Failed
    asynch_member_add_in_progress: ok
    emu_non_critical: Environmental Monitoring Unit Warning
    notpresent: Not Present
    diskgroup_degraded: Diskgroup Degraded
    emu_not_available: Environmental Monitoring Unit Not Available
    management_module_installed: ok
    suspended_attention: Suspended Error
    unknown: Unknown
    restoring_attention: Restoring Error
    emu_unrecoverable: Environmental Monitoring Unit Unrecoverable Error
    managed_by_other_agent: Managed by Other Agent
    unsupported: Unsupported
    member_attention: Member Error
    initialized_failed: Initialization Failed
    suspended_failed: Suspended Failed
    non_member_failed: Non Member Failed
    not_redundant_ok: ""
    management_module_not_installed: Management Module Not Installed
    non_member_ok: ""
    emu_unsupported: Environmental Monitoring Unit Unsupported
    not_present: Not Present
    uninitialized_failed: Uninitialized
    firmware_upgrade: Firmware Upgrade
    not_installed: Not installed
    asynch_member_remove_in_progress: ok
  cacheStatusInfoTT:
    default: ""
    no_mirror: No Mirror
  predictedFailureTT:
    "no": "false"
    "yes": "true"
  opStatusTT:
    normal: ok
    not present: MISSING
    notpresent: MISSING
    bad: failed
    notinstalled: MISSING
    no_mirror: degraded
    failed: failed
    good: ok
    not installed: MISSING
    default: UNKNOWN
    attention: degraded
    not_present: MISSING
    diskenclosurewarn: degraded
    not_installed: MISSING
connector:
  detection:
    criteria:
    # SSSU should exist and be in Path
    - type: osCommand
      commandLine: sssu help
      errorMessage: SSSU Does not appear to be installed on this system
      expectedResult: SSSU for HP
      executeLocally: true
    # SSSU Should be able to connect and list systems
    - type: osCommand
      commandLine: "sssu \"SELECT Manager %{HOSTNAME} username=%{USERNAME} password=%{PASSWORD}\" \"LS SYSTEM\""
      errorMessage: Unable to connect using SSSU
      expectedResult: Systems available on this Manager
      executeLocally: true
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          computes:
          # Process the sssu command throug an AWK script
          - type: awk
            script: EmbeddedFile(2)
            keep: ^MSHW
            separators: ;
        source(2):
          # Enclosure Source 2 = Copy of Source 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only Enclosures
            # MS_HW_Enclosure;ID;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_ENCLOSURE$
      mapping:
        # The discovery table
        # MS_HW_Enclosure;ID;
        source: $monitors.enclosure.discovery.sources.source(2)$
        attributes:
          id: $column(2)
          __display_id: $column(2)
          type: DiskSystem
          model: EVA System
          vendor: HP
          name: "sprintf(\"%s (%s %s - %s)\", $column(2), \"HP\", \"EVA System\", \"DiskSystem\")"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          computes:
          # Process the sssu command throug an AWK script
          - type: awk
            script: EmbeddedFile(2)
            keep: ^MSHW
            separators: ;
      mapping:
        # The value table (taken from enclosure.discovery, since we don't actually want to collect anything.
        source: $monitors.enclosure.discovery.sources.source(2)$
        deviceId: $column(2)
  blade:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only DiskControllers
            # MSHW_BLADE;Enclosure;DeviceID;Name;Status;Status Information;Model Number;Serial Number;WWN;Location
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_BLADE$
      mapping:
        # The discovery table
        # MSHW_BLADE;Enclosure;DeviceID;Name;Status;Status Information;Model Number;Serial Number;WWN;Location
        source: $monitors.blade.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(4)
          model: $column(7)
          serial_number: $column(8)
          blade_name: $column(4)
          info: "join($column(10), $column(9), \"Type: SAN Controller\", \" \")"
          hw.parent.type: DiskSystem
          hw.parent.id: $column(2)
          name: "sprintf(\"%s (%s - %s)\", $column(4), $column(4), $column(7))"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only DiskControllers
            # MSHW_BLADE;Enclosure;Location;Name;Status;Status Information;Model Number;Serial Number;WWN;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_BLADE$
            # Now translate  into OK/Warning/Alarm
            # MSHW_BLADE;Enclosure;Location;Name;Status;Status Information;Model Number;Serial Number;WWN;
          - type: translate
            column: 5
            translationTable: opStatusTT
            # Now translate Status information
            # MSHW_BLADE;Enclosure;Location;Name;Status;Status Information;Model Number;Serial Number;WWN;
          - type: translate
            column: 6
            translationTable: opStatusInfoTT
      mapping:
        # The value table
        source: $monitors.blade.collect.sources.source(1)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="blade"}: $column(5)
        legacyTextParameters:
          StatusInformation: $column(6)
  fan:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only Fans
            # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;Speed;DeviceID;InstallStatus;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_FAN$
            # Exclude fans not installed
            # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;Speed;DeviceID;InstallStatus;SystemName;
          - type: excludeMatchingLines
            column: 7
            valueList: "no"
          - type: translate
            column: 4
            translationTable: opStatusTT
          - type: excludeMatchingLines
            column: 4
            valueList: MISSING
      mapping:
        # The discovery table
        # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;Speed;DeviceID;InstallStatus;SystemName;
        source: $monitors.fan.discovery.sources.source(1)$
        attributes:
          id: $column(6)
          __display_id: $column(6)
          hw.parent.type: blade
          hw.parent.id: $column(2)
          name: $column(6)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only DiskControllers
            # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;Speed;DeviceID;InstallStatus;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_FAN$
            # duplicate for status information
            # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;statusinfo;Speed;DeviceID;InstallStatus;SystemName;
          - type: duplicateColumn
            column: 4
            # Now translate  status information
            # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;statusinfo;Speed;DeviceID;InstallStatus;SystemName;
          - type: translate
            column: 5
            translationTable: opStatusInfoTT
          - type: translate
            column: 4
            translationTable: opStatusTT
      mapping:
        # The value table
        # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;Speed;DeviceID;InstallStatus;SystemName;
        source: $monitors.fan.collect.sources.source(1)$
        deviceId: $column(7)
        metrics:
          hw.status{hw.type="fan"}: $column(4)
          hw.fan.speed: $column(6)
        legacyTextParameters:
          StatusInformation: $column(5)
  battery:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only Batterys
            # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_Battery$
            # Exclude Batterys not installed
            # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
          - type: excludeMatchingLines
            column: 4
            valueList: "not installed,not_installed,not present,not_present,notinstalled,notpresent,Not Present"
      mapping:
        # The discovery table
        # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
        source: $monitors.battery.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(3)
          type: $column(6)
          hw.parent.type: blade
          hw.parent.id: $column(2)
          name: "sprintf(\"%s (%s)\", $column(3), $column(6))"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only DiskControllers
            # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_Battery$
            # Now translate  into OK/Warning/Alarm
            # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
          - type: translate
            column: 4
            translationTable: opStatusTT
            # Now translate Status information
            # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
          - type: translate
            column: 5
            translationTable: opStatusInfoTT
      mapping:
        # The value table
        # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
        source: $monitors.battery.collect.sources.source(1)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="battery"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(5)
  logical_disk:
    discovery:
      sources:
        source(1):
          computes:
            # Awk it and keep only LogicalDisks
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: awk
            script: EmbeddedFile(2)
            keep: ^MSHW_LOGICALDISK
            separators: ;
            # Exclude Snapshots
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: excludeMatchingLines
            column: 10
            valueList: "Demand-allocated Snapshot,Fully-allocated Snapshot,SnapClone"
            # Convert Size from Gbytes to bytes
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: multiply
            column: 8
            value: 1073741824
        source(2):
          # Get the Enclosure Discovery for the Primordial Array
          # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only the Primordials
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_LOGICALDISK$
        source(3):
          # Union the main logical disk discovery with the Primordials
          # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          type: tableUnion
          tables:
          - $monitors.logical_disk.discovery.sources.source(1)$
          - $monitors.logical_disk.discovery.sources.source(2)$
      mapping:
        # The discovery table
        # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
        source: $monitors.logical_disk.discovery.sources.source(3)$
        attributes:
          id: $column(4)
          __display_id: $column(5)
          hw.logical_disk.limit: $column(8)
          type: $column(3)
          info: $column(10)
          hw.parent.type: enclosure
          hw.parent.id: $column(2)
          name: "sprintf(\"%s (%s)\", $column(5), $column(8))"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          computes:
            # Awk it and keep only LogicalDisks
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: awk
            script: EmbeddedFile(2)
            keep: ^MSHW_LOGICALDISK
            separators: ;
            # Now translate  into OK/Warning/Alarm
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: translate
            column: 6
            translationTable: opStatusTT
            # Now translate Status information
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: translate
            column: 7
            translationTable: opStatusInfoTT
            # Convert Unallocated Space from Gbytes to bytes
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: multiply
            column: 9
            value: 1073741824
        source(2):
          # Get the Enclosure Discovery for the Primordial Array
          # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only the Primordials
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_LOGICALDISK$
        source(3):
          # Union the main logical disk discovery with the Primordials
          # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          type: tableUnion
          tables:
          - $monitors.logical_disk.collect.sources.source(1)$
          - $monitors.logical_disk.collect.sources.source(2)$
      mapping:
        # The value table
        # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
        source: $monitors.logical_disk.collect.sources.source(3)$
        deviceId: $column(4)
        metrics:
          hw.status{hw.type="logical_disk"}: $column(6)
          hw.logical_disk.usage{state="free"}: $column(9)
          hw.logical_disk.usage{state="used"}: collectAllocatedSpace()
        legacyTextParameters:
          StatusInformation: $column(7)
  memory:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only Memorys
            # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_MEMORY$
          # exclude not installed
          - type: excludeMatchingLines
            column: 5
            valueList: "not installed,not_installed,not present,not_present,notinstalled,notpresent,Not Present"
      mapping:
        # The discovery table
        # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;SystemName;
        source: $monitors.memory.discovery.sources.source(1)$
        attributes:
          id: $column(4)
          type: $column(3)
          hw.parent.type: blade
          hw.parent.id: $column(2)
          name: "sprintf(\"%s (%s)\", $column(4), $column(3))"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only DiskControllers
            # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_MEMORY$
            # Duplicate Status Column
            # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;StatusInfo;SystemName;
          - type: duplicateColumn
            column: 5
            # Now translate  into OK/Warning/Alarm
            # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;StatusInfo;SystemName;
          - type: translate
            column: 5
            translationTable: opStatusTT
            # Translate Status info
            # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;StatusInfo;SystemName;
          - type: translate
            column: 6
            translationTable: cacheStatusInfoTT
      mapping:
        # The value table
        # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;SystemName;
        source: $monitors.memory.collect.sources.source(1)$
        deviceId: $column(4)
        metrics:
          hw.status{hw.type="memory"}: $column(5)
        legacyTextParameters:
          StatusInformation: $column(6)
  network:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only NetworkCards
            # MSHW_NETWORKCARD;Enclosure;NcType(hostport);Name;WWN;Status;Speed Mbit;LinkStatus;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_NETWORKCARD$
          # exclude not installed
          - type: excludeMatchingLines
            column: 6
            valueList: "not installed,not_installed,not present,not_present,notinstalled,notpresent,Not Present"
      mapping:
        # The discovery table
        # MSHW_NETWORKCARD;Enclosure;NcType(hostport);Name;WWN;Status;Speed Mbit;LinkStatus;SystemName;
        source: $monitors.network.discovery.sources.source(1)$
        attributes:
          id: $column(4)
          __display_id: $column(4)
          physical_address: $column(5)
          physical_address_type: WWN
          hw.parent.type: blade
          hw.parent.id: $column(2)
          name: $column(4)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only DiskControllers
            # MSHW_NETWORKCARD;Enclosure;NcType(hostport);Name;WWN;Status;Speed Mbit;LinkStatus;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_NetworkCard$
            # Now translate  into OK/Warning/Alarm
            # MSHW_NETWORKCARD;Enclosure;NcType(hostport);Name;WWN;Status;Speed Mbit;LinkStatus;SystemName;
          - type: translate
            column: 6
            translationTable: opStatusTT
            # Now translate  into OK/Warning/Alarm
            # MSHW_NETWORKCARD;Enclosure;NcType(hostport);Name;WWN;Status;Speed Mbit;LinkStatus;SystemName;
          - type: translate
            column: 8
            translationTable: linkStatusTT
      mapping:
        # The value table
        # MSHW_NETWORKCARD;Enclosure;NcType(hostport);Name;WWN;Status;Speed Mbit;LinkStatus; SystemName;
        source: $monitors.network.collect.sources.source(1)$
        deviceId: $column(4)
        metrics:
          hw.network.bandwidth.limit: megaBit2Bit($column(7))
          hw.network.up: legacyLinkStatus($column(8))
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only PhysicalDisks
            # MSHW_DISK;Shelf;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_DISK$
            # Convert Size from Gbytes to bytes
            # MSHW_DISK;Shelf;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
          - type: multiply
            column: 9
            value: 1000000000
        source(2):
          # Source(2) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only PhysicalDisks
            # MSHW_DISK_TO_BLADE_TABLE;Enclosure;Shelf;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_DISK_TO_BLADE_TABLE$
        source(3):
          # Table joint of (1) and (2)
          # as disks can ony be allocated to shelves where we need Enclosure
          # MSHW_DISK;Shelf;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;Location;MSHW_DISK_TO_BLADE_TABLE;Enclosure;Shelf;
          type: tableJoin
          leftTable: $monitors.physical_disk.discovery.sources.source(1)$
          rightTable: $monitors.physical_disk.discovery.sources.source(2)$
          leftKeyColumn: 2
          rightKeyColumn: 3
          defaultRightLine: ;;;
          computes:
          # exclude not installed
          - type: excludeMatchingLines
            column: 5
            valueList: "not installed,not_installed,not present,not_present,notinstalled,notpresent,Not Present"
      mapping:
        # The discovery table\n    1         2         3     4     5           6                 7              8         9            10         11     12    13              14        15            16             17     18        19       \t\t\t\t\t\t\t20      21\nMSHW_DISK;Shelf;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;Location;MSHW_DISK_TO_BLADE_TABLE;Enclosure;Shelf;
        source: $monitors.physical_disk.discovery.sources.source(3)$
        attributes:
          id: $column(3)
          __display_id: $column(7)
          vendor: $column(11)
          model: $column(12)
          serial_number: $column(15)
          firmware_version: $column(13)
          info: "join($column(18), $column(14), $column(16), \" \")"
          hw.parent.type: blade
          hw.parent.id: $column(20)
          name: "sprintf(\"%s (%s - %s)\", $column(7), $column(12), $column(9))"
        metrics:
          hw.physical_disk.size: $column(9)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only DiskControllers
            # MSHW_DISK;Enclosure;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_DISK$
            # Now translate  into OK/Warning/Alarm
            # MSHW_DISK;Enclosure;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
          - type: translate
            column: 5
            translationTable: opStatusTT
            # Now translate Status information
            # MSHW_DISK;Enclosure;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
          - type: translate
            column: 6
            translationTable: opStatusInfoTT
            # Now translate  into OK/Warning/Alarm
            # MSHW_DISK;Enclosure;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
          - type: translate
            column: 10
            translationTable: predictedFailureTT
      mapping:
        # The value table
        #     1         2         3     4     5        #  6        #        7        #     8         9        #   10         11     12    13        #     14        15        #   16        ;
        # MSHW_DISK;Enclosure;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
        source: $monitors.physical_disk.collect.sources.source(1)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="physical_disk"}: $column(5)
          hw.status{hw.type="physical_disk", state="predicted_failure"}: boolean($column(10))
        legacyTextParameters:
          StatusInformation: $column(6)
  power_supply:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only PowerSupplys
            # MSHW_PSU; Enclosure ;Name - (Controller Name - PSU Name);   Status       ;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PSU$
            # Exclude PowerSupplys not installed
            # MSHW_PSU; Enclosure ;Name - (Controller Name - PSU Name);   Status       ;SystemName;
          - type: excludeMatchingLines
            column: 4
            valueList: "not installed,not_installed,not present,not_present,notinstalled,notpresent,Not Present"
      mapping:
        # The discovery table
        # MSHW_PSU; Enclosure ;Name - (Controller Name - PSU Name);   Status       ;SystemName;
        source: $monitors.power_supply.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(3)
          hw.parent.type: blade
          hw.parent.id: $column(2)
          name: "sprintf(\"%s, $column(3))"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only DiskControllers
            # MSHW_PSU; Enclosure ;Name - (Controller Name - PSU Name);   Status       ;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PSU$
            # Now translate  into OK/Warning/Alarm
            # MSHW_PSU; Enclosure ;Name - (Controller Name - PSU Name);   Status       ;SystemName;
          - type: translate
            column: 4
            translationTable: opStatusTT
      mapping:
        # The value table
        # MSHW_PSU; Enclosure ;Name - (Controller Name - PSU Name);   Status       ;SystemName;
        source: $monitors.power_supply.collect.sources.source(1)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="power_supply"}: $column(4)
  temperature:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only Temperatures
            # MSHW_TEMP;Enclosure;Name;Temperature;Status;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_TEMP$
      mapping:
        # The discovery table
        # MSHW_TEMP;Enclosure;Name;Temperature;Status;SystemName;
        source: $monitors.temperature.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(3)
          hw.parent.type: blade
          hw.parent.id: $column(2)
          name: $column(3)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only DiskControllers
            # MSHW_TEMP;Enclosure;Name;Temperature;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_TEMP$
            # Now translate  into OK/Warning/Alarm
            # MSHW_TEMP;Enclosure;Name;Temperature;Status;
          - type: translate
            column: 5
            translationTable: opStatusTT
      mapping:
        # The value table
        # MSHW_TEMP;Enclosure;Name;Temperature;Status;
        source: $monitors.temperature.collect.sources.source(1)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="temperature"}: $column(5)
          hw.temperature: $column(4)
  other_device:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(1)$
          computes:
            # Keep only Temperatures
            # MSWH_OTHERDEVICE;Enclosure;Type;Name;OpState;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHERDEVICE$
          # Exclude not installed
          - type: excludeMatchingLines
            column: 5
            valueList: "not installed,not_installed,not present,not_present,notinstalled,notpresent,Not Present"
      mapping:
        # The discovery table
        # MSWH_OTHERDEVICE;Enclosure;Type;Name;OpState;SystemName;
        source: $monitors.other_device.discovery.sources.source(1)$
        attributes:
          device_type: $column(3)
          id: $column(4)
          __display_id: $column(4)
          hw.parent.type: blade
          hw.parent.id: $column(2)
          name: "sprintf(\"%s: %s\", $column(3), $column(4))"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          # MSWH_OTHERDEVICE;Enclosure;Type;Name;OpState;SystemName;
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep only Other Devices
            # MSWH_OTHERDEVICE;Enclosure;Type;Name;OpState;SystemName;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHERDEVICE$
            # Now translate  into OK/Warning/Alarm
            # MSWH_OTHERDEVICE;Enclosure;Type;Name;OpState;opState;SystemName;
          - type: duplicateColumn
            column: 5
            # Now translate  into OK/Warning/Alarm
            # MSWH_OTHERDEVICE;Enclosure;Type;Name;status;OpState;SystemName;
          - type: translate
            column: 5
            translationTable: opStatusTT
      mapping:
        # The value table
        # MSWH_OTHERDEVICE;Enclosure;Type;Name;status;OpState;SystemName;
        source: $monitors.other_device.collect.sources.source(1)$
        deviceId: $column(4)
        metrics:
          hw.status{hw.type="other_device"}: $column(5)
        legacyTextParameters:
          StatusInformation: $column(6)
