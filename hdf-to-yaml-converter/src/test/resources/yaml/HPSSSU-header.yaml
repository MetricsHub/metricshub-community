---
embedded:
  EmbeddedFile(2): "BEGIN { level=0;Enclosure=\"\" }\n\nfunction setValue(value) {\n\tvalue=$0;\n\tgsub(\"^ *<[^<>]+>\",\"\",value);\n\tgsub(\"</[^<>]+>$\",\"\",value);\n\tgsub(/ *$/,\"\",value);\n\treturn value\n}\n\nfunction clearArray(level) {\n\tclass[level]=\"\";\n\n\tobjectid[level]=\"\";\n\tobjectname[level]=\"\";\n\tobjecttype[level]=\"\";\n\tcontrollername[level]=\"\";\n\toperationalstate[level]=\"\";\n\n\toperationalstatedetail[level]=\"\";\n\tobjectparentid[level]=\"\";\n\tmodelnumber[level]=\"\";\n\tserialnumber[level]=\"\";\n\tcachecondition[level]=\"\";\n\n\twwnodename[level]=\"\";\n\tportname[level]=\"\";\n\twwid[level]=\"\";\n\tspeed[level]=\"\";\n\tportcondition[level]=\"\";\n\n\ttopology[level]=\"\";\n\tfanname[level]=\"\";\n\tstatus[level]=\"\";\n\tspeed[level]=\"\";\n\tname[level]=\"\";\n\n\ttempc[level]=\"\";\n\ttype[level]=\"\";\n\tstate[level]=\"\";\n\tcachebattery[level]=\"\";\n\tstatedetails[level]=\"\";\n\n\tdiskname[level]=\"\";\n\tdiskbaynumber[level]=\"\";\n\tshelfnumber[level]=\"\";\n\tdiskgroupname[level]=\"\";\n\tformattedcapacity[level]=\"\";\n\n\tfailurepredicted[level]=\"\";\n\tmanufacturer[level]=\"\";\n\tmodelnumber[level]=\"\";\n\tfirmwareversion[level]=\"\";\n\tdisktype[level]=\"\";\n\n\tserialnumber[level]=\"\";\n\tdiskgroupname[level]=\"\";\n\tsrclevelactual[level]=\"\";\n\tdiskgrouptype[level]=\"\";\n\ttotalstoragespacegb[level]=\"\";\n\n\tusedstoragespacegb[level]=\"\";\n\tfamilyname[level]=\"\";\n\tallocatedcapacity[level]=\"\";\n\tvirtualdisktype[level]=\"\";\n\tinstallstatus[level]=\"\";\n\n\tfailprediction[level]=\"\";\n\toutputlink[level]=\"\";\n\tinputlink[level]=\"\";\n\tdiskshelfname[level]=\"\";\n\tshelfnumber[level]=\"\";\n\n\tXXXXX[level]=\"\";\n\tXXXXX[level]=\"\";\n\tXXXXX[level]=\"\";\n\tXXXXX[level]=\"\";\n\tXXXXX[level]=\"\";\n}\n\nfunction printPrimordial (Enclosure,primordialSize,primordialUnallocated) {\n\tif (primordialSize > 0 && Enclosure!=\"\" ) {\n#           MSHW_LOGICALDISK; Enclosure ;Disk Group;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type) ;\n\t\tprint (\"MSHW_LOGICALDISK;\"Enclosure\";Primordial;\"Enclosure\" - Primordial;\"\";\"\";\"\";\"primordialSize\";\"primordialUnallocated\";\"\";0;\")\n\t}\n}\n\n$0 ~ /.*. LS CONTROLLER FULL XML$/ || $0 ~ /.*. LS VDISK FULL XML$/ {\n#  Print Existing Primordials and Zero variables\n\tprintPrimordial(Enclosure,primordialSize,primordialUnallocated)\n\tprimordialSize=0\n\tprimordialUnallocated=0\n#  Set the Enclosure\n\tEnclosure=$0\n\tgsub (/> LS CONTROLLER FULL XML$/,\"\",Enclosure)\n\tgsub (/> LS VDISK FULL XML$/,\"\",Enclosure)\n\tprint (\"MSHW_ENCLOSURE;\"Enclosure\";\")\n#  Clear the defaultController\n\tdefaultController=\"\"\n}\n\n#  Set the BlockSize for the Enclosure\n$0 ~ /<datablocksize>/ { datablocksize[enclosure]=setValue($0) }\n\n#  Go up a level\n$0 ~ \"^ *<[^/][^<>]+>$\" {\n\tgreatGrandParentLevel=level-2;\n\tgrandParentLevel=level-1;\n\tparentLevel=level;\n\tlevel=level+1;\n\tchildLevel=level+1;\n\tclass[level]=$0;\n\tgsub(/(^ *<)|(> *$)/,\"\",class[level]) ;\n}\n\n$0 ~ /<objectid>/ { objectid[level]=setValue($0) }\n$0 ~ /<objectname>/ { objectname[level]=setValue($0) }\n$0 ~ /<objecttype>/ {\n\tobjecttype[level]=setValue($0);\n\tif (objecttype[level] ~ /^diskshelf$/) {\n\t\tcontrollername[1]=objectname[level];\n\t\tgsub (/.Hardware./,\"\",controllername[1])\n\t}\n}\n\n$0 ~ /<controllername>/ {\n\tcontrollername[level]=setValue($0);\n\tif (defaultController == \"\") {\n\t\tdefaultController=setValue($0)\n\t}\n}\n\n$0 ~ /<operationalstate>/ { operationalstate[level]=setValue($0) }\n\n$0 ~ /<operationalstatedetail>/ { operationalstatedetail[level]=setValue($0) }\n$0 ~ /<objectparentid>/ { objectparentid[level]=setValue($0) }\n$0 ~ /<modelnumber>/ { modelnumber[level]=setValue($0) }\n$0 ~ /<serialnumber>/ { serialnumber[level]=setValue($0) }\n$0 ~ /<cachecondition>/ { cachecondition[level]=setValue($0) }\n\n$0 ~ /<wwnodename>/ { wwnodename[level]=setValue($0) }\n$0 ~ /<portname>/ { portname[level]=setValue($0) }\n$0 ~ /<wwid>/ {\n\twwid[level]=setValue($0);\n\tgsub(/[^A-Fa-f0-9]/,\"\",wwid[level])\n}\n$0 ~ /<speed>/ { speed[level]=setValue($0) }\n$0 ~ /<portcondition>/ { portcondition[level]=setValue($0) }\n\n$0 ~ /<topology>/ { topology[level]=setValue($0) }\n$0 ~ /<fanname>/ { fanname[level]=setValue($0) }\n$0 ~ /<status>/ { status[level]=setValue($0) }\n$0 ~ /<name>/ { name[level]=setValue($0) }\n\n$0 ~ /<tempc>/ { tempc[level]=setValue($0) }\n$0 ~ /<type>/ { type[level]=setValue($0) }\n$0 ~ /<state>/ { state[level]=setValue($0) }\n$0 ~ /<cachebattery>/ { cachebattery[level]=setValue($0) }\n$0 ~ /<statedetails>/ { statedetails[level]=setValue($0) }\n\n$0 ~ /<diskname>/ { diskname[level]=setValue($0) }\n$0 ~ /<diskbaynumber>/ { diskbaynumber[level]=setValue($0) }\n$0 ~ /<shelfnumber>/ { shelfnumber[level]=setValue($0) }\n$0 ~ /<diskgroupname>/ { diskgroupname[level]=setValue($0) }\n$0 ~ /<formattedcapacity>/ {\n\tformattedcapacity[level]=setValue($0);\n\tformattedcapacity[level]=formattedcapacity[level] * datablocksize[enclosure] / 1000000000\n}\n\n$0 ~ /<failurepredicted>/ { failurepredicted[level]=setValue($0) }\n$0 ~ /<manufacturer>/ { manufacturer[level]=setValue($0) }\n$0 ~ /<modelnumber>/ { modelnumber[level]=setValue($0) }\n$0 ~ /<firmwareversion>/ { firmwareversion[level]=setValue($0) }\n$0 ~ /<disktype>/ { disktype[level]=setValue($0) }\n\n$0 ~ /<serialnumber>/ { serialnumber[level]=setValue($0) }\n$0 ~ /<diskgroupname>/ { diskgroupname[level]=setValue($0) }\n$0 ~ /<srclevelactual>/ {\n\tsrclevelactual[level]=setValue($0)\n\tsrclevelactual[level]=gsub(/[^0-9]/,\"\",srclevelactual[level])\n}\n$0 ~ /<diskgrouptype>/ { diskgrouptype[level]=setValue($0) }\n$0 ~ /<totalstoragespacegb>/ { totalstoragespacegb[level]=setValue($0) }\n\n$0 ~ /<usedstoragespacegb>/ { usedstoragespacegb[level]=setValue($0) }\n$0 ~ /<familyname>/ { familyname[level]=setValue($0) }\n$0 ~ /<allocatedcapacity>/ { allocatedcapacity[level]=setValue($0) }\n$0 ~ /<virtualdisktype>/ { virtualdisktype[level]=setValue($0) }\n$0 ~ /<installstatus>/ { installstatus[level]=setValue($0) }\n\n$0 ~ /<failprediction>/ { failprediction[level]=setValue($0) }\n$0 ~ /<outputlink>/ { outputlink[level]=setValue($0) }\n$0 ~ /<inputlink>/ { inputlink[level]=setValue($0) }\n$0 ~ /<diskshelfname>/ { diskshelfname[level]=setValue($0) }\n$0 ~ /<shelfnumber>/ { shelfnumber[level]=setValue($0) }\n\n$0 ~ /<XXXXXXXX>/ { XXXXXXXX[level]=setValue($0) }\n$0 ~ /<XXXXXXXX>/ { XXXXXXXX[level]=setValue($0) }\n$0 ~ /<XXXXXXXX>/ { XXXXXXXX[level]=setValue($0) }\n$0 ~ /<XXXXXXXX>/ { XXXXXXXX[level]=setValue($0) }\n$0 ~ /<XXXXXXXX>/ { XXXXXXXX[level]=setValue($0) }\n\n\n#  Printing Section\n\n#  Exceptions\n\n$0 ~ /<controllertemperaturestatus>/ {\n\tcontrollertemperaturestatus=setValue($0)\n# \t      MSHW_TEMP;Enclosure;Name - (Controller Name - TempSensor Name);Temperature;Status;\n\tprint (\"MSHW_TEMP;\"Enclosure\"-\"controllername[1]\";\" controllername[1] \" - Temperature Status;\"\";\"controllertemperaturestatus \";\"Enclosure\";\")\n}\n\n#  Properly formatted sensors & go down a level\n$0 ~ \"^ *</[^<>]+>$\" {\n\n#  LS CONTROLLER SECTION\n# if (class[level] ~ /^object$/ && objecttype[level] ~ /^controller$/) {\n#           MSHW_CONTROLLER;Enclosure;Location;Name;Status;Status Information;Model Number;Serial Number;WWN;\n#\t\tprint (\"MSHW_CONTROLLER;\"Enclosure\";\"Enclosure objectname[level]\";\"controllername[level]\";\"operationalstate[level]\";\"operationalstatedetail[level]\";\"modelnumber[level]\";\"serialnumber[level]\";\"wwnodename[level]\";\"Enclosure\";\")\n#\t}\n\n\tif (class[level] ~ /^object$/ && objecttype[level] ~ /^controller$/) {\n\t\t#       MSHW_BLADE;Enclosure;Location;Name;Status;Status Information;Model Number;Serial Number;WWN;\n\t\tprint (\"MSHW_BLADE;\"Enclosure\";\"Enclosure\"-\"controllername[level]\";\"controllername[level]\";\"operationalstate[level]\";\"operationalstatedetail[level]\";\"modelnumber[level]\";\"serialnumber[level]\";WWN: \"wwnodename[level]\";Location: \"Enclosure\"-\"controllername[level])\n\t}\n\n\tif (class[level] ~ /^cachememory$/) {\n\t\t#       MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;\n\t\tprint (\"MSHW_MEMORY;\"Enclosure\"-\"controllername[1]\";\"class[level]\";\"Enclosure\" - \"controllername[1]\";\"cachecondition[level]\";\"Enclosure\";\")\n\t}\n\n\tif (class[level] ~ /^hostport$/ || class[level] ~ /^deviceport$/) {\n#           MSHW_NETWORKCARD;Enclosure;NcType(hostport);Name - (Controller Name - Port Name);WWN;Status;Speed Mbit;LinkStatus;\n\t\tprint (\"MSHW_NETWORKCARD;\"Enclosure\"-\"controllername[1]\";\"class[level]\";\"Enclosure\" - \"controllername[1]\" - \"portname[level]\";\"wwid[level]\";\"operationalstate[level]\";\"speed[level]*1000\";\"portcondition[level]\";\"Enclosure\";\" )\n\t}\n\n\tif (class[level] ~ /^fan$/ && status[level] != \"\") {\n\t\tif ( controllername[1] ~ /./ ) {\n\t\t\tprintID = Enclosure\" - \"controllername[1]\" - \"fanname[level];\n\t\t\tprintEnclosure = Enclosure\" - \"controllername[1]\n\t\t}\n\t\telse {\n\t\t\tprintID = Enclosure \" - \" fanname[level];\n\t\t\tprintEnclosure = Enclosure\"-\"defaultController\n\t\t}\n#         MSHW_FAN;Enclosure;Name - (Controller Name - Fan Name);Status;Speed;DeviceID;installstatus;\n\t\tprint (\"MSHW_FAN;\"printEnclosure\";\"printID\";\"status[level]\";\"speed[level]\";\"Enclosure\"-\"controllername[1]\"-\"fanname[level]\";\"installstatus[level]\";\"Enclosure\";\")\n\t}\n\n\tif (class[level] ~ /^sensor$/ && tempc[level] != \"\") {\n\t\tif ( controllername[1] ~ /./ ) {\n\t\t\tprintID = Enclosure\" - \"controllername[1]\" - \"name[level];\n\t\t\tprintEnclosure = Enclosure\" - \"controllername[1]\n\t\t}\n\t\telse {\n\t\t\tprintID = Enclosure\" - \" name[level];\n\t\t\tprintEnclosure = Enclosure\"-\"defaultController\n\t\t}\n#         MSHW_TEMP;Enclosure;Name - (Controller Name - TempSensor Name);Temperature;Status;\n\t\tprint (\"MSHW_TEMP;\"printEnclosure\";\" printID \";\" tempc[level] \";;\"Enclosure\";\")\n\t}\n\n\tif (class[level] ~ /^source$/ && state[level] != \"\") {\n\t\tif ( controllername[1] ~ /./ ) {\n\t\t\tprintID = Enclosure\" - \"controllername[1]\" - \"type[level];\n\t\t\tprintEnclosure = Enclosure\" - \"controllername[1]\n\t\t}\n\t\telse {\n\t\t\tprintID = Enclosure\" - \" type[level];\n\t\t\tprintEnclosure = Enclosure\"-\"defaultController\n\t\t}\n#         MSHW_PSU;Enclosure;Name - (Controller Name - PSU Name);Status;\n\t\tprint (\"MSHW_PSU;\" printEnclosure \";\" printID \";\" state[level] \";\"Enclosure\";\")\n\t}\n\n\n\tif (class[level] ~ /^cachebattery$/ && status[level] != \"\" ) {\n#\t\t\t\t\t\tMSHW_BATTERY; Enclosure ;Name - (Controller Name - Battery Name);   Status       ;Status Information;\n\t\tprint (\"MSHW_BATTERY;\"Enclosure\"-\"controllername[1]\";\"Enclosure\" - \"controllername[1]\" - CacheBattery;\" operationalstate[level] \";;Battery System;\"Enclosure\";\")\n\t}\n\n\tif (class[level] ~ /^module$/ && (class[grandParentLevel] ~ /^cachebattery$/ || class[greatGrandParentLevel] ~ /^cachebattery$/ ) ) {\n\t\tif ( controllername[1] ~ /./ ) {\n\t\t\tprintID = Enclosure\" - \" controllername[1] \" - \" name[level];\n\t\t\tprintEnclosure = Enclosure\" - \"controllername[1]\n\t\t}\n\t\telse {\n\t\t\tprintID = Enclosure \" - \" name[level];\n\t\t\tprintEnclosure = Enclosure \" - \" defaultController;\n\t\t}\n#\t\t\t\t\t\tMSHW_BATTERY; Enclosure ;Name - (Controller Name - Battery Name);Status      ;  Status Information ;\n\t\tprint (\"MSHW_BATTERY;\" printEnclosure \";\" printID \";\" operationalstate[level] \";\"statedetails[level]\";Battery Module;\"Enclosure\";\")\n\t}\n\n#  LS DISK SECTION\n#\t\t\t\t\t\tMSHW_DISK; Enclosure ;    Location       ;      Name             ;    Status               ;   Status Information    ;    Shelf, Disk Bay                                    ;    Disk Group        ;  Size GB                   ; failurepredicted          ;  Vendor               ;    Model             ; firmwareversion          ;  disktype       ; Serial Number       ;  diskgroupname                    ;\n\tif (class[level] ~ /^object$/ && objecttype[level] ~ /^disk$/) {\n# \tString is too long for one line. Editor failed to highligh syntax error.\n\t\tpart1 = \"MSHW_DISK;\"Enclosure\"-Shelf\"shelfnumber[level]\";\"Enclosure objectname[level]\";\"diskname[level]\";\"operationalstate[level]\";\"operationalstatedetail[level];\n\t\tpart2 = \";Shelf \"shelfnumber[level]\" - Disk \"diskbaynumber[level]\";\"diskgroupname[level]\";\" formattedcapacity[level] \";\" failurepredicted[level] \";\" manufacturer[level];\n\t\tpart3 = \";\" modelnumber[level] \";\" firmwareversion[level] \";Disk Type: \"disktype[level]\";\"serialnumber[level]\";Disk Group: \"diskgroupname[level]\";\" Enclosure\";Location: Shelf \"shelfnumber[level]\", Disk \"diskbaynumber[level]\";\";\n\t\tprint (part1 part2 part3)\n\t\tprimordialSize = primordialSize + formattedcapacity[level];\n\t\tif (diskgroupname[level] ~ /^Ungrouped Disks$/) {\n\t\t\tprimordialUnallocated = primordialUnallocated + formattedcapacity[level]\n\t\t}\n\t}\n\n#  LS DISK_GROUP SECTION\n\tif (class[level] ~ /^object$/ && objecttype[level] ~ /^diskgroupfolder$/) {\n#\t\t\t\t\t  MSHW_LOGICALDISK; Enclosure ;Disk Group;    Location       ;      Name             ;    Status               ;   Status Information         ; Size GB                    ;  Unallocated Space                                     ; AddInfo2 (Disk Group Type) ;\n\t\tprint (\"MSHW_LOGICALDISK;\"Enclosure\";Disk Group;\"Enclosure objectname[level]\";\"diskgroupname[level]\";\"operationalstate[level]\";\"operationalstatedetail[level]\";\"totalstoragespacegb[level]\";\"totalstoragespacegb[level] - usedstoragespacegb[level]\";Disk Group Type: \" diskgrouptype[level]\";1;\")\n\t}\n\n#  LS VDISK SECTION\n\tif (class[level] ~ /^object$/ && objecttype[level] ~ /^virtualdisk$/) {\n#\t\t\t\t\t\tMSHW_LOGICALDISK; Enclosure ;Virtual Disk;    Location       ;      Name         ;    Status               ;   Status Information          ; Size GB                  ;  (Unallocated Space)  ; AddInfo2 (Disk Group Type) ;\n\t\tprint (\"MSHW_LOGICALDISK;\"Enclosure\";Virtual Disk;\"Enclosure objectname[level]\";\"familyname[level]\";\"operationalstate[level]\";\"operationalstatedetail[level]\";\"allocatedcapacity[level]\";\"                     \";Type \" virtualdisktype[level]\";0;\")\n\t}\n\n#  LS DISK SHELF SECTION\n\tif (class[level] ~ /^bus$/) {\n\t\tif (failprediction[level] ~ /[Yy]es/ && operationalstate[level] ~ /[Gg]ood/) {\n\t\t\toperationalstate[level] = \"bad\"\n\t\t}\n#           MSHW_OTHERDEVICE ; Enclosure ;Type;   Name                                          ;   OpState               ;\n\t\tprint (\"MSHW_OTHERDEVICE;\"Enclosure\" - \"controllername[1]\";Bus;\"Enclosure\" - \" controllername[1] \" - \" name[level] \";\"operationalstate[level] \";\"Enclosure\";\")\n\t}\n\n\tif (class[level] ~ /^module$/ && class[parentLevel] ~ /^iomodules$/ && name[level] != \"\" ) {\n\t\tif (failprediction[level] ~ /[Yy]es/ && operationalstate[level] ~ /[Gg]ood/) {\n\t\t\toperationalstate[level] = \"bad\"\n\t\t}\n # \t\t\t\t\tMSWH_OTHERDEVICE ; Enclosure ;Type;Name;OpState;\n\t\tprint (\"MSWH_OTHERDEVICE;\"Enclosure \" - \" controllername[1]\";IO Module;\"Enclosure\" - \" controllername[1] \" - \" name[level] \";\"operationalstate[level] \";\"Enclosure\";\")\n\t}\n\n\tif (class[level] ~ /^port$/) {\n\t\tif (failprediction[level] ~ /[Yy]es/ && operationalstate[level] ~ /[Gg]ood/) {\n\t\t\toperationalstate[level] = \"bad\"\n\t\t}\n#\t\t\t\t\t\tMSHW_NETWORKCARD; Enclosure ; NcType(hostport)   ; Name - (Controller Name - Port Name); WWN  ;  Status          ;  Speed Mbit; LinkStatus    ;\n\t\tprint (\"MSHW_NETWORKCARD;\"Enclosure\"-\"controllername[1]\";\"class[level]\";\"Enclosure\" - \"controllername[1]\" - \"name[level]\" Input Link;;\"operationalstate[level]\";;\"inputlink[level]\";\" Enclosure\";\" )\n\t\tprint (\"MSHW_NETWORKCARD;\"Enclosure\"-\"controllername[1]\";\"class[level]\";\"Enclosure\" - \"controllername[1]\" - \"name[level]\" Output Link;;\"operationalstate[level]\";;\"outputlink[level]\";\" Enclosure\";\")\n\t}\n\n\tif (class[level] ~ /^emu$/) {\n\t\tif (failprediction[level] ~ /[Yy]es/ && operationalstate[level] ~ /[Gg]ood/) {\n\t\t\toperationalstate[level] = \"bad\"\n\t\t}\n #\t\t\t\t\tMSHW_OTHERDEVICE;Enclosure;Type;Name;OpState;\n\t\tprint (\"MSHW_OTHERDEVICE;\"Enclosure\" - \"controllername[1]\";EMU;\"Enclosure\" - \" controllername[1] \" - EMU;\"operationalstate[level] \";\"Enclosure\";\")\n\t}\n\n\tif (class[level] ~ /^fan$/ && operationalstate[level] ~ /^[Nn]ot*[Ii]ns*/) {\n\t\toperationalstate[level] = \"DiskenclosureWarn\"\n\t}\n\tif (class[level] ~ /^fan$/ && name[level] != \"\" && operationalstate[level] != \"\" ) {\n\t\tif ( controllername[1] ~ /./ ) {\n\t\t\tprintID = Enclosure\" - \"controllername[1]\" - \"name[level]\n\t\t}\n\t\telse {\n\t\t\tprintID = Enclosure \" - \" name[level];\n\t\t\tprintEnclosure = Enclosure\"-\"defaultController\n\t\t}\n#\t\t\t\t\t\tMSHW_FAN; Enclosure;Name - (Controller Name - Fan Name);Status;Speed;DeviceID;installstatus;\n\t\tprint (\"MSHW_FAN;\" printEnclosure \";\" printID \";\"operationalstate[level]\";;\"Enclosure\"-\"controllername[1]\"-\"name[level]\";;\"Enclosure\";\")\n\t}\n\n\tif (class[level] ~ /^powersupply$/ && operationalstate[level] ~ /^[Nn]ot*[Ii]ns*/) {\n\t\toperationalstate[level] = \"DiskenclosureWarn\"\n\t}\n\tif (class[level] ~ /^powersupply$/ && operationalstate[level] != \"\") {\n\t\t#\t\t\t\tMSHW_PSU; Enclosure ;Name - (Controller Name - PSU Name);   Status       ;\n\t\tprint (\"MSHW_PSU;\"Enclosure\"-\"controllername[1]\";\"Enclosure\" - \"controllername[1]\" - \"name[level]\";\" operationalstate[level] \";\"Enclosure\";\")\n\t}\n\n\tif (class[level] ~ /^object$/ && objecttype[level] ~ /^diskshelf$/) {\n\t\t#       MSHW_BLADE; Enclosure ;    Location                    ;      Name             ;    Status               ;   Status Information          ;    (Model Number)  ;    (Serial Number)  ; (WWN)     ;\n\t\tprint (\"MSHW_BLADE;\"Enclosure\";\"Enclosure\"-\"controllername[level]\";\"diskshelfname[level]\";\"operationalstate[level]\";\"operationalstatedetail[level]\";Disk Shelf\"       \";\"                   \";\"         \";\")\n\t\tprint (\"MSHW_DISK_TO_BLADE_TABLE;\"Enclosure\"-\"controllername[level]\";\"Enclosure\"-Shelf\"shelfnumber[level]\";\")\n\t}\n\n\tclearArray(level)\n\tlevel=level-1 ;\n}\n\nlevel < 0 {\n\tprint \"Error:  Level is negative\";\n\texit\n}\n\nEND {\n\tprintPrimordial(Enclosure,primordialSize,primordialUnallocated)\n}"
translations:
  linkStatusTT:
    fabric_login: "ok"
    bad: "degraded"
    good: "ok"
    link_up: "ok"
    link_down: "degraded"
  opStatusInfoTT:
    sc_locked: "SC Locked"
    emu_unknown: "Environmental Monitoring Unit Unknow Error"
    notinstalled: "Not installed"
    contains_ilf_disk: "Contains "
    initialized_ok: ""
    emu_critical: "Environmental Monitoring Unit Critical"
    initialized_unknown: ""
    non_member_attention: "Non Member Error"
    uninitialized_attention: "Uninitialized"
    uninitialized_ok: "Unintialized"
    emu_ok: ""
    emu_information: ""
    member_ok: ""
    not present: "Not Present"
    suspended_ok: "Suspended"
    not_redundant_attention: "Not Redundant"
    not_available: "Not Available"
    member_failed: "Member Failed"
    not installed: "Not installed"
    initialized_attention: "Initialization Error"
    not_redundant_failed: "Not Redundant"
    diskenclosurewarn: "Not Present"
    restoring_ok: "Restoring"
    restoring_failed: "Restoring Failed"
    asynch_member_add_in_progress: "ok"
    emu_non_critical: "Environmental Monitoring Unit Warning"
    notpresent: "Not Present"
    diskgroup_degraded: "Diskgroup Degraded"
    emu_not_available: "Environmental Monitoring Unit Not Available"
    management_module_installed: "ok"
    suspended_attention: "Suspended Error"
    unknown: "Unknown"
    restoring_attention: "Restoring Error"
    emu_unrecoverable: "Environmental Monitoring Unit Unrecoverable Error"
    managed_by_other_agent: "Managed by Other Agent"
    unsupported: "Unsupported"
    member_attention: "Member Error"
    initialized_failed: "Initialization Failed"
    suspended_failed: "Suspended Failed"
    non_member_failed: "Non Member Failed"
    not_redundant_ok: ""
    management_module_not_installed: "Management Module Not Installed"
    non_member_ok: ""
    emu_unsupported: "Environmental Monitoring Unit Unsupported"
    not_present: "Not Present"
    uninitialized_failed: "Uninitialized"
    firmware_upgrade: "Firmware Upgrade"
    not_installed: "Not installed"
    asynch_member_remove_in_progress: "ok"
  cacheStatusInfoTT:
    default: ""
    no_mirror: "No Mirror"
  predictedFailureTT:
    "no": "false"
    "yes": "true"
  opStatusTT:
    normal: "ok"
    not present: "MISSING"
    notpresent: "MISSING"
    bad: "failed"
    notinstalled: "MISSING"
    no_mirror: "degraded"
    failed: "failed"
    good: "ok"
    not installed: "MISSING"
    default: "UNKNOWN"
    attention: "degraded"
    not_present: "MISSING"
    diskenclosurewarn: "degraded"
    not_installed: "MISSING"
connector:
  detection:
    criteria:
      # SSSU should exist and be in Path
    - type: "osCommand"
      commandLine: "sssu help"
      errorMessage: "SSSU Does not appear to be installed on this system"
      expectedResult: "SSSU for HP"
      executeLocally: true
      # SSSU Should be able to connect and list systems
    - type: "osCommand"
      commandLine: "sssu \"SELECT Manager %{HOSTNAME} username=%{USERNAME} password=%{PASSWORD}\" \"LS SYSTEM\""
      errorMessage: "Unable to connect using SSSU"
      expectedResult: "Systems available on this Manager"
      executeLocally: true
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          computes:
            # Process the sssu command throug an AWK script
          - type: "awk"
            script: "EmbeddedFile(2)"
            keep: "^MSHW"
            separators: ";"
        source(2):
          # Enclosure Source 2 = Copy of Source 1
          type: "copy"
          from: "$monitors.enclosure.discovery.sources.source(1)$"
          computes:
            # Keep only Enclosures
            # MS_HW_Enclosure;ID;
          - type: "keepOnlyMatchingLines"
            column: 1
            regExp: "^MSHW_ENCLOSURE$"
      mapping:
        # The discovery table
        # MS_HW_Enclosure;ID;
        source: "$monitors.enclosure.discovery.sources.source(2)$"
        attributes:
          id: "$column(2)"
          __display_id: "$column(2)"
          type: "DiskSystem"
          model: "EVA System"
          vendor: "HP"
          name: "sprintf(\"%s (%s %s - %s)\", $column(2), \"HP\", \"EVA System\", \"DiskSystem\")"
    collect:
      # Collect type: MultiInstance
      type: "multiInstance"
      sources:
        source(1):
          computes:
            # Process the sssu command throug an AWK script
          - type: "awk"
            script: "EmbeddedFile(2)"
            keep: "^MSHW"
            separators: ";"
      mapping:
        # The value table (taken from enclosure.discovery, since we don't actually want to collect anything.
        source: "$monitors.enclosure.discovery.sources.source(2)$"
        deviceId: "$column(2)"
  blade:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: "copy"
          from: "$monitors.enclosure.discovery.sources.source(1)$"
          computes:
            # Keep only DiskControllers
            # MSHW_BLADE;Enclosure;DeviceID;Name;Status;Status Information;Model Number;Serial Number;WWN;Location
          - type: "keepOnlyMatchingLines"
            column: 1
            regExp: "^MSHW_BLADE$"
      mapping:
        # The discovery table
        # MSHW_BLADE;Enclosure;DeviceID;Name;Status;Status Information;Model Number;Serial Number;WWN;Location
        source: "$monitors.blade.discovery.sources.source(1)$"
        attributes:
          id: "$column(3)"
          __display_id: "$column(4)"
          model: "$column(7)"
          serial_number: "$column(8)"
          blade_name: "$column(4)"
          info: "join($column(10), $column(9), \"Type: SAN Controller\", \" \")"
          hw.parent.type: "DiskSystem"
          hw.parent.id: "$column(2)"
          name: "sprintf(\"%s (%s - %s)\", $column(4), $column(4), $column(7))"
    collect:
      # Collect type: MultiInstance
      type: "multiInstance"
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: "copy"
          from: "$monitors.enclosure.collect.sources.source(1)$"
          computes:
            # Keep only DiskControllers
            # MSHW_BLADE;Enclosure;Location;Name;Status;Status Information;Model Number;Serial Number;WWN;
          - type: "keepOnlyMatchingLines"
            column: 1
            regExp: "^MSHW_BLADE$"
            # Now translate  into OK/Warning/Alarm
            # MSHW_BLADE;Enclosure;Location;Name;Status;Status Information;Model Number;Serial Number;WWN;
          - type: "translate"
            column: 5
            translationTable: "opStatusTT"
            # Now translate Status information
            # MSHW_BLADE;Enclosure;Location;Name;Status;Status Information;Model Number;Serial Number;WWN;
          - type: "translate"
            column: 6
            translationTable: "opStatusInfoTT"
      mapping:
        # The value table
        source: "$monitors.blade.collect.sources.source(1)$"
        deviceId: "$column(3)"
        metrics:
          hw.status{hw.type="blade"}: "$column(5)"
        legacyTextParameters:
          StatusInformation: "$column(6)"
  fan:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: "copy"
          from: "$monitors.enclosure.discovery.sources.source(1)$"
          computes:
            # Keep only Fans
            # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;Speed;DeviceID;InstallStatus;SystemName;
          - type: "keepOnlyMatchingLines"
            column: 1
            regExp: "^MSHW_FAN$"
            # Exclude fans not installed
            # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;Speed;DeviceID;InstallStatus;SystemName;
          - type: "excludeMatchingLines"
            column: 7
            valueList: "no"
          - type: "translate"
            column: 4
            translationTable: "opStatusTT"
          - type: "excludeMatchingLines"
            column: 4
            valueList: "MISSING"
      mapping:
        # The discovery table
        # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;Speed;DeviceID;InstallStatus;SystemName;
        source: "$monitors.fan.discovery.sources.source(1)$"
        attributes:
          id: "$column(6)"
          __display_id: "$column(6)"
          hw.parent.type: "blade"
          hw.parent.id: "$column(2)"
          name: "$column(6)"
    collect:
      # Collect type: MultiInstance
      type: "multiInstance"
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: "copy"
          from: "$monitors.enclosure.collect.sources.source(1)$"
          computes:
            # Keep only DiskControllers
            # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;Speed;DeviceID;InstallStatus;SystemName;
          - type: "keepOnlyMatchingLines"
            column: 1
            regExp: "^MSHW_FAN$"
            # duplicate for status information
            # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;statusinfo;Speed;DeviceID;InstallStatus;SystemName;
          - type: "duplicateColumn"
            column: 4
            # Now translate  status information
            # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;statusinfo;Speed;DeviceID;InstallStatus;SystemName;
          - type: "translate"
            column: 5
            translationTable: "opStatusInfoTT"
          - type: "translate"
            column: 4
            translationTable: "opStatusTT"
      mapping:
        # The value table
        # MSHW_FAN;Enclosure;Name-(Controller Name-Fan Name);Status;Speed;DeviceID;InstallStatus;SystemName;
        source: "$monitors.fan.collect.sources.source(1)$"
        deviceId: "$column(7)"
        metrics:
          hw.status{hw.type="fan"}: "$column(4)"
          hw.fan.speed: "$column(6)"
        legacyTextParameters:
          StatusInformation: "$column(5)"
  battery:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: "copy"
          from: "$monitors.enclosure.discovery.sources.source(1)$"
          computes:
            # Keep only Batterys
            # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
          - type: "keepOnlyMatchingLines"
            column: 1
            regExp: "^MSHW_Battery$"
            # Exclude Batterys not installed
            # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
          - type: "excludeMatchingLines"
            column: 4
            valueList: "not installed,not_installed,not present,not_present,notinstalled,notpresent,Not Present"
      mapping:
        # The discovery table
        # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
        source: "$monitors.battery.discovery.sources.source(1)$"
        attributes:
          id: "$column(3)"
          __display_id: "$column(3)"
          type: "$column(6)"
          hw.parent.type: "blade"
          hw.parent.id: "$column(2)"
          name: "sprintf(\"%s (%s)\", $column(3), $column(6))"
    collect:
      # Collect type: MultiInstance
      type: "multiInstance"
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: "copy"
          from: "$monitors.enclosure.collect.sources.source(1)$"
          computes:
            # Keep only DiskControllers
            # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
          - type: "keepOnlyMatchingLines"
            column: 1
            regExp: "^MSHW_Battery$"
            # Now translate  into OK/Warning/Alarm
            # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
          - type: "translate"
            column: 4
            translationTable: "opStatusTT"
            # Now translate Status information
            # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
          - type: "translate"
            column: 5
            translationTable: "opStatusInfoTT"
      mapping:
        # The value table
        # MSHW_BATTERY;Enclosure;Name - (Controller Name - Battery Name);Status;Status Information;BatteryType;SystemName;
        source: "$monitors.battery.collect.sources.source(1)$"
        deviceId: "$column(3)"
        metrics:
          hw.status{hw.type="battery"}: "$column(4)"
        legacyTextParameters:
          StatusInformation: "$column(5)"
  logical_disk:
    discovery:
      sources:
        source(1):
          computes:
            # Awk it and keep only LogicalDisks
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: "awk"
            script: "EmbeddedFile(2)"
            keep: "^MSHW_LOGICALDISK"
            separators: ";"
            # Exclude Snapshots
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: "excludeMatchingLines"
            column: 10
            valueList: "Demand-allocated Snapshot,Fully-allocated Snapshot,SnapClone"
            # Convert Size from Gbytes to bytes
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: "multiply"
            column: 8
            value: "1073741824"
        source(2):
          # Get the Enclosure Discovery for the Primordial Array
          # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          type: "copy"
          from: "$monitors.enclosure.discovery.sources.source(1)$"
          computes:
            # Keep only the Primordials
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: "keepOnlyMatchingLines"
            column: 1
            regExp: "^MSHW_LOGICALDISK$"
        source(3):
          # Union the main logical disk discovery with the Primordials
          # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          type: "tableUnion"
          tables:
          - "$monitors.logical_disk.discovery.sources.source(1)$"
          - "$monitors.logical_disk.discovery.sources.source(2)$"
      mapping:
        # The discovery table
        # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
        source: "$monitors.logical_disk.discovery.sources.source(3)$"
        attributes:
          id: "$column(4)"
          __display_id: "$column(5)"
          hw.logical_disk.limit: "$column(8)"
          type: "$column(3)"
          info: "$column(10)"
          hw.parent.type: "enclosure"
          hw.parent.id: "$column(2)"
          name: "sprintf(\"%s (%s)\", $column(5), $column(8))"
    collect:
      # Collect type: MultiInstance
      type: "multiInstance"
      sources:
        source(1):
          computes:
            # Awk it and keep only LogicalDisks
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: "awk"
            script: "EmbeddedFile(2)"
            keep: "^MSHW_LOGICALDISK"
            separators: ";"
            # Now translate  into OK/Warning/Alarm
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: "translate"
            column: 6
            translationTable: "opStatusTT"
            # Now translate Status information
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: "translate"
            column: 7
            translationTable: "opStatusInfoTT"
            # Convert Unallocated Space from Gbytes to bytes
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: "multiply"
            column: 9
            value: "1073741824"
        source(2):
          # Get the Enclosure Discovery for the Primordial Array
          # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          type: "copy"
          from: "$monitors.enclosure.collect.sources.source(1)$"
          computes:
            # Keep only the Primordials
            # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          - type: "keepOnlyMatchingLines"
            column: 1
            regExp: "^MSHW_LOGICALDISK$"
        source(3):
          # Union the main logical disk discovery with the Primordials
          # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
          type: "tableUnion"
          tables:
          - "$monitors.logical_disk.collect.sources.source(1)$"
          - "$monitors.logical_disk.collect.sources.source(2)$"
      mapping:
        # The value table
        # MSHW_LOGICALDISK;Enclosure;Disk Group/VirtualDisk;Location;Name;Status;Status Information;Size GB;Unallocated Space;AddInfo2 (Disk Group Type);UseForCapacityReport;
        source: "$monitors.logical_disk.collect.sources.source(3)$"
        deviceId: "$column(4)"
        metrics:
          hw.status{hw.type="logical_disk"}: "$column(6)"
          hw.logical_disk.usage{state="free"}: "$column(9)"
          hw.logical_disk.usage{state="used"}: "collectAllocatedSpace()"
        legacyTextParameters:
          StatusInformation: "$column(7)"
  memory:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: "copy"
          from: "$monitors.enclosure.discovery.sources.source(1)$"
          computes:
            # Keep only Memorys
            # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;SystemName;
          - type: "keepOnlyMatchingLines"
            column: 1
            regExp: "^MSHW_MEMORY$"
            # exclude not installed
          - type: "excludeMatchingLines"
            column: 5
            valueList: "not installed,not_installed,not present,not_present,notinstalled,notpresent,Not Present"
      mapping:
        # The discovery table
        # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;SystemName;
        source: "$monitors.memory.discovery.sources.source(1)$"
        attributes:
          id: "$column(4)"
          type: "$column(3)"
          hw.parent.type: "blade"
          hw.parent.id: "$column(2)"
          name: "sprintf(\"%s (%s)\", $column(4), $column(3))"
    collect:
      # Collect type: MultiInstance
      type: "multiInstance"
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: "copy"
          from: "$monitors.enclosure.collect.sources.source(1)$"
          computes:
            # Keep only DiskControllers
            # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;SystemName;
          - type: "keepOnlyMatchingLines"
            column: 1
            regExp: "^MSHW_MEMORY$"
            # Duplicate Status Column
            # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;StatusInfo;SystemName;
          - type: "duplicateColumn"
            column: 5
            # Now translate  into OK/Warning/Alarm
            # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;StatusInfo;SystemName;
          - type: "translate"
            column: 5
            translationTable: "opStatusTT"
            # Translate Status info
            # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;StatusInfo;SystemName;
          - type: "translate"
            column: 6
            translationTable: "cacheStatusInfoTT"
      mapping:
        # The value table
        # MSHW_MEMORY;Enclosure;MemoryType(cachememory);Name(Controller Name);Status;SystemName;
        source: "$monitors.memory.collect.sources.source(1)$"
        deviceId: "$column(4)"
        metrics:
          hw.status{hw.type="memory"}: "$column(5)"
        legacyTextParameters:
          StatusInformation: "$column(6)"
  network:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: "copy"
          from: "$monitors.enclosure.discovery.sources.source(1)$"
          computes:
            # Keep only NetworkCards
            # MSHW_NETWORKCARD;Enclosure;NcType(hostport);Name;WWN;Status;Speed Mbit;LinkStatus;SystemName;
          - type: "keepOnlyMatchingLines"
            column: 1
            regExp: "^MSHW_NETWORKCARD$"
            # exclude not installed
          - type: "excludeMatchingLines"
            column: 6
            valueList: "not installed,not_installed,not present,not_present,notinstalled,notpresent,Not Present"
      mapping:
        # The discovery table
        # MSHW_NETWORKCARD;Enclosure;NcType(hostport);Name;WWN;Status;Speed Mbit;LinkStatus;SystemName;
        source: "$monitors.network.discovery.sources.source(1)$"
        attributes:
          id: "$column(4)"
          __display_id: "$column(4)"
          physical_address: "$column(5)"
          physical_address_type: "WWN"
          hw.parent.type: "blade"
          hw.parent.id: "$column(2)"
          name: "$column(4)"
    collect:
      # Collect type: MultiInstance
      type: "multiInstance"
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: "copy"
          from: "$monitors.enclosure.collect.sources.source(1)$"
          computes:
            # Keep only DiskControllers
            # MSHW_NETWORKCARD;Enclosure;NcType(hostport);Name;WWN;Status;Speed Mbit;LinkStatus;SystemName;
          - type: "keepOnlyMatchingLines"
            column: 1
            regExp: "^MSHW_NetworkCard$"
            # Now translate  into OK/Warning/Alarm
            # MSHW_NETWORKCARD;Enclosure;NcType(hostport);Name;WWN;Status;Speed Mbit;LinkStatus;SystemName;
          - type: "translate"
            column: 6
            translationTable: "opStatusTT"
            # Now translate  into OK/Warning/Alarm
            # MSHW_NETWORKCARD;Enclosure;NcType(hostport);Name;WWN;Status;Speed Mbit;LinkStatus;SystemName;
          - type: "translate"
            column: 8
            translationTable: "linkStatusTT"
      mapping:
        # The value table
        # MSHW_NETWORKCARD;Enclosure;NcType(hostport);Name;WWN;Status;Speed Mbit;LinkStatus; SystemName;
        source: "$monitors.network.collect.sources.source(1)$"
        deviceId: "$column(4)"
        metrics:
          hw.network.bandwidth.limit: "megaBit2Bit($column(7))"
          hw.network.up: "legacyLinkStatus($column(8))"
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: "copy"
          from: "$monitors.enclosure.discovery.sources.source(1)$"
          computes:
            # Keep only PhysicalDisks
            # MSHW_DISK;Shelf;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
          - type: "keepOnlyMatchingLines"
            column: 1
            regExp: "^MSHW_DISK$"
            # Convert Size from Gbytes to bytes
            # MSHW_DISK;Shelf;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
          - type: "multiply"
            column: 9
            value: "1000000000"
        source(2):
          # Source(2) = Enclosure Discovery 1
          type: "copy"
          from: "$monitors.enclosure.discovery.sources.source(1)$"
          computes:
            # Keep only PhysicalDisks
            # MSHW_DISK_TO_BLADE_TABLE;Enclosure;Shelf;
          - type: "keepOnlyMatchingLines"
            column: 1
            regExp: "^MSHW_DISK_TO_BLADE_TABLE$"
        source(3):
          # Table joint of (1) and (2)
          # as disks can ony be allocated to shelves where we need Enclosure
          # MSHW_DISK;Shelf;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;Location;MSHW_DISK_TO_BLADE_TABLE;Enclosure;Shelf;
          type: "tableJoin"
          leftTable: "$monitors.physical_disk.discovery.sources.source(1)$"
          rightTable: "$monitors.physical_disk.discovery.sources.source(2)$"
          leftKeyColumn: 2
          rightKeyColumn: 3
          defaultRightLine: ";;;"
          computes:
            # exclude not installed
          - type: "excludeMatchingLines"
            column: 5
            valueList: "not installed,not_installed,not present,not_present,notinstalled,notpresent,Not Present"
      mapping:
        # The discovery table\n    1         2         3     4     5           6                 7              8         9            10         11     12    13              14        15            16             17     18        19       \t\t\t\t\t\t\t20      21\nMSHW_DISK;Shelf;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;Location;MSHW_DISK_TO_BLADE_TABLE;Enclosure;Shelf;
        source: "$monitors.physical_disk.discovery.sources.source(3)$"
        attributes:
          id: "$column(3)"
          __display_id: "$column(7)"
          vendor: "$column(11)"
          model: "$column(12)"
          serial_number: "$column(15)"
          firmware_version: "$column(13)"
          info: "join($column(18), $column(14), $column(16), \" \")"
          hw.parent.type: "blade"
          hw.parent.id: "$column(20)"
          name: "sprintf(\"%s (%s - %s)\", $column(7), $column(12), $column(9))"
        metrics:
          hw.physical_disk.size: "$column(9)"
    collect:
      # Collect type: MultiInstance
      type: "multiInstance"
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: "copy"
          from: "$monitors.enclosure.collect.sources.source(1)$"
          computes:
            # Keep only DiskControllers
            # MSHW_DISK;Enclosure;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
          - type: "keepOnlyMatchingLines"
            column: 1
            regExp: "^MSHW_DISK$"
            # Now translate  into OK/Warning/Alarm
            # MSHW_DISK;Enclosure;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
          - type: "translate"
            column: 5
            translationTable: "opStatusTT"
            # Now translate Status information
            # MSHW_DISK;Enclosure;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
          - type: "translate"
            column: 6
            translationTable: "opStatusInfoTT"
            # Now translate  into OK/Warning/Alarm
            # MSHW_DISK;Enclosure;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
          - type: "translate"
            column: 10
            translationTable: "predictedFailureTT"
      mapping:
        # The value table
        #     1         2         3     4     5        #  6        #        7        #     8         9        #   10         11     12    13        #     14        15        #   16        ;
        # MSHW_DISK;Enclosure;Location;Name;Status;Status Information;Shelf - Disk Bay;Disk Group;Size GB;failurepredicted;Vendor;Model;firmwareversion;disktype;Serial Number;diskgroupname;SystemName;
        source: "$monitors.physical_disk.collect.sources.source(1)$"
        deviceId: "$column(3)"
        metrics:
          hw.status{hw.type="physical_disk"}: "$column(5)"
          hw.status{hw.type="physical_disk", state="predicted_failure"}: "boolean($column(10))"
        legacyTextParameters:
          StatusInformation: "$column(6)"
  power_supply:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: "copy"
          from: "$monitors.enclosure.discovery.sources.source(1)$"
          computes:
            # Keep only PowerSupplys
            # MSHW_PSU; Enclosure ;Name - (Controller Name - PSU Name);   Status       ;SystemName;
          - type: "keepOnlyMatchingLines"
            column: 1
            regExp: "^MSHW_PSU$"
            # Exclude PowerSupplys not installed
            # MSHW_PSU; Enclosure ;Name - (Controller Name - PSU Name);   Status       ;SystemName;
          - type: "excludeMatchingLines"
            column: 4
            valueList: "not installed,not_installed,not present,not_present,notinstalled,notpresent,Not Present"
      mapping:
        # The discovery table
        # MSHW_PSU; Enclosure ;Name - (Controller Name - PSU Name);   Status       ;SystemName;
        source: "$monitors.power_supply.discovery.sources.source(1)$"
        attributes:
          id: "$column(3)"
          __display_id: "$column(3)"
          hw.parent.type: "blade"
          hw.parent.id: "$column(2)"
          name: "sprintf(\"%s, $column(3))"
    collect:
      # Collect type: MultiInstance
      type: "multiInstance"
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: "copy"
          from: "$monitors.enclosure.collect.sources.source(1)$"
          computes:
            # Keep only DiskControllers
            # MSHW_PSU; Enclosure ;Name - (Controller Name - PSU Name);   Status       ;SystemName;
          - type: "keepOnlyMatchingLines"
            column: 1
            regExp: "^MSHW_PSU$"
            # Now translate  into OK/Warning/Alarm
            # MSHW_PSU; Enclosure ;Name - (Controller Name - PSU Name);   Status       ;SystemName;
          - type: "translate"
            column: 4
            translationTable: "opStatusTT"
      mapping:
        # The value table
        # MSHW_PSU; Enclosure ;Name - (Controller Name - PSU Name);   Status       ;SystemName;
        source: "$monitors.power_supply.collect.sources.source(1)$"
        deviceId: "$column(3)"
        metrics:
          hw.status{hw.type="power_supply"}: "$column(4)"
  temperature:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: "copy"
          from: "$monitors.enclosure.discovery.sources.source(1)$"
          computes:
            # Keep only Temperatures
            # MSHW_TEMP;Enclosure;Name;Temperature;Status;SystemName;
          - type: "keepOnlyMatchingLines"
            column: 1
            regExp: "^MSHW_TEMP$"
      mapping:
        # The discovery table
        # MSHW_TEMP;Enclosure;Name;Temperature;Status;SystemName;
        source: "$monitors.temperature.discovery.sources.source(1)$"
        attributes:
          id: "$column(3)"
          __display_id: "$column(3)"
          hw.parent.type: "blade"
          hw.parent.id: "$column(2)"
          name: "$column(3)"
    collect:
      # Collect type: MultiInstance
      type: "multiInstance"
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: "copy"
          from: "$monitors.enclosure.collect.sources.source(1)$"
          computes:
            # Keep only DiskControllers
            # MSHW_TEMP;Enclosure;Name;Temperature;Status;
          - type: "keepOnlyMatchingLines"
            column: 1
            regExp: "^MSHW_TEMP$"
            # Now translate  into OK/Warning/Alarm
            # MSHW_TEMP;Enclosure;Name;Temperature;Status;
          - type: "translate"
            column: 5
            translationTable: "opStatusTT"
      mapping:
        # The value table
        # MSHW_TEMP;Enclosure;Name;Temperature;Status;
        source: "$monitors.temperature.collect.sources.source(1)$"
        deviceId: "$column(3)"
        metrics:
          hw.status{hw.type="temperature"}: "$column(5)"
          hw.temperature: "$column(4)"
  other_device:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: "copy"
          from: "$monitors.enclosure.discovery.sources.source(1)$"
          computes:
            # Keep only Temperatures
            # MSWH_OTHERDEVICE;Enclosure;Type;Name;OpState;SystemName;
          - type: "keepOnlyMatchingLines"
            column: 1
            regExp: "^MSHW_OTHERDEVICE$"
            # Exclude not installed
          - type: "excludeMatchingLines"
            column: 5
            valueList: "not installed,not_installed,not present,not_present,notinstalled,notpresent,Not Present"
      mapping:
        # The discovery table
        # MSWH_OTHERDEVICE;Enclosure;Type;Name;OpState;SystemName;
        source: "$monitors.other_device.discovery.sources.source(1)$"
        attributes:
          device_type: "$column(3)"
          id: "$column(4)"
          __display_id: "$column(4)"
          hw.parent.type: "blade"
          hw.parent.id: "$column(2)"
          name: "sprintf(\"%s: %s\", $column(3), $column(4))"
    collect:
      # Collect type: MultiInstance
      type: "multiInstance"
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          # MSWH_OTHERDEVICE;Enclosure;Type;Name;OpState;SystemName;
          type: "copy"
          from: "$monitors.enclosure.collect.sources.source(1)$"
          computes:
            # Keep only Other Devices
            # MSWH_OTHERDEVICE;Enclosure;Type;Name;OpState;SystemName;
          - type: "keepOnlyMatchingLines"
            column: 1
            regExp: "^MSHW_OTHERDEVICE$"
            # Now translate  into OK/Warning/Alarm
            # MSWH_OTHERDEVICE;Enclosure;Type;Name;OpState;opState;SystemName;
          - type: "duplicateColumn"
            column: 5
            # Now translate  into OK/Warning/Alarm
            # MSWH_OTHERDEVICE;Enclosure;Type;Name;status;OpState;SystemName;
          - type: "translate"
            column: 5
            translationTable: "opStatusTT"
      mapping:
        # The value table
        # MSWH_OTHERDEVICE;Enclosure;Type;Name;status;OpState;SystemName;
        source: "$monitors.other_device.collect.sources.source(1)$"
        deviceId: "$column(4)"
        metrics:
          hw.status{hw.type="other_device"}: "$column(5)"
        legacyTextParameters:
          StatusInformation: "$column(6)"
