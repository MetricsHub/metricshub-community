---
embedded:
  EmbeddedFile(1): |-
    DEVICES=`/usr/bin/ls -1 /dev/ | /usr/bin/egrep ^ciss[0-9]$`
    for VOLUME in $DEVICES
                    do
                    %{SUDO:/opt/raidsa/bin/sautil}/opt/raidsa/bin/sautil /dev/$VOLUME -s
                    done
  EmbeddedFile(3): |-
    BEGIN {
        controller = "";
        size = "";
        mode = "";
    }

    $1 ~ /Device/ && $2 ~ /File/ {controller=$NF;gsub(/\057dev\057ciss/,"",controller);}


    /SCSI DEVICE SUMMARY/,/(SCSI BUS)|(LOGICAL DRIVE)/ {if (NF > 5) {
                 if ($(NF-1) ~ /[GgTtMm][Bb]/ && $(NF-5) ~ /[0-9]+/ && $(NF-4) ~ /[0-9]+/) {
                                                       size=$(NF-2) ;
                                                       if ($NF-1 ~ /[Mm][Bb]/) {size=size/1024}
                                                             else if ($NF-1 ~ /[Tt][Bb]/) {size=size*1024} ;
                                                         ID = ("C" controller "-CH"$(NF-5) "-ID" $(NF-4));
                                                         location = ("Controller-ciss" controller " Channel-" $(NF-5) " ID-"$(NF-4));
                                                         if (NF > 6) {location = (location " (" $(NF-6)")")};
                                                         {print "MSHW;"controller";"location";"ID";"size";"$NF";"}
                                                                                           }
                                                  }
                                     }

    /SATA DEVICE SUMMARY/,/SATA ENCLOSURE SUMMARY/    {if (NF > 8) {
                 if ($(NF-1)||$(NF-2)  ~ /[GgTtMm][Bb]/ && $3 ~ /[0-9]+/ && $4 ~ /[0-9]+/) {
                                                       size=$(NF-2) ;
                                                       if ($NF-1 ~ /[Mm][Bb]/) {size=size/1024}
                                                             else if ($NF-1 ~ /[Tt][Bb]/) {size=size*1024} ;
                                                         ID = ("C" controller "-Ct"$2 "-E"$3"-B"$4);
                                                         location = ("Controller-ciss" controller " Ct-" $2 " Enc-" $3 " Bay-" $4 );
                                                         print "MSHW;"controller";"location";"ID";"size";"$NF";"
                                                     }
                                                  }
                                     }
  EmbeddedFile(2): |-
    BEGIN {
            controller = "";
            model = "";
            modelnumber = "";
            serialnbr = "";
            devicefile = "";
            firmware = "";
    }
    $1 ~ /Controller/ && $2 ~ /Product/ && $3 ~ /Number/   {modelnumber=$NF}
    $1 ~ /Controller/ && $2 ~ /Product/ && $3 ~ /Name/     {model=substr($0,index($0,$4)); model=model " (" modelnumber")"}
    $1 ~ /Adapter/ && model == ""                          {model=substr($0,index($0,$2))}
    $1 ~ /Serial/ && $2 ~ /Number/                         {serialnbr=$NF}
    $1 ~ /Device/ && $2 ~ /File/                           {devicefile=$NF;controller=$NF;gsub(/\057dev\057ciss/,"",controller);}
    $1 ~ /Firmware/ && $2 ~ /Revision/ && controller != "" {firmware=$NF;
                                                              print ("MSHW;"controller";"model";"serialnbr";"devicefile";"firmware";")
                                                              controller = "";model = "";modelnumber = "";serialnbr = "";devicefile = "";firmware = "";
                                                             }
  EmbeddedFile(5): |-
    BEGIN { controller="";}

    $1 ~ /Device/ && $2 ~ /File/        {controller=$NF;gsub(/\057dev\057ciss/,"",controller);}

    /ARRAY ACCELERATOR/,/LOGICAL DRIVE/ {
      if ($1 ~ /[Bb]attery/ && $2 ~ /[Ss]tatus/ && $3 ~ /[Pp]ack/) { status = toupper ($NF);
                                                                       batteryID = $4 ; gsub (/[^0-9]/,"",batteryID);
                                                                       print ("MSHW;/dev/ciss"controller";C" controller"-BP" batteryID ";Controller ciss" controller " - Battery Pack #" batteryID";" status ";");

                                                                  }
                                        }
  EmbeddedFile(4): |-
    BEGIN {controller = "";
             volume = ""; raid = ""; size = ""; status = "";
           }

    $1 ~ /Device/ && $2 ~ /File/ {controller=$NF;gsub(/\057dev\057ciss/,"",controller);}

    /LOGICAL DRIVE SUMMARY/,/SCSI DEVICE SUMMARY/ {
               if ($1 ~ /([0-9]+)/ && $2 ~ /[0-9+]+|([Aa][Dd][Gg])/ && $4 ~ /[TtGgMm][Bb]/) {size=$3; if ($4 ~ /[Mm][Bb]/) {size=size/1024}
                                                                                       else if ($4 ~ /[Tt][Bb]/) {size=size*1024} ;
                                                                              print ("MSHW;"controller";C" controller"-LD"$1";"$2";"size";"$5";Controller ciss"controller" - Logical Disk " $1";");}
                                                    }
translations:
  BatteryStatusInformationTranslationTable:
    default: UNKNOWN
    failed: Failed
    ok: ""
  PhysicalDiskStatusInformationTranslationTable:
    default: UNKNOWN
    failed: Failed
    unassigned: Unassigned
    ok: ""
    spare: Spare
  BatteryStatusTranslationTable:
    default: UNKNOWN
    failed: failed
    ok: ok
  LogicalDiskStatusInformationTranslationTable:
    expanding: Expanding
    using: Using Interim Recovery Mode
    recovering: Recovering
    not: Not Yet Available
    default: UNKNOWN
    ready: Ready for Recovery Operation
    queued: Queued for Expanding
    failed: Failed
    ok: ""
    physical: Physical Disk not Properly Connected
    wrong: Wrong Physical Disk was Replaced
  LogicalDiskStatusTranslationTable:
    expanding: ok
    using: degraded
    recovering: degraded
    not: degraded
    default: UNKNOWN
    ready: degraded
    queued: ok
    failed: failed
    ok: ok
    physical: failed
    wrong: failed
  PhysicalDiskStatusTranslationTable:
    default: UNKNOWN
    failed: failed
    unassigned: ok
    ok: ok
    spare: ok
connector:
  displayName: HP-UX - Smart Array RAID
  platforms: "HP 9000,HP Integrity,HP SuperDome"
  reliesOn: HP-UX Smart Array Configuration Utility
  information: Display the physical disks connected to a Smart Array Controller and any configured logical drive and spare drive.
  version: 1.1
  detection:
    connectionTypes:
    - remote
    appliesTo:
    - HP
    criteria:
    # OS should be HP (for HP-UX, whatever version)
    - type: deviceType
      keep:
      - HP
    # The sautil should exist
    - type: osCommand
      commandLine: ls /opt/raidsa/bin/sautil
      expectedResult: sautil$
      errorMessage: The Smart Array RAID Controller Utility is not present on this system.
    # We should find disks attached to one controller
    - type: osCommand
      commandLine: /bin/sh $embedded.EmbeddedFile(1)$
      expectedResult: "[GgTtMm][Bb]"
      forceSerialization: true
      errorMessage: "There are not enough rights to execute the sautil utility, or no disks are listed."
sudoCommands:
- /opt/raidsa/bin/sautil
monitors:
  disk_controller:
    discovery:
      sources:
        source(1):
          # Source (1) : Contains the list of all Disk Controllers
          # /opt/raidsa/bin/sautil /dev/cissx -s output
          # DeviceFile;
          type: osCommand
          commandLine: /bin/sh $embedded.EmbeddedFile(1)$
          forceSerialization: true
        source(2):
          # Source(2) = Copy of source(1)
          # DeviceFile;
          type: copy
          from: $monitors.disk_controller.discovery.sources.source(1)$
          computes:
            # Run Source(1) through an AWK script
            # MSHW;Controller;Model;SerialNumber;DeviceID;Firmware
          - type: awk
            script: EmbeddedFile(2)
            separators: ;
            keep: ^MSHW;
            selectColumns: "2,3,4,5,6"
        source(3):
          # Source(3) = Copy of source(1)
          # DeviceFile;
          type: copy
          from: $monitors.disk_controller.discovery.sources.source(1)$
          computes:
            # Reformat Source(2) output to create a dependency table to link controllers to disks to arrays
            # MSHW;Controller;Location;DeviceID;Size;Status;
          - type: awk
            script: EmbeddedFile(3)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5,6,7"
        source(4):
          # Source (4) Table Join of Source (2) and Source (3) to keep only controllers that have physical disks  associated with them
          # (2) Controller;Model;SerialNumber;DeviceID;Firmware
          # (3) Controller;Location;DeviceID;Size;Status;
          # (4) Controller;Model;SerialNumber;DeviceID;Firmware;Controller;Location;DeviceID;Size;Status;
          type: tableJoin
          leftTable: $monitors.disk_controller.discovery.sources.source(2)$
          rightTable: $monitors.disk_controller.discovery.sources.source(3)$
          leftKeyColumn: 1
          rightKeyColumn: 1
      mapping:
        # InstanceTable = Source(4)
        # Controller;Model;SerialNumber;DeviceID;Firmware;Controller;Location;DeviceID;Size;Status;
        source: $monitors.disk_controller.discovery.sources.source(4)$
        attributes:
          id: $column(4)
          controller_number: $column(1)
          model: $column(2)
          firmware_version: $column(5)
          hw.parent.type: enclosure
          name: "sprintf(\"Disk Controller: %s (%s)\", $column(1), $column(2))"
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) %DiskController.Discovery.Source(1)
          # DeviceFile;
          type: copy
          from: $monitors.disk_controller.discovery.sources.source(1)$
          computes:
            # Reformat Source(1) output via EmbeddedFile(3)
            # Contains the list of all External and Internal Physical Disks in the system
            # MSHW;Controller;Location;DeviceID;Size;Status;
          - type: awk
            script: EmbeddedFile(3)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5"
            # Multiply to get Bytes
            #  Controller;Location;DeviceID;SizeBytes
          - type: multiply
            column: 4
            value: 1073741824
          - type: leftConcat
            column: 2
            value: "Location: "
      mapping:
        # The InstanceTable
        # Controller;Location;DeviceID;SizeBytes
        source: $monitors.physical_disk.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          info: $column(2)
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $column(1))"
          name: "sprintf(\"%s (%s)\", $column(3), $column(4))"
        metrics:
          hw.physical_disk.size: $column(4)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Runs /opt/raidsa/bin/sautil /dev/cissx -s
          # DeviceFile;
          type: osCommand
          commandLine: /bin/sh $embedded.EmbeddedFile(1)$
          forceSerialization: true
          computes:
            # Reformat Source(1) = List all Internal Physical Disks in the system and their status
            # The status can be either OK, FAILED, SPARE or UNASSIGNED.
            # MSHW;Controller;Location;DeviceID;Size;Status;
          - type: awk
            script: EmbeddedFile(3)
            keep: ^MSHW;
            separators: ;
            selectColumns: "4,6"
            # Duplicate the status column
            # DeviceID;Status;Status;
          - type: duplicateColumn
            column: 2
            # Translate the first status column into a PATROL status
            # DeviceID;PatrolStatus;Status;
          - type: translate
            column: 2
            translationTable: PhysicalDiskStatusTranslationTable
            # Translate the second status column into a Status Information
            # DeviceID;PatrolStatus;StatusInformation;
          - type: translate
            column: 3
            translationTable: PhysicalDiskStatusInformationTranslationTable
      mapping:
        # The ValueTable = source(1)
        #  DeviceID;PatrolStatus;StatusInformation;
        source: $monitors.physical_disk.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="physical_disk"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
  logical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = $monitors.disk_controller.discovery.sources.source(1)$
          # DeviceFile;
          type: copy
          from: $monitors.disk_controller.discovery.sources.source(1)$
          computes:
            # Reformat Source(1) = Builds logical drives Table
            # MSHW;controller;deviceID;raidlevel;size;status;location;
          - type: awk
            script: EmbeddedFile(4)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5,7"
            # Multiply to get Bytes
            # controller;deviceID;raidlevel;sizebytes;location;
          - type: multiply
            column: 4
            value: 1073741824
          - type: leftConcat
            column: 5
            value: "Location: "
      mapping:
        # The InstanceTable
        # controller;deviceID;raidlevel;sizebytes;location;
        source: $monitors.logical_disk.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          raid_level: $column(3)
          hw.logical_disk.limit: $column(4)
          info: $column(5)
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $column(1))"
          name: "sprintf(\"%s (%s - %s)\", $column(2), $column(3), $column(4))"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Collect type = Source(1) = Runs /opt/raidsa/bin/sautil /dev/cissx -s
          type: osCommand
          commandLine: /bin/sh $embedded.EmbeddedFile(1)$
          forceSerialization: true
          computes:
            # Reformat Source(1) = List all logical drives and their status
            # The status can be either OK, FAILED, SPARE or UNASSIGNED.
            # MSHW;controller;deviceID;raidlevel;size;status;location;
          - type: awk
            script: EmbeddedFile(4)
            keep: ^MSHW;
            separators: ;
            selectColumns: "3,6"
            # Duplicate the status column
            # deviceID;status;
          - type: duplicateColumn
            column: 2
            # Translate the first status column into a PATROL status
            # deviceID;Patrolstatus;status
          - type: translate
            column: 2
            translationTable: LogicalDiskStatusTranslationTable
            # Translate the first status column into a PATROL status
            # deviceID;Patrolstatus;StatusInformation
          - type: translate
            column: 3
            translationTable: LogicalDiskStatusInformationTranslationTable
      mapping:
        # The ValueTable = source(1)
        # deviceID;Patrolstatus;StatusInformation
        source: $monitors.logical_disk.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="logical_disk"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
  battery:
    discovery:
      sources:
        source(1):
          # Source(1) = Disk Controller Source (1)
          type: copy
          from: $monitors.disk_controller.discovery.sources.source(1)$
          computes:
          - type: awk
            script: EmbeddedFile(5)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4"
          - type: leftConcat
            column: 3
            value: "Location: "
      mapping:
        # The discovery table
        # controllerdeviceID;deviceID;location;
        source: $monitors.battery.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          info: $column(3)
          hw.parent.type: disk_controller
          hw.parent.id: $column(1)
          name: $column(2)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Runs /opt/raidsa/bin/sautil /dev/cissx -s
          # DeviceFile;
          type: osCommand
          commandLine: /bin/sh $embedded.EmbeddedFile(1)$
          forceSerialization: true
          computes:
            # Process sautil output through awk embeddedfile(5)
            # MSHW;controllerdeviceID;deviceID;location;status;
          - type: awk
            script: EmbeddedFile(5)
            keep: ^MSHW;
            separators: ;
            selectColumns: "3,5"
            # Duplicate the status column
            # DeviceID;Status;Status;
          - type: duplicateColumn
            column: 2
            # Translate the first status column into a PATROL status
            # DeviceID;PatrolStatus;Status;
          - type: translate
            column: 2
            translationTable: BatteryStatusTranslationTable
            # Translate the second status column into a Status Information
            # DeviceID;PatrolStatus;StatusInformation;
          - type: translate
            column: 3
            translationTable: BatteryStatusInformationTranslationTable
      mapping:
        # The ValueTable = source(1)
        #  DeviceID;PatrolStatus;StatusInformation;
        source: $monitors.battery.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="battery"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
