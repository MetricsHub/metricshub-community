---
monitors:
  enclosure:
    discovery:
      sources:
        source(3):
          computes:
          # Process the naviseccli command through an AWK script
          - type: awk
            script: $file("embeddedFile-1")$
            keep: ^MSHW
            separators: ;
        source(4):
          # Enclosure Source 2 = Copy of Source 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(3)$
          computes:
            # Keep only Enclosures
            # MS_HW_Enclosure;SystemModel;SerialNumber;SystemFirmware;SystemFaultLED;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_ENCLOSURE$
      mapping:
        # The discovery table
        # MS_HW_Enclosure;SystemModel;SerialNumber;SystemFirmware;SystemFaultLED;
        source: $monitors.enclosure.discovery.sources.source(4)$
        attributes:
          id: $column(3)
          __display_id: $column(3)
          serial_number: $column(3)
          model: $column(2)
          vendor: EMC
          type: Storage
          name: "sprintf(\"Storage: %s (%s %s)\", $column(3), \"EMC\", $column(2))"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(3):
          computes:
          # Process the naviseccli command through an AWK script
          - type: awk
            script: $file("embeddedFile-1")$
            keep: ^MSHW
            separators: ;
        source(4):
          # Enclosure Source 2 = Copy of Source 1
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
          computes:
            # Keep only Enclosures
            # MS_HW_Enclosure;SystemModel;SerialNumber;SystemFirmware;SystemFaultLED;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_ENCLOSURE$
            # Duplicate status, because we will translate it two times
            # MS_HW_Enclosure;SystemModel;SerialNumber;SystemFirmware;SystemFaultLED;SystemFaultLED;
          - type: duplicateColumn
            column: 5
            # Translate Status into PATROLStatus
            # MS_HW_Enclosure;SystemModel;SerialNumber;SystemFirmware;PATROLStatus;SystemFaultLED;
          - type: translate
            column: 5
            translationTable: systemStatusTranslationTable
            # Translate second Status into more readable string
            # MS_HW_Enclosure;SystemModel;SerialNumber;SystemFirmware;PATROLStatus;StatusInformation;
          - type: translate
            column: 6
            translationTable: systemStatusInformationTranslationTable
        source(5):
          # Take a copy of the last discovery for the next discovery to use
          type: copy
          from: $monitors.enclosure.discovery.sources.source(3)$
      mapping:
        # ValueTable = Source(2)
        source: $monitors.enclosure.collect.sources.source(4)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="enclosure"}: $column(5)
        legacyTextParameters:
          StatusInformation: $column(6)
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(3)$
          computes:
            # Keep only PhysicalDisk
            # MSHW_PHYDISK;DiskID;DiskVendor;DiskState;DiskStatusInformation;DiskModel;DiskRevision;DiskTLAPartNumber;DiskPartNumber;Size;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PHYDISK$
            # Convert Size from Mbytes to bytes
            # MSHW_PHYDISK;DiskID;DiskVendor;DiskState;DiskStatusInformation;DiskModel;DiskRevision;DiskTLAPartNumber;DiskPartNumber;Size;
          - type: multiply
            column: 10
            value: 1048576
            # Exclude Empty Disk Slots
            # MSHW_PHYDISK;DiskID;DiskVendor;DiskState;DiskStatusInformation;DiskModel;DiskRevision;DiskTLAPartNumber;DiskPartNumber;Size;
          - type: excludeMatchingLines
            column: 4
            valueList: Empty
      mapping:
        # The discovery table
        # MSHW_PHYDISK;DiskID;DiskVendor;DiskState;DiskStateInformation;DiskModel;DiskRevision;DiskTLAPartNumber;DiskPartNumber;Size;
        source: $monitors.physical_disk.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          __display_id: $column(2)
          vendor: $column(3)
          model: $column(6)
          firmware_version: $column(7)
          info: "join(\" \", $column(8), $column(9))"
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s - %s)\", $column(2), $column(3), bytes2HumanFormatBase10($column(10)))"
        metrics:
          hw.physical_disk.size: $column(10)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
          computes:
            # Keep only Physical Disks
            # MSHW_PHYDISK;DiskID;DiskVendor;DiskState;DiskStatusInformation;DiskModel;DiskRevision;DiskTLAPartNumber;DiskPartNumber;Size;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PHYDISK$
            # Now translate  into OK/Warning/Alarm
            # MSHW_PHYDISK;DiskID;DiskVendor;DiskState;DiskStatusInformation;DiskModel;DiskRevision;DiskTLAPartNumber;DiskPartNumber;Size;
          - type: translate
            column: 4
            translationTable: StatusTT
      mapping:
        # Value Table
        # MSHW_PHYDISK;DiskID;DiskVendor;DiskState;DiskStatusInformation;DiskModel;DiskRevision;DiskTLAPartNumber;DiskPartNumber;Size;
        source: $monitors.physical_disk.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="physical_disk"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(5)
  power_supply:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(3)$
          computes:
            # Keep only "OTHER"
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHER$
            # Keep only "Power"
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 2
            regExp: ^Power$
            # Exclude Empty
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: excludeMatchingLines
            column: 4
            valueList: Empty
      mapping:
        # The discovery table
        # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
        source: $monitors.power_supply.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(3)
          power_supply_type: $column(8)
          info: "join(\" \", $column(5), $column(6), $column(7))"
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s)\", $column(3), $column(8))"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
          computes:
            # Keep only PowerSupply
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHER$
            # Duplicate the State
            # MSHW_OTHER;Type;ComponentID;Status;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: duplicateColumn
            column: 4
            # Now translate  into OK/Warning/Alarm
            # MSHW_OTHER;Type;ComponentID;PatrolStatus;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: translate
            column: 4
            translationTable: StatusTT
      mapping:
        # Value Table
        # MSHW_OTHER;Type;ComponentID;PatrolStatus;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
        source: $monitors.power_supply.collect.sources.source(1)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="power_supply"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(5)
  memory:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(3)$
          computes:
            # Keep only "OTHER"
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;Size;Type;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHER$
            # Keep only "DIMM"
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;Size;Type;
          - type: keepOnlyMatchingLines
            column: 2
            regExp: ^DIMM$
            # Exclude Empty
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;Size;Type;
          - type: excludeMatchingLines
            column: 4
            valueList: Empty
          - type: leftConcat
            column: 5
            value: "Part Number: "
          - type: leftConcat
            column: 7
            value: "Version: "
      mapping:
        # The discovery table
        # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;Size;Type;
        source: $monitors.memory.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(3)
          serial_number: $column(6)
          model: $column(8)
          type: $column(10)
          info: "join(\" \", $column(5), $column(7))"
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s - %s MB)\", $column(3), $column(10), $column(9))"
        metrics:
          hw.memory.limit: mebiByte2Byte($column(9))
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
          computes:
            # Keep only Memory
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHER$
            # Duplicate the State
            # MSHW_OTHER;Type;ComponentID;Status;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: duplicateColumn
            column: 4
            # Now translate  into OK/Warning/Alarm
            # MSHW_OTHER;Type;ComponentID;PatrolStatus;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: translate
            column: 4
            translationTable: StatusTT
      mapping:
        # Value Table
        # MSHW_OTHER;Type;ComponentID;PatrolStatus;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
        source: $monitors.memory.collect.sources.source(1)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="memory"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(5)
  cpu:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(3)$
          computes:
            # Keep only "OTHER"
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHER$
            # Keep only "DIMM"
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 2
            regExp: ^CPU$
            # Exclude Empty
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: excludeMatchingLines
            column: 4
            valueList: Empty
          - type: leftConcat
            column: 6
            value: "SerialNumber: "
      mapping:
        # The discovery table
        # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
        source: $monitors.cpu.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(3)
          model: $column(8)
          info: "join(\" \", $column(5), $column(7), $column(6))"
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s)\", $column(3), $column(8))"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
          computes:
            # Keep only CPU
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHER$
            # Duplicate the State
            # MSHW_OTHER;Type;ComponentID;Status;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: duplicateColumn
            column: 4
            # Now translate  into OK/Warning/Alarm
            # MSHW_OTHER;Type;ComponentID;PatrolStatus;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: translate
            column: 4
            translationTable: StatusTT
      mapping:
        # Value Table
        # MSHW_OTHER;Type;ComponentID;PatrolStatus;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
        source: $monitors.cpu.collect.sources.source(1)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="cpu"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(5)
  other_device:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(3)$
          computes:
            # Keep only "OTHER"
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHER$
            # Keep only non DIMM / CPU
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: excludeMatchingLines
            column: 2
            valueList: "DIMM,CPU,Power"
            # Exclude Empty
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: excludeMatchingLines
            column: 4
            valueList: Empty
          - type: leftConcat
            column: 5
            value: "Part Number: "
          - type: leftConcat
            column: 6
            value: "Serial Number: "
      mapping:
        # The discovery table
        # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
        source: $monitors.other_device.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(3)
          device_type: $column(8)
          info: "join(\" \", $column(5), $column(6), $column(7))"
          hw.parent.type: enclosure
          name: "sprintf(\"%s: %s\", $column(8), $column(3))"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
          computes:
            # Keep only OtherDevice
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHER$
            # Duplicate the State
            # MSHW_OTHER;Type;ComponentID;Status;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: duplicateColumn
            column: 4
            # Now translate  into OK/Warning/Alarm
            # MSHW_OTHER;Type;ComponentID;PatrolStatus;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: translate
            column: 4
            translationTable: StatusTT
      mapping:
        # Value Table
        # MSHW_OTHER;Type;ComponentID;PatrolStatus;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
        source: $monitors.other_device.collect.sources.source(1)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="other_device"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(5)
  logical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(3)$
          computes:
            # Keep only LogicalDisk
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_LOGICALDISK$
      mapping:
        # Discovery Table
        source: $monitors.logical_disk.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          __display_id: $column(6)
          raid_level: $column(5)
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s)\", $column(6), $column(5))"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Split LogicalDisks into NaviSphereCLI Warnings (From Celerra Connector and Real Logical Disks)
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
          computes:
          # Keep only NaviSphereCLI Warnings.  These are pre-translated
          - type: keepOnlyMatchingLines
            column: 2
            regExp: ^NaviSphere CLI Failure$
        source(2):
          # Split LogicalDisks into NaviSphereCLI Warnings (From Celerra Connector and Real Logical Disks)
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
          computes:
            # Keep only RAIDGroups
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: keepOnlyMatchingLines
            column: 2
            regExp: ^RAIDGroup-
            # Translate the first status array into a patrol status array
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: arrayTranslate
            column: 3
            translationTable: RaidGroupStatusTranslationTable
            # Translate the second status array into a status information array
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: arrayTranslate
            column: 4
            translationTable: RaidGroupStatusInformationTranslationTable
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: convert
            column: 3
            conversion: array2SimpleStatus
        source(3):
          # Split LogicalDisks into NaviSphereCLI Warnings (From Celerra Connector and Real Logical Disks)
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
          computes:
            # Keep Only Logical Disks
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_LOGICALDISK$
            # Exclude RAIDGroups
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: excludeMatchingLines
            column: 2
            regExp: ^RAIDGroup-
            # Exclude NaviSphereCLI Warnings.  These are pre-translated
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: excludeMatchingLines
            column: 2
            regExp: ^NaviSphere CLI Failure$
            # Now translate  into OK/Warning/Alarm
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: translate
            column: 3
            translationTable: StatusTT
        source(4):
          # Union 1 and 2 and 3
          type: tableUnion
          tables:
          - $monitors.logical_disk.collect.sources.source(1)$
          - $monitors.logical_disk.collect.sources.source(2)$
          - $monitors.logical_disk.collect.sources.source(3)$
      mapping:
        # Value Table
        # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
        source: $monitors.logical_disk.collect.sources.source(4)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="logical_disk"}: $column(3)
        legacyTextParameters:
          StatusInformation: $column(4)
  network:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(3)$
          computes:
            # Keep only NetworkCards
            # MSHW_PORT;PortID;SPLinkStatus;SPPortStatus;StatusInformation;SFState;SPPortSpeed;Location;SPUID[PortID];FRU;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PORT$
            # Exclude ports with no SFP
            # MSHW_PORT;PortID;SPLinkStatus;SPPortStatus;StatusInformation;SFState;SPPortSpeed;Location;SPUID[PortID];FRU;
          - type: excludeMatchingLines
            column: 6
            valueList: None
          - type: leftConcat
            column: 8
            value: "Location: "
          - type: leftConcat
            column: 10
            value: "Part Number: "
          - type: leftConcat
            column: 9
            value: "SPUID: "
      mapping:
        # The discovery table
        # MSHW_PORT;PortID;SPLinkStatus;SPPortStatus;StatusInformation;SFState;SPPortSpeed;Location;SPUID[PortID];FRU;
        source: $monitors.network.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          __display_id: $column(2)
          info: "join(\" \", $column(8), $column(10), $column(9))"
          hw.parent.type: enclosure
          name: $column(2)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
          computes:
            # Keep only DiskControllers
            # MSHW_PORT;PortID;SPLinkStatus;SPPortStatus;SFState;SPPortSpeed;Location;SPUID[PortID];FRU;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PORT$
            # Now translate SPLinkStatus into OK/Warning/Alarm
            # MSHW_PORT;PortID;PATROLSPLinkStatus;SPPortStatus;SFState;SPPortSpeed;Location;SPUID[PortID];FRU;
          - type: translate
            column: 3
            translationTable: SPLinkStatusTT
          # Add SPPortStatus to Status Information
          - type: leftConcat
            column: 5
            value: Column(4)
            # Translate the Port Status
            # MSHW_PORT;PortID;SPLinkStatus;SPPortStatus;StatusInformation;SFState;SPPortSpeed;Location;SPUID[PortID];FRU;
          - type: translate
            column: 4
            translationTable: SPPortStatusTT
          # Add Port Status to Status Information
          - type: leftConcat
            column: 5
            value: "Port Status: "
          # Add SFP State to Status Information
          - type: rightConcat
            column: 5
            value: " - SFP State: "
          # Add SFState value to the Status Information
          - type: rightConcat
            column: 5
            value: Column(6)
            # Translate the Port Status
            # MSHW_PORT;PortID;SPLinkStatus;SPPortStatus;StatusInformation;SFState;SPPortSpeed;Location;SPUID[PortID];FRU;
          - type: translate
            column: 6
            translationTable: SFPPortStatusTT
            # Add the SFState to the SPPortStatus and Convert to SimpleStatus
            # MSHW_PORT;PortID;SPLinkStatus;SPPortStatus;StatusInformation;SFState;SPPortSpeed;Location;SPUID[PortID];FRU;
          - type: leftConcat
            column: 4
            value: '|'
          - type: leftConcat
            column: 4
            value: Column(6)
          - type: convert
            column: 4
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        source: $monitors.network.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.network.up: legacyLinkStatus($column(3))
          hw.network.bandwidth.limit: megaBit2Bit($column(7))
          hw.status{hw.type="network"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(5)
translations:
  SFPPortStatusTT:
    online: ok
    disabled: ok
    Default: failed
  SPPortStatusTT:
    online: ok
    disabled: ok
    Default: failed
  RaidGroupStatusInformationTranslationTable:
    Defragmenting: ""
    Degraded: Degraded
    Explicit_Remove: ""
    Expanding: ""
    Halted: Halted
    Busy: ok
    Valid_luns: ""
    Valid states are Invalid: Valid States are Invalid
    Invalid: Invalid
  systemStatusTranslationTable:
    Default: UNKNOWN
    "OFF": ok
    "ON": degraded
  StatusTT:
    Rebuilding: degraded
    no_mirror: degraded
    unformatted: degraded
    "Off": failed
    empty: failed
    Equalizing: ok
    valid: ok
    '*fault*': failed
    unsupported: failed
    Expanding: ok
    ready: ok
    Unbound: ok
    OK: ok
    spare: ok
    Binding: ok
    normal: ok
    faulted: failed
    bound: ok
    Formatting: degraded
    Enabled: ok
    fault: failed
    failed: failed
    degraded: degraded
    Default: UNKNOWN
    removed: failed
    Bypass: failed
    Transitioning: ok
    attention: degraded
    alerts.: failed
    Up: ok
    Online: degraded
    present: ok
    Power: ok
  systemStatusInformationTranslationTable:
    Default: Unknown System Fault LED Status
    "OFF": System Fault LED OFF
    "ON": System Fault LED ON
  SPLinkStatusTT:
    up: ok
    down: degraded
    Default: UNKNOWN
  RaidGroupStatusTranslationTable:
    Busy: ok
    Rebuilding: degraded
    Valid_luns: ok
    no_mirror: degraded
    empty: failed
    valid: ok
    '*fault*': failed
    Expanding: ok
    ready: ok
    Unbound: ok
    OK: ok
    Invalid: degraded
    normal: ok
    Explicit_Remove: ok
    faulted: failed
    Halted: failed
    bound: ok
    Enabled: ok
    fault: failed
    failed: failed
    degraded: degraded
    Defragmenting: ok
    removed: failed
    attention: degraded
    Valid states are Invalid: degraded
    Online: degraded
    present: ok
