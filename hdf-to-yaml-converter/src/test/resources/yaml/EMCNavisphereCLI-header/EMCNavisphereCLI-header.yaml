---
monitors:
  enclosure:
    discovery:
      sources:
        source(3):
          computes:
          # Process the naviseccli command through an AWK script
          - type: awk
            script: "${file::embeddedFile-1}"
            keep: ^MSHW
            separators: ;
        source(4):
          # Enclosure Source 2 = Copy of Source 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(3)}"
          computes:
            # Keep only Enclosures
            # MS_HW_Enclosure;SystemModel;SerialNumber;SystemFirmware;SystemFaultLED;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_ENCLOSURE$
      mapping:
        # The discovery table
        # MS_HW_Enclosure;SystemModel;SerialNumber;SystemFirmware;SystemFaultLED;
        source: "${source::monitors.enclosure.discovery.sources.source(4)}"
        attributes:
          id: $3
          __display_id: $3
          serial_number: $3
          model: $2
          vendor: EMC
          type: Storage
          name: "${awk::sprintf(\"Storage: %s (%s %s)\", $3, \"EMC\", $2)}"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(3):
          computes:
          # Process the naviseccli command through an AWK script
          - type: awk
            script: "${file::embeddedFile-1}"
            keep: ^MSHW
            separators: ;
        source(4):
          # Enclosure Source 2 = Copy of Source 1
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(3)}"
          computes:
            # Keep only Enclosures
            # MS_HW_Enclosure;SystemModel;SerialNumber;SystemFirmware;SystemFaultLED;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_ENCLOSURE$
            # Duplicate status, because we will translate it two times
            # MS_HW_Enclosure;SystemModel;SerialNumber;SystemFirmware;SystemFaultLED;SystemFaultLED;
          - type: duplicateColumn
            column: 5
            # Translate Status into PATROLStatus
            # MS_HW_Enclosure;SystemModel;SerialNumber;SystemFirmware;PATROLStatus;SystemFaultLED;
          - type: translate
            column: 5
            translationTable: "${translation::systemStatusTranslationTable}"
            # Translate second Status into more readable string
            # MS_HW_Enclosure;SystemModel;SerialNumber;SystemFirmware;PATROLStatus;StatusInformation;
          - type: translate
            column: 6
            translationTable: "${translation::systemStatusInformationTranslationTable}"
        source(5):
          # Take a copy of the last discovery for the next discovery to use
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(3)}"
      mapping:
        # ValueTable = Source(2)
        source: "${source::monitors.enclosure.collect.sources.source(4)}"
        deviceId: $3
        metrics:
          hw.status{hw.type="enclosure"}: $5
        legacyTextParameters:
          StatusInformation: $6
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(3)}"
          computes:
            # Keep only PhysicalDisk
            # MSHW_PHYDISK;DiskID;DiskVendor;DiskState;DiskStatusInformation;DiskModel;DiskRevision;DiskTLAPartNumber;DiskPartNumber;Size;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PHYDISK$
            # Convert Size from Mbytes to bytes
            # MSHW_PHYDISK;DiskID;DiskVendor;DiskState;DiskStatusInformation;DiskModel;DiskRevision;DiskTLAPartNumber;DiskPartNumber;Size;
          - type: multiply
            column: 10
            value: 1048576
            # Exclude Empty Disk Slots
            # MSHW_PHYDISK;DiskID;DiskVendor;DiskState;DiskStatusInformation;DiskModel;DiskRevision;DiskTLAPartNumber;DiskPartNumber;Size;
          - type: excludeMatchingLines
            column: 4
            valueList: Empty
      mapping:
        # The discovery table
        # MSHW_PHYDISK;DiskID;DiskVendor;DiskState;DiskStateInformation;DiskModel;DiskRevision;DiskTLAPartNumber;DiskPartNumber;Size;
        source: "${source::monitors.physical_disk.discovery.sources.source(1)}"
        attributes:
          id: $2
          __display_id: $2
          vendor: $3
          model: $6
          firmware_version: $7
          info: "${awk::join(\" \", $8, $9)}"
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s - %s)\", $2, $3, bytes2HumanFormatBase10($10))}"
        metrics:
          hw.physical_disk.size: $10
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(3)}"
          computes:
            # Keep only Physical Disks
            # MSHW_PHYDISK;DiskID;DiskVendor;DiskState;DiskStatusInformation;DiskModel;DiskRevision;DiskTLAPartNumber;DiskPartNumber;Size;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PHYDISK$
            # Now translate  into OK/Warning/Alarm
            # MSHW_PHYDISK;DiskID;DiskVendor;DiskState;DiskStatusInformation;DiskModel;DiskRevision;DiskTLAPartNumber;DiskPartNumber;Size;
          - type: translate
            column: 4
            translationTable: "${translation::StatusTT}"
      mapping:
        # Value Table
        # MSHW_PHYDISK;DiskID;DiskVendor;DiskState;DiskStatusInformation;DiskModel;DiskRevision;DiskTLAPartNumber;DiskPartNumber;Size;
        source: "${source::monitors.physical_disk.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="physical_disk"}: $4
        legacyTextParameters:
          StatusInformation: $5
  power_supply:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(3)}"
          computes:
            # Keep only "OTHER"
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHER$
            # Keep only "Power"
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 2
            regExp: ^Power$
            # Exclude Empty
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: excludeMatchingLines
            column: 4
            valueList: Empty
      mapping:
        # The discovery table
        # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
        source: "${source::monitors.power_supply.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $3
          power_supply_type: $8
          info: "${awk::join(\" \", $5, $6, $7)}"
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s)\", $3, $8)}"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(3)}"
          computes:
            # Keep only PowerSupply
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHER$
            # Duplicate the State
            # MSHW_OTHER;Type;ComponentID;Status;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: duplicateColumn
            column: 4
            # Now translate  into OK/Warning/Alarm
            # MSHW_OTHER;Type;ComponentID;PatrolStatus;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: translate
            column: 4
            translationTable: "${translation::StatusTT}"
      mapping:
        # Value Table
        # MSHW_OTHER;Type;ComponentID;PatrolStatus;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
        source: "${source::monitors.power_supply.collect.sources.source(1)}"
        deviceId: $3
        metrics:
          hw.status{hw.type="power_supply"}: $4
        legacyTextParameters:
          StatusInformation: $5
  memory:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(3)}"
          computes:
            # Keep only "OTHER"
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;Size;Type;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHER$
            # Keep only "DIMM"
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;Size;Type;
          - type: keepOnlyMatchingLines
            column: 2
            regExp: ^DIMM$
            # Exclude Empty
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;Size;Type;
          - type: excludeMatchingLines
            column: 4
            valueList: Empty
          - type: leftConcat
            column: 5
            value: "Part Number: "
          - type: leftConcat
            column: 7
            value: "Version: "
      mapping:
        # The discovery table
        # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;Size;Type;
        source: "${source::monitors.memory.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $3
          serial_number: $6
          model: $8
          type: $10
          info: "${awk::join(\" \", $5, $7)}"
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s - %s MB)\", $3, $10, $9)}"
        metrics:
          hw.memory.limit: mebiByte2Byte($9)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(3)}"
          computes:
            # Keep only Memory
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHER$
            # Duplicate the State
            # MSHW_OTHER;Type;ComponentID;Status;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: duplicateColumn
            column: 4
            # Now translate  into OK/Warning/Alarm
            # MSHW_OTHER;Type;ComponentID;PatrolStatus;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: translate
            column: 4
            translationTable: "${translation::StatusTT}"
      mapping:
        # Value Table
        # MSHW_OTHER;Type;ComponentID;PatrolStatus;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
        source: "${source::monitors.memory.collect.sources.source(1)}"
        deviceId: $3
        metrics:
          hw.status{hw.type="memory"}: $4
        legacyTextParameters:
          StatusInformation: $5
  cpu:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(3)}"
          computes:
            # Keep only "OTHER"
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHER$
            # Keep only "DIMM"
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 2
            regExp: ^CPU$
            # Exclude Empty
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: excludeMatchingLines
            column: 4
            valueList: Empty
          - type: leftConcat
            column: 6
            value: "SerialNumber: "
      mapping:
        # The discovery table
        # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
        source: "${source::monitors.cpu.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $3
          model: $8
          info: "${awk::join(\" \", $5, $7, $6)}"
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s)\", $3, $8)}"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(3)}"
          computes:
            # Keep only CPU
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHER$
            # Duplicate the State
            # MSHW_OTHER;Type;ComponentID;Status;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: duplicateColumn
            column: 4
            # Now translate  into OK/Warning/Alarm
            # MSHW_OTHER;Type;ComponentID;PatrolStatus;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: translate
            column: 4
            translationTable: "${translation::StatusTT}"
      mapping:
        # Value Table
        # MSHW_OTHER;Type;ComponentID;PatrolStatus;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
        source: "${source::monitors.cpu.collect.sources.source(1)}"
        deviceId: $3
        metrics:
          hw.status{hw.type="cpu"}: $4
        legacyTextParameters:
          StatusInformation: $5
  other_device:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(3)}"
          computes:
            # Keep only "OTHER"
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHER$
            # Keep only non DIMM / CPU
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: excludeMatchingLines
            column: 2
            valueList: "DIMM,CPU,Power"
            # Exclude Empty
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: excludeMatchingLines
            column: 4
            valueList: Empty
          - type: leftConcat
            column: 5
            value: "Part Number: "
          - type: leftConcat
            column: 6
            value: "Serial Number: "
      mapping:
        # The discovery table
        # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
        source: "${source::monitors.other_device.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $3
          device_type: $8
          info: "${awk::join(\" \", $5, $6, $7)}"
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s: %s\", $8, $3)}"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(3)}"
          computes:
            # Keep only OtherDevice
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHER$
            # Duplicate the State
            # MSHW_OTHER;Type;ComponentID;Status;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: duplicateColumn
            column: 4
            # Now translate  into OK/Warning/Alarm
            # MSHW_OTHER;Type;ComponentID;PatrolStatus;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: translate
            column: 4
            translationTable: "${translation::StatusTT}"
      mapping:
        # Value Table
        # MSHW_OTHER;Type;ComponentID;PatrolStatus;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
        source: "${source::monitors.other_device.collect.sources.source(1)}"
        deviceId: $3
        metrics:
          hw.status{hw.type="other_device"}: $4
        legacyTextParameters:
          StatusInformation: $5
  logical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(3)}"
          computes:
            # Keep only LogicalDisk
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_LOGICALDISK$
      mapping:
        # Discovery Table
        source: "${source::monitors.logical_disk.discovery.sources.source(1)}"
        attributes:
          id: $2
          __display_id: $6
          raid_level: $5
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s)\", $6, $5)}"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Split LogicalDisks into NaviSphereCLI Warnings (From Celerra Connector and Real Logical Disks)
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(3)}"
          computes:
          # Keep only NaviSphereCLI Warnings.  These are pre-translated
          - type: keepOnlyMatchingLines
            column: 2
            regExp: ^NaviSphere CLI Failure$
        source(2):
          # Split LogicalDisks into NaviSphereCLI Warnings (From Celerra Connector and Real Logical Disks)
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(3)}"
          computes:
            # Keep only RAIDGroups
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: keepOnlyMatchingLines
            column: 2
            regExp: ^RAIDGroup-
            # Translate the first status array into a patrol status array
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::RaidGroupStatusTranslationTable}"
            # Translate the second status array into a status information array
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: arrayTranslate
            column: 4
            translationTable: "${translation::RaidGroupStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: convert
            column: 3
            conversion: array2SimpleStatus
        source(3):
          # Split LogicalDisks into NaviSphereCLI Warnings (From Celerra Connector and Real Logical Disks)
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(3)}"
          computes:
            # Keep Only Logical Disks
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_LOGICALDISK$
            # Exclude RAIDGroups
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: excludeMatchingLines
            column: 2
            regExp: ^RAIDGroup-
            # Exclude NaviSphereCLI Warnings.  These are pre-translated
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: excludeMatchingLines
            column: 2
            regExp: ^NaviSphere CLI Failure$
            # Now translate  into OK/Warning/Alarm
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTT}"
        source(4):
          # Union 1 and 2 and 3
          type: tableUnion
          tables:
          - "${source::monitors.logical_disk.collect.sources.source(1)}"
          - "${source::monitors.logical_disk.collect.sources.source(2)}"
          - "${source::monitors.logical_disk.collect.sources.source(3)}"
      mapping:
        # Value Table
        # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
        source: "${source::monitors.logical_disk.collect.sources.source(4)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="logical_disk"}: $3
        legacyTextParameters:
          StatusInformation: $4
  network:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(3)}"
          computes:
            # Keep only NetworkCards
            # MSHW_PORT;PortID;SPLinkStatus;SPPortStatus;StatusInformation;SFState;SPPortSpeed;Location;SPUID[PortID];FRU;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PORT$
            # Exclude ports with no SFP
            # MSHW_PORT;PortID;SPLinkStatus;SPPortStatus;StatusInformation;SFState;SPPortSpeed;Location;SPUID[PortID];FRU;
          - type: excludeMatchingLines
            column: 6
            valueList: None
          - type: leftConcat
            column: 8
            value: "Location: "
          - type: leftConcat
            column: 10
            value: "Part Number: "
          - type: leftConcat
            column: 9
            value: "SPUID: "
      mapping:
        # The discovery table
        # MSHW_PORT;PortID;SPLinkStatus;SPPortStatus;StatusInformation;SFState;SPPortSpeed;Location;SPUID[PortID];FRU;
        source: "${source::monitors.network.discovery.sources.source(1)}"
        attributes:
          id: $2
          __display_id: $2
          info: "${awk::join(\" \", $8, $10, $9)}"
          hw.parent.type: enclosure
          name: $2
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(3)}"
          computes:
            # Keep only DiskControllers
            # MSHW_PORT;PortID;SPLinkStatus;SPPortStatus;SFState;SPPortSpeed;Location;SPUID[PortID];FRU;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PORT$
            # Now translate SPLinkStatus into OK/Warning/Alarm
            # MSHW_PORT;PortID;PATROLSPLinkStatus;SPPortStatus;SFState;SPPortSpeed;Location;SPUID[PortID];FRU;
          - type: translate
            column: 3
            translationTable: "${translation::SPLinkStatusTT}"
          # Add SPPortStatus to Status Information
          - type: leftConcat
            column: 5
            value: $4
            # Translate the Port Status
            # MSHW_PORT;PortID;SPLinkStatus;SPPortStatus;StatusInformation;SFState;SPPortSpeed;Location;SPUID[PortID];FRU;
          - type: translate
            column: 4
            translationTable: "${translation::SPPortStatusTT}"
          # Add Port Status to Status Information
          - type: leftConcat
            column: 5
            value: "Port Status: "
          # Add SFP State to Status Information
          - type: rightConcat
            column: 5
            value: " - SFP State: "
          # Add SFState value to the Status Information
          - type: rightConcat
            column: 5
            value: $6
            # Translate the Port Status
            # MSHW_PORT;PortID;SPLinkStatus;SPPortStatus;StatusInformation;SFState;SPPortSpeed;Location;SPUID[PortID];FRU;
          - type: translate
            column: 6
            translationTable: "${translation::SFPPortStatusTT}"
            # Add the SFState to the SPPortStatus and Convert to SimpleStatus
            # MSHW_PORT;PortID;SPLinkStatus;SPPortStatus;StatusInformation;SFState;SPPortSpeed;Location;SPUID[PortID];FRU;
          - type: leftConcat
            column: 4
            value: '|'
          - type: leftConcat
            column: 4
            value: $6
          - type: convert
            column: 4
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        source: "${source::monitors.network.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.network.up: legacyLinkStatus($3)
          hw.network.bandwidth.limit: megaBit2Bit($7)
          hw.status{hw.type="network"}: $4
        legacyTextParameters:
          StatusInformation: $5
translations:
  SFPPortStatusTT:
    online: ok
    disabled: ok
    Default: failed
  SPPortStatusTT:
    online: ok
    disabled: ok
    Default: failed
  RaidGroupStatusInformationTranslationTable:
    Defragmenting: ""
    Degraded: Degraded
    Explicit_Remove: ""
    Expanding: ""
    Halted: Halted
    Busy: ok
    Valid_luns: ""
    Valid states are Invalid: Valid States are Invalid
    Invalid: Invalid
  systemStatusTranslationTable:
    Default: UNKNOWN
    "OFF": ok
    "ON": degraded
  StatusTT:
    Rebuilding: degraded
    no_mirror: degraded
    unformatted: degraded
    "Off": failed
    empty: failed
    Equalizing: ok
    valid: ok
    '*fault*': failed
    unsupported: failed
    Expanding: ok
    ready: ok
    Unbound: ok
    OK: ok
    spare: ok
    Binding: ok
    normal: ok
    faulted: failed
    bound: ok
    Formatting: degraded
    Enabled: ok
    fault: failed
    failed: failed
    degraded: degraded
    Default: UNKNOWN
    removed: failed
    Bypass: failed
    Transitioning: ok
    attention: degraded
    alerts.: failed
    Up: ok
    Online: degraded
    present: ok
    Power: ok
  systemStatusInformationTranslationTable:
    Default: Unknown System Fault LED Status
    "OFF": System Fault LED OFF
    "ON": System Fault LED ON
  SPLinkStatusTT:
    up: ok
    down: degraded
    Default: UNKNOWN
  RaidGroupStatusTranslationTable:
    Busy: ok
    Rebuilding: degraded
    Valid_luns: ok
    no_mirror: degraded
    empty: failed
    valid: ok
    '*fault*': failed
    Expanding: ok
    ready: ok
    Unbound: ok
    OK: ok
    Invalid: degraded
    normal: ok
    Explicit_Remove: ok
    faulted: failed
    Halted: failed
    bound: ok
    Enabled: ok
    fault: failed
    failed: failed
    degraded: degraded
    Defragmenting: ok
    removed: failed
    attention: degraded
    Valid states are Invalid: degraded
    Online: degraded
    present: ok
