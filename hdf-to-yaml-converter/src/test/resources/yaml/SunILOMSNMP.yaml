---
connector:
  displayName: Oracle/Sun ILOM (SNMP)
  platforms: Oracle/Sun
  reliesOn: Sun/Oracle ILOM SNMP Agent
  version: 1.0
  information: This connector provides hardware monitoring for the Sun/Oracle Blade servers with ILOM cards via SNMP
  detection:
    connectionTypes:
    - remote
    appliesTo:
    - OOB
    - Storage
    supersedes:
    - SunILOMSSH
    criteria:
    - type: snmpGet
      oid: 1.3.6.1.4.1.42.2.70.101.1.1.2.1.5.1
      forceSerialization: true
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Get the Sensor Type table.
          # SensorID;SensorType;SensorClass;
          type: snmpTable
          oid: 1.3.6.1.4.1.42.2.70.101.1.1.6.1
          selectColumns: "ID,1,2"
          forceSerialization: true
        source(2):
          # Get the Sensor Status table.
          # SensorID;Status;
          type: snmpTable
          oid: 1.3.6.1.4.1.42.2.70.101.1.1.2.1
          selectColumns: "ID,3"
          forceSerialization: true
        source(3):
          # Get the LED Status table.
          # SensorID;LEDState;
          type: snmpTable
          oid: 1.3.6.1.4.1.42.2.70.101.1.1.12.1
          selectColumns: "ID,2"
          forceSerialization: true
          computes:
            # Translate the LEDStatus into a Normal Status
            # SensorID;LEDState;
          - type: translate
            column: 2
            translationTable: LEDStatusTranslationTable
            # Add Columns to match Sensor table (5)
            # SensorID;SensorType;SensorClass;SensorID;LEDState;
          - type: rightConcat
            column: 1
            value: ;;LED;
        source(4):
          # Get the Numeric Sensors table.
          # SensorID;CurrentValue;LowerNC;UpperNC;LowerC;UpperC;Exponent;
          type: snmpTable
          oid: 1.3.6.1.4.1.42.2.70.101.1.1.8.1
          selectColumns: "ID,4,8,9,10,11,2"
          forceSerialization: true
        source(5):
          # Let's build up tables 2,3 and 4 into a single sensor table
          # SensorID;SensorType;SensorClass;SensorID;Status;
          type: tableJoin
          leftTable: $monitors.enclosure.discovery.sources.source(1)$
          rightTable: $monitors.enclosure.discovery.sources.source(2)$
          leftKeyColumn: 1
          rightKeyColumn: 1
          defaultRightLine: ;;
        source(6):
          # Combine the Status and LEDStatus tables (Sensors should only be in one, with priority to the LED table)
          # SensorID;SensorType;SensorClass;SensorID;Status;
          type: tableUnion
          tables:
          - $monitors.enclosure.discovery.sources.source(3)$
          - $monitors.enclosure.discovery.sources.source(5)$
        source(7):
          # SensorID;SensorType;SensorClass;SensorID;Status;SensorID;CurrentValue;LowerNC;UpperNC;LowerC;UpperC;
          type: tableJoin
          leftTable: $monitors.enclosure.discovery.sources.source(6)$
          rightTable: $monitors.enclosure.discovery.sources.source(4)$
          leftKeyColumn: 1
          rightKeyColumn: 1
          defaultRightLine: ;;;;;;;
          computes:
            # Remove extra SensorId
            #      1        2          3         5      7           8       9       10     11     12
            # SensorID;SensorType;SensorClass;Status;CurrentValue;LowerNC;UpperNC;LowerC;UpperC;Exponent;
          - type: keepColumns
            columnNumbers: "1,2,3,5,7,8,9,10,11,12"
        source(8):
          # Get the Sensor FRU list table.
          # SensorID;PhysDesc;ParentID;Class;Name;Firmware;SerialNumber;Manufacturer;Model;
          type: snmpTable
          oid: 1.3.6.1.2.1.47.1.1.1.1
          selectColumns: "ID,2,4,5,7,9,11,12,13"
          forceSerialization: true
        source(9):
          # Now Attach Each Sensor to the FRU info
          # SensorID;PhysDesc;ParentID;Class;Name;Firmware;SerialNumber;Manufacturer;Model;SensorID;SensorType;SensorClass;Status;CurrentValue;LowerNC;UpperNC;LowerC;UpperC;Exponent;
          type: tableJoin
          leftTable: $monitors.enclosure.discovery.sources.source(8)$
          rightTable: $monitors.enclosure.discovery.sources.source(7)$
          leftKeyColumn: 1
          rightKeyColumn: 1
          defaultRightLine: ;;;;;;;;;
          computes:
            # Awk the table to process the Sensors
            # MSHW_CLASS;.....
          - type: awk
            script: $embedded.EmbeddedFile(1)$
            keep: ^MSHW
        source(10):
          # Make a copy for Enclosure Discovery
          # MSHW_CLASS;.....
          type: copy
          from: $monitors.enclosure.discovery.sources.source(9)$
          computes:
            # Keep Only Enclosure
            # MSHW_ENC;SensorID;Name;Firmware;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;ChassisConsumedPower;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: MSHW_ENC
          - type: leftConcat
            column: 4
            value: "Firmware Version: "
      mapping:
        # Instance Table
        # MSHW_ENC;SensorID;Name;Firmware;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;ChassisConsumedPower;
        source: $monitors.enclosure.discovery.sources.source(10)$
        attributes:
          id: $column(2)
          __display_id: $column(3)
          vendor: $column(6)
          model: $column(7)
          serial_number: $column(5)
          info: "join($column(10), $column(4), \" \")"
          name: "sprintf(\"Enclosure: %s (%s %s)\", $column(3), $column(6), $column(7))"
    collect:
      # Collect type is mono-instance
      type: multiInstance
      sources:
        source(1):
          # Get the Sensor Type table.
          # SensorID;SensorType;SensorClass;
          type: snmpTable
          oid: 1.3.6.1.4.1.42.2.70.101.1.1.6.1
          selectColumns: "ID,1,2"
          forceSerialization: true
        source(2):
          # Get the Sensor Status table.
          # SensorID;Status;
          type: snmpTable
          oid: 1.3.6.1.4.1.42.2.70.101.1.1.2.1
          selectColumns: "ID,3"
          forceSerialization: true
        source(3):
          # Get the LED Status table.
          # SensorID;State;
          type: snmpTable
          oid: 1.3.6.1.4.1.42.2.70.101.1.1.12.1
          selectColumns: "ID,2"
          forceSerialization: true
          computes:
            # Translate the LEDStatus into a Normal Status
            # SensorID;State;
          - type: translate
            column: 2
            translationTable: LEDStatusTranslationTable
            # Add Columns to match Sensor table (5)
            # SensorID;SensorType;SensorClass;SensorID;State;
          - type: rightConcat
            column: 1
            value: ;;LED;
        source(4):
          # Get the Numeric Sensors table.
          # SensorID;CurrentValue;LowerNC;UpperNC;LowerC;UpperC;Exponent;
          type: snmpTable
          oid: 1.3.6.1.4.1.42.2.70.101.1.1.8.1
          selectColumns: "ID,4,8,9,10,11,2"
          forceSerialization: true
        source(5):
          # Let's build up tables 2,3 and 4 into a single sensor table
          # SensorID;SensorType;SensorClass;SensorID;Status;
          type: tableJoin
          leftTable: $monitors.enclosure.collect.sources.source(1)$
          rightTable: $monitors.enclosure.collect.sources.source(2)$
          leftKeyColumn: 1
          rightKeyColumn: 1
          defaultRightLine: ;;
        source(6):
          # Combine the Status and LEDStatus tables (Sensors should only be in one, with priority to the LED table)
          # SensorID;SensorType;SensorClass;SensorID;Status;
          type: tableUnion
          tables:
          - $monitors.enclosure.collect.sources.source(3)$
          - $monitors.enclosure.collect.sources.source(5)$
        source(7):
          # SensorID;SensorType;SensorClass;SensorID;Status;SensorID;CurrentValue;LowerNC;UpperNC;LowerC;UpperC;Exponent;
          type: tableJoin
          leftTable: $monitors.enclosure.collect.sources.source(6)$
          rightTable: $monitors.enclosure.collect.sources.source(4)$
          leftKeyColumn: 1
          rightKeyColumn: 1
          defaultRightLine: ;;;;;;;
          computes:
            # Remove extra SensorId
            #      1        2          3         5      7           8       9       10     11      12
            # SensorID;SensorType;SensorClass;Status;CurrentValue;LowerNC;UpperNC;LowerC;UpperC;Exponent;
          - type: keepColumns
            columnNumbers: "1,2,3,5,7,8,9,10,11,12"
        source(8):
          # Get the Sensor FRU list table.
          # SensorID;PhysDesc;ParentID;Class;Name;Firmware;SerialNumber;Manufacturer;Model;
          type: snmpTable
          oid: 1.3.6.1.2.1.47.1.1.1.1
          selectColumns: "ID,2,4,5,7,9,11,12,13"
          forceSerialization: true
        source(9):
          # Now Attach Each Sensor to the FRU info
          # SensorID;PhysDesc;ParentID;Class;Name;Firmware;SerialNumber;Manufacturer;Model;SensorID;SensorType;SensorClass;Status;CurrentValue;LowerNC;UpperNC;LowerC;UpperC;Exponent;
          type: tableJoin
          leftTable: $monitors.enclosure.collect.sources.source(8)$
          rightTable: $monitors.enclosure.collect.sources.source(7)$
          leftKeyColumn: 1
          rightKeyColumn: 1
          defaultRightLine: ;;;;;;;;;
          computes:
            # Awk the table to process the Sensors
            # MSHW_CLASS;.....
          - type: awk
            script: $embedded.EmbeddedFile(1)$
            keep: ^MSHW
        source(10):
          # Make a copy for Enclosure Discovery
          # MSHW_CLASS;.....
          type: copy
          from: $monitors.enclosure.collect.sources.source(9)$
          computes:
            # Keep Only Enclosure
            # MSHW_ENC;SensorID;Name;Firmware;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;MSHWNUMERIC[ID];PowerConsumption;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: MSHW_ENC
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # MSHW_ENC;SensorID;Name;Firmware;SerialNumber;Manufacturer;Model;PatrolStatus;StatusInformation;SensorList;MSHWNUMERIC[ID];PowerConsumption;
          - type: arrayTranslate
            column: 8
            translationTable: StatusTranslationTable
            # Then we consolodate the Status Codes into a Single Status
            # MSHW_ENC;SensorID;Name;Firmware;SerialNumber;Manufacturer;Model;PatrolStatus;StatusInformation;SensorList;MSHWNUMERIC[ID];PowerConsumption;
          - type: convert
            column: 8
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # MSHW_ENC;SensorID;Name;Firmware;SerialNumber;Manufacturer;Model;PatrolStatus;StatusInformation;SensorList;MSHWNUMERIC[ID];PowerConsumption;
        source: $monitors.enclosure.collect.sources.source(10)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="enclosure"}: $column(8)
          hw.enclosure.power: $column(12)
          hw.enclosure.energy: fakeCounter($column(12))
        legacyTextParameters:
          StatusInformation: $column(9)
  temperature:
    discovery:
      sources:
        source(1):
          # Discovery
          type: copy
          from: $monitors.enclosure.discovery.sources.source(9)$
          computes:
            # Keep Only Temperature Sensors
            # MSHW_TEMP;SensorID;Name;CurrentValue;UpperNC;UpperC;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_TEMP
      mapping:
        # InstanceTable = Source(1)
        # MSHW_TEMP;SensorID;Name;CurrentValue;UpperNC;UpperC;Status;StatusInformation;SensorList;
        source: $monitors.temperature.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          __display_id: $column(3)
          info: $column(9)
          hw.parent.type: enclosure
          name: $column(3)
        metrics:
          hw.temperature.limit{limit_type="high.degraded"}: $column(5)
          hw.temperature.limit{limit_type="high.critical"}: $column(6)
    collect:
      # Collect type is mono-instance
      type: multiInstance
      sources:
        source(1):
          # Make a copy for Enclosure Collect
          # MSHW_CLASS;.....
          type: copy
          from: $monitors.enclosure.collect.sources.source(9)$
          computes:
            # Keep Only Enclosure
            # MSHW_TEMP;SensorID;Name;CurrentValue;UpperNC;UpperC;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_TEMP
            # Then we translate Status code into OK/WARN/ALARM (for the Status parameter)
            # MSHW_TEMP;SensorID;Name;CurrentValue;UpperNC;UpperC;Status;StatusInformation;SensorList;
          - type: arrayTranslate
            column: 7
            translationTable: StatusTranslationTable
            # Then we consolodate the Status Codes into a Single Status
            # MSHW_TEMP;SensorID;Name;CurrentValue;UpperNC;UpperC;Status;StatusInformation;SensorList;
          - type: convert
            column: 7
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # MSHW_TEMP;SensorID;Name;CurrentValue;UpperNC;UpperC;Status;StatusInformation;SensorList;
        source: $monitors.temperature.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.temperature: $column(4)
          hw.status{hw.type="temperature"}: $column(7)
        legacyTextParameters:
          StatusInformation: $column(8)
  fan:
    discovery:
      sources:
        source(1):
          # Discovery
          type: copy
          from: $monitors.enclosure.discovery.sources.source(9)$
          computes:
            # Keep Only Fan Sensors
            # MSHW_FAN;SensorID;Name;Status;StatusInformation;SensorList;CurrentValue;LowerNC;LowerC;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_FAN
      mapping:
        # InstanceTable = Source(1)
        # MSHW_FAN;SensorID;Name;Status;StatusInformation;SensorList;CurrentValue;LowerNC;LowerC;
        source: $monitors.fan.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          __display_id: $column(3)
          info: $column(6)
          hw.parent.type: enclosure
          name: $column(3)
        metrics:
          hw.fan.speed.limit{limit_type="low.degraded"}: $column(8)
          hw.fan.speed.limit{limit_type="low.critical"}: $column(9)
    collect:
      # Collect type is mono-instance
      type: multiInstance
      sources:
        source(1):
          # Make a copy for Enclosure Collect
          # MSHW_CLASS;.....
          type: copy
          from: $monitors.enclosure.collect.sources.source(9)$
          computes:
            # Keep Only Enclosure
            # MSHW_FAN;SensorID;Name;Status;StatusInformation;SensorList;CurrentValue;LowerNC;LowerC;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_FAN
            # Then we translate Status code into OK/WARN/ALARM (for the Status parameter)
            # MSHW_FAN;SensorID;Name;Status;StatusInformation;SensorList;CurrentValue;LowerNC;LowerC;
          - type: arrayTranslate
            column: 4
            translationTable: StatusTranslationTable
            # Then we consolodate the Status Codes into a Single Status
            # MSHW_FAN;SensorID;Name;Status;StatusInformation;SensorList;CurrentValue;LowerNC;LowerC;
          - type: convert
            column: 4
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # MSHW_FAN;SensorID;Name;Status;StatusInformation;SensorList;CurrentValue;LowerNC;LowerC;
        source: $monitors.fan.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.fan.speed: $column(7)
          hw.status{hw.type="fan"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(5)
  power_supply:
    discovery:
      sources:
        source(1):
          # Discovery
          type: copy
          from: $monitors.enclosure.discovery.sources.source(9)$
          computes:
            # Keep Only PowerSupply Sensors
            # MSHW_PSU;SensorID;Name;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_PSU
          # MSHW_PSU;SensorID;Name;SerialNumber: <serialNumber>;Manufacturer;Model;Status;StatusInformation;SensorList;
          - type: leftConcat
            column: 4
            value: "Serial Number: "
          # MSHW_PSU;SensorID;Name;SerialNumber: <serialNumber>;Manufacturer;Model: <Model>;Status;StatusInformation;SensorList;
          - type: leftConcat
            column: 6
            value: "Model: "
      mapping:
        # InstanceTable = Source(1)
        # MSHW_PSU;SensorID;Name;SerialNumber: <serialNumber>;Manufacturer;Model: <Model>;Status;StatusInformation;Sensor List: <SensorList>;
        source: $monitors.power_supply.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          __display_id: $column(3)
          info: "join($column(4), $column(6), $column(9), \" \")"
          hw.parent.type: enclosure
          name: $column(3)
    collect:
      # Collect type is mono-instance
      type: multiInstance
      sources:
        source(1):
          # Make a copy for Enclosure Collect
          # MSHW_CLASS;.....
          type: copy
          from: $monitors.enclosure.collect.sources.source(9)$
          computes:
            # Keep Only Enclosure
            # MSHW_PSU;SensorID;Name;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_PSU
            # Then we translate Status code into OK/WARN/ALARM (for the Status parameter)
            # MSHW_PSU;SensorID;Name;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
          - type: arrayTranslate
            column: 7
            translationTable: StatusTranslationTable
            # Then we consolodate the Status Codes into a Single Status
            # MSHW_PSU;SensorID;Name;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
          - type: convert
            column: 7
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # MSHW_PSU;SensorID;Name;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
        source: $monitors.power_supply.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="power_supply"}: $column(7)
        legacyTextParameters:
          StatusInformation: $column(8)
  voltage:
    discovery:
      sources:
        source(1):
          # Discovery
          type: copy
          from: $monitors.enclosure.discovery.sources.source(9)$
          computes:
            # Keep Only Voltage Sensors
            # MSHW_VOLT;SensorID;Name;CurrentValue;LowerNC;UpperNC;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_VOLT
      mapping:
        # InstanceTable = Source(1)
        # MSHW_VOLT;SensorID;Name;CurrentValue;LowerNC;UpperNC;Status;StatusInformation;SensorList;
        source: $monitors.voltage.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          __display_id: $column(3)
          info: $column(9)
          hw.parent.type: enclosure
          name: $column(3)
        metrics:
          hw.voltage.limit{limit_type="high.degraded"}: $column(6)
          hw.voltage.limit{limit_type="low.critical"}: $column(5)
    collect:
      # Collect type is mono-instance
      type: multiInstance
      sources:
        source(1):
          # Make a copy for Enclosure Collect
          # MSHW_CLASS;.....
          type: copy
          from: $monitors.enclosure.collect.sources.source(9)$
          computes:
            # Keep Only Enclosure
            # MSHW_VOLT;SensorID;Name;CurrentValue;LowerNC;UpperNC;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_VOLT
            # Then we translate Status code into OK/WARN/ALARM (for the Status parameter)
            # MSHW_VOLT;SensorID;Name;CurrentValue;LowerNC;UpperNC;Status;StatusInformation;SensorList;
          - type: arrayTranslate
            column: 7
            translationTable: StatusTranslationTable
            # Then we consolodate the Status Codes into a Single Status
            # MSHW_VOLT;SensorID;Name;CurrentValue;LowerNC;UpperNC;Status;StatusInformation;SensorList;
          - type: convert
            column: 7
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # MSHW_VOLT;SensorID;Name;CurrentValue;LowerNC;UpperNC;Status;StatusInformation;SensorList;
        source: $monitors.voltage.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.voltage: $column(4)
          hw.status{hw.type="voltage"}: $column(7)
        legacyTextParameters:
          StatusInformation: $column(8)
  memory:
    discovery:
      sources:
        source(1):
          # Discovery
          type: copy
          from: $monitors.enclosure.discovery.sources.source(9)$
          computes:
            # Keep Only Memory Sensors
            # MSHW_MEM;SensorID;Name;Size;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_MEM
      mapping:
        # InstanceTable = Source(1)
        # MSHW_MEM;SensorID;Name;Size;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
        source: $monitors.memory.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          __display_id: $column(3)
          vendor: $column(6)
          serial_number: $column(5)
          model: $column(7)
          info: $column(10)
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s - %s MB)\", $column(3), $column(6), $column(4))"
        metrics:
          hw.memory.limit: mebiByte2Byte($column(4))
    collect:
      # Collect type is mono-instance
      type: multiInstance
      sources:
        source(1):
          # Make a copy for Enclosure Collect
          # MSHW_CLASS;.....
          type: copy
          from: $monitors.enclosure.collect.sources.source(9)$
          computes:
            # Keep Only Enclosure
            # MSHW_MEM;SensorID;Name;Size;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_MEM
            # Then we translate Status code into OK/WARN/ALARM (for the Status parameter)
            # MSHW_MEM;SensorID;Name;Size;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
          - type: arrayTranslate
            column: 8
            translationTable: StatusTranslationTable
            # Then we consolodate the Status Codes into a Single Status
            # MSHW_MEM;SensorID;Name;Size;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
          - type: convert
            column: 8
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # MSHW_MEM;SensorID;Name;Size;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
        source: $monitors.memory.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="memory"}: $column(8)
        legacyTextParameters:
          StatusInformation: $column(9)
  cpu:
    discovery:
      sources:
        source(1):
          # Discovery
          type: copy
          from: $monitors.enclosure.discovery.sources.source(9)$
          computes:
            # Keep Only CPU Sensors
            # MSHW_CPU;SensorID;Name;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_CPU
      mapping:
        # InstanceTable = Source(1)
        # MSHW_CPU;SensorID;Name;Status;StatusInformation;SensorList;
        source: $monitors.cpu.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          __display_id: $column(3)
          info: $column(6)
          hw.parent.type: enclosure
          name: $column(3)
    collect:
      # Collect type is mono-instance
      type: multiInstance
      sources:
        source(1):
          # Make a copy for Enclosure Collect
          # MSHW_CLASS;.....
          type: copy
          from: $monitors.enclosure.collect.sources.source(9)$
          computes:
            # Keep Only Enclosure
            # MSHW_CPU;SensorID;Name;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_CPU
            # Then we translate Status code into OK/WARN/ALARM (for the Status parameter)
            # MSHW_CPU;SensorID;Name;Status;StatusInformation;SensorList;
          - type: arrayTranslate
            column: 4
            translationTable: StatusTranslationTable
            # Then we consolodate the Status Codes into a Single Status
            # MSHW_CPU;SensorID;Name;Status;StatusInformation;SensorList;
          - type: convert
            column: 4
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # MSHW_CPU;SensorID;Name;Status;StatusInformation;SensorList;
        source: $monitors.cpu.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="cpu"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(5)
  other_device:
    discovery:
      sources:
        source(1):
          # Discovery
          type: copy
          from: $monitors.enclosure.discovery.sources.source(9)$
          computes:
            # Keep Only OtherDevice Sensors
            # MSHW_OTHER;PhysDesc;SensorID;Name;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_OTHER
      mapping:
        # InstanceTable = Source(1)
        # MSHW_OTHER;PhysDesc;SensorID;Name;Status;StatusInformation;SensorList;
        source: $monitors.other_device.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(4)
          device_type: $column(2)
          info: $column(7)
          hw.parent.type: enclosure
          name: "sprintf(\"%s: %s\", $column(2), $column(4))"
    collect:
      # Collect type is mono-instance
      type: multiInstance
      sources:
        source(1):
          # Make a copy for Enclosure Collect
          # MSHW_CLASS;.....
          type: copy
          from: $monitors.enclosure.collect.sources.source(9)$
          computes:
            # Keep Only Enclosure
            # MSHW_OTHER;PhysDesc;SensorID;Name;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_OTHER
            # Then we translate Status code into OK/WARN/ALARM (for the Status parameter)
            # MSHW_OTHER;PhysDesc;SensorID;Name;Status;StatusInformation;SensorList;
          - type: arrayTranslate
            column: 5
            translationTable: StatusTranslationTable
            # Then we consolodate the Status Codes into a Single Status
            # MSHW_OTHER;PhysDesc;SensorID;Name;Status;StatusInformation;SensorList;
          - type: convert
            column: 5
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # MSHW_OTHER;PhysDesc;SensorID;Name;Status;StatusInformation;SensorList;
        source: $monitors.other_device.collect.sources.source(1)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="other_device"}: $column(5)
        legacyTextParameters:
          StatusInformation: $column(6)
  physical_disk:
    discovery:
      sources:
        source(1):
          # Discovery
          type: copy
          from: $monitors.enclosure.discovery.sources.source(9)$
          computes:
            # Keep Only PhysicalDisk Sensors
            # MSHW_PHYDISK;SensorID;Name;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_PHYDISK
      mapping:
        # InstanceTable = Source(1)
        # MSHW_PHYDISK;SensorID;Name;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
        source: $monitors.physical_disk.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          __display_id: $column(3)
          vendor: $column(5)
          model: $column(6)
          info: $column(9)
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s)\", $column(3), $column(5))"
    collect:
      # Collect type is mono-instance
      type: multiInstance
      sources:
        source(1):
          # Make a copy for Enclosure Collect
          # MSHW_CLASS;.....
          type: copy
          from: $monitors.enclosure.collect.sources.source(9)$
          computes:
            # Keep Only Enclosure
            # MSHW_PHYDISK;SensorID;Name;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW_PHYDISK
            # Then we translate Status code into OK/WARN/ALARM (for the Status parameter)
            # MSHW_PHYDISK;SensorID;Name;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
          - type: arrayTranslate
            column: 7
            translationTable: StatusTranslationTable
            # Then we consolodate the Status Codes into a Single Status
            # MSHW_PHYDISK;SensorID;Name;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
          - type: convert
            column: 7
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # MSHW_PHYDISK;SensorID;Name;SerialNumber;Manufacturer;Model;Status;StatusInformation;SensorList;
        source: $monitors.physical_disk.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="physical_disk"}: $column(7)
        legacyTextParameters:
          StatusInformation: $column(8)
embedded:
  EmbeddedFile(1): |-
    BEGIN { FS="[;]"; ChassisFound=-1; }
    function AppendStatus(StatusID) {
        if (Status != "") {
            PrintArray[StatusID] = 1
            StatusArray[StatusID] = StatusArray[StatusID] "|" Status
            SensorArray[StatusID] = SensorArray[StatusID] " " Name

            if (Status < 7) {
                StatusInformation[StatusID] = StatusInformation[StatusID] " " Name
            }
      }
        # For numeric sensors we initialize Status to ensure that the sensors are printed.
    }

    function createMSHWPRINT(MSHWCLASS,ID) {
        # Before we start, lets see if we can reclassify MSHW_OTHER devices by their name
        if (MSHWCLASS ~ /MSHW_OTHER/) {

            #Unwanted Sensors - Set Status to Null
            if (Name ~ /.OK2RM$/ ) { Status = ""}

            #CPU
            if ( Name ~ /MB.P[0-9]+$/ ) { MSHWCLASS = "MSHW_CPU" }

            #ENC

            #NETWORK

            #PHYDISK
            if ( Name ~ /HDD[0-9]/ ) { MSHWCLASS = "MSHW_PHYDISK" }

            #PSU
            if ( Name ~ /SYS.PS_FAULT/ ) { MSHWCLASS = "MSHW_PSU" }
            if ( Name ~ /SYS.PS[0-9]/ ) { MSHWCLASS = "MSHW_PSU" }

            #OTHER

            #FAN
            if ( Name ~ /FM[0-9]/ ) { MSHWCLASS = "MSHW_FAN" }
            if ( Name ~ /SYS.FAN_FAULT]/ ) { MSHWCLASS = "MSHW_FAN" }
            if ( Name ~ /FANBD]/ ) { MSHWCLASS = "MSHW_FAN" }

            #VOLT

            #TEMP
            if ( Name ~ /TEMP_FAULT/ ) { MSHWCLASS = "MSHW_TEMP" }

            #MEM
            if ( Name ~ /DIMM/ ) { MSHWCLASS = "MSHW_MEM" }
            if ( Name ~ /MB.P[0-9]+.D[0-9]+.SERVICE/ ) { MSHWCLASS = "MSHW_MEM" }

            #LED
            if ( Name ~ /LOCATE/ ) { MSHWCLASS = "MSHW_LED" }
            if ( Name ~ /^.SYS.OK$]/ ) { MSHWCLASS = "MSHW_LED" }
        }

        # Now let's reclassify troublesome sensors
        if (MSHWCLASS ~ /MSHW_ENC/ && Name ~ /SYS.MIDPLANE/) { MSHWCLASS = "MSHW_OTHER" }
        if (MSHWCLASS ~ /MSHW_ENC/ && Name ~ /SYS.IOCFG/) { MSHWCLASS = "MSHW_OTHER" }
        # Print by class
        if (MSHWCLASS ~ /MSHW_CPU/) {
            functionreturns = "MSHW_CPU;"ID";"Name";"
        }
        else if (MSHWCLASS ~ /MSHW_ENC/) {
          # The model number for Enclosure is not very good, let's use the PhysDesc
          Model = PhysDesc;
          functionreturns = "MSHW_ENC;"ID";"Name";"Firmware";"SerialNumber";"Manufacturer";"Model";"
        }
        else if (MSHWCLASS ~ /MSHW_NETWORK/) { functionreturns = "MSHW_NETWORK;"ID";"Name";" }
        else if (MSHWCLASS ~ /MSHW_PHYDISK/) { functionreturns = "MSHW_PHYDISK;"ID";"Name";"SerialNumber";"Manufacturer";"Model";" }
        else if (MSHWCLASS ~ /MSHW_PSU/) { functionreturns = "MSHW_PSU;"ID";"Name";"SerialNumber";"Manufacturer";"Model";" }
        else if (MSHWCLASS ~ /MSHW_OTHER/) { functionreturns = "MSHW_OTHER;"PhysDesc";"ID";"Name";" }
        else if (MSHWCLASS ~ /MSHW_FAN/) { functionreturns = "MSHW_FAN;"ID";"Name";" }
        else if (MSHWCLASS ~ /MSHW_VOLT/) {
          if ( LowerNC != "") { LowerNC = LowerNC * 1000 }
          if ( UpperNC != "") { UpperNC = UpperNC * 1000 }
          if ( CurrentValue != "") { CurrentValue = CurrentValue * 1000 }

            functionreturns = "MSHW_VOLT;"ID";"Name";"CurrentValue";"LowerNC";"UpperNC";"
        }
        else if (MSHWCLASS ~ /MSHW_TEMP/) { functionreturns = "MSHW_TEMP;"ID";"Name";"CurrentValue";"UpperNC";"UpperC";" }
        else if (MSHWCLASS ~ /MSHW_MEM/) { functionreturns = "MSHW_MEM;"ID";"Name";"Size";"SerialNumber";"Manufacturer";"Model";" }
        else if (MSHWCLASS ~ /MSHW_LED/) {}
        else {functionreturns = "ERROR UNKNOWN CLASS"}
        return functionreturns
    }

    # MAIN AWK

    NF > 8 && $1 ~ /^[0-9]+$/ {
        # Deal with the numeric exponent
        Exponent     = $19
        if (Exponent == -3) { Exponent = 0.001 }
        else if (Exponent == -2) { Exponent = 0.01 }
        else if (Exponent == -1) { Exponent = 0.1 }
        else if (Exponent == 0) { Exponent = 1 }
        else if (Exponent == 1) { Exponent = 10 }
        else if (Exponent == 2) { Exponent = 100 }
        else if (Exponent == 3) { Exponent = 1000 }
        else {Exponent = 1}

        SensorID     = $1
        PhysDesc     = $2
        ParentID     = $3
        Class        = $4
        Name         = $5
        Firmware     = $6
        SerialNumber = $7
        Manufacturer = $8
        Model        = $9
    #    SensorType   = $11
        SensorClass  = $12
        Status       = $13
        CurrentValue = $14 ; CurrentValue = CurrentValue * Exponent
        LowerNC      = $15 ; LowerNC = LowerNC * Exponent ; if (LowerNC==0) {LowerNC = ""}
        UpperNC      = $16 ; UpperNC = UpperNC * Exponent ; if (UpperNC==0) {UpperNC = ""}
        LowerC       = $17 ; LowerC = LowerC * Exponent ; if (LowerC==0) {LowerC = ""}
        UpperC       = $18 ; UpperC = UpperC * Exponent ; if (UpperC==0) {UpperC = ""}

        # 1 - Other
        if (Class == 1) {
            if ( PhysDesc ~ /^BIOS/ ) {
                PhysDesc = "BIOS"
                MSHWPRINT[SensorID] = createMSHWPRINT("MSHW_OTHER",SensorID)
                AppendStatus(SensorID)
            }
            else if ( PhysDesc ~ /^Network/ ) {
                MSHWPRINT[SensorID] = createMSHWPRINT("MSHW_NETWORK",SensorID)
                AppendStatus(SensorID)
            }
            else if ( PhysDesc ~ /^Processor/ || PhysDesc ~ /^Host Processor/ ) {
                MSHWPRINT[SensorID] = createMSHWPRINT("MSHW_CPU",SensorID)
                AppendStatus(SensorID) ;
            }
            else if ( PhysDesc ~ /^CPU Core/ ) {
                AppendStatus(ParentID)

                # Create a Child ID in case the Parent is not found
          MSHWCHILDPRINT[ParentID] = createMSHWPRINT("MSHW_OTHER",ParentID)
          coreParentID[SensorID]=ParentID
            }
            else if ( PhysDesc ~ /^L1 Bank/ ) {
                # add another layer of parenting
                coreParentID[SensorID]=coreParentID[ParentID]
                AppendStatus(coreParentID[ParentID])
            }
            else if ( PhysDesc ~ /^[ID]Cache/ ) {
                # add another layer of parenting
                coreParentID[SensorID]=coreParentID[ParentID] ;
                AppendStatus(coreParentID[ParentID])
            }
            else if ( PhysDesc ~ /^L[0-9]+ Bank/ ) {
                # add another layer of parenting
                coreParentID[SensorID]=coreParentID[ParentID]  ;
                AppendStatus(coreParentID[ParentID]) ;
            }
            else if ( PhysDesc ~ /^Indicator/ ) {
                #These should be LEDs, so translate status
          # 8=Off  9=On 10=Blinking
          # to 2=Major 5=Warn 7=OK

                if ((Name ~ /FAULT$/) || (Name ~ /SERVICE$/) ) {
                    if (Status == 8 ) { Status = 7}
                    if (Status == 9 ) { Status = 2}
                    if (Status == 10 ) { Status = 2}
                }
                if (Name ~ /OK$/ ) {
                    if (Status == 8 ) { Status = 2}
                    if (Status == 9 ) { Status = 7}
                    if (Status == 10 ) { Status = 7}
                }
                if (Name ~ /OK2RM$/ ) {
                    if (Status == 8 ) { Status = 7}
                    if (Status == 9 ) { Status = 5}
                    if (Status == 10 ) { Status = 5}
                }
                AppendStatus(ParentID)
                # Create a Child ID in case the Parent is not found
                MSHWCHILDPRINT[ParentID] = createMSHWPRINT("MSHW_OTHER",ParentID)
        }
            else {
                MSHWPRINT[SensorID] = createMSHWPRINT("MSHW_OTHER",SensorID)
                AppendStatus(SensorID)
            }
        }

        # 2 - Unknown
        if (Class == 2) {
            MSHWPRINT[SensorID] = createMSHWPRINT("MSHW_OTHER",SensorID)
            AppendStatus(SensorID)
        }

        # 3 - Chassis
        if (Class == 3) {
            ChassisFound = SensorID
            MSHWPRINT[SensorID] = createMSHWPRINT("MSHW_ENC",SensorID)
            AppendStatus(SensorID)
            PrintArray[SensorID] = 1
        }

        # 4 - Backplane
        if (Class == 4) {
            PhysDesc = "Backplane"
            MSHWPRINT[SensorID] = createMSHWPRINT("MSHW_OTHER",SensorID)
            AppendStatus(SensorID)
        }

        # 5 - Container
        if (Class == 5) {
            if ( PhysDesc ~ /Motherboard/ ) {
                MSHWPRINT[SensorID] = createMSHWPRINT("MSHW_OTHER",SensorID)
                AppendStatus(SensorID)
            }
            else if ( PhysDesc ~ /Disk/ ) {
                MSHWPRINT[SensorID] = createMSHWPRINT("MSHW_PHYDISK",SensorID)
                AppendStatus(SensorID)
            }
            else {
                MSHWPRINT[SensorID] = createMSHWPRINT("MSHW_OTHER",SensorID)
            }
        }

        # 6 - PowerSupply
        if (Class == 6) {
            MSHWPRINT[SensorID] = createMSHWPRINT("MSHW_PSU",SensorID)
            AppendStatus(SensorID)
        }

        # 7 - Fan
        if (Class == 7) {
            MSHWPRINT[SensorID] = createMSHWPRINT("MSHW_FAN",SensorID)
            AppendStatus(SensorID)
        }

        # 8 - Sensor
        if (Class == 8) {
            # Sensors to Ignore
            if (Name == "/SYS/PWRBS") { next }

            # Chassis Consumed Power Sum
            if (Name ~ /INPUT_POWER$/) {
                ChassisConsumedPower = ChassisConsumedPower + CurrentValue ;
                next
            }
            # 1 - Other - Attach it to its parent
            if (SensorClass == 1) {
                AppendStatus(ParentID)
                # Create a Child ID in case the Parent is not found
                MSHWCHILDPRINT[ParentID] = createMSHWPRINT("MSHW_OTHER",ParentID)
            }

            # 4 - Voltage
            if (SensorClass == 4) {
                MSHWPRINT[SensorID] = createMSHWPRINT("MSHW_VOLT",SensorID)
                PrintArray[SensorID] = 1
                AppendStatus(SensorID)
            }

            # 3 - Temperature
            if (SensorClass == 3) {
                MSHWPRINT[SensorID] = createMSHWPRINT("MSHW_TEMP",SensorID)
                PrintArray[SensorID] = 1
                AppendStatus(SensorID)
            }

            # 6 - Tachometer - Attach it to its parent - Set MSHWNUMERIC to add numeric columns to the end.
            if (SensorClass == 6) {
                MSHWNUMERIC[ParentID] = CurrentValue";"LowerNC";"LowerC";"
                PrintArray[ParentID] = 1
                AppendStatus(ParentID)
                # Create a Child ID in case the Parent is not found
                MSHWCHILDPRINT[ParentID] = createMSHWPRINT("MSHW_FAN",ParentID)
            }

            # 12 - Presence - Attach it to its parent
            if (SensorClass == 12) {
                # if there is a coreParentID, then attach it to that
                if ( coreParentID[ParentID] != "" ) {
                    AppendStatus(coreParentID[ParentID])
                }
                else {
                    AppendStatus(ParentID)
                }

                # Create a Child ID in case the Parent is not found
                MSHWCHILDPRINT[ParentID] = createMSHWPRINT("MSHW_OTHER",ParentID)
            }
        }

        # 9 - Module
        if (Class == 9) {
            if ( PhysDesc ~ /DIMM/ ) {
                MSHWPRINT[SensorID] = createMSHWPRINT("MSHW_MEM",SensorID)
                AppendStatus(SensorID) ;
            }
            else {
                MSHWPRINT[SensorID] = createMSHWPRINT("MSHW_OTHER",SensorID)}
            }

        # 10 - Port (Not yet seen in debugs)
        if (Class == 10) {
            MSHWPRINT[SensorID] = createMSHWPRINT("MSHW_NETWORK",SensorID)
            AppendStatus(SensorID)
        }

        # 11 - Stack
        if (Class == 11) { }

        # 12 - CPU (Not yet seen in debugs)
        if (Class == 12) {
            MSHWPRINT[SensorID] =  createMSHWPRINT("MSHW_CPU",SensorID)
            AppendStatus(SensorID)
        }
    }

    END {
        for (ID in PrintArray) {
            # If we did not find a parent for a sensor
            if (MSHWPRINT[ID] == "") {
                MSHWPRINT[ID] = MSHWCHILDPRINT[ID]
            }
            if (ID == ChassisFound) {
                print MSHWPRINT[ID] StatusArray[ID] ";Alerting Sensors: " StatusInformation[ID] ";Sensors: " SensorArray[ID] ";" MSHWNUMERIC[ID] ";" ChassisConsumedPower ";"
            }
            else {
                print MSHWPRINT[ID] StatusArray[ID] ";Alerting Sensors: " StatusInformation[ID] ";Sensors: " SensorArray[ID] ";" MSHWNUMERIC[ID]
            }
        }

        if (ChassisFound == -1) {
            print "MSHW_ENC;1;/SYS;;;;;"
        }
    }
translations:
  StatusTranslationTable:
    "1": failed
    "2": failed
    default: UNKNOWN
    "3": degraded
    "4": failed
    "5": degraded
    "6": degraded
    "7": ok
  LEDStatusTranslationTable:
    "1": ""
    "2": 8
    default: ""
    "3": 9
    "4": 10
