---
connector:
  displayName: Fujitsu Eternus DX Disk Arrays
  platforms: Fujitsu Eternus
  reliesOn: Fujitsu Eternus SMI-S Server
  version: 1.0
  information: "This connector discovers the enclosure and the disks of Fujitsu SAN disk arrays, as well as the storage pools and storage volumes. It will also discover and monitor the FC ports of the array and the various environment sensors when available (temperatures, fans, power supplies, etc.). It relies on the WBEM technology and supports SMI-S compliant disk arrays only."
  detection:
    connectionTypes:
    - remote
    - local
    appliesTo:
    - Storage
    supersedes:
    - SMISDiskArray
    criteria:
    - type: wbem
      namespace: root/eternus
      query: "SELECT Name,Dedicated FROM FUJITSU_StorageComputerSystem"
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Source = FUJITSU_StorageComputerSystem
          # FUJITSU_StorageComputerSystem;DeviceID;SystemName;
          type: wbem
          query: "SELECT __Path,Name,ElementName FROM FUJITSU_StorageComputerSystem"
          namespace: root/eternus
        source(2):
          # Get the link between FUJITSU_ControllerEnclosure and  FUJITSU_StorageComputerSystem
          # FUJITSU_ControllerEnclosure;FUJITSU_StorageComputerSystem
          type: wbem
          query: "SELECT Antecedent,Dependent FROM CIM_ComputerSystemPackage"
          namespace: root/eternus
        source(3):
          # Large Table (Should only be used on Right)
          # Get the link between  and
          # FUJITSU_StorageProduct;FUJITSU_ControllerEnclosure
          type: wbem
          query: "SELECT GroupComponent,PartComponent FROM CIM_ProductPhysicalComponent"
          namespace: root/eternus
        source(4):
          # Source = FUJITSU_StorageProduct
          # FUJITSU_StorageProduct;Model;Vendor;Firmware;SerialNumber;
          type: wbem
          query: "SELECT __Path,Name,Vendor,Version,IdentifyingNumber FROM FUJITSU_StorageProduct"
          namespace: root/eternus
        source(5):
          # Link FUJITSU_StorageComputerSystem to FUJITSU_ControllerEnclosure
          # FUJITSU_StorageComputerSystem;DeviceID;SystemName;FUJITSU_ControllerEnclosure;FUJITSU_StorageComputerSystem;
          type: tableJoin
          leftTable: "${source::monitors.enclosure.discovery.sources.source(1)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(2)}"
          leftKeyColumn: 1
          rightKeyColumn: 2
          keyType: Wbem
        source(6):
          # Link FUJITSU_StorageProduct to FUJITSU_ControllerEnclosure
          # FUJITSU_StorageComputerSystem;DeviceID;SystemName;FUJITSU_ControllerEnclosure;FUJITSU_StorageComputerSystem;FUJITSU_StorageProduct;FUJITSU_ControllerEnclosure;
          type: tableJoin
          leftTable: "${source::monitors.enclosure.discovery.sources.source(5)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(3)}"
          leftKeyColumn: 4
          rightKeyColumn: 2
          keyType: Wbem
        source(7):
          # Link FUJITSU_StorageProduct info to the main table.
          #          1          #           # 2        3          #          4          #            5          #           #  6          #          7          #           #       8          #    9     10      11        12
          # FUJITSU_StorageComputerSystem;DeviceID;SystemName;FUJITSU_ControllerEnclosure;FUJITSU_StorageComputerSystem;FUJITSU_StorageProduct;FUJITSU_ControllerEnclosure;FUJITSU_StorageProduct;Model;Vendor;Firmware;SerialNumber;
          type: tableJoin
          leftTable: "${source::monitors.enclosure.discovery.sources.source(6)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(4)}"
          leftKeyColumn: 6
          rightKeyColumn: 1
          keyType: Wbem
          computes:
            # Get rid of the Paths
            #          1            #           2        3            #        4            #          5            #            6            #        7            #             #   8            #  9     10      11        12
            # FUJITSU_StorageComputerSystem;DeviceID;SystemName;FUJITSU_ControllerEnclosure;FUJITSU_StorageComputerSystem;FUJITSU_StorageProduct;FUJITSU_ControllerEnclosure;FUJITSU_StorageProduct;Model;Vendor;Firmware;SerialNumber;
            #             #             #   DeviceID;SystemName;            #             #             #             #             #             #             #             #             #       Model;Vendor;Firmware;SerialNumber;
          - type: keepColumns
            columnNumbers: "2,3,9,10,11,12"
          - type: leftConcat
            column: 5
            value: "FirmwareVersion: "
        source(8):
          # Association Queries used by other classes
          # ENCLOSURES;FUJITSU_StorageComputerSystem;
          type: wbem
          query: "SELECT Antecedent,Dependent FROM CIM_SystemPackaging"
          namespace: root/eternus
        source(9):
          # ENCLOSURES;COMPONENT;
          # Examples:
          # FUJITSU_DeviceEnclosure           ;FUJITSU_PSU
          # FUJITSU_ControllerEnclosure       ;FUJITSU_BCU
          # FUJITSU_ControllerCard          # ;FUJITSU_IOM
          type: wbem
          query: "SELECT GroupComponent,PartComponent FROM CIM_PackageInChassis"
          namespace: root/eternus
        source(10):
          # Attach The Enclosures to the FUJITSU_StorageComputerSystem
          # ENCLOSURES;FUJITSU_StorageComputerSystem;FUJITSU_StorageComputerSystem;DeviceID;SystemName;
          type: tableJoin
          leftTable: "${source::monitors.enclosure.discovery.sources.source(8)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(1)}"
          leftKeyColumn: 2
          rightKeyColumn: 1
          keyType: Wbem
        source(11):
          # Attach The Components to the Enclosures
          # ENCLOSURES;COMPONENT;ENCLOSURES;FUJITSU_StorageComputerSystem;FUJITSU_StorageComputerSystem;SystemID;SystemName;
          type: tableJoin
          leftTable: "${source::monitors.enclosure.discovery.sources.source(9)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(10)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          keyType: Wbem
          computes:
            # Get rid of everything except COMPONENT Path DeviceID
            # COMPONENT = FUJITSU_PSU / FUJITSU_BCU / FUJITSU_IOM / FUJITSU_ChannelAdapterCard / FUJITSU_ControllerCard
            # COMPONENT;SystemID;
          - type: keepColumns
            columnNumbers: "2,6"
        source(12):
          # SUB-COMPONENTS
          # SUBCOMPONENT = FUJITSU_BTU / FUJITSU_SFP / FUJITSU_PhysicalMemory / FUJITSU_ChannelAdapterCard
          # SUBCOMPONENT;COMPONENT;
          type: wbem
          query: "SELECT GroupComponent,PartComponent FROM CIM_Container"
          namespace: root/eternus
        source(13):
          # Attach each SUBCOMPONENT to the COMPONENT/System Table
          # SUBCOMPONENT;COMPONENT;COMPONENT;SystemName;
          type: tableJoin
          leftTable: "${source::monitors.enclosure.discovery.sources.source(12)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(11)}"
          leftKeyColumn: 2
          rightKeyColumn: 1
          keyType: Wbem
          computes:
            # Keep only the subcomponent and SystemName
            # SUBCOMPONENT;SystemName;
          - type: keepColumns
            columnNumbers: "1,4"
      mapping:
        # The Instance Table
        # DeviceID;SystemName;Model;Vendor;Firmware;SerialNumber;
        source: "${source::monitors.enclosure.discovery.sources.source(7)}"
        attributes:
          id: $1
          __display_id: $2
          vendor: $4
          model: $3
          serial_number: $6
          type: Storage
          info: $5
          name: "${awk::sprintf(\"Storage: %s (%s %s)\", $2, $4, $3)}"
    collect:
      # Collect type is multiinstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = CIM_ComputerSystem (what else? we're looking for logical devices that have
          # a status, and that corresponds to a CIM_Chassis instance)
          # ComputerID;OperationalStatus;
          type: wbem
          query: "SELECT Name,OperationalStatus FROM FUJITSU_StorageComputerSystem"
          namespace: root/eternus
          computes:
            # Duplicate the "OperationalStatusArray" column
            # ComputerID;OperationalStatusArray;OperationalStatusArray;
          - type: duplicateColumn
            column: 2
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # ComputerID;PATROLStatusArray;Status
          - type: arrayTranslate
            column: 2
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # ComputerID;PATROLStatusArray;StatusInformation
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # ComputerID;PATROLStatus;StatusInformation
          - type: convert
            column: 2
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        source: "${source::monitors.enclosure.collect.sources.source(1)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="enclosure"}: $2
        legacyTextParameters:
          StatusInformation: $3
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = FUJITSU_DiskDrive
          # DeviceID;Name;SystemName;SizeKB;FUJITSU_DiskDrive;
          type: wbem
          query: "SELECT DeviceID,Name,SystemName,MaxMediaSize,__Path FROM FUJITSU_DiskDrive"
          namespace: root/eternus
          computes:
            # Remove "Disk Drive - " from the Name
            # DeviceID;Name;SystemName;SizeKB;FUJITSU_DiskDrive;
          - type: replace
            column: 2
            existingValue: 'Disk Drive - '
            newValue: ""
            # Convert the Disk Size to Bytes
            # DeviceID;Name;SystemName;SizeB;FUJITSU_DiskDrive;
          - type: multiply
            column: 4
            value: 1024
            # Add ":" And SystemaName to DeviceID to make ID unique
            # DeviceID;Name;SystemName;SizeB;FUJITSU_DiskDrive;
          - type: leftConcat
            column: 1
            value: ':'
          - type: leftConcat
            column: 1
            value: $3
        source(2):
          # Source(2) = FUJITSU_PhysicalDisk
          # FUJITSU_PhysicalDisk;Manufacturer;Model;SerialNumber;DriveType;FirmwareVersion;
          type: wbem
          query: "SELECT __Path,Manufacturer,Model,SerialNumber,Type,Version FROM FUJITSU_PhysicalDisk"
          namespace: root/eternus
        source(3):
          # Get DiskDrive to PhysicalDisk Association Table
          # FUJITSU_PhysicalDisk,FUJITSU_DiskDrive
          type: wbem
          query: "SELECT Antecedent,Dependent FROM CIM_Realizes"
          namespace: root/eternus
        source(4):
          # Attach FUJITSU_DiskDrive to CIM_Realizes
          # DeviceID;Name;SystemName;SizeKB;FUJITSU_DiskDrive;FUJITSU_PhysicalDisk;FUJITSU_DiskDrive;
          type: tableJoin
          leftTable: "${source::monitors.physical_disk.discovery.sources.source(1)}"
          rightTable: "${source::monitors.physical_disk.discovery.sources.source(3)}"
          leftKeyColumn: 5
          rightKeyColumn: 2
          keyType: Wbem
        source(5):
          # Attach Source (4) to FUJITSU_PhysicalDisk
          # DeviceID;Name;SystemName;SizeKB;FUJITSU_DiskDrive;FUJITSU_PhysicalDisk;FUJITSU_DiskDrive;FUJITSU_PhysicalDisk;Manufacturer;Model;SerialNumber;DriveType;FirmwareVersion;
          type: tableJoin
          leftTable: "${source::monitors.physical_disk.discovery.sources.source(4)}"
          rightTable: "${source::monitors.physical_disk.discovery.sources.source(2)}"
          leftKeyColumn: 6
          rightKeyColumn: 1
          keyType: Wbem
          computes:
            # Get rid of Paths
            #      1     2      3          4      5            #    6            #         7            #      8            #       9      10    11             12          13
            # DeviceID;Name;SystemName;SizeKB;FUJITSU_DiskDrive;FUJITSU_PhysicalDisk;FUJITSU_DiskDrive;FUJITSU_PhysicalDisk;Manufacturer;Model;SerialNumber;DriveType;FirmwareVersion;
            # DeviceID;Name;SystemName;SizeKB;            #             #             #             #             #         Manufacturer;Model;SerialNumber;DriveType;FirmwareVersion;
          - type: keepColumns
            columnNumbers: "1,2,3,4,9,10,11,12,13"
          - type: leftConcat
            column: 8
            value: "Disk Type: "
      mapping:
        # Instance Table
        #    1      2        3       4         5        6       7        #     8        # 9
        # DeviceID;Name;SystemName;SizeKB;Manufacturer;Model;SerialNumber;DriveType;FirmwareVersion;
        source: "${source::monitors.physical_disk.discovery.sources.source(5)}"
        attributes:
          id: $1
          __display_id: $2
          vendor: $5
          model: $6
          serial_number: $7
          firmware_version: $9
          info: $8
          hw.parent.type: enclosure
          hw.parent.id: $3
          name: "${awk::sprintf(\"%s (%s - %s)\", $2, $5, bytes2HumanFormatBase10($4))}"
        metrics:
          hw.physical_disk.size: $4
    collect:
      # Collect type is multiinstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = HITACHI_DiskDrive
          # SystemName;DeviceID;OperationalStatus;
          type: wbem
          query: "SELECT SystemName,DeviceID,OperationalStatus FROM FUJITSU_DiskDrive"
          namespace: root/eternus
          computes:
            # Add ":" And SystemaName to DeviceID to make ID unique
            # SystemName,DeviceID,OperationalStatus
          - type: leftConcat
            column: 2
            value: ':'
          - type: leftConcat
            column: 2
            value: $1
            # Duplicate the "OperationalStatus" column
            # SystemName,DeviceID,OperationalStatus
          - type: duplicateColumn
            column: 3
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # SystemName,DeviceID,PATROLStatusArray,OperationalStatus
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # SystemName,DeviceID,PATROLStatusArray,StatusInformation
          - type: arrayTranslate
            column: 4
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # SystemName,DeviceID,PATROLStatus,StatusInformation
          - type: convert
            column: 3
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # SystemName,DeviceID,PATROLStatus,StatusDescriptions
        source: "${source::monitors.physical_disk.collect.sources.source(1)}"
        attributes:
          id: $2
        metrics:
          hw.status{hw.type="physical_disk"}: $3
        legacyTextParameters:
          StatusInformation: $4
  network:
    discovery:
      sources:
        source(1):
          # Source(1) = HITACHI_FCPort
          #  DeviceID,SystemName,Speedbps,PermanentAddress,UsageRestriction,PortType
          type: wbem
          query: "SELECT DeviceID,SystemName,Speedbps,PermanentAddress,UsageRestriction,PortType FROM FUJITSU_FCPort"
          namespace: root/eternus
          computes:
            # convert from bit per second to mega bytes per second
            # DeviceID,SystemName,SpeedMBps,PermanentAddress,UsageRestriction,PortType
          - type: divide
            column: 3
            value: 1062500
            # Translate the Port Type (FC Only)
            # DeviceID,SystemName,SpeedMBps,PermanentAddress,UsageRestriction,PortType
          - type: translate
            column: 6
            translationTable: "${translation::PortTypeTranslationTable}"
            # Translate the Port Direction
            # DeviceID,SystemName,SpeedMBps,PermanentAddress,UsageRestriction,PortType
          - type: translate
            column: 5
            translationTable: "${translation::UsageRestrictionTranslationTable}"
            # Duplicate the DeviceID to allow a DisplayID
            # DisplayID,DeviceID,SystemName,SpeedMBps,PermanentAddress,UsageRestriction,PortType
          - type: duplicateColumn
            column: 1
            # Add ":" And SystemaName to Caption to make DeviceID unique
            # DisplayID,DeviceID,SystemName,SpeedMBps,PermanentAddress,UsageRestriction,PortType
          - type: leftConcat
            column: 2
            value: ':'
          - type: leftConcat
            column: 2
            value: $3
          - type: leftConcat
            column: 6
            value: "Usage Restriction: "
      mapping:
        # Instance Table
        # DisplayID,DeviceID,SystemName,SpeedMBps,PermanentAddress,UsageRestriction,PortType
        source: "${source::monitors.network.discovery.sources.source(1)}"
        attributes:
          id: $2
          __display_id: $1
          bandwidth: $4
          physical_address: $5
          physical_address_type: WWN
          device_type: $7
          info: $6
          hw.parent.type: enclosure
          hw.parent.id: $3
          name: "${awk::sprintf(\"%s (%s)\", $1, $7)}"
    collect:
      # Collect type is multiinstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = HITACHI_FCPort
          # DeviceID,Speed,OperationalStatus,SystemName
          type: wbem
          query: "SELECT DeviceID,Speed,OperationalStatus,SystemName FROM FUJITSU_FCPort"
          namespace: root/eternus
          computes:
            # convert from bit per second to mega bytes per second
            # DeviceID,Speed,OperationalStatus,SystemName
          - type: divide
            column: 2
            value: 1062500
            # Duplicate the "OperationalStatus" column
            # DeviceID,Speed,OperationalStatus,OperationalStatus,SystemName
          - type: duplicateColumn
            column: 3
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # DeviceID,Speed,PATROLStatusArray,OperationalStatus,SystemName
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # DeviceID,Speed,PATROLStatusArray,StatusInformation,SystemName
          - type: arrayTranslate
            column: 4
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # DeviceID,Speed,PATROLStatus,StatusInformation,SystemName
          - type: convert
            column: 3
            conversion: array2SimpleStatus
            # Add ":" And SystemaName to Caption to make DeviceID unique
            # DeviceID,Speed,PATROLStatus,StatusInformation,SystemName
          - type: leftConcat
            column: 1
            value: ':'
          - type: leftConcat
            column: 1
            value: $5
      mapping:
        # ValueTable = Source(1)
        # DeviceID,Speed,PATROLStatus,StatusInformation,SystemName
        source: "${source::monitors.network.collect.sources.source(1)}"
        attributes:
          id: $1
        metrics:
          hw.network.bandwidth.limit: megaBit2Bit($2)
          hw.status{hw.type="network"}: $3
        legacyTextParameters:
          StatusInformation: $4
  fan:
    discovery:
      sources:
        source(1):
          # Source(1) = FUJITSU_FAN
          # FUJITSU_FAN,DeviceID
          type: wbem
          query: "SELECT __PATH,ElementName FROM FUJITSU_FAN"
          namespace: root/eternus
          computes:
            # Remove Fan - from the DeviceID
            # FUJITSU_FAN,DeviceID
          - type: replace
            column: 2
            existingValue: 'FAN - '
            newValue: ""
            # Duplicate the DeviceID to make DeviceID and DisplayID
            # FUJITSU_FAN,DeviceID,DisplayID
          - type: duplicateColumn
            column: 2
        source(2):
          # Let's associate the FUJITSU_FAN with the enclosure using the SubComponent to System table
          # FUJITSU_FAN,DeviceID,DisplayID,SUBCOMPONENT;SystemName;
          type: tableJoin
          leftTable: "${source::monitors.fan.discovery.sources.source(1)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(13)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          keyType: Wbem
          computes:
            # Get rid of the Paths
            # DeviceID,DisplayID,SystemName
          - type: keepColumns
            columnNumbers: "2,3,5"
            # Add ":" And SystemaName to DeviceID to make ID unique
            # DeviceID,DisplayID,SystemName
          - type: leftConcat
            column: 1
            value: ':'
          - type: leftConcat
            column: 1
            value: $3
      mapping:
        # Instance Table
        # DeviceID,DisplayID,SystemName
        source: "${source::monitors.fan.discovery.sources.source(2)}"
        attributes:
          id: $1
          __display_id: $2
          hw.parent.type: enclosure
          hw.parent.id: $3
          name: $2
    collect:
      # Collect type is multiinstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = FUJITSU_FAN
          # FUJITSU_FAN;DeviceID;OperationalStatus;
          type: wbem
          query: "SELECT __PATH,ElementName,OperationalStatus FROM FUJITSU_FAN"
          namespace: root/eternus
          computes:
            # Remove Fan - from the DeviceID
            # FUJITSU_FAN,DeviceID,OperationalStatus;
          - type: replace
            column: 2
            existingValue: 'FAN - '
            newValue: ""
            # Duplicate the "OperationalStatus" column
            # FUJITSU_FAN,DeviceID,OperationalStatus
          - type: duplicateColumn
            column: 3
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # FUJITSU_FAN,DeviceID,PATROLStatusArray,OperationalStatus
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # FUJITSU_FAN,DeviceID,PATROLStatusArray,StatusInformation
          - type: arrayTranslate
            column: 4
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # FUJITSU_FAN,DeviceID,PATROLStatus,StatusInformation
          - type: convert
            column: 3
            conversion: array2SimpleStatus
        source(2):
          # Let's associate the FUJITSU_FAN with the enclosure using the SubComponent to System table
          # FUJITSU_FAN,DeviceID,PATROLStatus,StatusInformation,SUBCOMPONENT;SystemName;
          type: tableJoin
          leftTable: "${source::monitors.fan.collect.sources.source(1)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(13)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          keyType: Wbem
          computes:
            # Get rid of the Paths
            # DeviceID,PATROLStatus,StatusInformation,SystemName;
          - type: keepColumns
            columnNumbers: "2,3,4,6"
            # Add ":" And SystemaName to DeviceID to make ID unique
            # DeviceID,PATROLStatus,StatusInformation,SystemName;
          - type: leftConcat
            column: 1
            value: ':'
          - type: leftConcat
            column: 1
            value: $4
      mapping:
        # ValueTable = Source(1)
        # DeviceID,PATROLStatus,StatusInformation,SystemName;
        source: "${source::monitors.fan.collect.sources.source(2)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="fan"}: $2
        legacyTextParameters:
          StatusInformation: $3
  battery:
    discovery:
      sources:
        source(1):
          # Source(1) = FUJITSU_BTU (Battery Units)
          # FUJITSU_BTU,DeviceID
          type: wbem
          query: "SELECT __PATH,ElementName FROM FUJITSU_BTU"
          namespace: root/eternus
          computes:
            # Remove Fan - from the DeviceID
            # FUJITSU_BTU,DeviceID
          - type: replace
            column: 2
            existingValue: 'Battery Unit - '
            newValue: BatteryUnit-
            # Duplicate the DeviceID to make DeviceID and DisplayID
            # FUJITSU_BTU,DeviceID,DisplayID
          - type: duplicateColumn
            column: 2
        source(2):
          # Let's associate the FUJITSU_BTU with the enclosure using the SubComponent to System table
          # FUJITSU_BTU,DeviceID,DisplayID,SUBCOMPONENT;SystemName;
          type: tableJoin
          leftTable: "${source::monitors.battery.discovery.sources.source(1)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(13)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          keyType: Wbem
          computes:
            # Get rid of the Paths
            # DeviceID,DisplayID,SystemName
          - type: keepColumns
            columnNumbers: "2,3,5"
            # Add ":" And SystemaName to DeviceID to make ID unique
            # DeviceID,DisplayID,SystemName
          - type: leftConcat
            column: 1
            value: ':'
          - type: leftConcat
            column: 1
            value: $3
        source(3):
          # Source(3) = FUJITSU_BCU (Battery Control Units)
          # FUJITSU_BCU,DeviceID
          type: wbem
          query: "SELECT __PATH,ElementName FROM FUJITSU_BCU"
          namespace: root/eternus
          computes:
            # Remove Fan - from the DeviceID
            # FUJITSU_BCU,DeviceID
          - type: replace
            column: 2
            existingValue: 'Battery Control Unit - '
            newValue: BatteryControlUnit-
            # Duplicate the DeviceID to make DeviceID and DisplayID
            # FUJITSU_BCU,DeviceID,DisplayID
          - type: duplicateColumn
            column: 2
        source(4):
          # Let's associate the FUJITSU_BCU with the enclosure using the Component to System table
          # FUJITSU_BCU,DeviceID,DisplayID,COMPONENT;SystemName;
          type: tableJoin
          leftTable: "${source::monitors.battery.discovery.sources.source(3)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(11)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          keyType: Wbem
          computes:
            # Get rid of the Paths
            # DeviceID,DisplayID,SystemName
          - type: keepColumns
            columnNumbers: "2,3,5"
            # Add ":" And SystemaName to DeviceID to make ID unique
            # DeviceID,DisplayID,SystemName
          - type: leftConcat
            column: 1
            value: ':'
          - type: leftConcat
            column: 1
            value: $3
        source(5):
          # Union BTU and BCU
          # DeviceID,DisplayID,SystemName
          type: tableUnion
          tables:
          - "${source::monitors.battery.discovery.sources.source(2)}"
          - "${source::monitors.battery.discovery.sources.source(4)}"
      mapping:
        # Instance Table
        # DeviceID,DisplayID,SystemName
        source: "${source::monitors.battery.discovery.sources.source(5)}"
        attributes:
          id: $1
          __display_id: $2
          hw.parent.type: enclosure
          hw.parent.id: $3
          name: $2
    collect:
      # Collect type is multiinstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = FUJITSU_BTU
          # FUJITSU_BTU;DeviceID;OperationalStatus;
          type: wbem
          query: "SELECT __PATH,ElementName,OperationalStatus FROM FUJITSU_BTU"
          namespace: root/eternus
          computes:
            # Remove Fan - from the DeviceID
            # FUJITSU_BTU,DeviceID,OperationalStatus;
          - type: replace
            column: 2
            existingValue: 'Battery Unit - '
            newValue: BatteryUnit-
            # Duplicate the "OperationalStatus" column
            # FUJITSU_BTU,DeviceID,OperationalStatus
          - type: duplicateColumn
            column: 3
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # FUJITSU_BTU,DeviceID,PATROLStatusArray,OperationalStatus
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # FUJITSU_BTU,DeviceID,PATROLStatusArray,StatusInformation
          - type: arrayTranslate
            column: 4
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # FUJITSU_BTU,DeviceID,PATROLStatus,StatusInformation
          - type: convert
            column: 3
            conversion: array2SimpleStatus
        source(2):
          # Let's associate the FUJITSU_BTU with the enclosure using the SubComponent to System table
          # FUJITSU_BTU,DeviceID,PATROLStatus,StatusInformation,SUBCOMPONENT;SystemName;
          type: tableJoin
          leftTable: "${source::monitors.battery.collect.sources.source(1)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(13)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          keyType: Wbem
          computes:
            # Get rid of the Paths
            # DeviceID,PATROLStatus,StatusInformation,SystemName;
          - type: keepColumns
            columnNumbers: "2,3,4,6"
            # Add ":" And SystemaName to DeviceID to make ID unique
            # DeviceID,PATROLStatus,StatusInformation,SystemName;
          - type: leftConcat
            column: 1
            value: ':'
          - type: leftConcat
            column: 1
            value: $4
        source(3):
          # Source(3) = FUJITSU_BCU
          # FUJITSU_BCU;DeviceID;OperationalStatus;
          type: wbem
          query: "SELECT __PATH,ElementName,OperationalStatus FROM FUJITSU_BCU"
          namespace: root/eternus
          computes:
            # Remove Fan - from the DeviceID
            # FUJITSU_BCU,DeviceID,OperationalStatus;
          - type: replace
            column: 2
            existingValue: 'Battery Control Unit - '
            newValue: BatteryControlUnit-
            # Duplicate the "OperationalStatus" column
            # FUJITSU_BCU,DeviceID,OperationalStatus
          - type: duplicateColumn
            column: 3
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # FUJITSU_BCU,DeviceID,PATROLStatusArray,OperationalStatus
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # FUJITSU_BCU,DeviceID,PATROLStatusArray,StatusInformation
          - type: arrayTranslate
            column: 4
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # FUJITSU_BCU,DeviceID,PATROLStatus,StatusInformation
          - type: convert
            column: 3
            conversion: array2SimpleStatus
        source(4):
          # Let's associate the FUJITSU_BCU with the enclosure using the Component to System table
          # FUJITSU_BCU,DeviceID,PATROLStatus,StatusInformation,COMPONENT;SystemName;
          type: tableJoin
          leftTable: "${source::monitors.battery.collect.sources.source(3)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(11)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          keyType: Wbem
          computes:
            # Get rid of the Paths
            # DeviceID,PATROLStatus,StatusInformation,SystemName;
          - type: keepColumns
            columnNumbers: "2,3,4,6"
            # Add ":" And SystemaName to DeviceID to make ID unique
            # DeviceID,PATROLStatus,StatusInformation,SystemName;
          - type: leftConcat
            column: 1
            value: ':'
          - type: leftConcat
            column: 1
            value: $4
        source(5):
          # Union BTU and BCU
          # DeviceID,PATROLStatus,StatusInformation,SystemName;
          type: tableUnion
          tables:
          - "${source::monitors.battery.collect.sources.source(2)}"
          - "${source::monitors.battery.collect.sources.source(4)}"
      mapping:
        # ValueTable = Source(1)
        # DeviceID,PATROLStatus,StatusInformation,SystemName;
        source: "${source::monitors.battery.collect.sources.source(5)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="battery"}: $2
        legacyTextParameters:
          StatusInformation: $3
  memory:
    discovery:
      sources:
        source(1):
          # Source(1) = FUJITSU_PhysicalMemory
          # FUJITSU_PhysicalMemory,DeviceID,Capacity,PartNumber
          type: wbem
          query: "SELECT __PATH,ElementName,Capacity,PartNumber FROM FUJITSU_PhysicalMemory"
          namespace: root/eternus
          computes:
            # Remove Controller Memory  - from the DeviceID
            # FUJITSU_PhysicalMemory,DeviceID,Capacity,PartNumber
          - type: replace
            column: 2
            existingValue: 'Controller Memory - '
            newValue: ""
            # Duplicate the DeviceID to make DeviceID and DisplayID
            # FUJITSU_PhysicalMemory,DeviceID,DisplayID,Capacity,PartNumber
          - type: duplicateColumn
            column: 2
            # Convert size to MB
            # FUJITSU_PhysicalMemory,DeviceID,DisplayID,Capacity,PartNumber
          - type: divide
            column: 4
            value: 1048576
        source(2):
          # Let's associate the FUJITSU_PhysicalMemory with the Contoller using the Component to SubComponent table
          # FUJITSU_PhysicalMemory,DeviceID,DisplayID,Capacity,PartNumber;CONTROLLER;FUJITSU_PhysicalMemory;
          type: tableJoin
          leftTable: "${source::monitors.memory.discovery.sources.source(1)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(12)}"
          leftKeyColumn: 1
          rightKeyColumn: 2
          keyType: Wbem
        source(3):
          # Let's associate the Contoller with the SYSTEM using the Component to SubComponent table
          # FUJITSU_PhysicalMemory,DeviceID,DisplayID,Capacity,PartNumber;CONTROLLER;FUJITSU_PhysicalMemory;SYSTEM;CONTROLLER;
          type: tableJoin
          leftTable: "${source::monitors.memory.discovery.sources.source(2)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(12)}"
          leftKeyColumn: 6
          rightKeyColumn: 2
          keyType: Wbem
        source(4):
          # Let's associate the FUJITSU_PhysicalMemory with the enclosure using the SYSTEM to System table
          # FUJITSU_PhysicalMemory,DeviceID,DisplayID,Capacity,PartNumber;CONTROLLER;FUJITSU_PhysicalMemory;SYSTEM;CONTROLLER;SYSTEM;SystemName;
          type: tableJoin
          leftTable: "${source::monitors.memory.discovery.sources.source(3)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(13)}"
          leftKeyColumn: 8
          rightKeyColumn: 1
          keyType: Wbem
          computes:
            # Get rid of the Paths
            # DeviceID,DisplayID,Capacity,PartNumber,SystemName
          - type: keepColumns
            columnNumbers: "2,3,4,5,11"
            # Add ":" And SystemaName to DeviceID to make ID unique
            # DeviceID,DisplayID,Capacity,PartNumber,SystemName
          - type: leftConcat
            column: 1
            value: ':'
          - type: leftConcat
            column: 1
            value: $5
      mapping:
        # Instance Table
        # DeviceID,DisplayID,Capacity,PartNumber,SystemName
        source: "${source::monitors.memory.discovery.sources.source(4)}"
        attributes:
          id: $1
          model: $4
          __display_id: $2
          hw.parent.type: enclosure
          hw.parent.id: $5
          name: "${awk::sprintf(\"%s (%s MB)\", $2, $3)}"
        metrics:
          hw.memory.limit: mebiByte2Byte($3)
    collect:
      # Collect type is multiinstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = FUJITSU_PhysicalMemory
          # FUJITSU_PhysicalMemory;DeviceID;OperationalStatus;
          type: wbem
          query: "SELECT __PATH,ElementName,OperationalStatus FROM FUJITSU_PhysicalMemory"
          namespace: root/eternus
          computes:
            # Remove Controller Memory  - from the DeviceID
            # FUJITSU_PhysicalMemory,DeviceID,OperationalStatus;
          - type: replace
            column: 2
            existingValue: 'Controller Memory - '
            newValue: ""
            # Duplicate the "OperationalStatus" column
            # FUJITSU_PhysicalMemory,DeviceID,OperationalStatus
          - type: duplicateColumn
            column: 3
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # FUJITSU_PhysicalMemory,DeviceID,PATROLStatusArray,OperationalStatus
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # FUJITSU_PhysicalMemory,DeviceID,PATROLStatusArray,StatusInformation
          - type: arrayTranslate
            column: 4
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # FUJITSU_PhysicalMemory,DeviceID,PATROLStatus,StatusInformation
          - type: convert
            column: 3
            conversion: array2SimpleStatus
        source(2):
          # Let's associate the FUJITSU_PhysicalMemory with the Contoller using the Component to SubComponent table
          # FUJITSU_PhysicalMemory,DeviceID,PATROLStatus,StatusInformation;CONTROLLER;FUJITSU_PhysicalMemory;
          type: tableJoin
          leftTable: "${source::monitors.memory.collect.sources.source(1)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(12)}"
          leftKeyColumn: 1
          rightKeyColumn: 2
          keyType: Wbem
        source(3):
          # Let's associate the Contoller with the SYSTEM using the Component to SubComponent table
          # FUJITSU_PhysicalMemory,DeviceID,PATROLStatus,StatusInformation;CONTROLLER;FUJITSU_PhysicalMemory;SYSTEM;CONTROLLER;
          type: tableJoin
          leftTable: "${source::monitors.memory.collect.sources.source(2)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(12)}"
          leftKeyColumn: 5
          rightKeyColumn: 2
          keyType: Wbem
        source(4):
          # Let's associate the FUJITSU_PhysicalMemory with the enclosure using the SYSTEM to System table
          # FUJITSU_PhysicalMemory,DeviceID,PATROLStatus,StatusInformation;CONTROLLER;FUJITSU_PhysicalMemory;SYSTEM;CONTROLLER;SYSTEM;SystemName;
          type: tableJoin
          leftTable: "${source::monitors.memory.collect.sources.source(3)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(13)}"
          leftKeyColumn: 7
          rightKeyColumn: 1
          keyType: Wbem
          computes:
            # Get rid of the Paths
            # DeviceID,PATROLStatus,StatusInformation;SystemName;
          - type: keepColumns
            columnNumbers: "2,3,4,10"
            # Add ":" And SystemaName to DeviceID to make ID unique
            # DeviceID,PATROLStatus,StatusInformation,SystemName;
          - type: leftConcat
            column: 1
            value: ':'
          - type: leftConcat
            column: 1
            value: $4
      mapping:
        # ValueTable = Source(1)
        # DeviceID,PATROLStatus,StatusInformation,SystemName;
        source: "${source::monitors.memory.collect.sources.source(4)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="memory"}: $2
        legacyTextParameters:
          StatusInformation: $3
  other_device:
    discovery:
      sources:
        source(1):
          # Source(1) = FUJITSU_IOM
          # FUJITSU_IOM,DeviceID
          type: wbem
          query: "SELECT __PATH,ElementName FROM FUJITSU_IOM"
          namespace: root/eternus
          computes:
            # Remove Fan - from the DeviceID
            # FUJITSU_IOM,DeviceID
          - type: replace
            column: 2
            existingValue: 'I/O Module - '
            newValue: ""
            # Add device Type
            # Type;FUJITSU_IOM,DeviceID
          - type: leftConcat
            column: 1
            value: IO Module;
        source(2):
          # Source(2) = FUJITSU_ChannelAdapterCard
          # FUJITSU_ChannelAdapterCard,DeviceID
          type: wbem
          query: "SELECT __PATH,ElementName FROM FUJITSU_ChannelAdapterCard"
          namespace: root/eternus
          computes:
            # Remove Fan - from the DeviceID
            # FUJITSU_ChannelAdapterCard,DeviceID
          - type: replace
            column: 2
            existingValue: 'Channel Adapter Card - '
            newValue: ""
            # Add device Type
            # Type;FUJITSU_ChannelAdapterCard,DeviceID
          - type: leftConcat
            column: 1
            value: ChannelAdapterCard;
        source(3):
          # Source(3) = FUJITSU_ControllerCard
          # FUJITSU_ControllerCard,DeviceID
          type: wbem
          query: "SELECT __PATH,ElementName FROM FUJITSU_ControllerCard"
          namespace: root/eternus
          computes:
            # Remove Fan - from the DeviceID
            # FUJITSU_ControllerCard,DeviceID
          - type: replace
            column: 2
            existingValue: 'Controller Card - '
            newValue: ""
            # Add device Type
            # Type;FUJITSU_ControllerCard,DeviceID
          - type: leftConcat
            column: 1
            value: ControllerCard;
        source(4):
          # Union all the components together
          # Type;COMPONENT,DeviceID
          type: tableUnion
          tables:
          - "${source::monitors.other_device.discovery.sources.source(1)}"
          - "${source::monitors.other_device.discovery.sources.source(2)}"
          - "${source::monitors.other_device.discovery.sources.source(3)}"
          computes:
            # Duplicate the DeviceID to get DisplayID
            # Type;COMPONENT;DeviceID;DisplayID;
          - type: duplicateColumn
            column: 3
        source(5):
          # Let's associate the FUJITSU_FAN with the enclosure using the SubComponent to System table
          # Type;COMPONENT,DeviceID,DisplayID,COMPONENT;SystemName;
          type: tableJoin
          leftTable: "${source::monitors.other_device.discovery.sources.source(4)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(11)}"
          leftKeyColumn: 2
          rightKeyColumn: 1
          keyType: Wbem
          computes:
            # Get rid of the Paths
            # Type,DeviceID,DisplayID,SystemName
          - type: keepColumns
            columnNumbers: "1,3,4,6"
            # Add ":" And SystemName to DeviceID to make ID unique
            # Type,DeviceID,DisplayID,SystemName
          - type: leftConcat
            column: 2
            value: ':'
          - type: leftConcat
            column: 2
            value: $4
        source(6):
          # Source(1) = FUJITSU_ChannelAdapterCard
          # FUJITSU_ChannelAdapterCard,DeviceID
          type: wbem
          query: "SELECT __PATH,ElementName FROM FUJITSU_ChannelAdapterCard"
          namespace: root/eternus
          computes:
            # Remove Fan - from the DeviceID
            # FUJITSU_ChannelAdapterCard,DeviceID
          - type: replace
            column: 2
            existingValue: 'Channel Adapter Card - '
            newValue: ""
            # Add device Type
            # Type;FUJITSU_ChannelAdapterCard,DeviceID
          - type: leftConcat
            column: 1
            value: ChannelAdapterCard;
            # Duplicate the DeviceID to make DeviceID and DisplayID
            # Type;FUJITSU_ChannelAdapterCard,DeviceID,DisplayID
          - type: duplicateColumn
            column: 3
        source(7):
          # Let's associate the FUJITSU_ChannelAdapterCard with the enclosure using the SubComponent to System table
          # Type;FUJITSU_ChannelAdapterCard,DeviceID,DisplayID,SUBCOMPONENT;SystemName;
          type: tableJoin
          leftTable: "${source::monitors.other_device.discovery.sources.source(6)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(13)}"
          leftKeyColumn: 2
          rightKeyColumn: 1
          keyType: Wbem
          computes:
            # Get rid of the Paths
            # Type;DeviceID,DisplayID,SystemName
          - type: keepColumns
            columnNumbers: "1,3,4,6"
            # Add ":" And SystemaName to DeviceID to make ID unique
            # Type;DeviceID,DisplayID,SystemName
          - type: leftConcat
            column: 2
            value: ':'
          - type: leftConcat
            column: 2
            value: $4
        source(8):
          # Join the Components and SubComponents together
          type: tableUnion
          tables:
          - "${source::monitors.other_device.discovery.sources.source(5)}"
          - "${source::monitors.other_device.discovery.sources.source(7)}"
      mapping:
        # Instance Table
        # Type;DeviceID,DisplayID,SystemName
        source: "${source::monitors.other_device.discovery.sources.source(8)}"
        attributes:
          id: $2
          __display_id: $3
          device_type: $1
          hw.parent.type: enclosure
          hw.parent.id: $4
          name: "${awk::sprintf(\"%s: %s\", $1, $3)}"
    collect:
      # Collect type is multiinstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = FUJITSU_IOM
          # FUJITSU_IOM,DeviceID
          type: wbem
          query: "SELECT __PATH,ElementName,OperationalStatus FROM FUJITSU_IOM"
          namespace: root/eternus
          computes:
            # Remove Fan - from the DeviceID
            # FUJITSU_IOM,DeviceID,OperationalStatus
          - type: replace
            column: 2
            existingValue: 'I/O Module - '
            newValue: ""
            # Add device Type
            # Type;FUJITSU_IOM,DeviceID,OperationalStatus
          - type: leftConcat
            column: 1
            value: IO Module;
        source(2):
          # Source(2) = FUJITSU_ChannelAdapterCard
          # FUJITSU_ChannelAdapterCard,DeviceID,OperationalStatus
          type: wbem
          query: "SELECT __PATH,ElementName,OperationalStatus FROM FUJITSU_ChannelAdapterCard"
          namespace: root/eternus
          computes:
            # Remove Fan - from the DeviceID
            # FUJITSU_ChannelAdapterCard,DeviceID,OperationalStatus
          - type: replace
            column: 2
            existingValue: 'Channel Adapter Card - '
            newValue: ""
            # Add device Type
            # Type;FUJITSU_ChannelAdapterCard,DeviceID,OperationalStatus
          - type: leftConcat
            column: 1
            value: ChannelAdapterCard;
        source(3):
          # Source(3) = FUJITSU_ControllerCard
          # FUJITSU_ControllerCard,DeviceID,OperationalStatus
          type: wbem
          query: "SELECT __PATH,ElementName,OperationalStatus FROM FUJITSU_ControllerCard"
          namespace: root/eternus
          computes:
            # Remove Fan - from the DeviceID
            # FUJITSU_ControllerCard,DeviceID,OperationalStatus
          - type: replace
            column: 2
            existingValue: 'Controller Card - '
            newValue: ""
            # Add device Type
            # Type;FUJITSU_ControllerCard,DeviceID,OperationalStatus
          - type: leftConcat
            column: 1
            value: ControllerCard;
        source(4):
          # Union all the components together
          # Type;COMPONENT,DeviceID,OperationalStatus
          type: tableUnion
          tables:
          - "${source::monitors.other_device.collect.sources.source(1)}"
          - "${source::monitors.other_device.collect.sources.source(2)}"
          - "${source::monitors.other_device.collect.sources.source(3)}"
          computes:
            # Duplicate the DeviceID to get DisplayID
            # Type;COMPONENT;DeviceID;DisplayID;OperationalStatus
          - type: duplicateColumn
            column: 3
        source(5):
          # Let's associate the FUJITSU_FAN with the enclosure using the SubComponent to System table
          # Type;COMPONENT,DeviceID,DisplayID,OperationalStatus,COMPONENT;SystemName;
          type: tableJoin
          leftTable: "${source::monitors.other_device.collect.sources.source(4)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(11)}"
          leftKeyColumn: 2
          rightKeyColumn: 1
          keyType: Wbem
          computes:
            # Get rid of the Paths
            # Type,DeviceID,DisplayID,OperationalStatus,SystemName
          - type: keepColumns
            columnNumbers: "1,3,4,5,7"
            # Add ":" And SystemName to DeviceID to make ID unique
            # Type,DeviceID,DisplayID,OperationalStatus,SystemName
          - type: leftConcat
            column: 2
            value: ':'
          - type: leftConcat
            column: 2
            value: $5
        source(6):
          # Source(1) = FUJITSU_ChannelAdapterCard
          # FUJITSU_ChannelAdapterCard,DeviceID,OperationalStatus
          type: wbem
          query: "SELECT __PATH,ElementName,OperationalStatus FROM FUJITSU_ChannelAdapterCard"
          namespace: root/eternus
          computes:
            # Remove Channel Adapter Card - from the DeviceID
            # FUJITSU_ChannelAdapterCard,DeviceID,OperationalStatus
          - type: replace
            column: 2
            existingValue: 'Channel Adapter Card - '
            newValue: ""
            # Add device Type
            # Type;FUJITSU_ChannelAdapterCard,DeviceID,OperationalStatus
          - type: leftConcat
            column: 1
            value: ChannelAdapterCard;
            # Duplicate the DeviceID to make DeviceID and DisplayID
            # Type;FUJITSU_ChannelAdapterCard,DeviceID,DisplayID,OperationalStatus
          - type: duplicateColumn
            column: 3
        source(7):
          # Let's associate the FUJITSU_FAN with the enclosure using the SubComponent to System table
          # Type;FUJITSU_ChannelAdapterCard,DeviceID,DisplayID,OperationalStatus,SUBCOMPONENT;SystemName;
          type: tableJoin
          leftTable: "${source::monitors.other_device.collect.sources.source(6)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(13)}"
          leftKeyColumn: 2
          rightKeyColumn: 1
          keyType: Wbem
          computes:
            # Get rid of the Paths
            # Type;DeviceID,DisplayID,OperationalStatus,SystemName
          - type: keepColumns
            columnNumbers: "1,3,4,5,7"
            # Add ":" And SystemaName to DeviceID to make ID unique
            # Type;DeviceID,DisplayID,OperationalStatus,SystemName
          - type: leftConcat
            column: 2
            value: ':'
          - type: leftConcat
            column: 2
            value: $4
        source(8):
          # Join the Components and SubComponents together
          # Type;DeviceID,DisplayID,OperationalStatus,SystemName
          type: tableUnion
          tables:
          - "${source::monitors.other_device.collect.sources.source(5)}"
          - "${source::monitors.other_device.collect.sources.source(7)}"
          computes:
            # Duplicate the "OperationalStatus" column
            # Type;DeviceID,DisplayID,OperationalStatus,OperationalStatus,SystemName
          - type: duplicateColumn
            column: 4
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # Type;DeviceID,DisplayID,PATROLStatusArray,OperationalStatus,SystemName
          - type: arrayTranslate
            column: 4
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # Type;DeviceID,DisplayID,PATROLStatusArray,StatusInformation,SystemName
          - type: arrayTranslate
            column: 5
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # Type;DeviceID,DisplayID,PATROLStatus,StatusInformation,SystemName
          - type: convert
            column: 4
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # Type;DeviceID,DisplayID,PATROLStatus,StatusInformation,SystemName
        source: "${source::monitors.other_device.collect.sources.source(8)}"
        attributes:
          id: $2
        metrics:
          hw.status{hw.type="other_device"}: $4
        legacyTextParameters:
          StatusInformation: $5
  power_supply:
    discovery:
      sources:
        source(1):
          # Source(1) = FUJITSU_PSU
          # FUJITSU_PSU,DeviceID
          type: wbem
          query: "SELECT __PATH,ElementName FROM FUJITSU_PSU"
          namespace: root/eternus
          computes:
            # Remove Fan - from the DeviceID
            # FUJITSU_PSU,DeviceID
          - type: replace
            column: 2
            existingValue: 'Power Supply Unit - '
            newValue: ""
            # Duplicate the DeviceID to make DeviceID and DisplayID
            # FUJITSU_PSU,DeviceID,DisplayID
          - type: duplicateColumn
            column: 2
        source(2):
          # Let's associate the FUJITSU_PSU with the enclosure using the Component to System table
          # FUJITSU_PSU,DeviceID,DisplayID,COMPONENT;SystemName;
          type: tableJoin
          leftTable: "${source::monitors.power_supply.discovery.sources.source(1)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(11)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          keyType: Wbem
          computes:
            # Get rid of the Paths
            # DeviceID,DisplayID,SystemName
          - type: keepColumns
            columnNumbers: "2,3,5"
            # Add ":" And SystemaName to DeviceID to make ID unique
            # DeviceID,DisplayID,SystemName
          - type: leftConcat
            column: 1
            value: ':'
          - type: leftConcat
            column: 1
            value: $3
      mapping:
        # Instance Table
        # DeviceID,DisplayID,SystemName
        source: "${source::monitors.power_supply.discovery.sources.source(2)}"
        attributes:
          id: $1
          __display_id: $2
          hw.parent.type: enclosure
          hw.parent.id: $3
          name: $2
    collect:
      # Collect type is multiinstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = FUJITSU_PSU
          # FUJITSU_PSU;DeviceID;OperationalStatus;
          type: wbem
          query: "SELECT __PATH,ElementName,OperationalStatus FROM FUJITSU_PSU"
          namespace: root/eternus
          computes:
            # Remove Fan - from the DeviceID
            # FUJITSU_PSU,DeviceID,OperationalStatus;
          - type: replace
            column: 2
            existingValue: 'Power Supply Unit - '
            newValue: ""
            # Duplicate the "OperationalStatus" column
            # FUJITSU_PSU,DeviceID,OperationalStatus
          - type: duplicateColumn
            column: 3
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # FUJITSU_PSU,DeviceID,PATROLStatusArray,OperationalStatus
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # FUJITSU_PSU,DeviceID,PATROLStatusArray,StatusInformation
          - type: arrayTranslate
            column: 4
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # FUJITSU_PSU,DeviceID,PATROLStatus,StatusInformation
          - type: convert
            column: 3
            conversion: array2SimpleStatus
        source(2):
          # Let's associate the FUJITSU_FAN with the enclosure using the Component to System table
          # FUJITSU_PSU,DeviceID,PATROLStatus,StatusInformation,COMPONENT;SystemName;
          type: tableJoin
          leftTable: "${source::monitors.power_supply.collect.sources.source(1)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(11)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          keyType: Wbem
          computes:
            # Get rid of the Paths
            # DeviceID,PATROLStatus,StatusInformation,SystemName;
          - type: keepColumns
            columnNumbers: "2,3,4,6"
            # Add ":" And SystemaName to DeviceID to make ID unique
            # DeviceID,PATROLStatus,StatusInformation,SystemName;
          - type: leftConcat
            column: 1
            value: ':'
          - type: leftConcat
            column: 1
            value: $4
      mapping:
        # ValueTable = Source(1)
        # DeviceID,PATROLStatus,StatusInformation,SystemName;
        source: "${source::monitors.power_supply.collect.sources.source(2)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="power_supply"}: $2
        legacyTextParameters:
          StatusInformation: $3
  logical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = FUJITSU_StorageVolume
          # ElementName,NumberOfBlocks,BlockSize,SystemID,RaidLevel
          type: wbem
          query: "SELECT ElementName,NumberOfBlocks,BlockSize,SystemName,RaidLevel FROM FUJITSU_StorageVolume"
          namespace: root/eternus
          computes:
            # Compute the real size of the volumes (SizeInBlocks * BlockSize)
            # ElementName,SizeBytes,BlockSize,SystemID,RaidLevel
          - type: multiply
            column: 2
            value: $3
            # Get rid of BlockSize
            # ElementName,SizeBytes,SystemID,RaidLevel
          - type: keepColumns
            columnNumbers: "1,2,4,5"
            # Add RemainingManagedSpace,IncludeInCapacityReport,Type
            # ElementName,SizeBytes,RemainingManagedSpace,IncludeInCapacityReport,Type,SystemID,RaidLevel
          - type: rightConcat
            column: 2
            value: ;;1;Volume
        source(2):
          # Source(2) = CIM_StoragePool
          # CIM_StoragePool,ElementName,SizeBytes,RemainingManagedSpace,__PATH
          type: wbem
          query: "SELECT __PATH,ElementName,TotalManagedSpace,RemainingManagedSpace,__PATH FROM CIM_StoragePool"
          namespace: root/eternus
          computes:
            # Extract the Creation Class from the PATH
            # CIM_StoragePool,ElementName,SizeBytes,RemainingManagedSpace,CreationClassName
          - type: extract
            column: 5
            subColumn: 1
            subSeparators: .
            # Do not take into account the storage pools when counting the total logical disk size
            # CIM_StoragePool,ElementName,SizeBytes,RemainingManagedSpace,IncludeInCapacityReport,Type
          - type: translate
            column: 5
            translationTable: "${translation::CreationClassNameStoragePoolTranslationTable}"
        source(3):
          # Association Pool to Storage System
          # CIM_StoragePool,FUJITSU_StorageComputerSystem
          type: wbem
          query: "SELECT PartComponent,GroupComponent FROM cim_hostedstoragepool"
          namespace: root/eternus
        source(4):
          # Attach the Pool to the Association Table
          # CIM_StoragePool,ElementName,SizeBytes,RemainingManagedSpace,IncludeInCapacityReport,Type,CIM_StoragePool,FUJITSU_StorageComputerSystem
          type: tableJoin
          leftTable: "${source::monitors.logical_disk.discovery.sources.source(2)}"
          rightTable: "${source::monitors.logical_disk.discovery.sources.source(3)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          keyType: Wbem
        source(5):
          # Attach the above table to the enclosure discovery
          #         1           2           3          #  4          #      5          #         6           7           8          #           #        9          #           #  10       11
          # CIM_StoragePool,ElementName,SizeBytes,RemainingManagedSpace,IncludeInCapacityReport,Type,CIM_StoragePool,FUJITSU_StorageComputerSystem;FUJITSU_StorageComputerSystem;SystemID;SystemName;
          type: tableJoin
          leftTable: "${source::monitors.logical_disk.discovery.sources.source(4)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(1)}"
          leftKeyColumn: 8
          rightKeyColumn: 1
          keyType: Wbem
        source(6):
          # Make a copy of Discovery Source  for use in Collect
          # CIM_StoragePool,ElementName,SizeBytes,RemainingManagedSpace,IncludeInCapacityReport,Type,CIM_StoragePool,FUJITSU_StorageComputerSystem;FUJITSU_StorageComputerSystem;SystemID;SystemName;
          type: copy
          from: "${source::monitors.logical_disk.discovery.sources.source(5)}"
          computes:
            # Get CIM_Storagepool to System ID for use in Collect
            # CIM_StoragePool,SystemID
          - type: keepColumns
            columnNumbers: "1,10"
        source(7):
          # Now Another Copy for use by Discovery
          # CIM_StoragePool,ElementName,SizeBytes,RemainingManagedSpace,IncludeInCapacityReport,Type,CIM_StoragePool,FUJITSU_StorageComputerSystem;FUJITSU_StorageComputerSystem;SystemID;SystemName;
          type: copy
          from: "${source::monitors.logical_disk.discovery.sources.source(5)}"
          computes:
            # Get rid of the Paths
            # ElementName,SizeBytes,RemainingManagedSpace,IncludeInCapacityReport,Type,SystemID
          - type: keepColumns
            columnNumbers: "2,3,4,5,6,10"
            # Add a blank RaidLevel Column
            # ElementName,SizeBytes,RemainingManagedSpace,IncludeInCapacityReport,Type,SystemID,RaidLevel
          - type: rightConcat
            column: 6
            value: ;
        source(8):
          # Union of Volumes and Pools
          # ElementName,SizeBytes,RemainingManagedSpace,IncludeInCapacityReport,Type,SystemID,RaidLevel
          type: tableUnion
          tables:
          - "${source::monitors.logical_disk.discovery.sources.source(1)}"
          - "${source::monitors.logical_disk.discovery.sources.source(7)}"
          computes:
            # Duplicate the DeviceID to allow a DisplayID
            # DeviceID,DisplayID,SizeBytes,RemainingManagedSpace,IncludeInCapacityReport,Type,SystemID,RaidLevel
          - type: duplicateColumn
            column: 1
            # Add ":" And SystemaName to Caption to make DeviceID unique
            # DeviceID,DisplayID,SizeBytes,RemainingManagedSpace,IncludeInCapacityReport,Type,SystemID,RaidLevel
          - type: leftConcat
            column: 1
            value: ':'
          - type: leftConcat
            column: 1
            value: $7
      mapping:
        # Instance Table
        # DeviceID,DisplayID,SizeBytes,RemainingManagedSpace,IncludeInCapacityReport,Type,SystemID,RaidLevel
        source: "${source::monitors.logical_disk.discovery.sources.source(8)}"
        attributes:
          id: $1
          __display_id: $2
          raid_level: $8
          __use_for_capacity_report: $5
          type: $6
          hw.parent.type: enclosure
          hw.parent.id: $7
          name: "${awk::sprintf(\"%s (%s - %s)\", $2, $8, bytes2HumanFormatBase2($3))}"
        metrics:
          hw.logical_disk.limit: $3
        conditionalCollection:
          hw.logical_disk.usage{state="free"}: $4
    collect:
      # Collect type is multiinstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = FUJITSU_StorageVolume
          # ElementName,OperationalStatus,SystemID
          type: wbem
          query: "SELECT ElementName,OperationalStatus,SystemName FROM FUJITSU_StorageVolume"
          namespace: root/eternus
          computes:
            # Add a blank RemainingManagedSpace
            # ElementName,OperationalStatus,RemainingManagedSpace,SystemID
          - type: leftConcat
            column: 3
            value: ;
        source(2):
          # Source(2) = FUJITSU_RAIDStoragePool
          # ElementName,OperationalStatus,RemainingManagedSpace,CIM_StoragePool
          type: wbem
          query: "SELECT ElementName,OperationalStatus,RemainingManagedSpace,__PATH FROM CIM_StoragePool"
          namespace: root/eternus
        source(3):
          # Attach the Pool to the Association Table
          # ElementName,OperationalStatus,RemainingManagedSpace,CIM_StoragePool,CIM_StoragePool,SystemID
          type: tableJoin
          leftTable: "${source::monitors.logical_disk.collect.sources.source(2)}"
          rightTable: "${source::monitors.logical_disk.discovery.sources.source(6)}"
          leftKeyColumn: 4
          rightKeyColumn: 1
          keyType: Wbem
          computes:
            # Trim Columns
            # ElementName,OperationalStatus,RemainingManagedSpace,SystemID
          - type: keepColumns
            columnNumbers: "1,2,3,6"
        source(4):
          # Union of Volumes and Pools
          # ElementName,OperationalStatus,RemainingManagedSpace,SystemID
          type: tableUnion
          tables:
          - "${source::monitors.logical_disk.collect.sources.source(1)}"
          - "${source::monitors.logical_disk.collect.sources.source(3)}"
          computes:
            # Add ":" And SystemaName to Caption to make DeviceID unique
            # ElementName,OperationalStatus,RemainingManagedSpace,SystemID
          - type: leftConcat
            column: 1
            value: ':'
          - type: leftConcat
            column: 1
            value: $4
            # Duplicate the "OperationalStatusArray" column
            # ElementName,OperationalStatus,OperationalStatus,RemainingManagedSpace,SystemID
          - type: duplicateColumn
            column: 2
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # ElementName,PATROLStatusArray,OperationalStatus,RemainingManagedSpace,SystemID
          - type: arrayTranslate
            column: 2
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # ElementName,PATROLStatusArray,StatusInformation,RemainingManagedSpace,SystemID
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # ElementName,PATROLStatusArray,StatusInformation,RemainingManagedSpace,SystemID
          - type: convert
            column: 2
            conversion: array2SimpleStatus
      mapping:
        # Value Table
        # ElementName,PATROLStatusArray,StatusInformation,RemainingManagedSpace,SystemID
        source: "${source::monitors.logical_disk.collect.sources.source(4)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="logical_disk"}: $2
          hw.logical_disk.usage{state="free"}: $4
          hw.logical_disk.usage{state="used"}: collectAllocatedSpace()
        legacyTextParameters:
          StatusInformation: $3
translations:
  DMTFOperationStatusTranslationTable:
    "11": degraded
    "12": failed
    "13": failed
    "14": failed
    "15": ok
    "16": degraded
    "17": ok
    "18": ok
    Default: UNKNOWN
    "2": ok
    "3": degraded
    "4": degraded
    "5": degraded
    "6": failed
    "7": failed
    "8": degraded
    "9": degraded
    "10": failed
  PortTypeTranslationTable:
    "11": FC Port NL
    "12": FC Port F/NL
    "13": FC Port Nx
    "14": FC Port E
    "15": FC Port F
    "16": FC Port FL
    "17": FC Port B
    "18": FC Port G
    "19": FC Port GL
    Default: FC Port
    "10": FC Port N
  CreationClassNameStoragePoolTranslationTable:
    FUJITSU_SDPVPool: 0;SDPV Pool
    FUJITSU_FlexibleTierPool: 0;Flexible Tier Pool
    FUJITSU_SnapDataPool: 0;Snap Data Pool
    FUJITSU_PrimordialStoragePool: 0;Primordial Storage Pool
    FUJITSU_FlexibleTierSubPool: 0;Flexible Tier Sub Pool
    Default: 0;Storage Pool
    FUJITSU_ThinProvisioningPool: 0;Thin Provisioning Pool
    FUJITSU_RAIDStoragePool: 0;RAID Storage Pool
  UsageRestrictionTranslationTable:
    "2": Front-end Port
    "3": Back-end Port
    Default: ""
  DMTFOperationStatusInformationTranslationTable:
    "11": In Service
    "12": No Contact
    "13": Lost Communication
    "14": Aborted
    "15": Dormant
    "16": Supporting Entity in Error
    "17": Completed
    "18": Power Mode
    Default: ""
    "2": ""
    "3": Degraded
    "4": Stressed
    "5": Predicted Failure
    "6": Error
    "7": Non-Recoverable Error
    "8": Starting
    "9": Stopping
    "10": Stopped
