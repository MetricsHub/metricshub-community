---
embedded:
  EmbeddedFile(1): |
    #!/bin/sh

    # First, check that cediag is actually installed
    if /bin/test ! -f /opt/SUNWcest/bin/cediag ; then
        /bin/echo "ERROR: cediag is not installed"
        exit 1
    fi

    # Check that we got cestat command (with maybe sudo) in $1 and cediag in $2
    CESTATCOMMAND="%{SUDO:/opt/SUNWcest/bin/cediag}/opt/SUNWcest/bin/cestat"
    CEDIAGCOMMAND="%{SUDO:/opt/SUNWcest/bin/cediag}/opt/SUNWcest/bin/cediag"
    CESTATOPTION="-v"
    CEDIAGOPTION="-v"

    # Debug settings
    #CESTATCOMMAND="cat /tmp/cestatexample"
    #CEDIAGCOMMAND="cat /tmp/cediagexample"
    #CESTATOPTION=""
    #CEDIAGOPTION=""

    # Accept the cediag license
    LICENSEFILE=$HOME/.cediag.licence.accepted
    if /bin/test "$LOGNAME" = "root" ; then
        if /bin/test ! -d /var/opt/SUNWcest/conf ; then
            if /bin/test ! -d /var/opt/SUNWcest ; then
                mkdir /var/opt/SUNWcest
            fi
            /bin/mkdir /var/opt/SUNWcest/conf
        fi
        LICENSEFILE=/var/opt/SUNWcest/conf/licence.accepted.for.root
    fi

    if /bin/test ! -f $LICENSEFILE ; then
        $CEDIAGCOMMAND -V|/usr/bin/awk '{ print(substr($0, 9)); }'>$LICENSEFILE
    fi

    # Parse cestat to show the discovered DIMMs
    DIMMLIST=`$CESTATCOMMAND $CESTATOPTION|/usr/bin/awk '{
        if ($NF == "no" || $NF == "YES")
        {
            dimmID = $1;
            for (i=2 ; i<= NF-6 ; i++)
            {
                dimmID = dimmID "_" $i
            }
            print dimmID;
        }
    }'`

    # Add 'Overall' as an object to be monitored, corresponding to the whole memory system
    DIMMLIST="$DIMMLIST Overall"

    # Execute cediag and store its output in a temporary file
    CEDIAGOUTPUTFILE=/tmp/MS_HW_cediagoutput_$$

    $CEDIAGCOMMAND $CEDIAGOPTION|/usr/bin/awk 'BEGIN {
        overallPagesRetired = 0;
        overallPagesRetiredLimit = 1000000;
        overallDatapathFaults = 0;
        overallUE = 0;
        overallRule4 = 0;
        overallRule5 = 0;
        overallRule6 = 0;
        quoteChar = sprintf("%c", 39);
    }
    /^cediag: / {


        if ($2 == "Pages" && $3 == "Retired:")
        {
            overallPagesRetired = $4;
        }

        if ($0 ~ /info: MPR \(deduced\) PRL pages:/)
        {
            overallPagesRetiredLimit = $7;
        }

        if ($0 ~ /info: MPR PRL pages:/)
        {
            overallPagesRetiredLimit = $6;
        }

        if ($2 == "findings:" && $4 == "datapath" && $5 == "fault")
        {
            overallDatapathFaults = $3;
        }

        if ($2 == "findings:" && $4 == "UE(s)")
        {
            overallUE = $3;
        }

        if ($2 == "findings:" && $0 ~ /DIMMs with a failure pattern matching rule#4$/)
        {
            overallRule4 = $3;
        }

        if ($2 == "findings:" && $0 ~ /DIMMs with a failure pattern matching rule#5$/)
        {
            overallRule5 = $3;
        }

        if ($2 == "findings:" && $0 ~ /DIMMs with a failure pattern matching rule#6$/)
        {
            overallRule6 = $3;
        }

        if ($2 ~ /advice:.*:/ && $3 == "replace" && $4 == "DIMM")
        {
            dimmID = "";
            status = "OK";
            statusInformation = "";
            predictedFailure = "false";

            quotePos = index($0, quoteChar);
            if (quotePos > 0)
            {
                tempID = substr($0, quotePos + 1);
                quotePos = index(tempID, quoteChar);
                if (quotePos > 0)
                {
                    tempID = substr(tempID, 1, quotePos - 1);
                    for (i=1 ; i<=split(tempID, tempIDsplitted, " ") ; i++)
                    {
                        dimmID = dimmID "_" tempIDsplitted[i]
                    }
                    dimmID = substr(dimmID, 2, length(dimmID) - 1);
                }
            }

            if ($2 == "advice:HIGH:")
            {
                status = "ALARM";
                statusInformation = "Replacement needed";
                predictedFailure = "true";
            }
            else if ($2 == "advice:MEDIUM:")
            {
                status = "OK";
                statusInformation = "Replacement advised";
                predictedFailure = "true";
            }

            if (dimmID != "")
            {
                print "MSHW;" dimmID ";" predictedFailure ";" status ";" statusInformation
            }
        }

    }
    END {
        if (overallPagesRetired > overallPagesRetiredLimit)
        {
            print "MSHW;Overall;false;ALARM;Too many pages retired";
        }
        else if (overallDatapathFaults > 0)
        {
            print "MSHW;Overall;false;ALARM;Datapath faults detected";
        }
        else if (overallUE > 0)
        {
            print "MSHW;Overall;false;ALARM;Uncorrectable errors detected";
        }
        else if (overallRule4 > 0)
        {
            print "MSHW;Overall;false;ALARM;Module replacement needed";
        }
        else if (overallRule5 + overallRule6 > 0)
        {
            print "MSHW;Overall;true;OK;Module replacement advised";
        }

    }'>$CEDIAGOUTPUTFILE

    # For each DIMM found with cestat, show its status found in cediag, or OK if nothing in cediag
    for DIMM in $DIMMLIST
    do

    DIMMRESULT=`/usr/bin/grep "^MSHW;$DIMM;" $CEDIAGOUTPUTFILE`
    if /bin/test "$DIMMRESULT" = "" ; then
        /bin/echo "MSHW;$DIMM;false;OK;"
    else
        /bin/echo $DIMMRESULT
    fi

    done

    # Remove the temporary file
    /bin/rm -f $CEDIAGOUTPUTFILE
connector:
  displayName: Oracle/Sun Solaris - Memory Modules (cediag)
  platforms: Oracle/Sun
  reliesOn: "Sun Solaris system commands (cediag, cestat)"
  information: Provides memory modules monitoring on Sun Solaris 8 and 9 SPARC systems. Requires root privileges.
  version: 1.0
  detection:
    connectionTypes:
    - remote
    appliesTo:
    - Solaris
    criteria:
    # OS should be SunOS,SOLARIS (Solaris on SPARC)
    - type: deviceType
      keep:
      - SunOS
      - SOLARIS
    # The various following tools have to be present
    - type: osCommand
      commandLine: /bin/ls /opt/SUNWcest/bin/cestat
      expectedResult: ^/opt/SUNWcest/bin/cestat$
    - type: osCommand
      commandLine: /bin/ls /opt/SUNWcest/bin/cediag
      expectedResult: ^/opt/SUNWcest/bin/cediag$
    # Cestat should work (it won't if not as superuser)
    - type: osCommand
      commandLine: "%{SUDO:/opt/SUNWcest/bin/cediag}/opt/SUNWcest/bin/cestat -v"
      expectedResult: ^Page Retirement Statistics Tool
sudoCommands:
- /opt/SUNWcest/bin/cediag
monitors:
  memory:
    discovery:
      sources:
        source(1):
          # Source(1) = output of EmbeddedFile(1)
          # deviceID;predictedFailure;status;statusInformation
          type: osCommand
          commandLine: /bin/sh $embedded.EmbeddedFile(1)$
          keep: ^MSHW;
          separators: ;
          selectColumns: "2,3,4,5"
      mapping:
        # InstanceTable = Source(3)
        source: $monitors.memory.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          vendor: $column(1)
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s)\", $column(1), $column(1))"
    collect:
      # Collect type is "multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Memory.Discovery.Source(1)
          # Because actually, we're not going to collect every 2 minutes. Collect will rely on
          # discovery results (which got status and statusInformation) every hour.
          # So, parameters will still be refreshed every 2 minutes but will reflect values collected
          # every hour. This is sufficient because Sun recommends running cediag/cestat once a day, so...
          # deviceID;predictedFailure;status;statusInformation
          type: copy
          from: $monitors.memory.discovery.sources.source(1)$
      mapping:
        # ValueTable = Source(1)
        source: $monitors.memory.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="memory", state="predicted_failure"}: boolean($column(2))
          hw.status{hw.type="memory"}: $column(3)
        legacyTextParameters:
          StatusInformation: $column(4)
