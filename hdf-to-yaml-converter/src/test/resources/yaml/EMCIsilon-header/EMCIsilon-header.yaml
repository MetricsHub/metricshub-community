---
sudoCommands:
- /usr/bin/isi
- /usr/bin/isi_for_array
connector:
  detection:
    criteria:
    # Check that /usr/bin/isi exists
    - type: osCommand
      commandLine: "if [ -f /usr/bin/isi ] ; then echo ms_hw_isi_found ; fi"
      errorMessage: /usr/bin/isi not found
      expectedResult: ms_hw_isi_found
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Source(1) = Run isi_hw_check
          type: osCommand
          commandLine: "/bin/zsh -c \"%{SUDO:/usr/bin/isi_for_array} /usr/bin/isi_for_array /usr/bin/isi_hwtools/isi_hw_check -l /tmp/MS_HW_isi_hw_check\" "
          timeout: 1200
          computes:
            # Process the command through an AWK script
            # Sorts Parallel to Sequential
          - type: awk
            script: "${file::embeddedFile-7}"
            # Process the command through an AWK script
            # MSHW_CLASS;  ....
          - type: awk
            script: "${file::embeddedFile-1}"
            keep: ^MSHW
            separators: ;
        source(2):
          # Source(2) = Run isi status -v
          # NOTE:  _IsiStatusCommand is a constant (from individual connector)
          type: osCommand
          commandLine: "/bin/zsh -c \"%{SUDO:/usr/bin/isi} _IsiStatusCommand \" "
          timeout: 60
          computes:
            # Process the command through an AWK script
            # MSHW_ENCLOSURE;Class;nodeNumber;Status;Status;IPAddress;
          - type: awk
            script: "${file::embeddedFile-4}"
            keep: ^MSHW
            separators: ;
        source(3):
          # Source(3) = Run isi devices
          type: osCommand
          commandLine: "/bin/zsh -c \"%{SUDO:/usr/bin/isi_for_array} /usr/bin/isi_for_array _IsiDevicesCommand \" "
          timeout: 60
          computes:
            # Process the command through an AWK script
            # Sorts Parallel to Sequential
          - type: awk
            script: "${file::embeddedFile-7}"
            # Process the command through an AWK script
            # MSHW_Node;nodeName;nodeNumber;
            # MSHW_PhysicalDisk;Location;Lnum;SerialNumber;Status;Status;
          - type: awk
            script: "${file::embeddedFile-5}"
            keep: ^MSHW
            separators: ;
        source(4):
          # Join the Enclosure Instance list (source 2) with the nodename to nodeid table from isi devices
          # MSHW_ENCLOSURE;Class;nodeNumber;Status;Status;IPAddress;MSHW_Node;nodeName;nodeNumber;
          type: tableJoin
          leftTable: "${source::monitors.enclosure.discovery.sources.source(2)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(3)}"
          leftKeyColumn: 3
          rightKeyColumn: 3
          defaultRightLine: MSHW_Cluster;Cluster;Cluster;
        source(5):
          # Get FRU information
          # Source(5) = Run auparts
          type: osCommand
          commandLine: "/bin/zsh -c \"%{SUDO:/usr/bin/isi_for_array} /usr/bin/isi_for_array /usr/bin/isi_hwtools/isi_hw_status\" "
          timeout: 60
          computes:
            # Process through awk to get model, serial, etc.
            # MSHW;nodeName;systemSerialNumber;systemProductModel;systemRAM;
          - type: awk
            script: "${file::embeddedFile-10}"
            keep: ^MSHW
            separators: ;
        source(6):
          # Join the Main discovery with the FRU info
          # MSHW_ENCLOSURE;Class;nodeNumber;Status;Status;IPAddress;MSHW_Node;nodeName;nodeNumber;MSHW;nodeName;systemSerialNumber;systemProductModel;systemRAM;
          type: tableJoin
          leftTable: "${source::monitors.enclosure.discovery.sources.source(4)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(5)}"
          leftKeyColumn: 8
          rightKeyColumn: 2
          defaultRightLine: ;;;;;
          computes:
          - type: leftConcat
            column: 14
            value: "Memory: "
      mapping:
        # Instance Table
        # MSHW_ENCLOSURE;Class;nodeNumber;Status;Status;IPAddress;MSHW_Node;nodeName;nodeNumber;MSHW;nodeName;systemSerialNumber;systemProductModel;systemRAM;
        #       1        # 2       3        4        5      6        # 7       8        # 9       10    11       12        #         # 13        #    14
        source: "${source::monitors.enclosure.discovery.sources.source(6)}"
        attributes:
          id: $8
          __display_id: $8
          vendor: EMC
          model: $13
          serial_number: $12
          type: $2
          info: $14
          name: "${awk::sprintf(\"Enclosure: %s (%s %s)\", $8, \"EMC\", $13)}"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = Run isi status -w
          type: osCommand
          commandLine: "/bin/zsh -c \"%{SUDO:/usr/bin/isi} _IsiStatusCommand\" "
          timeout: 60
          computes:
            # Process the command through an AWK script
            # MSHW_ENCLOSURE;Class;nodeNumber;Status;Status;IPAddress;
          - type: awk
            script: "${file::embeddedFile-4}"
            keep: ^MSHW
            separators: ;
        source(2):
          # Take a copy of the Enclosure Collect
          # MSHW_ENCLOSURE;Class;nodeNumber;Status;Status;IPAddress;
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep only Cluster
            # MSHW_ENCLOSURE;Class;nodeNumber;Status;Status;IPAddress;
          - type: keepOnlyMatchingLines
            column: 2
            valueList: Cluster
            # Translate the Status to Patrol Status
            # MSHW_ENCLOSURE;Class;nodeNumber;PatrolStatus;Status;IPAddress;
          - type: translate
            column: 4
            translationTable: "${translation::ClusterStatusTranslationTable}"
            # Replace the Cluster's name (nodeNumber) with "Cluster"
            # MSHW_ENCLOSURE;Class;nodeName;PatrolStatus;Status;IPAddress;
          - type: replace
            column: 3
            existingValue: $3
            newValue: Cluster
        source(3):
          # Join the Source 1 collect with discovery source 3 so that we can get node names
          # MSHW_ENCLOSURE;Class;nodeNumber;Status;Status;IPAddress;MSHW_Node;nodeName;nodeNumber;
          type: tableJoin
          leftTable: "${source::monitors.enclosure.collect.sources.source(1)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(3)}"
          leftKeyColumn: 3
          rightKeyColumn: 3
          computes:
            # Replace the Node Number with the Node Name
            # MSHW_ENCLOSURE;Class;nodeName;Status;Status;IPAddress;MSHW_Node;nodeName;nodeNumber;
          - type: replace
            column: 3
            existingValue: $3
            newValue: $8
            # Translate the Patrol Status
            # MSHW_ENCLOSURE;Class;nodeName;PatrolStatus;Status;IPAddress;MSHW_Node;nodeName;nodeNumber;
          - type: translate
            column: 4
            translationTable: "${translation::NodeStatusTranslationTable}"
            # Translate the Status Information
            # MSHW_ENCLOSURE;Class;nodeName;PatrolStatus;StatusInformation;IPAddress;MSHW_Node;nodeName;nodeNumber;
          - type: translate
            column: 5
            translationTable: "${translation::NodeStatusInformationTranslationTable}"
            # Get rid of the unwanted columns
            # MSHW_ENCLOSURE;Class;nodeName;PatrolStatus;StatusInformation;IPAddress;
          - type: keepColumns
            columnNumbers: "1,2,3,4,5,6"
        source(4):
          # Union Clusters and Nodes
          # MSHW_ENCLOSURE;Class;nodeName;PatrolStatus;StatusInformation;IPAddress;
          type: tableUnion
          tables:
          - "${source::monitors.enclosure.collect.sources.source(2)}"
          - "${source::monitors.enclosure.collect.sources.source(3)}"
        source(5):
          # Now discover information for other collects
          # Source(5) = Run auparts
          type: osCommand
          commandLine: "/bin/zsh -c \"%{SUDO:/usr/bin/isi_for_array} /usr/bin/isi_for_array /usr/bin/isi_hwtools/isi_hw_status\" "
          timeout: 60
          computes:
            # Process the command through an AWK script
            # Sorts Parallel to Sequential
          - type: awk
            script: "${file::embeddedFile-7}"
            # Process the command through an AWK script
            # MSHW_Class;systemName;DeviceID;DisplayID;Status;Status;
          - type: awk
            script: "${file::embeddedFile-2}"
            keep: ^MSHW
            separators: ;
      mapping:
        # The value table
        # MSHW_ENCLOSURE;Class;nodeName;PatrolStatus;StatusInformation;IPAddress;
        source: "${source::monitors.enclosure.collect.sources.source(4)}"
        attributes:
          id: $3
        metrics:
          hw.status{hw.type="enclosure"}: $4
        legacyTextParameters:
          StatusInformation: $5
  fan:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Keep only Fans
            # MSHW_FAN;ChassisID;DeviceID;DisplayID;LowerThresholds;UpperThreshold;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_FAN$
      mapping:
        # The discovery table
        # MSHW_FAN;ChassisID;DeviceID;DisplayID;LowerThresholds;UpperThreshold;
        source: "${source::monitors.fan.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $4
        metrics:
          hw.fan.speed.limit{limit_type="low.critical"}: $5
    collect:
      # Collect
      # Collect type: MultiInstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(5)}"
          computes:
            # Keep only MSHW
            # MSHW;ID;Value;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW$
      mapping:
        # The value table
        # MSHW;ID;Value;
        source: "${source::monitors.fan.collect.sources.source(1)}"
        attributes:
          id: $2
        metrics:
          hw.fan.speed: $3
  voltage:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Keep only Voltages
            # MSHW_VOLTAGE;ChassisID;DeviceID;DisplayID;LowerThresholds;UpperThreshold;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_VOLTAGE$
            # Multiply the thresholds by 1000 to get mV
            # MSHW_VOLTAGE;ChassisID;DeviceID;DisplayID;LowerThresholds;UpperThreshold;
          - type: multiply
            column: 5
            value: 1000
          - type: multiply
            column: 6
            value: 1000
      mapping:
        # The discovery table
        # MSHW_VOLTAGE;ChassisID;DeviceID;DisplayID;LowerThresholds;UpperThreshold;
        source: "${source::monitors.voltage.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $4
        metrics:
          hw.voltage.limit{limit_type="high.degraded"}: $6
          hw.voltage.limit{limit_type="low.critical"}: $5
    collect:
      # Collect
      # Collect type: MultiInstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(5)}"
          computes:
            # Keep only MSHW
            # MSHW;ID;Value;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW$
            # Multiply the voltage by 1000 to get mV
            # MSHW;ID;Value;
          - type: multiply
            column: 3
            value: 1000
      mapping:
        # The value table
        # MSHW;ID;Value;
        source: "${source::monitors.voltage.collect.sources.source(1)}"
        attributes:
          id: $2
        metrics:
          hw.voltage: $3
  temperature:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Keep only Temperatures
            # MSHW_TEMPERATURE;ChassisID;DeviceID;DisplayID;LowerThresholds;UpperThreshold;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_TEMPERATURE$
      mapping:
        # The discovery table
        # MSHW_TEMPERATURE;ChassisID;DeviceID;DisplayID;LowerThresholds;UpperThreshold;
        source: "${source::monitors.temperature.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $4
        metrics:
          hw.temperature.limit{limit_type="high.critical"}: $6
    collect:
      # Collect
      # Collect type: MultiInstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(5)}"
          computes:
            # Keep only MSHW
            # MSHW;ID;Value;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW$
      mapping:
        # The value table
        # MSHW;ID;Value;
        source: "${source::monitors.temperature.collect.sources.source(1)}"
        attributes:
          id: $2
        metrics:
          hw.temperature: $3
  power_supply:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Keep only PowerSupplys
            # MSHW_POWERSUPPLY;nodeName;nodeName-Global;Global;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_POWERSUPPLY$
      mapping:
        # The discovery table
        # MSHW_PowerSupply;ChassisID;DeviceID;DisplayID;LowerThresholds;UpperThreshold;
        source: "${source::monitors.power_supply.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $4
    collect:
      # Collect
      # Collect type: MultiInstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(5)}"
          computes:
            # Keep only MSHW
            # MSHW_POWERSUPPLY;nodeName-Global;status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_POWERSUPPLY$
            # Duplicate the Status Column
            # MSHW_POWERSUPPLY;nodeName-Global;status;status;
          - type: duplicateColumn
            column: 3
            # Translate first Status into a PATROL status
            # MSHW_POWERSUPPLY;nodeName-Global;Patrolstatus;status;
          - type: translate
            column: 3
            translationTable: "${translation::PowerSupplyStatusTranslationTable}"
      mapping:
        # The value table
        # MSHW;ID;Value;
        source: "${source::monitors.power_supply.collect.sources.source(1)}"
        attributes:
          id: $2
        metrics:
          hw.status{hw.type="power_supply"}: $3
        legacyTextParameters:
          StatusInformation: $4
  cpu:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Keep only CPUs
            # MSHW_CPU;nodeName;nodeName-Global;Global;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_CPU$
      mapping:
        # The discovery table
        # MSHW_CPU;ChassisID;DeviceID;DisplayID;LowerThresholds;UpperThreshold;
        source: "${source::monitors.cpu.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $4
    collect:
      # Collect
      # Collect type: MultiInstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(5)}"
          computes:
            # Keep only MSHW
            # MSHW_CPU;nodeName-Global;status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_CPU$
            # Duplicate the Status Column
            # MSHW_CPU;nodeName-Global;status;status;
          - type: duplicateColumn
            column: 3
            # Translate first Status into a PATROL status
            # MSHW_CPU;nodeName-Global;Patrolstatus;status;
          - type: translate
            column: 3
            translationTable: "${translation::CPUStatusTranslationTable}"
      mapping:
        # The value table
        # MSHW;ID;Value;
        source: "${source::monitors.cpu.collect.sources.source(1)}"
        attributes:
          id: $2
        metrics:
          hw.status{hw.type="cpu"}: $3
        legacyTextParameters:
          StatusInformation: $4
  battery:
    discovery:
      sources:
        source(1):
          # Source(1) = Run isi batterystatus
          type: osCommand
          commandLine: "/bin/zsh -c \"%{SUDO:/usr/bin/isi_for_array} /usr/bin/isi_for_array _IsiBatteryCommand \" "
          timeout: 60
          computes:
            # Process the command through an AWK script
            # Sorts Parallel to Sequential
          - type: awk
            script: "${file::embeddedFile-7}"
            # Process the command through an AWK script
            # MSHW_BATTERY;ChassisID;DeviceID;DisplayID;status;status;
          - type: awk
            script: "${file::embeddedFile-3}"
            keep: ^MSHW
            separators: ;
      mapping:
        # The discovery table
        # MSHW_BATTERY;ChassisID;DeviceID;DisplayID;status;status;
        source: "${source::monitors.battery.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $4
    collect:
      # Collect type is MultiInstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = Run isi batterystatus
          type: osCommand
          commandLine: "/bin/zsh -c \"%{SUDO:/usr/bin/isi_for_array} /usr/bin/isi_for_array _IsiBatteryCommand \" "
          timeout: 60
          computes:
            # Process the command through an AWK script
            # Sorts Parallel to Sequential
          - type: awk
            script: "${file::embeddedFile-7}"
            # Process the command through an AWK script
            # MSHW_BATTERY;ChassisID;DeviceID;DisplayID;status;status;
          - type: awk
            script: "${file::embeddedFile-3}"
            keep: ^MSHW
            separators: ;
            # Translate first Status into a PATROL status
            # MSHW_BATTERY;ChassisID;DeviceID;DisplayID;Patrolstatus;status;
          - type: translate
            column: 5
            translationTable: "${translation::BatteryStatusTranslationTable}"
      mapping:
        # The ValueTable = Source(1)
        # MSHW_BATTERY;ChassisID;DeviceID;DisplayID;Patrolstatus;status;
        source: "${source::monitors.battery.collect.sources.source(1)}"
        attributes:
          id: $3
        metrics:
          hw.status{hw.type="battery"}: $5
        legacyTextParameters:
          StatusInformation: $6
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 3
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(3)}"
          computes:
            # Keep only PhysicalDisk
            # MSHW_PhysicalDisk;ChassisID;DeviceID;DisplayID;Lnum;SerialNumber;Status;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PhysicalDisk$
        source(2):
          # Source(2) = Enclosure Discovery 1
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Keep only PhysicalDisk
            # MSHW_PhysicalDisk;DeviceID;Manufacturer;Model;Firmware;SizeGB;SerialNumber;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PhysicalDisk$
            # Convert GB to bytes
            # MSHW_PhysicalDisk;DeviceID;Manufacturer;Model;Firmware;SizeB;SerialNumber;
          - type: multiply
            column: 6
            value: 1000000000
        source(3):
          # Join the Status table (1) with the FRU table (2)
          # MSHW_PhysicalDisk;ChassisID;DeviceID;DisplayID;Lnum;SerialNumber;Status;Status;MSHW_PhysicalDisk;DeviceID;Manufacturer;Model;Firmware;SizeB;SerialNumber;
          type: tableJoin
          leftTable: "${source::monitors.physical_disk.discovery.sources.source(1)}"
          rightTable: "${source::monitors.physical_disk.discovery.sources.source(2)}"
          leftKeyColumn: 3
          rightKeyColumn: 2
          defaultRightLine: ;;;;;;;
      mapping:
        # The discovery table
        #      1        #       2         3        4       5     6        #   7      8        9        #      10        11         12      13     14    15
        # MSHW_PhysicalDisk;ChassisID;DeviceID;DisplayID;Lnum;SerialNumber;Status;Status;MSHW_PhysicalDisk;DeviceID;Manufacturer;Model;Firmware;SizeB;SerialNumber;
        source: "${source::monitors.physical_disk.discovery.sources.source(3)}"
        attributes:
          id: $3
          __display_id: $4
          model: $12
          vendor: $11
          firmware_version: $13
          serial_number: $6
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s (%s - %s)\", $4, $11, bytes2HumanFormatBase10($14))}"
        metrics:
          hw.physical_disk.size: $14
    collect:
      # Collect type is MultiInstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = Run isi devices
          type: osCommand
          commandLine: "/bin/zsh -c \"%{SUDO:/usr/bin/isi_for_array} /usr/bin/isi_for_array _IsiDrivesCommand \" "
          timeout: 60
          computes:
            # Process the command through an AWK script
            # Sorts Parallel to Sequential
          - type: awk
            script: "${file::embeddedFile-7}"
            # Process the command through an AWK script
            # MSHW_PhysicalDisk;Location;Lnum;SerialNumber;Status;Status;
          - type: awk
            script: "${file::embeddedFile-5}"
            keep: ^MSHW
            separators: ;
            # Keep only PhysicalDisk
            # MSHW_PhysicalDisk;ChassisID;DeviceID;DisplayID;Lnum;SerialNumber;Status;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PhysicalDisk$
            # Translate first Status into a PATROL status
            # MSHW_PhysicalDisk;ChassisID;DeviceID;DisplayID;Lnum;SerialNumber;PatrolStatus;Status;
          - type: translate
            column: 7
            translationTable: "${translation::PhysicalDiskStatusTranslationTable}"
      mapping:
        # The ValueTable = Source(1)
        # MSHW_PhysicalDisk;ChassisID;DeviceID;DisplayID;Lnum;SerialNumber;Status;Status;
        source: "${source::monitors.physical_disk.collect.sources.source(1)}"
        attributes:
          id: $3
        metrics:
          hw.status{hw.type="physical_disk"}: $7
        legacyTextParameters:
          StatusInformation: $8
  network:
    discovery:
      sources:
        source(1):
          # Source(1) = Run isi networks list interfaces --verbose --wide --show-inactive
          type: osCommand
          commandLine: "/bin/zsh -c \"%{SUDO:/usr/bin/isi} _IsiNetworkCommand \" "
          timeout: 60
          computes:
            # Process the command through an AWK script
            # MSHW;NodeNumber;NICName;NICName;Interface;IPAddress;Status;
          - type: awk
            script: "${file::embeddedFile-6}"
            keep: ^MSHW
            separators: ;
        source(2):
          # Join the Enclosure Instance list (source 2) with the nodename to nodeid table from isi devices
          # MSHW;NodeNumber;NICName;NICName;Interface;IPAddress;Status;MSHW_Node;nodeName;nodeNumber;
          type: tableJoin
          leftTable: "${source::monitors.network.discovery.sources.source(1)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(3)}"
          leftKeyColumn: 2
          rightKeyColumn: 3
          computes:
            # Add a - and the NodeName to the NICName to make the DeviceID
            # MSHW;NodeNumber;DeviceID;DisplayID;Interface;IPAddress;Status;MSHW_Node;nodeName;nodeNumber;
          - type: leftConcat
            column: 3
            value: '-'
          - type: leftConcat
            column: 3
            value: $9
      mapping:
        # The discovery table
        # MSHW;NodeNumber;DeviceID;DisplayID;Interface;IPAddress;Status;MSHW_Node;nodeName;nodeNumber;
        source: "${source::monitors.network.discovery.sources.source(2)}"
        attributes:
          id: $3
          __display_id: $4
          hw.parent.type: enclosure
          hw.parent.id: $9
          name: $4
    collect:
      # Collect type is MultiInstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = Run isi networks list interfaces --verbose --wide --show-inactive
          type: osCommand
          commandLine: "/bin/zsh -c \"%{SUDO:/usr/bin/isi} _IsiNetworkCommand \" "
          timeout: 60
          computes:
            # Process the command through an AWK script
            # MSHW;NodeNumber;NICName;NICName;Interface;IPAddress;Status;
          - type: awk
            script: "${file::embeddedFile-6}"
            keep: ^MSHW
            separators: ;
        source(2):
          # Join the Enclosure Instance list (source 2) with the nodename to nodeid table from isi devices
          # MSHW;NodeNumber;NICName;NICName;Interface;IPAddress;Status;MSHW_Node;nodeName;nodeNumber;
          type: tableJoin
          leftTable: "${source::monitors.network.discovery.sources.source(1)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(3)}"
          leftKeyColumn: 2
          rightKeyColumn: 3
          computes:
            # Add a - and the NodeName to the NICName to make the DeviceID
            # MSHW;NodeNumber;DeviceID;DisplayID;Interface;IPAddress;Status;MSHW_Node;nodeName;nodeNumber;
          - type: leftConcat
            column: 3
            value: '-'
          - type: leftConcat
            column: 3
            value: $9
            # Get rid of the unwanted columns
            # MSHW;DeviceID;Status;
          - type: keepColumns
            columnNumbers: "1,3,7"
            # Duplicate the Status (twice)
            # MSHW;DeviceID;Status;Status;Status;
          - type: duplicateColumn
            column: 3
          - type: duplicateColumn
            column: 3
            # Translate first Status into a PATROL status
            # MSHW;DeviceID;PatrolStatus;Status;Status;
          - type: translate
            column: 3
            translationTable: "${translation::NetworkCardStatusTranslationTable}"
            # Translate third Status into a Link status
            # MSHW;DeviceID;PatrolStatus;Status;LinkStatus;
          - type: translate
            column: 5
            translationTable: "${translation::LinkStatusTranslationTable}"
      mapping:
        # The ValueTable = Source(1)
        # MSHW;DeviceID;PatrolStatus;Status;LinkStatus;
        source: "${source::monitors.network.collect.sources.source(2)}"
        attributes:
          id: $2
        metrics:
          hw.status{hw.type="network"}: $3
          hw.network.up: legacyLinkStatus($5)
        legacyTextParameters:
          StatusInformation: $4
  logical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = Run isi storagepool health --verbose
          type: osCommand
          commandLine: "/bin/zsh -c \"%{SUDO:/usr/bin/isi} /usr/bin/isi storagepool health --verbose\" "
          timeout: 60
          computes:
            # Process the command through an AWK script
            # MSHW;ID;Status;AdditionalInformation;StatusInformation;
          - type: awk
            script: "${file::embeddedFile-8}"
            separators: ;
            # Keep only LogicalDisk
            # MSHW;ID;Status;AdditionalInformation;StatusInformation;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW
        source(2):
          # Source(2) = isi storagepool list --verbose --no-header --format csv
          # ID;Nodes;Requested Protection;Type;Children;HDD Used;HDD Total;HDD % Used;SSD Used;SSD Total;SSD % Used;
          type: osCommand
          commandLine: "/bin/zsh -c \"%{SUDO:/usr/bin/isi} /usr/bin/isi storagepool list --verbose --no-header --format csv\" "
          timeout: 60
          computes:
            # Process the command through an AWK script
            # ID;TotalSize;
          - type: awk
            script: "${file::embeddedFile-9}"
            separators: ;
            # Keep Columns
            # ID;HDD Total;
          - type: keepColumns
            columnNumbers: "2,3"
            # Convert to Bytes
            # ID;TotalSize;
          - type: multiply
            column: 2
            value: 1073741824
        source(3):
          # Join the Logical Disk information with the Size Information
          # MSHW;ID;Status;AdditionalInformation;StatusInformation;ID;TotalSize;
          type: tableJoin
          leftTable: "${source::monitors.logical_disk.discovery.sources.source(1)}"
          rightTable: "${source::monitors.logical_disk.discovery.sources.source(2)}"
          leftKeyColumn: 2
          rightKeyColumn: 1
          defaultRightLine: ;;
          computes:
          - type: leftConcat
            column: 4
            value: "Protection Policy: "
      mapping:
        # The discovery table
        # MSHW;ID;Status;AdditionalInformation;StatusInformation;ID;TotalSize;
        source: "${source::monitors.logical_disk.discovery.sources.source(3)}"
        attributes:
          id: $2
          __display_id: $2
          info: $4
          hw.parent.type: enclosure
          hw.parent.id: Cluster
          name: "${awk::sprintf(\"%s (%s)\", $2, bytes2HumanFormatBase2($7))}"
        metrics:
          hw.logical_disk.limit: $7
    collect:
      # Collect type is MultiInstance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = Run isi devices
          type: osCommand
          commandLine: "/bin/zsh -c \"%{SUDO:/usr/bin/isi} /usr/bin/isi storagepool health --verbose\" "
          timeout: 60
          computes:
            # Process the command through an AWK script
            # MSHW;ID;Status;AdditionalInformation;StatusInformation;
          - type: awk
            script: "${file::embeddedFile-8}"
            separators: ;
            # Keep only LogicalDisk
            # MSHW;ID;Status;AdditionalInformation;StatusInformation;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW
            # Translate first Status into a PATROL status
            # MSHW;ID;Status;AdditionalInformation;StatusInformation;
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::LogicalDiskStatusTranslationTable}"
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # MSHW;ID;Status;AdditionalInformation;StatusInformation;
          - type: convert
            column: 3
            conversion: array2SimpleStatus
      mapping:
        # The ValueTable = Source(1)
        # MSHW;ID;Status;AdditionalInformation;StatusInformation;
        source: "${source::monitors.logical_disk.collect.sources.source(1)}"
        attributes:
          id: $2
        metrics:
          hw.status{hw.type="logical_disk"}: $3
        legacyTextParameters:
          StatusInformation: $5
translations:
  BatteryStatusTranslationTable:
    Ready-enabled: ok
    Good-Test: ok
    Good-Testing: ok
    Testing-Good: ok
    Good-Good: ok
    Good: ok
    Default: failed
    Ready-enabled-fully charged: ok
  LinkStatusTranslationTable:
    no carrier: degraded
    inactive: degraded
    up: ok
    Default: degraded
  PowerSupplyStatusTranslationTable:
    OK: ok
    Default: failed
  ClusterStatusTranslationTable:
    OK: ok
    Default: failed
  CPUStatusTranslationTable:
    Normal: ok
    Default: failed
  NodeStatusInformationTranslationTable:
    "-A--": Attention
    DA--: Down Attention
    DASR: Down Attention Smartfailed Read-Only
    "-ASR": Attention Smartfailed Read-Only
    DAS-: Down Attention Smartfailed
    "--SR": Smartfailed Read-Only
    "-A-R": Attention Read-Only
    Default: UNKNOWN
    "--S-": Smartfailed
    "---R": Read-Only
    D--R: Down Read-Only
    "----": ""
    D---: Down
    D-SR: Down Smartfailed Read-Only
    "-AS-": Attention Smartfailed
    D-S-: Down Smartfailed
    OK: ""
    DA-R: Down Attention Read-Only
  NodeStatusTranslationTable:
    "-A--": degraded
    DA--: failed
    DASR: failed
    "-ASR": degraded
    DAS-: failed
    "--SR": degraded
    "-A-R": degraded
    Default: UNKNOWN
    "--S-": degraded
    "---R": degraded
    D--R: failed
    "----": ok
    D---: failed
    D-SR: failed
    "-AS-": degraded
    D-S-: failed
    OK: ok
    DA-R: failed
  LogicalDiskStatusTranslationTable:
    Down: degraded
    MissingDrives: failed
    TooFewNodes: failed
    SmartFailed: degraded
    OK: ok
    Repair: failed
    Default: failed
  PhysicalDiskStatusTranslationTable:
    NEW: degraded
    WRONG_TYPE: degraded
    SED_ERROR: failed
    L3: ok
    JOURNAL: ok
    SMARTFAIL: degraded
    HEALTHY: ok
    BOOT_DRIVE: ok
    PREPARING: degraded
    STALLED: ok
    Default: failed
    NOT: failed
    UNENCRYPTED: failed
    ERASE: degraded
    RESTRIPE: degraded
    SUSPENDED: degraded
    INSECURE: failed
    USED: degraded
    REPLACE: failed
  NetworkCardStatusTranslationTable:
    no carrier: ok
    inactive: ok
    up: ok
    Default: failed
