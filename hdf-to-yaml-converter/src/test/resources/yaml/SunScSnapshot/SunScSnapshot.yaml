---
connector:
  displayName: Oracle/Sun Solaris - Environment (ALOM-CMT snapshot)
  platforms: Oracle/Sun
  reliesOn: Sun Explorer and the ALOM-CMT card
  information: "Gives environmental and disk information (temperatures, fans, etc.) on Sun SPARC T1/T2 servers equipped with an ALOM card. Gathers the hardware information from the ALOM card in-band (no SSH connection over the network). Requires the SUNWexplo (Sun Explorer) package."
  version: 1.1
  detection:
    connectionTypes:
    - remote
    - local
    appliesTo:
    - Solaris
    supersedes:
    - IpmiTool
    criteria:
    # DETECTION
    - type: deviceType
      keep:
      - SunOS
      - Solaris
    # Only on sun4v systems
    - type: osCommand
      commandLine: /bin/uname -m
      expectedResult: ^sun4v$
    - type: osCommand
      commandLine: /bin/ls /opt/SUNWexplo/bin/snapshot
      expectedResult: ^/opt/SUNWexplo/bin/snapshot$
      errorMessage: Sun Explorer's snapshot utility is not installed.
    - type: osCommand
      forceSerialization: true
      commandLine: "while /usr/bin/pgrep \"^snapshot$\">/dev/null; do /usr/bin/sleep 1; done;/usr/bin/echo showplatform -v,13,14>/tmp/MS_HW_snapshot.test;%{SUDO:/opt/SUNWexplo/bin/snapshot}/opt/SUNWexplo/bin/snapshot -c /tmp/MS_HW_snapshot.test -v|/usr/bin/dos2unix -ascii -437;/usr/bin/rm -f /tmp/MS_HW_snapshot.test"
      expectedResult: "^SUNW,"
      errorMessage: Sun Explorer's snapshot utililty does not seem to be able to connect to the SC.
sudoCommands:
- /opt/SUNWexplo/bin/snapshot
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Source(1) = Output of the showenvironment command + uname -i
          # Since the prtdiag connector is now disabled for sun4v systems, this connector needs to at least
          # create the enclosure icon even though the snapshot command does not work (because Sun Explorer
          # wasn't installed, or root credentials were not provided)
          type: osCommand
          forceSerialization: true
          commandLine: "while /bin/pgrep \"^snapshot$\">/dev/null; do /bin/sleep 1; done;%{SUDO:/opt/SUNWexplo/bin/snapshot}/opt/SUNWexplo/bin/snapshot -c ${file::embeddedFile-1}|/bin/dos2unix -ascii -437;/bin/uname -i"
          computes:
            # Reformat snapshot and uname's output through awk (see EmbeddedFile(3))
            # Model;
          - type: awk
            script: "${file::embeddedFile-3}"
            keep: ^MSHW;
            separators: ;
            selectColumns: 2
            # Replace '-' with blanks (because model is displayed as Sun-Fire-T200)
            # Model;
          - type: replace
            column: 1
            existingValue: '-'
            newValue: ' '
        source(2):
          # Source(2) = Output of the showenvironment command
          type: osCommand
          forceSerialization: true
          commandLine: "while /bin/pgrep \"^snapshot$\">/dev/null; do /bin/sleep 1; done;%{SUDO:/opt/SUNWexplo/bin/snapshot}/opt/SUNWexplo/bin/snapshot -c ${file::embeddedFile-2}|/bin/dos2unix -ascii -437"
          separators: " \t"
          selectColumns: 1-
          computes:
            # In the first column, which is supposed to contain the deviceID, replace dots (.) by slashes
            # so that we will be able to support both the Sun Fire V210, V240 and V440 line and the T1-based line
            # in the same time
          - type: replace
            column: 1
            existingValue: .
            newValue: /
      mapping:
        # InstanceTable = Source(1)
        source: "${source::monitors.enclosure.discovery.sources.source(1)}"
        attributes:
          id: sun4v
          model: $1
          name: "${awk::sprintf(\"Enclosure: (%s)\", $1)}"
    collect:
      # Collect type is multi-instance (execute once)
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Output of the showenvironment command
          type: osCommand
          forceSerialization: true
          commandLine: "while /bin/pgrep \"^snapshot$\">/dev/null; do /bin/sleep 1; done;%{SUDO:/opt/SUNWexplo/bin/snapshot}/opt/SUNWexplo/bin/snapshot -c ${file::embeddedFile-2}|/bin/dos2unix -ascii -437"
          separators: " \t"
          selectColumns: 1-
          computes:
            # In the first column, which is supposed to contain the deviceID, replace dots (.) by slashes
            # so that we will be able to support both the Sun Fire V210, V240 and V440 line and the T1-based line
            # in the same time
          - type: replace
            column: 1
            existingValue: .
            newValue: /
      mapping:
        # ValueTable = Source(1)
        source: sun4v
        deviceId: $1
  fan:
    discovery:
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Discovery.Source(2)
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(2)}"
          computes:
            # Keep only lines where the first column (the supposed fan ID) matches with ^FT[0-9] or /F[0-9]/ or ^F[0-9]/
            # FanID;status;speed;warning;alarm
          - type: keepOnlyMatchingLines
            column: 1
            regExp: "\\(^FT[0-9]\\)\\|\\(/F[0-9]/\\)\\|\\(^F[0-9]\\)\\|\\(/FM[0-9]/F\\)"
            # Exclude things that are obviously not fans
            # FanID;status;speed;warning;alarm
          - type: excludeMatchingLines
            column: 1
            regExp: /T_
            # Replace dashes ("-") in the thresholds by nothing
            # FanID;status;speed;warning;alarm
          - type: replace
            column: 4
            existingValue: '-'
            newValue: ""
          - type: replace
            column: 5
            existingValue: '-'
            newValue: ""
      mapping:
        # Instance Table = Source(1)
        source: "${source::monitors.fan.discovery.sources.source(1)}"
        attributes:
          id: $1
          sensor_location: $1
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s)\", $1, $1)}"
        metrics:
          hw.fan.speed.limit{limit_type="low.degraded"}: $4
          hw.fan.speed.limit{limit_type="low.critical"}: $5
    collect:
      # Collect type is "all instances in one shot
      type: multiInstance
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Collect.Source(1)
          # Yeah that's kind of weird. Fan collect values will be refreshed only when/whether
          # enclosure collect values are refreshed. This is to spare some unneeded snapshot executions.
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep only lines where the first column (the supposed fan ID) matches with ^FT[0-9] or /F[0-9]/ or ^F[0-9]/
            # FanID;status;speed;warning;alarm
          - type: keepOnlyMatchingLines
            column: 1
            regExp: "\\(^FT[0-9]\\)\\|\\(/F[0-9]/\\)\\|\\(^F[0-9]\\)\\|\\(/FM[0-9]/F\\)"
            # Exclude things that are obviously not fans
            # FanID;status;speed;warning;alarm
          - type: excludeMatchingLines
            column: 1
            regExp: /T_
            # Duplicate the status column
            # FanID;status;status;speed;warning;alarm
          - type: duplicateColumn
            column: 2
            # Translate the first column into a PATROL Status
            # FanID;PATROLStatus;status;speed;warning;alarm
          - type: translate
            column: 2
            translationTable: "${translation::FanStatusTranslationTable}"
      mapping:
        # ValueTable = Source(3)
        source: "${source::monitors.fan.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="fan"}: $2
          hw.fan.speed: $4
        legacyTextParameters:
          StatusInformation: $3
  temperature:
    discovery:
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Discovery.Source(2)
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(2)}"
          computes:
            # Keep only lines where the first column (the supposed temperature ID) matches with /T_ or /TCORE
            # TemperatureID;Status;Temperature;LowHard;LowSoft;LowWarn;HighWarn;HighSoft;HighHard
          - type: keepOnlyMatchingLines
            column: 1
            regExp: \(/T_\)\|\(/TCORE\)
            # Replace dashes ("-") in the thresholds by nothing
            # TemperatureID;Status;Temperature;LowHard;LowSoft;LowWarn;HighWarn;HighSoft;HighHard
          - type: replace
            column: 7
            existingValue: '-'
            newValue: ""
          - type: replace
            column: 8
            existingValue: '-'
            newValue: ""
      mapping:
        # Instance Table = Source(1)
        source: "${source::monitors.temperature.discovery.sources.source(1)}"
        attributes:
          id: $1
          sensor_location: $1
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s)\", $1, $1)}"
        metrics:
          hw.temperature.limit{limit_type="high.degraded"}: $7
          hw.temperature.limit{limit_type="high.critical"}: $8
    collect:
      # Collect type is "all instances in one shot
      type: multiInstance
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Collect.Source(1)
          # Yeah that's kind of weird. Temperature collect values will be refreshed only when/whether
          # enclosure collect values are refreshed. This is to spare some unneeded snapshot executions.
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep only lines where the first column (the supposed fan ID) matches with /T_ or /TCORE
            # TemperatureID;Status;Temperature;LowHard;LowSoft;LowWarn;HighWarn;HighSoft;HighHard
          - type: keepOnlyMatchingLines
            column: 1
            regExp: \(/T_\)\|\(/TCORE\)
            # Duplicate the status column
            # TemperatureID;Status;Status;Temperature;LowHard;LowSoft;LowWarn;HighWarn;HighSoft;HighHard
          - type: duplicateColumn
            column: 2
            # Translate the first column into a PATROL Status
            # TemperatureID;PATROLStatus;Status;Temperature;LowHard;LowSoft;LowWarn;HighWarn;HighSoft;HighHard
          - type: translate
            column: 2
            translationTable: "${translation::TemperatureStatusTranslationTable}"
      mapping:
        # ValueTable = Source(3)
        source: "${source::monitors.temperature.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="temperature"}: $2
          hw.temperature: $4
        legacyTextParameters:
          StatusInformation: $3
  voltage:
    discovery:
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Discovery.Source(2)
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(2)}"
          computes:
            # Keep only lines where the first column (the supposed Voltage ID) matches with /V_
            # VoltageID;Status;Voltage;LowSoft;LowWarn;HighWarn;HighSoft
          - type: keepOnlyMatchingLines
            column: 1
            regExp: /V_
            # Replace dashes ("-") in the thresholds by nothing
            # VoltageID;Status;Voltage;LowSoft;LowWarn;HighWarn;HighSoft
          - type: replace
            column: 5
            existingValue: --
            newValue: ""
            # Convert volts into millivolts
            # VoltageID;Status;Voltage;LowSoft;LowWarnMilli;HighWarnMilli;HighSoft
          - type: multiply
            column: 5
            value: 1000
          - type: multiply
            column: 6
            value: 1000
      mapping:
        # Instance Table = Source(1)
        source: "${source::monitors.voltage.discovery.sources.source(1)}"
        attributes:
          id: $1
          sensor_location: $1
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s)\", $1, $1)}"
        metrics:
          hw.voltage.limit{limit_type="low.critical"}: $5
          hw.voltage.limit{limit_type="high.degraded"}: $6
    collect:
      # Collect type is "all instances in one shot
      type: multiInstance
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Collect.Source(1)
          # Yeah that's kind of weird. Voltage collect values will be refreshed only when/whether
          # enclosure collect values are refreshed. This is to spare some unneeded telnet sessions.
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep only lines where the first column (the supposed Voltage ID) matches with /V_
            # VoltageID;Status;Voltage;LowSoft;LowWarn;HighWarn;HighSoft
          - type: keepOnlyMatchingLines
            column: 1
            regExp: /V_
            # Duplicate the status column
            # VoltageID;Status;Status;Voltage;LowSoft;LowWarn;HighWarn;HighSoft
          - type: duplicateColumn
            column: 2
            # Translate the first column into a PATROL Status
            # VoltageID;Status;Status;Voltage;LowSoft;LowWarn;HighWarn;HighSoft
          - type: translate
            column: 2
            translationTable: "${translation::VoltageStatusTranslationTable}"
            # Convert volts into millivolts
            # VoltageID;Status;Status;VoltageMilli;LowSoft;LowWarn;HighWarn;HighSoft
          - type: multiply
            column: 4
            value: 1000
      mapping:
        # ValueTable = Source(3)
        source: "${source::monitors.voltage.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="voltage"}: $2
          hw.voltage: $4
        legacyTextParameters:
          StatusInformation: $3
  power_supply:
    discovery:
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Discovery.Source(2)
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(2)}"
          computes:
            # Keep only lines where the first column (the supposed PowerSupply ID) matches with ^PS[0-9] or /PS[0-9]$
            # and whose 5th column contains either "ON" or "OFF"
            # PowerSupplyID;Status;Underspeed;Overtemp;Overvolt;Undervolt;Overcurrent
          - type: keepOnlyMatchingLines
            column: 1
            regExp: "\\(^PS[0-9]\\)\\|\\(/PS[0-9]$\\)"
          - type: keepOnlyMatchingLines
            column: 5
            regExp: "^O[NF]+$"
        source(2):
          # Source(2) = copy of Enclosure.Discovery.Source(2)
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(2)}"
          computes:
            # Keep only lines where the first column (the supposed PowerSupply ID) matches with ^PS[0-9] or /PS[0-9]$
            # and whose 2nd column is "PRESENT"
            # PowerSupplyID;Present;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: "\\(^PS[0-9]\\)\\|\\(/PS[0-9]$\\)"
          - type: keepOnlyMatchingLines
            column: 2
            regExp: ^PRESENT$
        source(3):
          # Source(3) = Union of Source(1) and Source(2)
          # PowerSupplyID
          type: tableUnion
          tables:
          - "${source::monitors.power_supply.discovery.sources.source(1)}"
          - "${source::monitors.power_supply.discovery.sources.source(2)}"
      mapping:
        # Instance Table = Source(3)
        source: "${source::monitors.power_supply.discovery.sources.source(3)}"
        attributes:
          id: $1
          hw.parent.type: enclosure
          name: $1
    collect:
      # Collect type is "all instances in one shot
      type: multiInstance
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Collect.Source(1)
          # Yeah that's kind of weird. PowerSupply collect values will be refreshed only when/whether
          # enclosure collect values are refreshed. This is to spare some unneeded snapshot executions.
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep only lines where the first column (the supposed PowerSupply ID) matches with ^PS[0-9] or /PS[0-9]$
            # and whose 5th column contains either "ON" or "OFF"
            # PowerSupplyID;Status;Underspeed;Overtemp;Overvolt;Undervolt;Overcurrent
          - type: keepOnlyMatchingLines
            column: 1
            regExp: "\\(^PS[0-9]\\)\\|\\(/PS[0-9]$\\)"
          - type: keepOnlyMatchingLines
            column: 5
            regExp: "^O[NF]+$"
            # Keep only the device ID and status columns
            # PowerSupplyID;Status;
          - type: keepColumns
            columnNumbers: "1,2"
        source(2):
          # Source(2) = copy of Enclosure.Discovery.Source(2)
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep only lines where the first column (the supposed PowerSupply ID) matches with ^PS[0-9] or /PS[0-9]$
            # and whose 2nd column is "PRESENT"
            # PowerSupplyID;Present;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: "\\(^PS[0-9]\\)\\|\\(/PS[0-9]$\\)"
          - type: keepOnlyMatchingLines
            column: 2
            regExp: ^PRESENT$
            # Keep only the device ID and status columns
            # PowerSupplyID;Status;
          - type: keepColumns
            columnNumbers: "1,3"
        source(3):
          # Source(3) = Union of Source(1) and Source(2)
          # PowerSupplyID;Status;
          type: tableUnion
          tables:
          - "${source::monitors.power_supply.collect.sources.source(1)}"
          - "${source::monitors.power_supply.collect.sources.source(2)}"
          computes:
            # Duplicate the status column
            # PowerSupplyID;Status;Status;
          - type: duplicateColumn
            column: 2
            # Translate the first column into a PATROL Status
            # PowerSupplyID;PATROLStatus;Status;
          - type: translate
            column: 2
            translationTable: "${translation::PowerSupplyStatusTranslationTable}"
            # Translate the second status into a more readable string
            # PowerSupplyID;PATROLStatus;StatusInformation;
          - type: replace
            column: 3
            existingValue: "No"
            newValue: No input source
      mapping:
        # ValueTable = Source(1)
        source: "${source::monitors.power_supply.collect.sources.source(3)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="power_supply"}: $2
        legacyTextParameters:
          StatusInformation: $3
  other_device:
    discovery:
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Discovery.Source(2)
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(2)}"
          computes:
            # Keep only lines where the first column (the supposed OtherDevice ID) matches with \(/I_\)\|\(/FF_\)
            # OtherDeviceID;Status
          - type: keepOnlyMatchingLines
            column: 1
            regExp: \(/I_\)\|\(/FF_\)
      mapping:
        # Instance Table = Source(1)
        source: "${source::monitors.other_device.discovery.sources.source(1)}"
        attributes:
          id: $1
          device_type: Current
          additional_label: $1
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s: %s (%s)\", \"Current\", $1, $1)}"
    collect:
      # Collect type is "all instances in one shot
      type: multiInstance
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Collect.Source(1)
          # Yeah that's kind of weird. OtherDevice collect values will be refreshed only when/whether
          # enclosure collect values are refreshed. This is to spare some unneeded snapshot executions.
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep only lines where the first column (the supposed OtherDevice ID) matches with \(/I_\)\|\(/FF_\)
            # OtherDeviceID;Status;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: \(/I_\)\|\(/FF_\)
            # Duplicate the status column
            # OtherDeviceID;Status;Status
          - type: duplicateColumn
            column: 2
            # Translate the first column into a PATROL Status
            # OtherDeviceID;PATROLStatus;Status
          - type: translate
            column: 2
            translationTable: "${translation::OtherDeviceStatusTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        source: "${source::monitors.other_device.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="other_device"}: $2
        legacyTextParameters:
          StatusInformation: $3
translations:
  TemperatureStatusTranslationTable:
    faulty: degraded
    OK: ok
    Default: failed
  FanStatusTranslationTable:
    faulty: degraded
    OK: ok
    Default: failed
  VoltageStatusTranslationTable:
    faulty: degraded
    OK: ok
    Default: failed
  PowerSupplyStatusTranslationTable:
    faulty: failed
    OK: ok
    Default: failed
  OtherDeviceStatusTranslationTable:
    faulty: degraded
    OK: ok
    Default: failed
