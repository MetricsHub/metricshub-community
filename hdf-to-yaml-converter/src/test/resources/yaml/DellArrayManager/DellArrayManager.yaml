---
connector:
  displayName: Dell OpenManage Array Manager
  platforms: Dell PowerEdge
  reliesOn: Dell OpenManage Server Administrator
  version: 1.0
  information: This connector provides disks monitoring through the Dell OpenManage Array Manager SNMP agent (not to be confused with Storage Manager).
  detection:
    connectionTypes:
    - remote
    - local
    appliesTo:
    - NT
    - Linux
    criteria:
    - type: snmpGetNext
      oid: 1.3.6.1.4.1.674.10893.1.1.130.4.1
monitors:
  disk_controller:
    discovery:
      sources:
        source(1):
          # Source(1) = the controllerTable
          # ID;ControllerIndex;Model;FWRev;
          type: snmpTable
          oid: 1.3.6.1.4.1.674.10893.1.1.130.1.1
          selectColumns: "ID,1,2,8"
      mapping:
        # The InstanceTable
        source: "${source::monitors.disk_controller.discovery.sources.source(1)}"
        attributes:
          id: $1
          controller_number: $2
          model: $3
          firmware_version: $4
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"Disk Controller: %s (%s)\", $2, $3)}"
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = the arrayDiskTable snmp table
          # ID;DiskNumber;Vendor;Serial;SizeMB
          type: snmpTable
          oid: 1.3.6.1.4.1.674.10893.1.1.130.4.1
          selectColumns: "ID,1,3,7,11"
        source(2):
          # Source(2) = the arrayDiskChannelConnectionTable snmp table
          # DiskNumber;ControllerNumber
          type: snmpTable
          oid: 1.3.6.1.4.1.674.10893.1.1.130.6.1
          selectColumns: "3,7"
        source(3):
          # Source(3) = a default value tables in order to be able to attach disks to a controller
          # This is because some computers with DELL Array Manager don't have this previous
          # table (arrayDiskChannelConnectionTable)
          type: static
          value: |-
            1;1;
            2;1;
            3;1;
            4;1;
            5;1;
            6;1;
            7;1;
            8;1;
            9;1;
            10;1;
            11;1;
            12;1;
            13;1;
            14;1;
            15;1;
            16;1;
            17;1;
            18;1;
            19;1;
            20;1;
            21;1
            22;1
            23;1
            24;1
            25;1
            26;1
            27;1
            28;1
            29;1
            30;1
            31;1
            32;1
            33;1
            34;1
            35;1
            36;1
            37;1
            38;1
            39;1
            40;1
        source(4):
          # Source(4) = Union of Source(2) (the real arrayDiskChannelConnectionTable) and
          # Source(3) (the default values)
          type: tableUnion
          tables:
          - "${source::monitors.physical_disk.discovery.sources.source(2)}"
          - "${source::monitors.physical_disk.discovery.sources.source(3)}"
        source(5):
          # Source(5) = table joint between Source(1) and Source(4)
          # ID;DiskNumber;Vendor;Serial;SizeMB;DiskNumber;ControllerNumber
          type: tableJoin
          leftTable: "${source::monitors.physical_disk.discovery.sources.source(1)}"
          rightTable: "${source::monitors.physical_disk.discovery.sources.source(4)}"
          leftKeyColumn: 2
          rightKeyColumn: 1
          computes:
            # Convert the size into bytes
            # ID;DiskNumber;Vendor;Serial;Size;DiskNumber;ControllerNumber
          - type: multiply
            column: 5
            value: 1048576
      mapping:
        # The instance table = Source(1)
        source: "${source::monitors.physical_disk.discovery.sources.source(5)}"
        attributes:
          id: $1
          vendor: $3
          serial_number: $4
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $7)"
          name: "${awk::sprintf(\"%s (%s - %s)\", $1, $3, bytes2HumanFormatBase10($5))}"
        metrics:
          hw.physical_disk.size: $5
    collect:
      # Collect type = mono-instance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = SNMP Get on the arrayDiskState value of the arrayDiskTable SNMP table
          # ID;arrayDiskStatus;arrayDiskSeverity
          type: snmpTable
          oid: 1.3.6.1.4.1.674.10893.1.1.130.4.1
          selectColumns: "ID,4,5"
          computes:
            # Translate the arrayDiskState into a PATROL status
            # patrolDiskStatus;arrayDiskState
          - type: translate
            column: 3
            translationTable: "${translation::PhysicalDiskStatusTranslationTable}"
            # Translate the arrayDiskState into a PATROL information
            # patrolDiskStatus;arrayDiskState
          - type: translate
            column: 2
            translationTable: "${translation::PhysicalDiskStatusInformationTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        source: "${source::monitors.physical_disk.collect.sources.source(1)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="physical_disk"}: $3
        legacyTextParameters:
          StatusInformation: $2
  logical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = the virtualDiskTable snmp table
          # ID;virtualDiskNumber;SizeMB;RaidLevel
          type: snmpTable
          oid: 1.3.6.1.4.1.674.10893.1.1.140.1.1
          selectColumns: "ID,1,6,13"
          computes:
            # Translate size into bytes
            # ID;virtualDiskNumber;Size;RaidLevel
          - type: multiply
            column: 3
            value: 1048576
            # Translate the FaultToleranceLevel into a more readable string
            # ID;ControllerNumber;RAIDLevel;Size
          - type: translate
            column: 4
            translationTable: "${translation::RAIDLevelTranslationTable}"
        source(2):
          # Source(2) = the arrayDiskLogicalConnectionTable snmp table
          # physicalDiskNumber;VirtualDiskNumber
          type: snmpTable
          oid: 1.3.6.1.4.1.674.10893.1.1.140.3.1
          selectColumns: "3,5"
        source(3):
          # Source(3) = table joint between source(1) and source(2)
          # ID;virtualDiskNumber;Size;RaidLevel;physicalDiskNumber;VirtualDiskNumber
          type: tableJoin
          leftTable: "${source::monitors.logical_disk.discovery.sources.source(1)}"
          rightTable: "${source::monitors.logical_disk.discovery.sources.source(2)}"
          leftKeyColumn: 2
          rightKeyColumn: 2
        source(4):
          # Source(4) = the arrayDiskChannelConnectionTable snmp table
          # arrayDiskNumber;controllerNumber
          type: snmpTable
          oid: 1.3.6.1.4.1.674.10893.1.1.130.6.1
          selectColumns: "3,7"
        source(5):
          # Source(5) = a default value tables in order to be able to attach disks to a controller
          # This is because some computers with DELL Array Manager don't have this previous
          # table (arrayDiskChannelConnectionTable)
          type: static
          value: |-
            1;1;
            2;1;
            3;1;
            4;1;
            5;1;
            6;1;
            7;1;
            8;1;
            9;1;
            10;1;
            11;1;
            12;1;
            13;1;
            14;1;
            15;1;
            16;1;
            17;1;
            18;1;
            19;1;
            20;1;
            21;1
            22;1
            23;1
            24;1
            25;1
            26;1
            27;1
            28;1
            29;1
            30;1
            31;1
            32;1
            33;1
            34;1
            35;1
            36;1
            37;1
            38;1
            39;1
            40;1
        source(6):
          # Source(6) = Union of Source(4) (the real arrayDiskChannelConnectionTable) and
          # Source(5) (the default values)
          type: tableUnion
          tables:
          - "${source::monitors.logical_disk.discovery.sources.source(4)}"
          - "${source::monitors.logical_disk.discovery.sources.source(5)}"
        source(7):
          # Source(5) = table joint between source(3) and source(6)
          # ID;virtualDiskNumber;Size;RaidLevel;physicalDiskNumber;VirtualDiskNumber;arrayDiskNumber;controllerNumber
          type: tableJoin
          leftTable: "${source::monitors.logical_disk.discovery.sources.source(3)}"
          rightTable: "${source::monitors.logical_disk.discovery.sources.source(6)}"
          leftKeyColumn: 5
          rightKeyColumn: 1
      mapping:
        # The InstanceTable
        source: "${source::monitors.logical_disk.discovery.sources.source(7)}"
        attributes:
          id: $1
          raid_level: $4
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $8)"
          name: "${awk::sprintf(\"%s (%s - %s)\", $1, $4, bytes2HumanFormatBase2($3))}"
        metrics:
          hw.logical_disk.limit: $3
    collect:
      # Collect type = mono-instance
      type: monoInstance
      sources:
        source(1):
          # Source(1) = SNMP Get on the virtualDiskState value of the virtualDiskTable SNMP table
          # virtualDiskState
          type: snmpGet
          oid: "1.3.6.1.4.1.674.10893.1.1.140.1.1.4.${logical_disk::id}"
          computes:
            # Duplicate this status, because we will translate it two times
            # virtualDiskState;virtualDiskState
          - type: duplicateColumn
            column: 1
            # Translate the virtualDiskState into a PATROL status
            # patrolDiskStatus;virtualDiskState
          - type: translate
            column: 1
            translationTable: "${translation::LogicalDiskStatusTranslationTable}"
            # Translate the virtualDiskState into a more readable string
            # patrolDiskStatus;arrayDiskStatusInformation
          - type: translate
            column: 2
            translationTable: "${translation::LogicalDiskStatusInformationTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        source: "${source::monitors.logical_disk.collect.sources.source(1)}"
        metrics:
          hw.status{hw.type="logical_disk"}: $1
        legacyTextParameters:
          StatusInformation: $2
translations:
  RAIDLevelTranslationTable:
    "11": 30
    "12": 50
    "13": Add Spares
    "14": Delete Logical
    "15": Transform Logical
    "18": 0+1
    Default: ""
    "1": Concatenated
    "2": 0
    "3": 1
    "4": 2
    "5": 3
    "6": 4
    "7": 5
    "8": 6
    "9": 7
    "10": 10
  PhysicalDiskStatusInformationTranslationTable:
    "11": Formatting
    "12": Diagnosing
    "13": Initializing
    Default: Unknown Status
    "1": Ready
    "2": Failed
    "3": Online
    "4": Offline
    "5": Degraded
    "6": Recovering
    "7": Removed
    "8": Resynching
    "9": Rebuilding
    "10": No media
  LogicalDiskStatusInformationTranslationTable:
    "1": Ready
    "2": Failed
    "24": Rebuilding
    "35": Initializing
    "3": Online
    "4": Offline
    "15": Resynching
    "26": Formatting
    "6": Degraded
    Default: Unknown Status
  LogicalDiskStatusTranslationTable:
    "1": ok
    "2": failed
    "24": degraded
    "35": ok
    "3": ok
    "4": failed
    "15": degraded
    "26": ok
    "6": degraded
    Default: UNKNOWN
  PhysicalDiskStatusTranslationTable:
    "0": ok
    "1": degraded
    "2": failed
    "3": failed
    Default: UNKNOWN
