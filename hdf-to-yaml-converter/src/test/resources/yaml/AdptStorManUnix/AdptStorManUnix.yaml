---
connector:
  displayName: Adaptec - StorMan - RAID
  platforms: Any system with Adaptec
  reliesOn: arcconf
  information: Gives information about physical disks and volumes of Adaptec SAS RAID controllers through the arcconf utility.
  version: 1.0
  detection:
    connectionTypes:
    - remote
    - local
    appliesTo:
    - Solaris
    - Linux
    criteria:
    - type: deviceType
      keep:
      - Solaris
      - SunOS
      - Linux
    # We should find disks attached to one controller
    - type: osCommand
      commandLine: "/bin/sh ${file::embeddedFile-1}"
      expectedResult: Hard drive
      errorMessage: No Adaptec Controller with Physical Disks attached or not enough rights to execute arcconf.
sudoCommands:
- "/[opt|usr]/StorMan/arcconf"
monitors:
  disk_controller:
    discovery:
      sources:
        source(1):
          type: osCommand
          commandLine: "/bin/sh ${file::embeddedFile-3}"
          computes:
            # Reformat Source(1) output via EmbeddedFile(4)
            # MSHW;controllerID;status;model;serial;slot;memory;firmware;driver;batteryStatus;
          - type: awk
            script: "${file::embeddedFile-4}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,4,5,6,7,8,9,10"
      mapping:
        # The InstanceTable
        # controllerID;model;serial;slot;memory;firmware;driver;batteryStatus;
        source: "${source::monitors.disk_controller.discovery.sources.source(1)}"
        attributes:
          id: $1
          controller_number: $1
          model: $2
          serial_number: $3
          firmware_version: $6
          driver_version: $7
          info: "${awk::join(\" \", $4, $5)}"
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"Disk Controller: %s (%s)\", $1, $2)}"
    collect:
      # Collect type is "all instances in one shot
      type: multiInstance
      sources:
        source(1):
          # Source(1) = EF4
          type: osCommand
          commandLine: "/bin/sh ${file::embeddedFile-3}"
          computes:
            # Reformat Source(1) output via EmbeddedFile(4)
            # MSHW;controllerID;status;model;serial;slot;memory;firmware;driver;batteryStatus;
          - type: awk
            script: "${file::embeddedFile-4}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,10"
            # Translate the Status into a PATROL status
            # controllerID;Patrolstatus;batteryStatus;
          - type: translate
            column: 2
            translationTable: "${translation::DiskControllerStatusTranslationTable}"
            # Translate the Status into a PATROL status
            # controllerID;Patrolstatus;PatrolBatteryStatus;
          - type: translate
            column: 3
            translationTable: "${translation::ControllerBatteryStatusTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        # controllerID;Patrolstatus;status;PatrolBatteryStatus;batteryStatus;
        source: "${source::monitors.disk_controller.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="disk_controller"}: $2
  physical_disk:
    discovery:
      sources:
        source(1):
          type: osCommand
          commandLine: "/bin/sh ${file::embeddedFile-1}"
          computes:
            # Reformat Source(1) output via EmbeddedFile(2)
            # MSHW;controllerID;hardDriveID;status;location;vendor;model;firmware;serialNumber;sizeGB;channel;
          - type: awk
            script: "${file::embeddedFile-2}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,5,6,7,8,9,10,11"
            # Multiply to get Bytes
            # controllerID;hardDriveID;location;vendor;model;firmware;serialNumber;sizeB;channel;
          - type: multiply
            column: 8
            value: 1073741824
      mapping:
        # The InstanceTable
        # controllerID;hardDriveID;location;vendor;model;firmware;serialNumber;sizeB;channel;
        source: "${source::monitors.physical_disk.discovery.sources.source(1)}"
        attributes:
          id: $2
          vendor: $4
          model: $5
          serial_number: $7
          info: "${awk::join(\" \", $3, $9)}"
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $1)"
          name: "${awk::sprintf(\"%s (%s - %s)\", $2, $4, bytes2HumanFormatBase10($8))}"
        metrics:
          hw.physical_disk.size: $8
    collect:
      # Collect type is "all instances in one shot
      type: multiInstance
      sources:
        source(1):
          # Source(1) = EF1
          type: osCommand
          commandLine: "/bin/sh ${file::embeddedFile-1}"
          computes:
            # Reformat Source(1) output via EmbeddedFile(2)
            # MSHW;controllerID;hardDriveID;status;location;vendor;model;firmware;serialNumber;sizeGB;Channel;
          - type: awk
            script: "${file::embeddedFile-2}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "3,4"
            # Duplicate the Status column
            # hardDriveID;Status;Status
          - type: duplicateColumn
            column: 2
            # Remove spaces in the Statys column
            # hardDriveID;Status;Status
          - type: replace
            column: 2
            existingValue: ' '
            newValue: ""
            # Translate the Status into a PATROL status
            # hardDriveID;PATROLStatus;Status
          - type: translate
            column: 2
            translationTable: "${translation::DiskStatusTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        source: "${source::monitors.physical_disk.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="physical_disk"}: $2
        legacyTextParameters:
          StatusInformation: $3
  logical_disk:
    discovery:
      sources:
        source(1):
          type: osCommand
          commandLine: "/bin/sh ${file::embeddedFile-5}"
          computes:
            # Reformat Source(1) output via EmbeddedFile(6)
            # MSHW;controllerID;logicaldriveID;logicaldriveName;status;size;raidLevel;statusInfo;
          - type: awk
            script: "${file::embeddedFile-6}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,6,7"
            # Multiply to get Bytes
            # controllerID;logicaldriveID;logicaldriveName;size;raidLevel;
          - type: multiply
            column: 4
            value: 1073741824
      mapping:
        # The InstanceTable
        # controllerID;logicaldriveID;logicaldriveName;size;raidLevel;
        source: "${source::monitors.logical_disk.discovery.sources.source(1)}"
        attributes:
          id: $2
          raid_level: $5
          __display_id: $3
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $1)"
          name: "${awk::sprintf(\"%s (%s - %s)\", $3, $5, bytes2HumanFormatBase2($4))}"
        metrics:
          hw.logical_disk.limit: $4
    collect:
      # Collect type is "all instances in one shot
      type: multiInstance
      sources:
        source(1):
          # Source(1) = EF5
          type: osCommand
          commandLine: "/bin/sh ${file::embeddedFile-5}"
          computes:
            # Reformat Source(1) output via EmbeddedFile(6)
            # MSHW;controllerID;logicaldriveID;logicaldriveName;status;size;raidLevel;statusInfo;
          - type: awk
            script: "${file::embeddedFile-6}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "3,5,8"
            # Translate the Status into a PATROL status
            # logicaldriveID;Patrolstatus;statusInfo;
          - type: translate
            column: 2
            translationTable: "${translation::LogicalDiskStatusTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        # logicaldriveID;Patrolstatus;status;
        source: "${source::monitors.logical_disk.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="logical_disk"}: $2
        legacyTextParameters:
          StatusInformation: $3
translations:
  DiskStatusTranslationTable:
    okay: ok
    inaccessible: failed
    raw: ok
    rebuilding: degraded
    failed: failed
    down: failed
    Default: UNKNOWN
    offline: failed
    device-error: failed
    unsupported: failed
    removed: failed
    ready: ok
    online: ok
    spare: ok
  ControllerBatteryStatusTranslationTable:
    discharging: ok
    maintenance mode: degraded
    optimal: ok
    over temperature: failed
    charging: ok
    charging disabled: ok
    failed: failed
    ok: ok
    degraded: degraded
    Default: UNKNOWN
  DiskControllerStatusTranslationTable:
    optimal: ok
    warning: degraded
    failed: failed
    ok: ok
    degraded: degraded
    Default: UNKNOWN
  LogicalDiskStatusTranslationTable:
    okay: ok
    inaccessible: failed
    impacted: degraded
    optimal: ok
    standby: ok
    rebuilding: degraded
    partitioned: ok
    failed: failed
    degraded: degraded
    hot: ok
    Default: UNKNOWN
    logical: degraded
    ready: ok
    online: ok
    suboptimal: degraded
    uninitialized: ok
