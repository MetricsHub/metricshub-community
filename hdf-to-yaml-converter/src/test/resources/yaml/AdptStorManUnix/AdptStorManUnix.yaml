---
connector:
  displayName: Adaptec - StorMan - RAID
  platforms: Any system with Adaptec
  reliesOn: arcconf
  information: Gives information about physical disks and volumes of Adaptec SAS RAID controllers through the arcconf utility.
  version: 1.0
  detection:
    connectionTypes:
    - remote
    - local
    appliesTo:
    - Solaris
    - Linux
    criteria:
    - type: deviceType
      keep:
      - Solaris
      - SunOS
      - Linux
    # We should find disks attached to one controller
    - type: osCommand
      commandLine: /bin/sh $file("embeddedFile-1")$
      expectedResult: Hard drive
      errorMessage: No Adaptec Controller with Physical Disks attached or not enough rights to execute arcconf.
sudoCommands:
- "/[opt|usr]/StorMan/arcconf"
monitors:
  disk_controller:
    discovery:
      sources:
        source(1):
          type: osCommand
          commandLine: /bin/sh $file("embeddedFile-3")$
          computes:
            # Reformat Source(1) output via EmbeddedFile(4)
            # MSHW;controllerID;status;model;serial;slot;memory;firmware;driver;batteryStatus;
          - type: awk
            script: $file("embeddedFile-4")$
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,4,5,6,7,8,9,10"
      mapping:
        # The InstanceTable
        # controllerID;model;serial;slot;memory;firmware;driver;batteryStatus;
        source: $monitors.disk_controller.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          controller_number: $column(1)
          model: $column(2)
          serial_number: $column(3)
          firmware_version: $column(6)
          driver_version: $column(7)
          info: "join(\" \", $column(4), $column(5))"
          hw.parent.type: enclosure
          name: "sprintf(\"Disk Controller: %s (%s)\", $column(1), $column(2))"
    collect:
      # Collect type is "all instances in one shot
      type: multiInstance
      sources:
        source(1):
          # Source(1) = EF4
          type: osCommand
          commandLine: /bin/sh $file("embeddedFile-3")$
          computes:
            # Reformat Source(1) output via EmbeddedFile(4)
            # MSHW;controllerID;status;model;serial;slot;memory;firmware;driver;batteryStatus;
          - type: awk
            script: $file("embeddedFile-4")$
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,10"
            # Translate the Status into a PATROL status
            # controllerID;Patrolstatus;batteryStatus;
          - type: translate
            column: 2
            translationTable: DiskControllerStatusTranslationTable
            # Translate the Status into a PATROL status
            # controllerID;Patrolstatus;PatrolBatteryStatus;
          - type: translate
            column: 3
            translationTable: ControllerBatteryStatusTranslationTable
      mapping:
        # ValueTable = Source(1)
        # controllerID;Patrolstatus;status;PatrolBatteryStatus;batteryStatus;
        source: $monitors.disk_controller.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="disk_controller"}: $column(2)
  physical_disk:
    discovery:
      sources:
        source(1):
          type: osCommand
          commandLine: /bin/sh $file("embeddedFile-1")$
          computes:
            # Reformat Source(1) output via EmbeddedFile(2)
            # MSHW;controllerID;hardDriveID;status;location;vendor;model;firmware;serialNumber;sizeGB;channel;
          - type: awk
            script: $file("embeddedFile-2")$
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,5,6,7,8,9,10,11"
            # Multiply to get Bytes
            # controllerID;hardDriveID;location;vendor;model;firmware;serialNumber;sizeB;channel;
          - type: multiply
            column: 8
            value: 1073741824
      mapping:
        # The InstanceTable
        # controllerID;hardDriveID;location;vendor;model;firmware;serialNumber;sizeB;channel;
        source: $monitors.physical_disk.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          vendor: $column(4)
          model: $column(5)
          serial_number: $column(7)
          info: "join(\" \", $column(3), $column(9))"
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $column(1))"
          name: "sprintf(\"%s (%s - %s)\", $column(2), $column(4), bytes2HumanFormatBase10($column(8)))"
        metrics:
          hw.physical_disk.size: $column(8)
    collect:
      # Collect type is "all instances in one shot
      type: multiInstance
      sources:
        source(1):
          # Source(1) = EF1
          type: osCommand
          commandLine: /bin/sh $file("embeddedFile-1")$
          computes:
            # Reformat Source(1) output via EmbeddedFile(2)
            # MSHW;controllerID;hardDriveID;status;location;vendor;model;firmware;serialNumber;sizeGB;Channel;
          - type: awk
            script: $file("embeddedFile-2")$
            keep: ^MSHW;
            separators: ;
            selectColumns: "3,4"
            # Duplicate the Status column
            # hardDriveID;Status;Status
          - type: duplicateColumn
            column: 2
            # Remove spaces in the Statys column
            # hardDriveID;Status;Status
          - type: replace
            column: 2
            existingValue: ' '
            newValue: ""
            # Translate the Status into a PATROL status
            # hardDriveID;PATROLStatus;Status
          - type: translate
            column: 2
            translationTable: DiskStatusTranslationTable
      mapping:
        # ValueTable = Source(1)
        source: $monitors.physical_disk.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="physical_disk"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
  logical_disk:
    discovery:
      sources:
        source(1):
          type: osCommand
          commandLine: /bin/sh $file("embeddedFile-5")$
          computes:
            # Reformat Source(1) output via EmbeddedFile(6)
            # MSHW;controllerID;logicaldriveID;logicaldriveName;status;size;raidLevel;statusInfo;
          - type: awk
            script: $file("embeddedFile-6")$
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,6,7"
            # Multiply to get Bytes
            # controllerID;logicaldriveID;logicaldriveName;size;raidLevel;
          - type: multiply
            column: 4
            value: 1073741824
      mapping:
        # The InstanceTable
        # controllerID;logicaldriveID;logicaldriveName;size;raidLevel;
        source: $monitors.logical_disk.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          raid_level: $column(5)
          __display_id: $column(3)
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $column(1))"
          name: "sprintf(\"%s (%s - %s)\", $column(3), $column(5), bytes2HumanFormatBase2($column(4)))"
        metrics:
          hw.logical_disk.limit: $column(4)
    collect:
      # Collect type is "all instances in one shot
      type: multiInstance
      sources:
        source(1):
          # Source(1) = EF5
          type: osCommand
          commandLine: /bin/sh $file("embeddedFile-5")$
          computes:
            # Reformat Source(1) output via EmbeddedFile(6)
            # MSHW;controllerID;logicaldriveID;logicaldriveName;status;size;raidLevel;statusInfo;
          - type: awk
            script: $file("embeddedFile-6")$
            keep: ^MSHW;
            separators: ;
            selectColumns: "3,5,8"
            # Translate the Status into a PATROL status
            # logicaldriveID;Patrolstatus;statusInfo;
          - type: translate
            column: 2
            translationTable: LogicalDiskStatusTranslationTable
      mapping:
        # ValueTable = Source(1)
        # logicaldriveID;Patrolstatus;status;
        source: $monitors.logical_disk.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="logical_disk"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
translations:
  DiskStatusTranslationTable:
    okay: ok
    inaccessible: failed
    raw: ok
    rebuilding: degraded
    failed: failed
    down: failed
    Default: UNKNOWN
    offline: failed
    device-error: failed
    unsupported: failed
    removed: failed
    ready: ok
    online: ok
    spare: ok
  ControllerBatteryStatusTranslationTable:
    discharging: ok
    maintenance mode: degraded
    optimal: ok
    over temperature: failed
    charging: ok
    charging disabled: ok
    failed: failed
    ok: ok
    degraded: degraded
    Default: UNKNOWN
  DiskControllerStatusTranslationTable:
    optimal: ok
    warning: degraded
    failed: failed
    ok: ok
    degraded: degraded
    Default: UNKNOWN
  LogicalDiskStatusTranslationTable:
    okay: ok
    inaccessible: failed
    impacted: degraded
    optimal: ok
    standby: ok
    rebuilding: degraded
    partitioned: ok
    failed: failed
    degraded: degraded
    hot: ok
    Default: UNKNOWN
    logical: degraded
    ready: ok
    online: ok
    suboptimal: degraded
    uninitialized: ok
