---
embedded:
  EmbeddedFile(1): |-
    # ENCLOSURE
    $0 ~ /Agent.Host Information/ {Section="ENC"}
    Section=="ENC" {
      if ($1 ~ /Model:/)  {SystemModel = $2}
      else if ($1 ~ /Prom/ && $2 ~ /Rev:/) {SystemFirmware = $NF}
      else if ($1 ~ /Serial/ && $2 ~ /No:/)  {SystemSerial = $NF}
      }

    # ARRAY
    $0 ~ /Array Information/ {Section="ARRAY"}
    Section=="ARRAY" {
      if ($1 ~ /Array/ && $2 ~ /Name:/) {ArrayName = $NF}
      else if ( $0 ~ /^Bus [0-9]* Enclosure [0-9]*.*State:/ || $0 ~ /^SP [A-Z0-9] State:/ || $0 ~ /^Enclosure SPE.*State:/ ) {
                                                                 ComponentID = $0 ;
                                                                 gsub(/State:/,":",ComponentID)
                                                                 gsub(/ ?:.*$/,"",ComponentID)
                                                                 ComponentIDs[ComponentID] = ComponentID;
                                                                 Type[ComponentID] = $5 ;
                                                                 if ($0 ~ /^SP [A-Z0-9] State:/) {Type[ComponentID] = "SP"};
                                                                 if (/^Enclosure SPE.*State:/) {
                                                                   Typetemp = $0
                                                                   gsub(/Enclosure SPE /,"",Typetemp) ;
                                                                   gsub(/( [^ ][^ ]?)? State:.*/,"",Typetemp) ;
                                                                   gsub(/SPS? [AB] /,"",Typetemp) ;
                                                                   Type[ComponentID] = Typetemp
                                                                   }
                                                                 Status[ComponentID] = $0
                                                                 gsub(/.*: */,"",Status[ComponentID])
                                                                 gsub(/ *$/,"",Status[ComponentID])
                                                               }
      }

    # HBA
    $0 ~ /^HBA Information/ {Section="HBA"}

    # Ports
    $0 ~ /Information about each SPPORT/ {Section="SPPORT"}
    Section=="SPPORT" {
      if ($1 ~ /SP/ && $2 ~ /Name:/) {SPName = $0; gsub(/.*: */,"",SPName);}
      else if ($1 ~ /SP/ && $2 ~ /Port/ && $3 ~ /ID:/) {SPID = $NF ; PortID = SPName " Port " SPID ; Ports[PortID] = PortID ;}
      else if ($1 ~ /Link/ && $2 ~ /Status:/) {SPLinkStatus[PortID] = $NF }
      else if ($1 ~ /Port/ && $2 ~ /Status:/) {SPPortStatus[PortID] = $NF ; SPPortStatusInformation[PortID] = $0 ; gsub(/Status: */,"", SPPortStatusInformation[PortID]) }
      else if ($1 ~ /SFP/ && $2 ~ /State:/)     {SFState[PortID] = $NF }
      else if ($1 ~ /Speed/ && $2 ~ /Value/)     {SPPortSpeed[PortID] = $NF ; gsub(/[Gg]bps/,"000",SPPortSpeed[PortID]);gsub(/[Mm]bps/,"",SPPortSpeed[PortID]);gsub(/N.A/,"",SPPortSpeed[PortID])}
      else if ($1 ~ /I.O/ && $2 ~ /Module/ && $3 ~ /Slot:/) {SPIOSlot[PortID] = "IO Module " $NF}
      else if ($1 ~ /Physical/ && $2 ~ /Port/ && $3 ~ /ID:/) {SPPhysPortID[PortID] = "Port ID " $NF}
    # (removed)  else if ($1 ~ /SP/ && $2 ~ /UID:/)     {SPUID[PortID] = "UID: "$NF }
      else if ($1 ~ /SFP.Connector/ && $2 ~ /EMC/ && $3 ~ /Part/) {SPEMCPartNumber[PortID] = "Part Number: " $NF ; gsub (/N.A$/,"",SPEMCPartNumber[PortID]) }
      else if ($1 ~ /SFP.Connector/ && $2 ~ /EMC/ && $3 ~ /Serial/) {SPEMCSerialNumber[PortID] = "Serial Number: " $NF ; gsub (/N.A$/,"",SPEMCSerialNumber[PortID])}
      else if ($1 ~ /SFP.Connector/ && $2 ~ /Vendor/ && $3 ~ /Part/) {SPVendorPartNumber[PortID] = "Alternative Part Number: " $NF ; gsub (/N.A$/,"",SPVendorPartNumber[PortID])}
      else if ($1 ~ /SFP.Connector/ && $2 ~ /Vendor/ && $3 ~ /Serial/) {SPVendorSerialNumber[PortID] = "Alternative Serial Number: " $NF ; gsub (/N.A$/,"",SPVendorSerialNumber[PortID])}
      }
    # SP Information
    $0 ~ /^SP Information/ {Section="SP"}
    Section=="SP" {
      if ($1 ~ /System/ && $2 ~ /Fault/ && $3 ~ /LED:/) {SystemFaultLED = $NF}
      }

    # PHYSICAL DISK
    $0 ~ /All Disks Information/ {Section="PD"}
    Section=="PD" {
      if ($0 ~ /^Bus [0-9]+ Enclosure [0-9]+ +Disk [A-Za-z0-9]+$/) {DiskID = $0; DiskIDs[DiskID]= DiskID;}
      else if ($1 ~ /Vendor/ && $2 ~ /Id:/) {DiskVendor[DiskID] = $NF}
      else if ($1 ~ /State/) {DiskState[DiskID] = $NF ; DiskStateInformation[DiskID] = $0 ; gsub(/.*State:? */,"", DiskStateInformation[DiskID])}
      else if ($1 ~ /Capacity:/) {Size[DiskID] = $NF}
      else if ($1 ~ /Product/ && $2 ~ /Id:/)  {DiskModel[DiskID] = $0; gsub(/.*: */,"",DiskModel[DiskID])}
      else if ($1 ~ /Product/ && $2 ~ /Revision:/) {DiskRevision[DiskID] = $NF}
      else if ($1 ~ /Clariion/ && $2 ~ /TLA/ && $3 ~ /Part/) {DiskTLAPartNumber[DiskID] =  $NF; gsub (/Number:/,"",DiskTLAPartNumber[DiskID]) ;
                                                                     gsub (/PWR$/,"",DiskTLAPartNumber[DiskID]) ;
                                                                     DiskTLAPartNumber[DiskID] = "Alternative Part Number: " DiskTLAPartNumber[DiskID] }
      else if ($1 ~ /Clariion/ && $2 ~ /Part/ && $3 ~ /Number:/) {DiskPartNumber[DiskID] = "Part Number: "$NF}
      }
    # Raid Group
    $0 ~ /All RAID Groups Information/ {Section="RG"}
    Section=="RG" {
      if ($1 ~ /RaidGroup/ && $2 ~ /ID/) {LDiskID = "RAIDGroup-" $NF ;LDiskIDs[LDiskID]= LDiskID; LDiskName[LDiskID] = LDiskID;}
      else if ($1 ~ /RaidGroup/ && $2 ~ /Type/) {LDiskRaid[LDiskID] = $NF}
      else if ($1 ~ /RaidGroup/ && $2 ~ /State/) {State = $0 ; gsub(/.*: */,"",State); LDiskState[LDiskID] = LDiskState[LDiskID] "|" State
                                                       endofState = 0;
                                                       while (endofState=="0") {getline
                                                                                   if( $0 ~ /:/ ) {endofState = 1}
                                                                                   else {State = $0 ; gsub(/ */,"",State);
                                                                                         LDiskState[LDiskID] = LDiskState[LDiskID] "|" State
                                                                                        }
                                                                                  }
                                                      }
      }

    # Raid Group (LUNs)
    # Get additional RG status information from its LUNs
    $0 ~/LOGICAL UNIT NUMBER/ {Section="LUN"}
    Section=="LUN" {
      if ($1 ~ /RAIDGroup/ && $2 ~ /ID/) { LDiskID = "RAIDGroup-" $NF  ;}
      else if ($1 ~ /State/) { State = $0 ; gsub(/.*: */,"",State);
                                     # A faulted LUN Raid Group is just a degraded one
                                     if ( tolower(State) ~ /faulted/) { State = "Degraded" }
                                     LDiskState[LDiskID] = LDiskState[LDiskID] "|" State
                                     LDiskID = ""
                                   }
      }

    # Storage Pools
    $1 ~ /Pool/ && $2 ~ /Name:/ {Section="SPOOL"; PoolName = $0 ; gsub(/.*: */,"",PoolName) }
    Section=="SPOOL" {
      if ($1 ~ /Pool/ && $2 ~ /ID/) { LDiskID = "StoragePool-" $NF ; LDiskIDs[LDiskID] = LDiskID ; LDiskName[LDiskID] = PoolName }
      else if ($1 ~ /Raid/ && $2 ~ /Type/) {LDiskRaid[LDiskID] = $NF}
      else if ($1 ~ /State/) {LDiskState[LDiskID] = $NF}
      }

    # Resume Information
    $0 ~ /Resume Information/ {Section="FRU"}
    $0 !~ /:/ && Section != "NAS" {ComponentID=""}
    #SP
    Section=="FRU" {
      if ($1 ~ /SP/ && $2 ~ /[A-Z]/) { ComponentID = "SP " $2 ; Type[ComponentID]="SP"}
    #For non-SP, set StorageProcessor
      else if ($1 ~ /Storage/ && $2 ~ /Processor/ && $3 ~ /^[A-Z]$/) {StorageProcessor = $3}
    #For power supplies and LCC, Set the Location aswell
      else if ($0 ~ /Bus [0-9] Enclosure [0-9]/) {Location = $0}
      else if ($0 ~ /Enclosure SPE/) {Location = $0}
      else if ($1 ~ /Power/ && $2 ~ /^[A-Z][A-Z0-9]?$/) {StorageProcessor = $2 ; ComponentID = Location " Power " StorageProcessor ; Type[ComponentID] = "Power"}
      else if ($1 ~ /Standby/ && $2 ~ /Power/ && $3 ~ /Supply/) { ComponentID = "Enclosure SPE SPS " StorageProcessor ; Type[ComponentID] = "SPS" }
      else if ($1 ~ /Management/ && $2 ~ /Module/) { ComponentID = Location " Management Module " $3 ; Type[ComponentID] = "SPS" }
      else if ($1 ~ /Fan/ && $2 ~ /[0-9]/) { ComponentID = Location " Fan " $2 ; Type[ComponentID] = "FAN" }
      else if ($1 ~ /LCC/ && $2 ~ /^[A-Z]$/) {StorageProcessor = $2 ; ComponentID = Location " LCC " StorageProcessor ; Type[ComponentID] = "LCC"}
      else if ($1 ~ /ICM/ && $2 ~ /^[A-Z]$/) {StorageProcessor = $2 ; ComponentID = Location " ICM " StorageProcessor ; Type[ComponentID] = "ICM"}
      else if ($1 ~ /CPU/ && $2 ~ /Module/) { ComponentID = "Bus 0 Enclosure 0 CPU Module " StorageProcessor ; Type[ComponentID] = "CPU"
                                              ComponentID2 = "Enclosure SPE CPU Module " StorageProcessor ; Type[ComponentID] = "CPU"
                                            }
      else if ($1 ~ /I.O/ && $2 ~ /Module/) { ComponentID = "Bus 0 Enclosure 0 SP " StorageProcessor " I/O Module " $3 ; Type[ComponentID] = "IOM"
                                              ComponentID2 = "Enclosure SPE SP " StorageProcessor " I/O Module " $3 ; Type[ComponentID2] = "IOM"
                                            }
      else if ($1 ~ /EMC/ && $2 ~ /Part/ && $3 ~ /Number:/) {ComponentPartNumber[ComponentID] = "Part Number: " $NF
                                                             ComponentPartNumber[ComponentID2] = ComponentPartNumber[ComponentID]
                                                            }
      else if ($1 ~ /EMC/ && $2 ~ /Serial/ && $3 ~ /Number:/) {ComponentSerialNumber[ComponentID] = "Serial Number: " $NF
                                                               ComponentSerialNumber[ComponentID2] = ComponentSerialNumber[ComponentID]
                                                              }
      else if ($1 ~ /EMC/ && $2 ~ /Assembly/ && $3 ~ /Revision:/) {ComponentRevision[ComponentID] = "Version: "$NF
                                                                   ComponentRevision[ComponentID2] = ComponentRevision[ComponentID]
                                                                  }
      else if ($1 ~ /Assembly/ && $2 ~ /Name:/) {ComponentDescription[ComponentID] = $0; gsub(/^.*: */,"",ComponentDescription[ComponentID])
                                                 ComponentDescription[ComponentID2] = ComponentDescription[ComponentID]
                                                }
      }

    $0 ~ /All logical Units Information/ {Section="LD"}
    $0 ~ /Snap View Information/ {Section="SV"}

    # Process output of nas_inventory
    $0 ~ /MS_HW_NAS_INVENTORY_START/ {Section="NAS"}
    Section=="NAS" {
      if ($1 ~ /Component/ && $2 ~ /Name/) {
        ComponentID  = $0 ; gsub(/.* = /,"",ComponentID )
        if (ComponentID ~ /^Shelf/) {
              Bus = ComponentID
              gsub(/Shelf /,"",Bus)
              gsub("/.*","",Bus)
              Enclosure = ComponentID
              gsub("Shelf [0-9]+/","",Enclosure)
              gsub(" .*","",Enclosure)
            ComponentDetails = ComponentID
            gsub("Shelf [0-9]+/[0-9]+ ","",ComponentDetails)
            ComponentID = "Bus " Bus " Enclosure " Enclosure " " ComponentDetails
            }
        if (ComponentID ~ /Power Supply/) { gsub(/Power Supply/,"Power",ComponentID) }
        }
      else if ($1 ~ /Type/) { ComponentType = $0 ; gsub(/.* = /,"",ComponentType )  }
      else if ($1 ~ /Status/) { ComponentStatus = $0 ; gsub(/.* = /,"",ComponentStatus ) ; gsub(/[(].*/,"",ComponentStatus) ; gsub(/Error.*: /,"",ComponentStatus) }
      else if ($1 ~ /Variant/) { Description = $0 ; gsub(/.* = /,"",Description )}
      else if ($1 ~ /Version/) { Version = $0 ; gsub(/.* = /,"",Version )}
      else if ($1 ~ /Serial/) { SerialNumber = $0 ; gsub(/.* = /,"",SerialNumber )}
      else if ($1 ~ /Part/) { PartNumber = $0 ; gsub(/.* = /,"",PartNumber )}
      else if ($0 ~ /EMC_PART_NUMBER/) { PartNumber = $0 ; gsub(/.*EMC_PART_NUMBER:/,"",PartNumber )}
      else if ($0 ~ /EMC_ASSEMBLY_REVISION/) { Revision = $0 ; gsub(/.*EMC_ASSEMBLY_REVISION:/,"",Revision ) }
      else if ($0 ~ /DIMM_TYPE/) { DimmType = $0 ; gsub(/.*DIMM_TYPE:/,"",DimmType )}

      # Create a fake Logical Disk to indicate Navisphere CLI failures
      else if ($0 ~ /MS_HW_NAS_NaviSphereCLI_Failure/) { print "MSHW_LOGICALDISK;NaviSphere CLI Failure;ALARM;Unknown login error for block side of system, see debug;;NaviSphere CLI Failure;"}
      else if ($0 ~ /MS_HW_NAS_Authentication_failed/) { print "MSHW_LOGICALDISK;NaviSphere CLI Failure;ALARM;Authentication failed for block side of system;;NaviSphere CLI Failure;"}
      else if ($0 ~ /MS_HW_NAS_No_SP_In_Hosts/) { print "MSHW_LOGICALDISK;NaviSphere CLI Failure;ALARM;No SP addresses in /etc/hosts file;;NaviSphere CLI Failure;"}
      else if ($0 ~ /MS_HW_NAS_Authentication_blocked/) { print "MSHW_LOGICALDISK;NaviSphere CLI Failure;ALARM;Excessive failed authentication attempts for block side of system;;NaviSphere CLI Failure;"}
      else if ($0 ~ /MS_HW_NAS_Not_Compatible/) { print "MSHW_LOGICALDISK;NaviSphere CLI Failure;ALARM;Connector not compatible with this version of the KM;;NaviSphere CLI Failure;"}
      else if ($0 ~ /MS_HW_NAS_INVENTORY_END/ || $1 ~ /Location/) {
        if (toupper(ComponentType) ~ /VNX/ || ComponentType ~ /Clar/ || ComponentType ~ /Celerra/) {
            SystemModel = Description
            SystemFirmware = Version
            SystemSerial = SerialNumber
            }
        else if (ComponentType ~ /Disk/) {
            DiskID = ComponentID
            gsub(/ Disk/,"  Disk",DiskID)
            DiskIDs[DiskID]=DiskID
            if (DiskState[DiskID] == "") {DiskState[DiskID]=ComponentStatus}
            DiskRevision[DiskID]=Version
            DiskTLAPartNumber[DiskID]=PartNumber
            DiskSerialNumber=SerialNumber
            }
        else {
            ComponentIDs[ComponentID] = ComponentID;
            if (ComponentType != "") { Type[ComponentID] = ComponentType }
            if (PartNumber != "") { ComponentPartNumber[ComponentID] = PartNumber }
            if (SerialNumber != "") { ComponentSerialNumber[ComponentID] = SerialNumber }
            if (Revision != "") { ComponentRevision[ComponentID] = Revision }
            if (DimmType != "") {
                                 if (DimmType ~ /MB$/) { DimmArraySize = split(DimmType,DimmArray," ")
                                                         DimmSize = DimmArray[DimmArraySize]
                                                         gsub(DimmSize,"",DimmType);
                                                         gsub(/MB/,"",DimmSize)
                                                         ComponentDimmSize[ComponentID] = DimmSize
                                                         ComponentDimmType[ComponentID] = DimmType
                                                       }
                                 else {ComponentDimmType[ComponentID] = DimmType }
                                }
            if (Description != "") { ComponentDescription[ComponentID] = Description }
            if (ComponentStatus != "" && Status[ComponentID] == "") { Status[ComponentID] = ComponentStatus }
            }
        ComponentType = ""
        ComponentStatus = ""
        Description = ""
        Version = ""
        SerialNumber = ""
        PartNumber = ""
        Revision = ""
        DimmType = ""
        }
      }
    # We will now process the previous discovery (if available).
    # If the status of a physical disk is removed then we will replace that disk's information with that of the previous discover
    $0 ~ /^MSHW_PHYDISK/ {
      # Split the line (see print below to know the fields)
      split($0,PHYDISKArray,";")
      DiskID=PHYDISKArray[2]
      if ( tolower(DiskState[DiskID]) ~ /removed/ ) {
        # If current information is empty, replace with that of last discovery
        if ( DiskVendor[DiskID] !~ /.../ ) { DiskVendor[DiskID] = PHYDISKArray[3] }
        if ( DiskModel[DiskID] !~ /.../ ) { DiskModel[DiskID] = PHYDISKArray[5] }
        if ( DiskRevision[DiskID] !~ /.../ ) { DiskRevision[DiskID] = PHYDISKArray[6] }
        if ( DiskTLAPartNumber[DiskID] !~ /.../ ) { DiskTLAPartNumber[DiskID] = PHYDISKArray[7] }
        if ( DiskPartNumber[DiskID] !~ /.../ ) { DiskPartNumber[DiskID] = PHYDISKArray[8] }
        if ( Size[DiskID] !~ /.../ ) { Size[DiskID] = PHYDISKArray[9] }
      }
    }


    END{
    # ENCLOSURE
    print "MSHW_ENCLOSURE;" SystemModel ";" SystemSerial ";" "Prom Rev:" SystemFirmware ";" SystemFaultLED ";"
    # PHYSICAL DISK
    for (DiskID in DiskIDs) { if (DiskID != "") {
          print "MSHW_PHYDISK;" DiskID ";" DiskVendor[DiskID] ";" DiskState[DiskID] ";" DiskStateInformation[DiskID] ";" DiskModel[DiskID] ";" DiskRevision[DiskID] ";" DiskTLAPartNumber[DiskID] ";"  DiskPartNumber[DiskID] ";" Size[DiskID] ";"
        }
        }

    # LOGICAL DISK
    for (LDiskID in LDiskIDs) { print "MSHW_LOGICALDISK;" LDiskID ";" LDiskState[LDiskID] ";" LDiskState[LDiskID] ";" LDiskRaid[LDiskID] ";" LDiskName[LDiskID] ";"}

    # Components
    for (ComponentID in ComponentIDs) { if (ComponentID != "" && Status[ComponentID] != "" ) {
      if(Type[ComponentID] != "DIMM") {
          print "MSHW_OTHER;" Type[ComponentID] ";" ComponentID ";" Status[ComponentID] ";" ComponentPartNumber[ComponentID] ";" ComponentSerialNumber[ComponentID] ";" ComponentRevision[ComponentID] ";" ComponentDescription[ComponentID] ";"
          }
      else {
          print "MSHW_OTHER;" Type[ComponentID] ";" ComponentID ";" Status[ComponentID] ";" ComponentPartNumber[ComponentID] ";" ComponentSerialNumber[ComponentID] ";" ComponentRevision[ComponentID] ";" ComponentDescription[ComponentID] ";" ComponentDimmSize[ComponentID] ";" ComponentDimmType[ComponentID] ";"
          }
      }
      }

    # Ports
    for (PortID in Ports) { if (PortID != "") {
        FRU = ""
        if ( SPEMCPartNumber[PortID] != "" ) { FRU = SPEMCPartNumber[PortID] " - " }
      if ( SPEMCSerialNumber[PortID] != "" ) { FRU = FRU SPEMCSerialNumber[PortID] " - " }
      if ( SPVendorPartNumber[PortID] != "" ) { FRU = FRU SPVendorPartNumber[PortID] " - " }
      if ( SPVendorSerialNumber[PortID] != "" ) { FRU = FRU SPVendorSerialNumber[PortID]}
      gsub (/ - $/,"",FRU)
      Location = ""
      if (SPIOSlot[PortID] != "" && SPPhysPortID[PortID] != "") { Location = "Location: " SPIOSlot[PortID] " " SPPhysPortID[PortID] }
      print "MSHW_PORT;" PortID ";" SPLinkStatus[PortID] ";" SPPortStatus[PortID] ";" SPPortStatusInformation[ID] ";" SFState[PortID] ";"SPPortSpeed[PortID] ";" Location ";"   ";" FRU ";"
      }
    }
    }
translations:
  SFPPortStatusTT:
    default: failed
    online: ok
    disabled: ok
  SPPortStatusTT:
    default: failed
    online: ok
    disabled: ok
  RaidGroupStatusInformationTranslationTable:
    expanding: ""
    halted: Halted
    valid states are invalid: Valid States are Invalid
    defragmenting: ""
    valid_luns: ""
    busy: ok
    invalid: Invalid
    explicit_remove: ""
    degraded: Degraded
  systemStatusTranslationTable:
    default: UNKNOWN
    "off": ok
    "on": degraded
  StatusTT:
    expanding: ok
    unbound: ok
    rebuilding: degraded
    binding: ok
    no_mirror: degraded
    unformatted: degraded
    enabled: ok
    empty: failed
    valid: ok
    default: UNKNOWN
    '*fault*': failed
    unsupported: failed
    ready: ok
    up: ok
    power: ok
    ok: ok
    spare: ok
    normal: ok
    faulted: failed
    bound: ok
    fault: failed
    failed: failed
    degraded: degraded
    "off": failed
    bypass: failed
    removed: failed
    transitioning: ok
    attention: degraded
    online: degraded
    alerts.: failed
    present: ok
    equalizing: ok
    formatting: degraded
  systemStatusInformationTranslationTable:
    default: Unknown System Fault LED Status
    "off": System Fault LED OFF
    "on": System Fault LED ON
  SPLinkStatusTT:
    default: UNKNOWN
    up: ok
    down: degraded
  RaidGroupStatusTranslationTable:
    expanding: ok
    unbound: ok
    rebuilding: degraded
    no_mirror: degraded
    enabled: ok
    empty: failed
    valid: ok
    '*fault*': failed
    ready: ok
    busy: ok
    ok: ok
    halted: failed
    normal: ok
    faulted: failed
    bound: ok
    fault: failed
    failed: failed
    degraded: degraded
    valid states are invalid: degraded
    removed: failed
    defragmenting: ok
    valid_luns: ok
    invalid: degraded
    attention: degraded
    online: degraded
    explicit_remove: ok
    present: ok
monitors:
  enclosure:
    discovery:
      sources:
        source(3):
          computes:
          # Process the naviseccli command through an AWK script
          - type: awk
            script: EmbeddedFile(1)
            keep: ^MSHW
            separators: ;
        source(4):
          # Enclosure Source 2 = Copy of Source 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(3)$
          computes:
            # Keep only Enclosures
            # MS_HW_Enclosure;SystemModel;SerialNumber;SystemFirmware;SystemFaultLED;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_ENCLOSURE$
      mapping:
        # The discovery table
        # MS_HW_Enclosure;SystemModel;SerialNumber;SystemFirmware;SystemFaultLED;
        source: $monitors.enclosure.discovery.sources.source(4)$
        attributes:
          id: $column(3)
          __display_id: $column(3)
          serial_number: $column(3)
          model: $column(2)
          vendor: EMC
          type: Storage
          name: "sprintf(\"%s (%s %s - %s)\", $column(3), \"EMC\", $column(2), \"Storage\")"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(3):
          computes:
          # Process the naviseccli command through an AWK script
          - type: awk
            script: EmbeddedFile(1)
            keep: ^MSHW
            separators: ;
        source(4):
          # Enclosure Source 2 = Copy of Source 1
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
          computes:
            # Keep only Enclosures
            # MS_HW_Enclosure;SystemModel;SerialNumber;SystemFirmware;SystemFaultLED;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_ENCLOSURE$
            # Duplicate status, because we will translate it two times
            # MS_HW_Enclosure;SystemModel;SerialNumber;SystemFirmware;SystemFaultLED;SystemFaultLED;
          - type: duplicateColumn
            column: 5
            # Translate Status into PATROLStatus
            # MS_HW_Enclosure;SystemModel;SerialNumber;SystemFirmware;PATROLStatus;SystemFaultLED;
          - type: translate
            column: 5
            translationTable: systemStatusTranslationTable
            # Translate second Status into more readable string
            # MS_HW_Enclosure;SystemModel;SerialNumber;SystemFirmware;PATROLStatus;StatusInformation;
          - type: translate
            column: 6
            translationTable: systemStatusInformationTranslationTable
        source(5):
          # Take a copy of the last discovery for the next discovery to use
          type: copy
          from: $monitors.enclosure.discovery.sources.source(3)$
      mapping:
        # ValueTable = Source(2)
        source: $monitors.enclosure.collect.sources.source(4)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="enclosure"}: $column(5)
        legacyTextParameters:
          StatusInformation: $column(6)
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(3)$
          computes:
            # Keep only PhysicalDisk
            # MSHW_PHYDISK;DiskID;DiskVendor;DiskState;DiskStatusInformation;DiskModel;DiskRevision;DiskTLAPartNumber;DiskPartNumber;Size;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PHYDISK$
            # Convert Size from Mbytes to bytes
            # MSHW_PHYDISK;DiskID;DiskVendor;DiskState;DiskStatusInformation;DiskModel;DiskRevision;DiskTLAPartNumber;DiskPartNumber;Size;
          - type: multiply
            column: 10
            value: 1048576
            # Exclude Empty Disk Slots
            # MSHW_PHYDISK;DiskID;DiskVendor;DiskState;DiskStatusInformation;DiskModel;DiskRevision;DiskTLAPartNumber;DiskPartNumber;Size;
          - type: excludeMatchingLines
            column: 4
            valueList: Empty
      mapping:
        # The discovery table
        # MSHW_PHYDISK;DiskID;DiskVendor;DiskState;DiskStateInformation;DiskModel;DiskRevision;DiskTLAPartNumber;DiskPartNumber;Size;
        source: $monitors.physical_disk.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          __display_id: $column(2)
          vendor: $column(3)
          model: $column(6)
          firmware_version: $column(7)
          info: "join($column(8), $column(9), \" \")"
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s - %s)\", $column(2), $column(6), $column(10))"
        metrics:
          hw.physical_disk.size: $column(10)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
          computes:
            # Keep only Physical Disks
            # MSHW_PHYDISK;DiskID;DiskVendor;DiskState;DiskStatusInformation;DiskModel;DiskRevision;DiskTLAPartNumber;DiskPartNumber;Size;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PHYDISK$
            # Now translate  into OK/Warning/Alarm
            # MSHW_PHYDISK;DiskID;DiskVendor;DiskState;DiskStatusInformation;DiskModel;DiskRevision;DiskTLAPartNumber;DiskPartNumber;Size;
          - type: translate
            column: 4
            translationTable: StatusTT
      mapping:
        # Value Table
        # MSHW_PHYDISK;DiskID;DiskVendor;DiskState;DiskStatusInformation;DiskModel;DiskRevision;DiskTLAPartNumber;DiskPartNumber;Size;
        source: $monitors.physical_disk.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="physical_disk"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(5)
  power_supply:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(3)$
          computes:
            # Keep only "OTHER"
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHER$
            # Keep only "Power"
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 2
            regExp: ^Power$
            # Exclude Empty
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: excludeMatchingLines
            column: 4
            valueList: Empty
      mapping:
        # The discovery table
        # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
        source: $monitors.power_supply.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(3)
          power_supply_type: $column(8)
          info: "join($column(5), $column(6), $column(7), \" \")"
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s)\", $column(3), $column(8))"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
          computes:
            # Keep only PowerSupply
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHER$
            # Duplicate the State
            # MSHW_OTHER;Type;ComponentID;Status;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: duplicateColumn
            column: 4
            # Now translate  into OK/Warning/Alarm
            # MSHW_OTHER;Type;ComponentID;PatrolStatus;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: translate
            column: 4
            translationTable: StatusTT
      mapping:
        # Value Table
        # MSHW_OTHER;Type;ComponentID;PatrolStatus;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
        source: $monitors.power_supply.collect.sources.source(1)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="power_supply"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(5)
  memory:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(3)$
          computes:
            # Keep only "OTHER"
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;Size;Type;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHER$
            # Keep only "DIMM"
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;Size;Type;
          - type: keepOnlyMatchingLines
            column: 2
            regExp: ^DIMM$
            # Exclude Empty
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;Size;Type;
          - type: excludeMatchingLines
            column: 4
            valueList: Empty
          - type: leftConcat
            column: 5
            value: "Part Number: "
          - type: leftConcat
            column: 7
            value: "Version: "
      mapping:
        # The discovery table
        # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;Size;Type;
        source: $monitors.memory.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(3)
          serial_number: $column(6)
          model: $column(8)
          type: $column(10)
          info: "join($column(5), $column(7), \" \")"
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s - %s - %s)\", $column(3), $column(8), $column(10), $column(9))"
        metrics:
          hw.memory.limit: mebiByte2Byte($column(9))
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
          computes:
            # Keep only Memory
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHER$
            # Duplicate the State
            # MSHW_OTHER;Type;ComponentID;Status;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: duplicateColumn
            column: 4
            # Now translate  into OK/Warning/Alarm
            # MSHW_OTHER;Type;ComponentID;PatrolStatus;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: translate
            column: 4
            translationTable: StatusTT
      mapping:
        # Value Table
        # MSHW_OTHER;Type;ComponentID;PatrolStatus;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
        source: $monitors.memory.collect.sources.source(1)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="memory"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(5)
  cpu:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(3)$
          computes:
            # Keep only "OTHER"
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHER$
            # Keep only "DIMM"
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 2
            regExp: ^CPU$
            # Exclude Empty
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: excludeMatchingLines
            column: 4
            valueList: Empty
          - type: leftConcat
            column: 6
            value: "SerialNumber: "
      mapping:
        # The discovery table
        # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
        source: $monitors.cpu.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(3)
          model: $column(8)
          info: "join($column(5), $column(7), $column(6), \" \")"
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s)\", $column(3), $column(8))"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
          computes:
            # Keep only CPU
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHER$
            # Duplicate the State
            # MSHW_OTHER;Type;ComponentID;Status;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: duplicateColumn
            column: 4
            # Now translate  into OK/Warning/Alarm
            # MSHW_OTHER;Type;ComponentID;PatrolStatus;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: translate
            column: 4
            translationTable: StatusTT
      mapping:
        # Value Table
        # MSHW_OTHER;Type;ComponentID;PatrolStatus;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
        source: $monitors.cpu.collect.sources.source(1)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="cpu"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(5)
  other_device:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(3)$
          computes:
            # Keep only "OTHER"
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHER$
            # Keep only non DIMM / CPU
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: excludeMatchingLines
            column: 2
            valueList: "DIMM,CPU,Power"
            # Exclude Empty
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: excludeMatchingLines
            column: 4
            valueList: Empty
          - type: leftConcat
            column: 5
            value: "Part Number: "
          - type: leftConcat
            column: 6
            value: "Serial Number: "
      mapping:
        # The discovery table
        # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
        source: $monitors.other_device.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(3)
          device_type: $column(8)
          info: "join($column(5), $column(6), $column(7), \" \")"
          hw.parent.type: enclosure
          name: "sprintf(\"%s: %s\", $column(8), $column(3))"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
          computes:
            # Keep only OtherDevice
            # MSHW_OTHER;Type;ComponentID;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_OTHER$
            # Duplicate the State
            # MSHW_OTHER;Type;ComponentID;Status;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: duplicateColumn
            column: 4
            # Now translate  into OK/Warning/Alarm
            # MSHW_OTHER;Type;ComponentID;PatrolStatus;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
          - type: translate
            column: 4
            translationTable: StatusTT
      mapping:
        # Value Table
        # MSHW_OTHER;Type;ComponentID;PatrolStatus;Status;ComponentPartNumber;ComponentSerialNumber;ComponentRevision;ComponentDescription;
        source: $monitors.other_device.collect.sources.source(1)$
        deviceId: $column(3)
        metrics:
          hw.status{hw.type="other_device"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(5)
  logical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(3)$
          computes:
            # Keep only LogicalDisk
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_LOGICALDISK$
      mapping:
        # Discovery Table
        source: $monitors.logical_disk.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          __display_id: $column(6)
          raid_level: $column(5)
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s)\", $column(6), $column(5))"
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Split LogicalDisks into NaviSphereCLI Warnings (From Celerra Connector and Real Logical Disks)
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
          computes:
          # Keep only NaviSphereCLI Warnings.  These are pre-translated
          - type: keepOnlyMatchingLines
            column: 2
            regExp: ^NaviSphere CLI Failure$
        source(2):
          # Split LogicalDisks into NaviSphereCLI Warnings (From Celerra Connector and Real Logical Disks)
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
          computes:
            # Keep only RAIDGroups
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: keepOnlyMatchingLines
            column: 2
            regExp: ^RAIDGroup-
            # Translate the first status array into a patrol status array
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: arrayTranslate
            column: 3
            translationTable: RaidGroupStatusTranslationTable
            # Translate the second status array into a status information array
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: arrayTranslate
            column: 4
            translationTable: RaidGroupStatusInformationTranslationTable
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: convert
            column: 3
            conversion: array2SimpleStatus
        source(3):
          # Split LogicalDisks into NaviSphereCLI Warnings (From Celerra Connector and Real Logical Disks)
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
          computes:
            # Keep Only Logical Disks
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_LOGICALDISK$
            # Exclude RAIDGroups
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: excludeMatchingLines
            column: 2
            regExp: ^RAIDGroup-
            # Exclude NaviSphereCLI Warnings.  These are pre-translated
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: excludeMatchingLines
            column: 2
            regExp: ^NaviSphere CLI Failure$
            # Now translate  into OK/Warning/Alarm
            # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
          - type: translate
            column: 3
            translationTable: StatusTT
        source(4):
          # Union 1 and 2 and 3
          type: tableUnion
          tables:
          - $monitors.logical_disk.collect.sources.source(1)$
          - $monitors.logical_disk.collect.sources.source(2)$
          - $monitors.logical_disk.collect.sources.source(3)$
      mapping:
        # Value Table
        # MSHW_LOGICALDISK;ID;Status;StatusInformation;RaidLevel;Name;
        source: $monitors.logical_disk.collect.sources.source(4)$
        deviceId: $column(2)
        metrics:
          hw.status{hw.type="logical_disk"}: $column(3)
        legacyTextParameters:
          StatusInformation: $column(4)
  network:
    discovery:
      sources:
        source(1):
          # Source(1) = Enclosure Discovery 1
          type: copy
          from: $monitors.enclosure.discovery.sources.source(3)$
          computes:
            # Keep only NetworkCards
            # MSHW_PORT;PortID;SPLinkStatus;SPPortStatus;StatusInformation;SFState;SPPortSpeed;Location;SPUID[PortID];FRU;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PORT$
            # Exclude ports with no SFP
            # MSHW_PORT;PortID;SPLinkStatus;SPPortStatus;StatusInformation;SFState;SPPortSpeed;Location;SPUID[PortID];FRU;
          - type: excludeMatchingLines
            column: 6
            valueList: None
          - type: leftConcat
            column: 8
            value: "Location: "
          - type: leftConcat
            column: 10
            value: "Part Number: "
          - type: leftConcat
            column: 9
            value: "SPUID: "
      mapping:
        # The discovery table
        # MSHW_PORT;PortID;SPLinkStatus;SPPortStatus;StatusInformation;SFState;SPPortSpeed;Location;SPUID[PortID];FRU;
        source: $monitors.network.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          __display_id: $column(2)
          info: "join($column(8), $column(10), $column(9), \" \")"
          hw.parent.type: enclosure
          name: $column(2)
    collect:
      # Collect type: MultiInstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = Enclosure Collect 1
          type: copy
          from: $monitors.enclosure.collect.sources.source(3)$
          computes:
            # Keep only DiskControllers
            # MSHW_PORT;PortID;SPLinkStatus;SPPortStatus;SFState;SPPortSpeed;Location;SPUID[PortID];FRU;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: ^MSHW_PORT$
            # Now translate SPLinkStatus into OK/Warning/Alarm
            # MSHW_PORT;PortID;PATROLSPLinkStatus;SPPortStatus;SFState;SPPortSpeed;Location;SPUID[PortID];FRU;
          - type: translate
            column: 3
            translationTable: SPLinkStatusTT
          # Add SPPortStatus to Status Information
          - type: leftConcat
            column: 5
            value: Column(4)
            # Translate the Port Status
            # MSHW_PORT;PortID;SPLinkStatus;SPPortStatus;StatusInformation;SFState;SPPortSpeed;Location;SPUID[PortID];FRU;
          - type: translate
            column: 4
            translationTable: SPPortStatusTT
          # Add Port Status to Status Information
          - type: leftConcat
            column: 5
            value: "Port Status: "
          # Add SFP State to Status Information
          - type: rightConcat
            column: 5
            value: " - SFP State: "
          # Add SFState value to the Status Information
          - type: rightConcat
            column: 5
            value: Column(6)
            # Translate the Port Status
            # MSHW_PORT;PortID;SPLinkStatus;SPPortStatus;StatusInformation;SFState;SPPortSpeed;Location;SPUID[PortID];FRU;
          - type: translate
            column: 6
            translationTable: SFPPortStatusTT
            # Add the SFState to the SPPortStatus and Convert to SimpleStatus
            # MSHW_PORT;PortID;SPLinkStatus;SPPortStatus;StatusInformation;SFState;SPPortSpeed;Location;SPUID[PortID];FRU;
          - type: leftConcat
            column: 4
            value: '|'
          - type: leftConcat
            column: 4
            value: Column(6)
          - type: convert
            column: 4
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        source: $monitors.network.collect.sources.source(1)$
        deviceId: $column(2)
        metrics:
          hw.network.up: legacyLinkStatus($column(3))
          hw.network.bandwidth.limit: megaBit2Bit($column(7))
          hw.status{hw.type="network"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(5)
