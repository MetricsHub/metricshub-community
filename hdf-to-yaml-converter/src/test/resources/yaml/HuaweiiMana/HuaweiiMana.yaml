---
connector:
  displayName: Huawei Servers - Management Card
  platforms: Huawei
  reliesOn: Huawei iMana or iBMC Management Card
  version: 1.0
  information: This connector provides hardware monitoring through Huawei iMana Management Card using SNMP.
  detection:
    connectionTypes:
    - remote
    - local
    appliesTo:
    - OOB
    supersedes:
    - IpmiTool
    criteria:
    # check that we got at least one CPU declared here
    - type: snmpGetNext
      oid: 1.3.6.1.4.1.2011.2.235.1.1.15.50
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Get the model name
          # ModelName;SerialNumber;DeviceSlotID;
          type: snmpTable
          oid: 1.3.6.1.4.1.2011.2.235.1.1.1
          selectColumns: "6,7,15"
      mapping:
        # InstanceTable = Source(5)
        source: "${source::monitors.enclosure.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $3
          vendor: Huawei
          model: $1
          type: Computer
          serial_number: $2
          name: "${awk::sprintf(\"Computer: %s (%s %s)\", $3, \"Huawei\", $1)}"
    collect:
      # Collect type is mono-instance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Get a list of Enclosures
          # State;PowerConsumption;DeviceSlotID;
          type: snmpTable
          oid: 1.3.6.1.4.1.2011.2.235.1.1.1
          selectColumns: "1,13,15"
          computes:
            # Duplicate status, because we will translate it two times
            # State;State;PowerConsumption;DeviceSlotID;
          - type: duplicateColumn
            column: 1
            # Translate Status into PATROLStatus
            # PatrolStatus;State;PowerConsumption;DeviceSlotID;
          - type: translate
            column: 1
            translationTable: "${translation::StatusTranslationTable}"
            # Translate second Status into more readable string
            # PatrolStatus;StatusInformation;PowerConsumption;DeviceSlotID;
          - type: translate
            column: 2
            translationTable: "${translation::StatusInformationTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        # PatrolStatus;StatusInformation;PowerConsumption;DeviceSlotID;
        source: "${source::monitors.enclosure.collect.sources.source(1)}"
        attributes:
          id: $4
        metrics:
          hw.enclosure.power: $3
          hw.enclosure.energy: fakeCounter($3)
          hw.status{hw.type="enclosure"}: $1
        legacyTextParameters:
          StatusInformation: $2
  cpu:
    discovery:
      sources:
        source(1):
          # Source(1) = cpuDescriptionEntry SNMP table
          # ID;Manufacturer;Family;Type;ClockRate;DeviceName;
          type: snmpTable
          oid: 1.3.6.1.4.1.2011.2.235.1.1.15.50.1
          selectColumns: "1,2,3,4,5,10"
          computes:
            # Remove (R) from Manufacturer and Family
            # ID;Manufacturer;Family;Type;ClockRate;DeviceName;
          - type: replace
            column: 2
            existingValue: (R)
            newValue: ""
          - type: replace
            column: 3
            existingValue: (R)
            newValue: ""
            # Remove GHz from ClockRate and Multiply by 1000
            # ID;Manufacturer;Family;Type;ClockRate;DeviceName;
          - type: replace
            column: 5
            existingValue: GHz
            newValue: ""
          - type: multiply
            column: 5
            value: 1000
            # Concat the type to family
            # ID;Manufacturer;Family;Type;ClockRate;DeviceName;
          - type: rightConcat
            column: 3
            value: ' '
          - type: rightConcat
            column: 3
            value: $4
            # Keep Only  CPUs with a Manufacturer
            # ID;Manufacturer;Family;Type;ClockRate;DeviceName;
          - type: keepOnlyMatchingLines
            column: 2
            regExp: .
      mapping:
        # Instance Table
        # ID;Manufacturer;Family;Type;ClockRate;DeviceName;
        source: "${source::monitors.cpu.discovery.sources.source(1)}"
        attributes:
          id: $1
          __display_id: $6
          model: $3
          vendor: $2
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s - %s - %s)\", $6, $2, $3, megaHertz2HumanFormat($5))}"
        metrics:
          hw.cpu.speed.limit{limit_type="max"}: megaHertz2Hertz($5)
    collect:
      # Collect type is mono-instance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Get a list of CPUs
          # ID;Status;
          type: snmpTable
          oid: 1.3.6.1.4.1.2011.2.235.1.1.15.50.1
          selectColumns: "1,6"
          computes:
            # Duplicate status, because we will translate it two times
            # ID;State;State;
          - type: duplicateColumn
            column: 2
            # Translate Status into PATROLStatus
            # ID;PatrolStatus;State;
          - type: translate
            column: 2
            translationTable: "${translation::StatusTranslationTable}"
            # Translate second Status into more readable string
            # ID;PatrolStatus;StatusInformation;
          - type: translate
            column: 3
            translationTable: "${translation::StatusInformationTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        # ID;PatrolStatus;StatusInformation;
        source: "${source::monitors.cpu.collect.sources.source(1)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="cpu"}: $2
        legacyTextParameters:
          StatusInformation: $3
  power_supply:
    discovery:
      sources:
        source(1):
          # Source(1) = PowerSupplyDescriptionEntry SNMP table
          # ID;Manufacturer;Model;Present;DeviceName;
          type: snmpTable
          oid: 1.3.6.1.4.1.2011.2.235.1.1.6.50.1
          selectColumns: "1,2,4,9,13"
          computes:
          # Keep only present supplies
          - type: keepOnlyMatchingLines
            column: 4
            valueList: 2
          - type: leftConcat
            column: 2
            value: "Vendor: "
          - type: leftConcat
            column: 3
            value: "Model: "
      mapping:
        # Instance Table
        # ID;Manufacturer;Model;Present;DeviceName;
        source: "${source::monitors.power_supply.discovery.sources.source(1)}"
        attributes:
          id: $1
          __display_id: $5
          info: "${awk::join(\" \", $2, $3)}"
          hw.parent.type: enclosure
          name: $5
    collect:
      # Collect type is mono-instance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Get a list of PowerSupplys
          # ID;Status;
          type: snmpTable
          oid: 1.3.6.1.4.1.2011.2.235.1.1.6.50.1
          selectColumns: "1,7"
          computes:
            # Duplicate status, because we will translate it two times
            # ID;State;State;
          - type: duplicateColumn
            column: 2
            # Translate Status into PATROLStatus
            # ID;PatrolStatus;State;
          - type: translate
            column: 2
            translationTable: "${translation::StatusTranslationTable}"
            # Translate second Status into more readable string
            # ID;PatrolStatus;StatusInformation;
          - type: translate
            column: 3
            translationTable: "${translation::StatusInformationTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        # ID;PatrolStatus;StatusInformation;
        source: "${source::monitors.power_supply.collect.sources.source(1)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="power_supply"}: $2
        legacyTextParameters:
          StatusInformation: $3
  fan:
    discovery:
      sources:
        source(1):
          # Source(1) = FanDescriptionEntry SNMP table
          # ID;Present;DeviceName;
          type: snmpTable
          oid: 1.3.6.1.4.1.2011.2.235.1.1.8.50.1
          selectColumns: "1,3,7"
          computes:
          # Keep only present supplies
          - type: keepOnlyMatchingLines
            column: 2
            valueList: 2
      mapping:
        # Instance Table
        # ID;Present;DeviceName;
        source: "${source::monitors.fan.discovery.sources.source(1)}"
        attributes:
          id: $1
          __display_id: $3
          hw.parent.type: enclosure
          name: $3
    collect:
      # Collect type is mono-instance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Get a list of Fans
          # ID;Speed;Status;
          type: snmpTable
          oid: 1.3.6.1.4.1.2011.2.235.1.1.8.50.1
          selectColumns: "1,2,4"
          computes:
            # Duplicate status, because we will translate it two times
            # ID;Speed;State;State;
          - type: duplicateColumn
            column: 3
            # Translate Status into PATROLStatus
            # ID;Speed;PatrolStatus;State;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTranslationTable}"
            # Translate second Status into more readable string
            # ID;Speed;PatrolStatus;StatusInformation;
          - type: translate
            column: 4
            translationTable: "${translation::StatusInformationTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        # ID;Speed;PatrolStatus;StatusInformation;
        source: "${source::monitors.fan.collect.sources.source(1)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="fan"}: $3
          hw.fan.speed: $2
        legacyTextParameters:
          StatusInformation: $4
  memory:
    discovery:
      sources:
        source(1):
          # Source(1) = MemoryDescriptionEntry SNMP table
          # ID;Manufacturer;Size;Clock;Status;DeviceName;
          type: snmpTable
          oid: 1.3.6.1.4.1.2011.2.235.1.1.16.50.1
          selectColumns: "1,3,4,5,6,10"
          computes:
          # Keep only modules with a valid status
          - type: keepOnlyMatchingLines
            column: 5
            valueList: "1,2,3,4"
          # Remove MB from the size
          - type: replace
            column: 3
            existingValue: ' MB'
            newValue: ""
          - type: leftConcat
            column: 4
            value: "Speed: "
      mapping:
        # Instance Table
        # ID;Manufacturer;Size;Clock;Status;DeviceName;
        source: "${source::monitors.memory.discovery.sources.source(1)}"
        attributes:
          id: $1
          __display_id: $6
          vendor: $2
          info: $4
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s - %s MB)\", $6, $2, $3)}"
        metrics:
          hw.memory.limit: mebiByte2Byte($3)
    collect:
      # Collect type is mono-instance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Get a list of Memorys
          # ID;Status;
          type: snmpTable
          oid: 1.3.6.1.4.1.2011.2.235.1.1.16.50.1
          selectColumns: "1,6"
          computes:
            # Duplicate status, because we will translate it two times
            # ID;State;State;
          - type: duplicateColumn
            column: 2
            # Translate Status into PATROLStatus
            # ID;PatrolStatus;State;
          - type: translate
            column: 2
            translationTable: "${translation::StatusTranslationTable}"
            # Translate second Status into more readable string
            # ID;PatrolStatus;StatusInformation;
          - type: translate
            column: 3
            translationTable: "${translation::StatusInformationTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        # ID;PatrolStatus;StatusInformation;
        source: "${source::monitors.memory.collect.sources.source(1)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="memory"}: $2
        legacyTextParameters:
          StatusInformation: $3
  temperature:
    discovery:
      sources:
        source(1):
          # Source(1) = TemperatureDescriptionEntry SNMP table
          # ObjectID;Reading;UpperNR;UpperC;
          type: snmpTable
          oid: 1.3.6.1.4.1.2011.2.235.1.1.26.50.1
          selectColumns: "2,3,4,5"
          computes:
            # Replace  65535 Thresholds
            # ObjectID;Reading;UpperNR;UpperC;
          - type: replace
            column: 3
            existingValue: 65535
            newValue: ""
          - type: replace
            column: 4
            existingValue: 65535
            newValue: ""
            # Divide the threholds by 10
            # ObjectID;Reading;UpperNR;UpperC;
          - type: divide
            column: 3
            value: 10
          - type: divide
            column: 4
            value: 10
            # Duplicate the UpperC threshold
            # ObjectID;Reading;UpperNR;UpperC;UpperC;
          - type: duplicateColumn
            column: 4
            # Concat UpperNR to the Second UpperC
            # ObjectID;Reading;UpperNR;UpperC;BothThresholds;
          - type: rightConcat
            column: 5
            value: $3
            # Keep only sensors with a valid tbreshold
            # ObjectID;Reading;UpperNR;UpperC;BothThresholds;
          - type: keepOnlyMatchingLines
            column: 5
            regExp: .
        source(2):
          # Because the temperature specific table is missing alot of thresholds, let's also take the general sensor table
          # Source(2) = GeneralSensorTable SNMP table
          # ObjectID;Reading;UpperNR;UpperC;Type;
          type: snmpTable
          oid: 1.3.6.1.4.1.2011.2.235.1.1.13.50.1
          selectColumns: "1,2,3,4,10"
          computes:
          # Keep only temperature sensors
          - type: keepOnlyMatchingLines
            column: 5
            valueList: 1
            # Replace  na Thresholds
            # ObjectID;Reading;UpperNR;UpperC;Type;
          - type: replace
            column: 3
            existingValue: na
            newValue: ""
          - type: replace
            column: 4
            existingValue: na
            newValue: ""
            # Replace Type with UpperC
            # ObjectID;Reading;UpperNR;UpperC;UpperC;
          - type: replace
            column: 5
            existingValue: $5
            newValue: $4
            # Concat UpperNR to the Second UpperC
            # ObjectID;Reading;UpperNR;UpperC;BothThresholds;
          - type: rightConcat
            column: 5
            value: $3
            # Keep only sensors with a valid tbreshold
            # ObjectID;Reading;UpperNR;UpperC;BothThresholds;
          - type: keepOnlyMatchingLines
            column: 5
            regExp: .
          # Exclude temperatures with negative values
          - type: excludeMatchingLines
            column: 2
            regExp: '-'
        source(3):
          # Union 1 and 2
          # ObjectID;Reading;UpperNR;UpperC;BothThresholds;
          type: tableUnion
          tables:
          - "${source::monitors.temperature.discovery.sources.source(1)}"
          - "${source::monitors.temperature.discovery.sources.source(2)}"
      mapping:
        # Instance Table
        # ObjectID;Reading;UpperNR;UpperC;BothThresholds;
        source: "${source::monitors.temperature.discovery.sources.source(3)}"
        attributes:
          id: $1
          __display_id: $1
          hw.parent.type: enclosure
          name: $1
        metrics:
          hw.temperature.limit{limit_type="high.degraded"}: $4
          hw.temperature.limit{limit_type="high.critical"}: $3
    collect:
      # Collect type is mono-instance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = TemperatureDescriptionEntry SNMP table
          # ObjectID;Reading;
          type: snmpTable
          oid: 1.3.6.1.4.1.2011.2.235.1.1.26.50.1
          selectColumns: "2,3"
          computes:
            # Divide the reading by 10
            # ObjectID;Reading;
          - type: divide
            column: 2
            value: 10
        source(2):
          # Source(2) = GeneralSensorTable SNMP table
          # ObjectID;Reading;
          type: snmpTable
          oid: 1.3.6.1.4.1.2011.2.235.1.1.13.50.1
          selectColumns: "1,2"
        source(3):
          # Union 1 and 2
          # ObjectID;Reading;
          type: tableUnion
          tables:
          - "${source::monitors.temperature.collect.sources.source(1)}"
          - "${source::monitors.temperature.collect.sources.source(2)}"
      mapping:
        # ValueTable = Source(1)
        # ObjectID;Reading;
        source: "${source::monitors.temperature.collect.sources.source(3)}"
        attributes:
          id: $1
        metrics:
          hw.temperature: $2
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = PhysicalDiskDescriptionEntry SNMP table
          # ID;Present;DeviceName;
          type: snmpTable
          oid: 1.3.6.1.4.1.2011.2.235.1.1.18.50.1
          selectColumns: "1,2,6"
          computes:
          # Keep only present supplies
          - type: keepOnlyMatchingLines
            column: 2
            valueList: 2
      mapping:
        # Instance Table
        # ID;Present;DeviceName;
        source: "${source::monitors.physical_disk.discovery.sources.source(1)}"
        attributes:
          id: $1
          __display_id: $3
          hw.parent.type: enclosure
          name: $3
    collect:
      # Collect type is mono-instance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Get a list of PhysicalDisks
          # ID;Status;
          type: snmpTable
          oid: 1.3.6.1.4.1.2011.2.235.1.1.18.50.1
          selectColumns: "1,3"
          computes:
            # Duplicate status, because we will translate it two times
            # ID;State;State;
          - type: duplicateColumn
            column: 2
            # Translate Status into PATROLStatus
            # ID;PatrolStatus;State;
          - type: translate
            column: 2
            translationTable: "${translation::StatusTranslationTable}"
            # Translate second Status into more readable string
            # ID;PatrolStatus;StatusInformation;
          - type: translate
            column: 3
            translationTable: "${translation::StatusInformationTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        # ID;PatrolStatus;StatusInformation;
        source: "${source::monitors.physical_disk.collect.sources.source(1)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="physical_disk"}: $2
        legacyTextParameters:
          StatusInformation: $3
  other_device:
    discovery:
      sources:
        source(1):
          # Source(1) = OtherDeviceDescriptionEntry SNMP table
          # ID;Presence;Status;DeviceName;
          type: snmpTable
          oid: 1.3.6.1.4.1.2011.2.235.1.1.24.50.1
          selectColumns: "1,2,3,7"
          computes:
          # Keep only present cards
          - type: keepOnlyMatchingLines
            column: 2
            valueList: 2
          # Keep only cards with a valid status
          - type: keepOnlyMatchingLines
            column: 2
            valueList: "1,2,3,4"
      mapping:
        # Instance Table
        # ID;Manufacturer;Model;Present;DeviceName;
        source: "${source::monitors.other_device.discovery.sources.source(1)}"
        attributes:
          id: $1
          __display_id: $4
          device_type: PCI-E Card
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s: %s\", \"PCI-E Card\", $4)}"
    collect:
      # Collect type is mono-instance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Get a list of OtherDevices
          # ID;Status;
          type: snmpTable
          oid: 1.3.6.1.4.1.2011.2.235.1.1.24.50.1
          selectColumns: "1,3"
          computes:
            # Duplicate status, because we will translate it two times
            # ID;State;State;
          - type: duplicateColumn
            column: 2
            # Translate Status into PATROLStatus
            # ID;PatrolStatus;State;
          - type: translate
            column: 2
            translationTable: "${translation::StatusTranslationTable}"
            # Translate second Status into more readable string
            # ID;PatrolStatus;StatusInformation;
          - type: translate
            column: 3
            translationTable: "${translation::StatusInformationTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        # ID;PatrolStatus;StatusInformation;
        source: "${source::monitors.other_device.collect.sources.source(1)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="other_device"}: $2
        legacyTextParameters:
          StatusInformation: $3
translations:
  StatusInformationTranslationTable:
    "1": ""
    "2": Minor Fault
    "3": Major Fault
    "4": Critical Fault
    "5": Device Missing
    Default: Unknown Status
  StatusTranslationTable:
    "1": ok
    "2": degraded
    "3": failed
    "4": failed
    "5": failed
    Default: UNKNOWN
