---
embedded:
  EmbeddedFile(1): |-
    list volume
    exit
  EmbeddedFile(3): exit
  EmbeddedFile(2): |-
    BEGIN {
        foundHeader = 0;
    }
    ($1 == "Volume" && $2 == "###" && $3 == "Ltr" && $4 == "Label" && $5 == "Fs" && $6 == "Type" && $7 == "Size" && $8 == "Status" && $9 == "Info") {
        ltrIndex = index($0, "Ltr")
        labelIndex = index($0, "Label")
        fsIndex = index($0, "Fs")
        typeIndex = index($0, "Type")
        sizeIndex = index($0, "Size")
        statusIndex = index($0, "Status")
        infoIndex = index($0, "Info")
        foundHeader = 1;
    }
    ($1 == "Volume" && $2 ~ /^[0-9]+$/ && foundHeader == 1) {

        # Get the fields
        volumeID = $2;
        letter = substr($0, ltrIndex, 3);
        label = substr($0, labelIndex, fsIndex - labelIndex);
        fs = substr($0, fsIndex, typeIndex - fsIndex);
        type = substr($0, typeIndex, sizeIndex - typeIndex);
        sizeT = substr($0, sizeIndex, statusIndex - sizeIndex);
        status = substr($0, statusIndex, infoIndex - statusIndex);
        info = substr($0, infoIndex, length($0) - infoIndex + 1);

        # Do some processing, remove unnecessary white spaces
        gsub(" ", "", letter);
        sub("^ +", "", label); sub(" +$", "", label);
        sub("^ +", "", fs); sub(" +$", "", fs);
        sub("^ +", "", type); sub(" +$", "", type);
        gsub(" ", "", sizeT);
        sub("^ +", "", status); sub(" +$", "", status);
        sub("^ +", "", info); sub(" +$", "", info);

        # Convert size to bytes
        size = "";
        if (substr(sizeT, length(sizeT), 1) == "B")
        {
            size = substr(sizeT, 1, length(sizeT) - 1);

            # Handle unit multipliers
            if (substr(size, length(size), 1) == "K")
            {
                size = substr(size, 1, length(size) - 1) * 1024;
            }
            else if (substr(size, length(size), 1) == "M")
            {
                size = substr(size, 1, length(size) - 1) * 1024 * 1024;
            }
            else if (substr(size, length(size), 1) == "G")
            {
                size = substr(size, 1, length(size) - 1) * 1024 * 1024 * 1024;
            }
            else if (substr(size, length(size), 1) == "T")
            {
                size = substr(size, 1, length(size) - 1) * 1024 * 1024 * 1024 * 1024;
            }

            # Make sure we got a number
            if (size !~ /^[0-9]+$/)
            {
                size = "";
            }
        }

        # Add a colon to the drive letter, if any
        if (letter ~ /^[A-Z]$/)
        {
            letter = letter ":"
        }

        # Build the displayID from label and letter
        if (letter != "" && label != "")
        {
            displayID = letter " - " label;
        }
        else if (letter != "" && label == "")
        {
            displayID = letter;
        }
        else if (letter == "" && label != "")
        {
            displayID = label;
        }
        else
        {
            displayID = "";
        }

        # Replace "Partition" type with nothing
        if (type == "Partition")
        {
            type = "";
        }

        print "MSHW;" volumeID ";" displayID ";" letter ";" type ";" fs ";" size ";" status ";" info ";"
    }
translations:
  LogicalDiskTranslationTable:
    rebuild: degraded
    default: UNKNOWN
    healthy: ok
    failed redundancy: degraded
    failed rd: degraded
    failed: failed
    regenerating: degraded
    formatting: ok
    resynching: degraded
    unknown: failed
connector:
  displayName: Windows - DiskPart
  platforms: Any system
  reliesOn: The DISKPART.EXE command-line utility
  information: "Discovers and monitors the logical disks in a Microsoft Windows system through the DISKPART.EXE utility, notably the software RAID volumes."
  version: 1.0
  detection:
    appliesTo:
    - NT
    criteria:
    # OS should be Windows
    - type: deviceType
      keep:
      - NT
    # Diskpart must be int he path and return something meaningful. Please note that we're using CHCP 437 to make sure the locale is English.
    - type: osCommand
      commandLine: CHCP 437&&DISKPART.EXE /S %EmbeddedFile(3)%
      expectedResult: Leaving DiskPart
      timeout: 120
monitors:
  logical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = DISKPART.EXE running "list volume" and "exit
          type: osCommand
          commandLine: CHCP 437&&DISKPART.EXE /S %EmbeddedFile(1)%
          timeout: 120
          computes:
            # Run Source(1) through an AWK script
            # ID;Label;Letter;VolumeType;FileSystem;Size;Status;MoreInformation
          - type: awk
            script: EmbeddedFile(2)
            separators: ;
            keep: ^MSHW;
            selectColumns: "2,3,4,5,6,7,8,9"
            # Exclude DVDs and stupid stuff
            # ID;Label;Letter;VolumeType;FileSystem;Size;Status;MoreInformation
          - type: excludeMatchingLines
            column: 4
            valueList: "CD-ROM,DVD-ROM,Removable"
          - type: leftConcat
            column: 5
            value: "File System: "
          - type: leftConcat
            column: 8
            value: "Volume Information: "
      mapping:
        # The InstanceTable
        source: $monitors.logical_disk.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          __display_id: $column(2)
          raid_level: $column(4)
          hw.logical_disk.limit: $column(6)
          info: "join($column(5), $column(8), \" \")"
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s - %s)\", $column(2), $column(4), $column(6))"
    collect:
      # Collection is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = DISKPART.EXE running "list volume" and "exit
          type: osCommand
          commandLine: CHCP 437&&DISKPART.EXE /S %EmbeddedFile(1)%
          timeout: 120
          computes:
            # Run Source(1) through an AWK script
            # ID;Status;
          - type: awk
            script: EmbeddedFile(2)
            separators: ;
            keep: ^MSHW;
            selectColumns: "2,8"
            # Duplicate the status column
            # ID;Status;Status
          - type: duplicateColumn
            column: 2
            # Now translate Status to Patrol Status
            # status
          - type: translate
            column: 2
            translationTable: LogicalDiskTranslationTable
      mapping:
        # ValueTable = Source(1)
        source: $monitors.logical_disk.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="logical_disk"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
