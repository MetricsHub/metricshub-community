---
connector:
  displayName: Dell MX Chassis and Blades (REST)
  platforms: Dell MX7000
  version: 1.0
  information: "This connector provides hardware monitoring for Dell MX Series. It monitors the enclosure and physical disks as well as the various environment sensors (CPUs, temperatures, fans, power supplies, memory, disk controllers, batteries and network cards)."
  detection:
    connectionTypes:
    - remote
    appliesTo:
    - OOB
    criteria:
    # Hardware Sentry v10.2.00+
    - type: productRequirements
      kmVersion: 10.2.00
    - type: http
      method: GET
      url: /api/DeviceService/Devices
      header: "${file::embeddedFile-1}"
      expectedResult: api
      errorMessage: Invalid credentials / not an MX7000
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Discovery
          # List the devices
          type: http
          method: GET
          url: /api/DeviceService/Devices
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /value
            properties: /@odata.id;/DeviceName;/Identifier;/Model;/Type;/SlotConfiguration/ChassisName;/SlotConfiguration/SlotNumber;
            separator: ;
        source(2):
          # keep only chassis and blades
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
          - type: keepOnlyMatchingLines
            column: 6
            regExp: 2000
          - type: translate
            column: 6
            translationTable: "${translation::TypeTranslationTable}"
      mapping:
        # Enclosure Instance Table
        source: "${source::monitors.enclosure.discovery.sources.source(2)}"
        attributes:
          id: $3
          __display_id: $3
          model: $5
          serial_number: $4
          vendor: Dell
          type: $6
          name: "${awk::sprintf(\"Enclosure: %s (%s %s)\", $3, \"Dell\", $5)}"
    collect:
      # Collection
      type: multiInstance
      sources:
        source(1):
          type: http
          method: GET
          url: /api/DeviceService/Devices
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /value
            properties: /DeviceName;/Status;/Status;/SlotConfiguration/SlotNumber;
            separator: ;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTranslationTable}"
          - type: translate
            column: 4
            translationTable: "${translation::StatusInformationTranslationTable}"
      mapping:
        # Enclosure Value Table
        source: "${source::monitors.enclosure.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="enclosure"}: $3
        legacyTextParameters:
          StatusInformation: $4
  blade:
    discovery:
      sources:
        source(1):
          # Discovery
          # now create a container blade with global status
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
          - type: keepOnlyMatchingLines
            column: 6
            regExp: 1000
          # '"jsonid;/@odata.id;/DeviceName;/Identifier;/Model;/Type;/SlotConfiguration/ChassisName;/SlotConfiguration/SlotNumber;"'
          - type: replace
            column: 6
            existingValue: 1000
            newValue: blade
      mapping:
        # Enclosure Instance Table
        source: "${source::monitors.blade.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $3
          blade_name: $3
          model: $5
          serial_number: $4
          info: "Vendor: Dell"
          hw.parent.type: enclosure
          hw.parent.id: $7
          name: "${awk::sprintf(\"%s (%s - %s)\", $3, $3, $5)}"
    collect:
      sources:
        source(1):
          # collect the blades
          # "JSONID;/DeviceName;/Status;/Status;/SlotConfiguration/SlotNumber;"
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
      mapping:
        source: "${source::monitors.blade.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="blade"}: $3
        legacyTextParameters:
          StatusInformation: $4
  other_device:
    discovery:
      sources:
        source(1):
          # Discovery
          # first other device represent the network switchs
          type: http
          method: GET
          url: /api/DeviceService/Devices
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /value
            properties: /@odata.type;/DeviceName;/DeviceName;/Identifier;/Model;/Type;
            separator: ;
        source(2):
          type: copy
          from: "${source::monitors.other_device.discovery.sources.source(1)}"
          computes:
          - type: excludeMatchingLines
            column: 7
            regExp: \(1000\)\|\(2000\)
          - type: translate
            column: 7
            translationTable: "${translation::TypeTranslationTable}"
        source(3):
          type: copy
          from: "${source::monitors.other_device.discovery.sources.source(1)}"
          computes:
          - type: keepOnlyMatchingLines
            column: 7
            regExp: 2000
        source(4):
          # now attach the other device to the chassis
          type: tableJoin
          leftTable: "${source::monitors.other_device.discovery.sources.source(2)}"
          rightTable: "${source::monitors.other_device.discovery.sources.source(3)}"
          leftKeyColumn: 2
          rightKeyColumn: 2
          computes:
          - type: replace
            column: 2
            existingValue: $2
            newValue: $10
        source(5):
          # add the chassis controllers (CMC)
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: json_array_extended
          url: $2/InventoryDetails('chassisControllerList')
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /Entry/Value/InventoryInfo
            properties: ../../Column(2);/Name;/Name;/FirmwareVersion;
            separator: ;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: .
        source(6):
          type: tableUnion
          tables:
          - "${source::monitors.other_device.discovery.sources.source(4)}"
          - "${source::monitors.other_device.discovery.sources.source(5)}"
          computes:
          - type: leftConcat
            column: 5
            value: "SerialNumber: "
      mapping:
        source: "${source::monitors.other_device.discovery.sources.source(6)}"
        attributes:
          id: $3
          __display_id: $4
          device_type: $7
          info: "${awk::join(\" \", $5, $6)}"
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s: %s\", $7, $4)}"
    collect:
      sources:
        source(1):
          # Collect
          type: http
          method: GET
          url: /api/DeviceService/Devices
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /value
            properties: /DeviceName;/Status;/Status;
            separator: ;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTranslationTable}"
          - type: translate
            column: 4
            translationTable: "${translation::StatusInformationTranslationTable}"
        source(2):
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: json_array_extended
          url: $2/InventoryDetails('chassisControllerList')
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /Entry/Value/InventoryInfo
            properties: /Name;/Health;/Health;
            separator: ;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTranslationTable}"
          - type: translate
            column: 4
            translationTable: "${translation::StatusInformationTranslationTable}"
        source(3):
          type: tableUnion
          tables:
          - "${source::monitors.other_device.collect.sources.source(1)}"
          - "${source::monitors.other_device.collect.sources.source(2)}"
      mapping:
        # Blade Value Table
        source: "${source::monitors.other_device.collect.sources.source(3)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="other_device"}: $3
        legacyTextParameters:
          StatusInformation: $4
  cpu:
    discovery:
      sources:
        source(1):
          # Discovery
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: json_array_extended
          url: $2/InventoryDetails('serverProcessors')
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /Entry/Value/InventoryInfo
            properties: ../../Column(2);/SlotNumber;/BrandName;/ModelName;/MaxSpeed;
            separator: ;
          - type: replace
            column: 3
            existingValue: CPU.
            newValue: ""
          - type: keepOnlyMatchingLines
            column: 3
            regExp: .
          # compute now the disk ID
          - type: rightConcat
            column: 2
            value: ;
          # compute now the disk ID
          - type: leftConcat
            column: 3
            value: $2
          - type: rightConcat
            column: 3
            value: $4
      mapping:
        # CPU Instance Table
        source: "${source::monitors.cpu.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          vendor: $5
          model: $6
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s - %s - %s)\", $4, $5, $6, megaHertz2HumanFormat($7))}"
        metrics:
          hw.cpu.speed.limit{limit_type="max"}: megaHertz2Hertz($7)
    collect:
      # Collect
      type: multiInstance
      sources:
        source(1):
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: json_array
          url: $2/InventoryDetails('serverProcessors')
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /Entry/Value/InventoryInfo
            properties: ../../Column(2);/SlotNumber;/Status;/Status;
            separator: ;
          - type: translate
            column: 4
            translationTable: "${translation::StatusTranslationTable}"
          - type: translate
            column: 5
            translationTable: "${translation::StatusInformationTranslationTable}"
          - type: rightConcat
            column: 2
            value: $3
      mapping:
        # CPU Value Table
        source: "${source::monitors.cpu.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="cpu"}: $4
        legacyTextParameters:
          StatusInformation: $5
  memory:
    discovery:
      sources:
        source(1):
          # Discovery
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: json_array_extended
          url: $2/InventoryDetails('serverMemoryDevices')
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /Entry/Value/InventoryInfo
            properties: ../../Column(2);/InstanceId;/Name;/Size;/Manufacturer;/PartNumber;/SerialNumber;
            separator: ;
          - type: replace
            column: 4
            existingValue: DIMM.
            newValue: ""
          # Exclude memory with empty names
          - type: keepOnlyMatchingLines
            column: 3
            regExp: .
      mapping:
        # Memory Instance Table
        source: "${source::monitors.memory.discovery.sources.source(1)}"
        attributes:
          id: $8
          __display_id: $4
          vendor: $6
          model: $7
          serial_number: $8
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s - %s MB)\", $4, $6, $5)}"
        metrics:
          hw.memory.limit: mebiByte2Byte($5)
    collect:
      # Collect
      type: multiInstance
      sources:
        source(1):
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: json_array_extended
          url: $2/InventoryDetails('serverMemoryDevices')
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: Entry/Value/InventoryInfo
            properties: /InstanceId;/Status;/Status;/SerialNumber;
            separator: ;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTranslationTable}"
          - type: translate
            column: 4
            translationTable: "${translation::StatusInformationTranslationTable}"
      mapping:
        # Memory Value Table
        source: "${source::monitors.memory.collect.sources.source(1)}"
        deviceId: $5
        metrics:
          hw.status{hw.type="memory"}: $3
        legacyTextParameters:
          StatusInformation: $4
  fan:
    discovery:
      sources:
        source(1):
          # Discovery
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: json_array_extended
          url: $2/InventoryDetails('chassisFansList')
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /Entry/Value/InventoryInfo
            properties: ../../Column(3);/MemberId;/Name;/MemberId
            separator: ;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: .
          - type: leftConcat
            column: 3
            value: $2
          # remove /entry/value from jsonid to use it in the above tablejoint
          - type: replace
            column: 1
            existingValue: /Entry/Value
            newValue: ""
      mapping:
        # Fan Instance Table
        source: "${source::monitors.fan.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          hw.parent.type: Chassis
          hw.parent.id: $2
          name: $4
    collect:
      # Collection
      type: multiInstance
      sources:
        source(1):
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: json_array
          url: $2/InventoryDetails('chassisFansList')
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /InventoryInfo
            properties: /MemberId;/Status;/Speed;/Pwm;/Status;
            separator: ;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTranslationTable}"
          - type: translate
            column: 6
            translationTable: "${translation::StatusInformationTranslationTable}"
        source(2):
          type: tableJoin
          leftTable: "${source::monitors.fan.collect.sources.source(1)}"
          rightTable: "${source::monitors.fan.discovery.sources.source(1)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          computes:
          - type: leftConcat
            column: 2
            value: $8
      mapping:
        # Fan Value Table
        source: "${source::monitors.fan.collect.sources.source(2)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="fan"}: $3
          hw.fan.speed: $4
          hw.fan.speed_ratio: percent2Ratio($5)
        legacyTextParameters:
          StatusInformation: $6
  disk_controller:
    discovery:
      sources:
        source(1):
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: json_array_extended
          url: $2/InventoryDetails('serverRaidControllers')
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /Entry/Value/InventoryInfo
            properties: ../../Column(2);/Fqdd;/FirmwareVersion;/ServerVirtualDisks;
            separator: ;
          - type: duplicateColumn
            column: 2
          - type: rightConcat
            column: 3
            value: $4
          - type: keepOnlyMatchingLines
            column: 5
            regExp: .
      mapping:
        # DiskController Instance Table
        # JsonID;<System>;<System+Fqdd/name>(unique);Fqdd;FirmwareVersion;ServerVirtualDisks;
        source: "${source::monitors.disk_controller.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          controller_number: $3
          firmware_version: $5
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"Disk Controller: %s\", $4)}"
    collect:
      # Collection
      type: multiInstance
      sources:
        source(1):
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: json_array_extended
          url: $2/InventoryDetails('serverRaidControllers')
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /Entry/Value/InventoryInfo
            properties: ../../Column(2);/Fqdd;/Status;/Status;
            separator: ;
          - type: translate
            column: 4
            translationTable: "${translation::StatusTranslationTable}"
          - type: translate
            column: 5
            translationTable: "${translation::StatusInformationTranslationTable}"
          - type: duplicateColumn
            column: 2
          - type: rightConcat
            column: 3
            value: $4
      mapping:
        # DiskController Value Table
        source: "${source::monitors.disk_controller.collect.sources.source(1)}"
        deviceId: $3
        metrics:
          hw.status{hw.type="disk_controller"}: $5
        legacyTextParameters:
          StatusInformation: $6
  physical_disk:
    discovery:
      sources:
        source(1):
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: json_array_extended
          url: $2/InventoryDetails('serverArrayDisks')
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /Entry/Value/InventoryInfo
            properties: ../../Column(2);/Id;/DiskNumber;/VendorName;/SerialNumber;/ModelNumber;/Size;/MediaType;/BusType;
            separator: ;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: .
      mapping:
        # PhysicalDisk Instance Table
        # 1        #  2       3   4        #  5        #    6        #  7        #    8     9         10
        # EntryKey;BladeId;/Id;/DiskNumber;/VendorName;/SerialNumber;/ModelNumber;/Size;/MediaType;/BusType;
        source: "${source::monitors.physical_disk.discovery.sources.source(1)}"
        attributes:
          id: $6
          __display_id: $4
          vendor: $5
          serial_number: $6
          model: $7
          info: "${awk::join(\" \", $10, $9)}"
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s - %s)\", $4, $5, bytes2HumanFormatBase10($8))}"
        metrics:
          hw.physical_disk.size: $8
    collect:
      # Collection
      type: multiInstance
      sources:
        source(1):
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: json_array
          url: $2/InventoryDetails('serverArrayDisks')
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /InventoryInfo
            properties: /SerialNumber;/Status;/Status;/RemainingReadWriteEndurance;
            separator: ;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTranslationTable}"
          - type: translate
            column: 4
            translationTable: "${translation::StatusInformationTranslationTable}"
          - type: replace
            column: 5
            existingValue: 255
            newValue: ""
      mapping:
        # PhysicalDisk Value Table
        source: "${source::monitors.physical_disk.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="physical_disk"}: $3
          hw.physical_disk.endurance_utilization{state="remaining"}: percent2Ratio($5)
        legacyTextParameters:
          StatusInformation: $4
  logical_disk:
    discovery:
      sources:
        source(1):
          # Discovery
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: json_array_extended
          url: $2/InventoryDetails('serverRaidControllers')
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /Entry/Value/InventoryInfo/ServerVirtualDisks
            properties: ../../../Column(2);/Id;/Fqdd;/Layout;/MediaType;/Size;../Fqdd
            separator: ;
          - type: rightConcat
            column: 2
            value: $8
      mapping:
        # LogicalDisk Instance Table
        source: "${source::monitors.logical_disk.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          raid_level: $5
          type: $6
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $2)"
          name: "${awk::sprintf(\"%s (%s - %s)\", $4, $5, bytes2HumanFormatBase2($7))}"
        metrics:
          hw.logical_disk.limit: $7
    collect:
      # Collect
      type: multiInstance
      sources:
        source(1):
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: json_array
          url: $2/InventoryDetails('serverRaidControllers')
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /InventoryInfo/ServerVirtualDisks
            properties: /Id;/Status;/Status;
            separator: ;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTranslationTable}"
          - type: translate
            column: 4
            translationTable: "${translation::StatusInformationTranslationTable}"
      mapping:
        # LogicalDisk Value Table
        source: "${source::monitors.logical_disk.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="logical_disk"}: $3
        legacyTextParameters:
          StatusInformation: $4
  power_supply:
    discovery:
      sources:
        source(1):
          # Discovery
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: json_array_extended
          url: $2/InventoryDetails('chassisPowerSupplies')
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /Entry/Value/InventoryInfo
            properties: ../../Column(3);/MemberId;/Name;/CapacityWatts;/PowerSupplyType;/EnableState;/MemberId
            separator: ;
          - type: excludeMatchingLines
            column: 7
            regExp: Absent
          - type: keepOnlyMatchingLines
            column: 3
            regExp: .
          - type: leftConcat
            column: 3
            value: $2
          - type: replace
            column: 1
            existingValue: /Entry/Value
            newValue: ""
      mapping:
        # PowerSupply Instance Table
        source: "${source::monitors.power_supply.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          power_supply_type: $6
          hw.parent.type: Chassis
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s (%s - %s W)\", $4, $6, $5)}"
        metrics:
          hw.power_supply.limit: $5
    collect:
      # Collection
      type: multiInstance
      sources:
        source(1):
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: json_array
          url: $2/InventoryDetails('chassisPowerSupplies')
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /InventoryInfo
            properties: /MemberId;/HealthState;/HealthState;
            separator: ;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTranslationTable}"
          - type: translate
            column: 4
            translationTable: "${translation::StatusInformationTranslationTable}"
        source(2):
          type: tableJoin
          leftTable: "${source::monitors.power_supply.collect.sources.source(1)}"
          rightTable: "${source::monitors.power_supply.discovery.sources.source(1)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          computes:
          # jsonid;/MemberId;/HealthState;/HealthState;jsonid;../../Column(3);/MemberId;/Name;/CapacityWatts;/PowerSupplyType;/EnableState;/MemberId
          - type: leftConcat
            column: 2
            value: $6
      mapping:
        # PowerSupply Value Table
        source: "${source::monitors.power_supply.collect.sources.source(2)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="power_supply"}: $3
        legacyTextParameters:
          StatusInformation: $4
  battery:
    discovery:
      sources:
        source(1):
          # Discovery
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: json_array_extended
          url: $2/InventoryDetails('subsystemRollupStatus')
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /Entry/Value/InventoryInfo
            properties: ../../Column(2);../../Column(2);/SubsystemName;
            separator: ;
          - type: keepOnlyMatchingLines
            column: 4
            regExp: batteryRollupStatus
          - type: rightConcat
            column: 3
            value: $4
      mapping:
        # Battery Instance Table
        source: "${source::monitors.battery.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: battery
          hw.parent.type: enclosure
          name: battery
    collect:
      # Collection
      type: multiInstance
      sources:
        source(1):
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: json_array
          url: $2/InventoryDetails('subsystemRollupStatus')
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /Entry/Value/InventoryInfo
            properties: ../../Column(2);/Status;/Status;/SubsystemName;
            separator: ;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTranslationTable}"
          - type: translate
            column: 4
            translationTable: "${translation::StatusInformationTranslationTable}"
          - type: rightConcat
            column: 2
            value: $5
      mapping:
        # Battery Value Table
        source: "${source::monitors.battery.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="battery"}: $3
        legacyTextParameters:
          StatusInformation: $4
  temperature:
    discovery:
      sources:
        source(1):
          # Discovery
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: json_array_extended
          url: $2/InventoryDetails('chassisTemperatureList')
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /Entry/Value/InventoryInfo
            properties: ../../Column(3);/MemberId;/SensorName;/UpperThresholdNoncritical;/UpperThresholdCritical;/ReadingCelsius;/MemberId
            separator: ;
          - type: keepOnlyMatchingLines
            column: 4
            regExp: .
          - type: keepOnlyMatchingLines
            column: 7
            regExp: .
          - type: leftConcat
            column: 3
            value: $2
          # remove /entry/value from jsonid to use it in the above tablejoint
          - type: replace
            column: 1
            existingValue: /Entry/Value
            newValue: ""
      mapping:
        # Temperature Instance Table
        # JsonId;<System>;MemberId;SensorName;
        source: "${source::monitors.temperature.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          hw.parent.type: Chassis
          hw.parent.id: $2
          name: $4
    collect:
      # Collection
      type: multiInstance
      sources:
        source(1):
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: json_array
          url: $2/InventoryDetails('chassisTemperatureList')
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /InventoryInfo
            properties: /MemberId;/Status;/ReadingCelsius;/Status;
            separator: ;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTranslationTable}"
          - type: translate
            column: 5
            translationTable: "${translation::StatusInformationTranslationTable}"
        source(2):
          # as fan and psu joint with temp discovery to compute id with enclosure id
          # jsonid;/MemberId;/Status;/ReadingCelsius;/Status;jsonid;../../Column(3);/MemberId;/SensorName;/UpperThresholdNoncritical;/UpperThresholdCritical;/ReadingCelsius;Memberid
          type: tableJoin
          leftTable: "${source::monitors.temperature.collect.sources.source(1)}"
          rightTable: "${source::monitors.temperature.discovery.sources.source(1)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          computes:
          - type: leftConcat
            column: 2
            value: $7
      mapping:
        # Temperature Value Table
        source: "${source::monitors.temperature.collect.sources.source(2)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="temperature"}: $3
          hw.temperature: $4
        legacyTextParameters:
          StatusInformation: $5
  network:
    discovery:
      sources:
        source(1):
          # Discovery
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: json_array_extended
          url: $2/InventoryDetails('serverNetworkInterfaces')
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /Entry/Value/InventoryInfo/Ports/Partitions
            properties: ../../../../Column(2);/Fqdd;/PermanentMacAddress;../ProductName;../../VendorName;/FcoeMode;/MaxBandwidth;
            separator: ;
          - type: translate
            column: 7
            translationTable: "${translation::TypeTranslationTable}"
          - type: translate
            column: 9
            translationTable: "${translation::LinkSpeedDeactivationTranslationTable}"
        source(2):
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: json_array_extended
          url: $2/InventoryDetails('serverFcCards')
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /Entry/Value/InventoryInfo
            properties: ../../Column(2);/Fqdd;/Wwn;/DeviceName;/VendorName;/PortSpeed;
            separator: ;
          - type: rightConcat
            column: 6
            value: ;FC;WWN
          - type: replace
            column: 9
            existingValue: ' Gbps'
            newValue: '000'
          - type: translate
            column: 9
            translationTable: "${translation::LinkSpeedDeactivationTranslationTable}"
        source(3):
          type: tableUnion
          tables:
          - "${source::monitors.network.discovery.sources.source(1)}"
          - "${source::monitors.network.discovery.sources.source(2)}"
          computes:
          - type: keepOnlyMatchingLines
            column: 3
            regExp: .
      mapping:
        # NetworkCard Instance Table
        source: "${source::monitors.network.discovery.sources.source(3)}"
        attributes:
          id: $4
          __display_id: $3
          physical_address: $4
          model: $5
          vendor: $6
          device_type: $7
          physical_address_type: $8
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s - %s - %s)\", $3, $7, $6, $5)}"
        conditionalCollection:
          hw.network.bandwidth.limit: megaBit2Bit($9)
    collect:
      # Collection
      type: multiInstance
      sources:
        source(1):
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: json_array_extended
          url: $2/InventoryDetails('serverNetworkInterfaces')
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /Entry/Value/InventoryInfo/Ports/Partitions
            properties: /PermanentMACAddress;../LinkSpeed;../LinkStatus;
            separator: ;
          - type: duplicateColumn
            column: 4
          - type: translate
            column: 4
            translationTable: "${translation::FCLinkStatusTranslationTable}"
        source(2):
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(2)}"
            concatMethod: json_array_extended
          url: $2/InventoryDetails('serverFcCards')
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /Entry/Value/InventoryInfo
            properties: /Wwn;/PortSpeed;/LinkStatus;
            separator: ;
          - type: duplicateColumn
            column: 4
          - type: replace
            column: 3
            existingValue: ' Gbps'
            newValue: '000'
          - type: translate
            column: 4
            translationTable: "${translation::FcLinkStatusTranslationTable}"
          - type: replace
            column: 3
            existingValue: No Link
            newValue: 0
        source(3):
          type: tableUnion
          tables:
          - "${source::monitors.network.collect.sources.source(1)}"
          - "${source::monitors.network.collect.sources.source(2)}"
      mapping:
        # NetworkCard Value Table
        source: "${source::monitors.network.collect.sources.source(3)}"
        deviceId: $2
        legacyTextParameters:
          StatusInformation: $5
        metrics:
          hw.network.up: legacyLinkStatus($4)
          hw.network.bandwidth.limit: megaBit2Bit($3)
translations:
  TypeTranslationTable:
    "8000": Storage IOM
    "4000": NETWORK IO Module
    "1000": Server
    "2000": Chassis
    Enabled: FC;WWN
    "3000": Storage
    Disabled: Ethernet;MAC
  FcLinkStatusTranslationTable:
    Up: ok
    Default: degraded
  StatusInformationTranslationTable:
    "5000": The device/group does not have a valid status.
    "4000": The device is in critical state.
    "1000": The device is running normal.
    "2000": Status is not determined.
    "3000": The device has warning state.
    Default: failed
  StatusTranslationTable:
    "5000": UNKNOWN
    "4000": failed
    "1000": ok
    "2000": UNKNOWN
    "3000": degraded
    Default: failed
  LinkSpeedDeactivationTranslationTable:
    "0": ""
    Default: "True"
