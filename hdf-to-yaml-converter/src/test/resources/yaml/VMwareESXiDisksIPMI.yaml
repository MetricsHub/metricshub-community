---
embedded:
  EmbeddedFile(1): "BEGIN {FS=\"[;]\"}\n{ID = $5; gsub(\"\\.[^.]*$\",\"\",ID);\n if ($4 == \"11\") { PresenceID[ID] = $5 };\n if (ID in tags2) {\n\t                  if (tags3[ID] < $3) {tags3[ID] = ($3);}\n\t                  if ($3 > 5) {if (tags2[ID]==\"\") {tags2[ID] = $2}\n\t                               else {tags2[ID] = (tags2[ID] \" - \" $2)}\n\t                              }\n\t                 }\n\telse {if ($3 > 0) {tags3[ID] = ($3)};\n\t\t    if ($3 > 5) {tags2[ID] = $2};\n\t\t   }\n}\nEND { for (ID in tags3)\n      print (\"MSHW;\" PresenceID[ID] \";\"tags2[ID]\";\"tags3[ID]\";\")\n    }"
translations:
  statusTranslationTable:
    "0": UNKNOWN
    default: UNKNOWN
    "25": failed
    "15": degraded
    "5": ok
    "30": failed
    "20": failed
    "10": degraded
connector:
  displayName: VMware ESXi - Disks (IPMI)
  platforms: VMware ESXi
  reliesOn: WBEM
  version: 1.1
  information: This connector provides disk monitoring through the VMware ESX4i agent's discrete IPMI sensors
  detection:
    connectionTypes:
    - remote
    - local
    appliesTo:
    - OOB
    - Linux
    criteria:
    - _comment: Checking the version of ESXi
      type: wbem
      namespace: root/cimv2
      query: SELECT MajorVersion FROM VMware_HypervisorSoftwareIdentity
      expectedResult: "^[34567]"
    - _comment: Check that there are sensors of IPMI Type 13 and SensorType 11 (Presence)
      type: wbem
      namespace: root/cimv2
      query: "SELECT IpmiSensorType,SensorType,CurrentState FROM OMC_DiscreteSensor"
      expectedResult: ^13;11;Assert;
monitors:
  physical_disk:
    discovery:
      sources:
        source(1):
          type: wbem
          query: "SELECT MonitoredDeviceID,Caption,HealthState,IpmiSensorType,SensorType,CurrentState,DeviceID FROM OMC_DiscreteSensor"
          namespace: root/cimv2
          computes:
            # Keep only Sensors of IPMI type 13
            # MonitoredDeviceID,Caption,HealthState,IpmiSensorType,SensorType,CurrentState,DeviceID
          - type: keepOnlyMatchingLines
            column: 4
            valueList: 13
            # Keep only Sensors of SensorType 11 (Presence)
            # MonitoredDeviceID,Caption,HealthState,IpmiSensorType,SensorType,CurrentState,DeviceID
          - type: keepOnlyMatchingLines
            column: 5
            valueList: 11
            # Keep only Disks that are "Present", i.e. presence = Assert
            # MonitoredDeviceID,Caption,HealthState,IpmiSensorType,SensorType,CurrentState,DeviceID
          - type: keepOnlyMatchingLines
            column: 6
            valueList: Assert
            # Remove "Drive Present" from caption
            # MonitoredDeviceID,Caption,HealthState,IpmiSensorType,SensorType,CurrentState,DeviceID
          - type: replace
            column: 2
            existingValue: Drive Present
            newValue: ""
            # Concat PD to the Device ID (to avoid numerical comparison table join in Patrol)
            # MonitoredDeviceID,Caption,HealthState,IpmiSensorType,SensorType,CurrentState,DeviceID
          - type: leftConcat
            column: 7
            value: PD
      mapping:
        # The Instance table
        # MonitoredDeviceID,Caption,HealthState,IpmiSensorType,SensorType,CurrentState,DeviceID
        source: $monitors.physical_disk.discovery.sources.source(1)$
        attributes:
          id: $column(7)
          __display_id: $column(2)
          hw.parent.type: enclosure
          name: "sprintf(\"%s, $column(2))"
    collect:
      _comment: The DiskController collect is a "MultiInstance" collect
      type: multiInstance
      sources:
        source(1):
          # Get a list of discrete sensors
          # DeviceID,Caption,HealthState,IpmiSensorType
          type: wbem
          query: "SELECT MonitoredDeviceID,Caption,HealthState,IpmiSensorType,SensorType,DeviceID FROM OMC_DiscreteSensor"
          namespace: root/cimv2
          computes:
            # Keep only Sensors of IPMI type 13
            # MonitoredDeviceID,Caption,HealthState,IpmiSensorType,SensorType,DeviceID
          - type: keepOnlyMatchingLines
            column: 4
            valueList: 13
            # Keep only MonitoredDeviceID,Caption,HealthState so that we can use the same awk array translation as in memory.collect
            # MonitoredDeviceID,Caption,HealthState,SensorType,DeviceID
          - type: keepColumns
            columnNumbers: "1,2,3,5,6"
            # Process the discrete sensors to take worse Status and make each ID unique
            # DeviceID,StatusInformation,HealthState
          - type: awk
            script: EmbeddedFile(1)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4"
            # Patrol Status comes from HealthState
            # DeviceID,StatusInformation,HealthState
          - type: translate
            column: 3
            translationTable: statusTranslationTable
            # Add PD to the Identifier (see discovery)
            # DeviceID,StatusInformation,HealthState
          - type: leftConcat
            column: 1
            value: PD
      mapping:
        # ValueTable = Source(1)
        # DeviceID,StatusInformation,PatrolStatus
        source: $monitors.physical_disk.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="physical_disk"}: $column(3)
        legacyTextParameters:
          StatusInformation: $column(2)
