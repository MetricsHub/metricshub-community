---
connector:
  displayName: Oracle/Sun Solaris - Non-Sun Disks
  platforms: Oracle/Sun
  reliesOn: "Sun Solaris system commands (iostat, dd)"
  information: Gives physical disk information (status and error count) on Sun Solaris systems through the iostat -En utility. Supports only non-Sun official disks.
  version: 1.7
  detection:
    connectionTypes:
    - remote
    - local
    appliesTo:
    - Solaris
    criteria:
    # Solaris only
    - type: deviceType
      keep:
      - SunOS
      - Solaris
    # iostat must return something
    - type: osCommand
      commandLine: /usr/bin/iostat -En
      expectedResult: "Soft [Ee]rrors.*Hard [Ee]rrors.*Transport [Ee]rrors"
      errorMessage: iostat seems to not work as expected. Please check the output of 'iostat -En'
sudoCommands:
- /usr/bin/dd
monitors:
  disk_controller:
    discovery:
      sources:
        source(1):
          # Source(1) = output of iostat reformatted by the awk (see EmbeddedFile(1))
          # DeviceID
          type: osCommand
          commandLine: "/usr/bin/iostat -En|/usr/bin/awk -f ${file::embeddedFile-1}|/usr/bin/uniq"
          keep: ^MSHW;
          separators: ;
          selectColumns: 2
        source(2):
          # Source(2) = output of iostat
          type: osCommand
          commandLine: iostat -En
          computes:
            # Reformat iostat's output through awk (see EmbeddedFile(2))
            # DeviceID;ControllerNumber;Size;VendorModel;SerialNumber
          - type: awk
            script: "${file::embeddedFile-2}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5,6"
        source(3):
          # Source(3) = Table Joint of source(1) and source(2)
          # this is to remove disk controllers which don't have physical disks attached to
          # DeviceID;DiskDeviceID;ControllerNumber;Size;VendorModel;SerialNumber
          type: tableJoin
          leftTable: "${source::monitors.disk_controller.discovery.sources.source(1)}"
          rightTable: "${source::monitors.disk_controller.discovery.sources.source(2)}"
          leftKeyColumn: 1
          rightKeyColumn: 2
      mapping:
        # InstanceTable = Source(3)
        source: "${source::monitors.disk_controller.discovery.sources.source(3)}"
        attributes:
          id: $1
          __display_id: $1
          controller_number: $1
          model: ""
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"Disk Controller: %s (%s)\", $1, \"\")}"
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = copy of DiskController.Discovery.Source(2)
          type: copy
          from: "${source::monitors.disk_controller.discovery.sources.source(2)}"
      mapping:
        # InstanceTable = Source(1)
        source: "${source::monitors.physical_disk.discovery.sources.source(1)}"
        attributes:
          id: $1
          __display_id: $1
          vendor: $4
          serial_number: $5
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $2)"
          name: "${awk::sprintf(\"%s (%s - %s)\", $1, $4, bytes2HumanFormatBase10($3))}"
        metrics:
          hw.physical_disk.size: $3
    collect:
      # Collect type is "all instances in one shot
      type: multiInstance
      sources:
        source(1):
          # Source(1) = output of iostat
          type: osCommand
          commandLine: /usr/bin/iostat -En
          computes:
            # Source(1) = output of iostat reformatted by awk (see EmbeddedFile(3))
            # DeviceID;ErrorCount;HardErrorCount;MediaErrorCount;DeviceNotReadyErrorCount;NoDeviceErrorCount;TransportErrorCount;RecoverableErrorCount;IllegalRequestErrorCount;PredictedFailure
          - type: awk
            script: "${file::embeddedFile-3}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5,6,7,8,9,10,11"
        source(2):
          # Source(2) = output of the shell script based on the format command
          # DeviceID;Status;StatusInformation
          type: osCommand
          commandLine: "/usr/bin/sh ${file::embeddedFile-4}"
          keep: ^MSHW;
          separators: ;
          selectColumns: "2,3,4"
        source(3):
          # Source(3) = Table joint of Source(1) and Source(2)
          # DeviceID;ErrorCount;HardErrorCount;MediaErrorCount;DeviceNotReadyErrorCount;NoDeviceErrorCount;TransportErrorCount;RecoverableErrorCount;IllegalRequestErrorCount;PredictedFailure;DeviceID;Status;StatusInformation
          type: tableJoin
          leftTable: "${source::monitors.physical_disk.collect.sources.source(1)}"
          rightTable: "${source::monitors.physical_disk.collect.sources.source(2)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
      mapping:
        # ValueTable = Source(3)
        source: "${source::monitors.physical_disk.collect.sources.source(3)}"
        deviceId: $1
        metrics:
          hw.errors{hw.type="physical_disk"}: $2
          hw.errors{hw.type="physical_disk", hw.error.type="hard"}: $3
          hw.errors{hw.type="physical_disk", hw.error.type="media"}: $4
          hw.errors{hw.type="physical_disk", hw.error.type="device_not_ready"}: $5
          hw.errors{hw.type="physical_disk", hw.error.type="no_device"}: $6
          hw.errors{hw.type="physical_disk", hw.error.type="transport"}: $7
          hw.errors{hw.type="physical_disk", hw.error.type="recoverable"}: $8
          hw.errors{hw.type="physical_disk", hw.error.type="illegal_request"}: $9
          hw.status{hw.type="physical_disk", state="predicted_failure"}: boolean($10)
          hw.status{hw.type="physical_disk"}: $12
        legacyTextParameters:
          StatusInformation: $13
