---
connector:
  displayName: Oracle/Sun ZFS Storage Appliance
  platforms: Oracle ZFS Storage Appliance
  reliesOn: Oracle ZFS Command Line (SSH)
  information: "Provides chassis, CPU, disk, fan, memory, PSU and PCIe cards status for ZFS Storage Appliances"
  version: 1.0
  detection:
    connectionTypes:
    - remote
    appliesTo:
    - Storage
    criteria:
    - type: osCommand
      commandLine: maintenance hardware show
      expectedResult: ' *NAME *STATE *MANUFACTURER *MODEL *SERIAL *'
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Enclosures
          # Run the maintenance hardware show command
          type: osCommand
          forceSerialization: true
          commandLine: maintenance hardware show
          computes:
            # AWK it
            # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          - type: awk
            script: "${file::embeddedFile-1}"
            keep: ^MSHW;
            separators: ;
        source(2):
          # Make a copy so that other discoveries can use the raw results
          # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Keep Only Chassis
            # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: "chassis-[0-9]+$"
        source(3):
          # Make a copy so that other discoveries can use the Primary Chassis
          # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(2)}"
          computes:
            # Keep Only Chassis
            # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          - type: keepOnlyMatchingLines
            column: 2
            regExp: "chassis-[0-9]+$"
      mapping:
        # The discovery table = source(2)
        # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
        source: "${source::monitors.enclosure.discovery.sources.source(3)}"
        attributes:
          id: $3
          __display_id: $4
          vendor: $7
          model: $8
          serial_number: $9
          type: Chassis
          name: "${awk::sprintf(\"Enclosure: %s (%s %s)\", $4, $7, $8)}"
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Run the maintenance hardware show command
          type: osCommand
          forceSerialization: true
          commandLine: maintenance hardware show
          computes:
            # AWK it
            # chassis;id;state;state;rpm;
          - type: awk
            script: "${file::embeddedFile-1}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,5,6,10"
        source(2):
          # Make a copy so that other discoveries can use the raw results
          # chassis;id;state;state;rpm;
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep Only Chassis
            # chassis;id;PATROLStatus;state;rpm;
          - type: keepOnlyMatchingLines
            column: 2
            regExp: "chassis-[0-9]+$"
            # Translate the first Status code into a PATROLStatus
            # chassis;id;PATROLStatus;state;rpm;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        # chassis;id;PATROLStatus;state;rpm;
        source: "${source::monitors.enclosure.collect.sources.source(2)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="enclosure"}: $3
        legacyTextParameters:
          StatusInformation: $4
  fan:
    discovery:
      sources:
        source(1):
          # Take list of components from Enclosure 1
          # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Keep Only Chassis
            # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: "fan-[0-9]+$"
            # Add Serial Number to Addtional Infomation
            # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          - type: leftConcat
            column: 9
            value: "Serial Number: "
            # Exclude absent instances
            # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          - type: excludeMatchingLines
            column: 5
            valueList: absent
      mapping:
        # The discovery table = source(1)
        # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
        source: "${source::monitors.fan.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          info: $9
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $4
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Take the component status list from Enclosure 1
          # chassis;id;state;state;rpm;
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep Only Chassis
            # chassis;id;PATROLStatus;state;rpm;
          - type: keepOnlyMatchingLines
            column: 2
            regExp: "fan-[0-9]+$"
            # Translate the first Status code into a PATROLStatus
            # chassis;id;PATROLStatus;state;rpm;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        # chassis;id;PATROLStatus;state;rpm;
        source: "${source::monitors.fan.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="fan"}: $3
        legacyTextParameters:
          StatusInformation: $4
  power_supply:
    discovery:
      sources:
        source(1):
          # Take list of components from Enclosure 1
          # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Keep Only Chassis
            # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: "psu-[0-9]+$"
            # Add Serial Number to Addtional Infomation
            # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          - type: leftConcat
            column: 9
            value: "Serial Number: "
            # Exclude absent instances
            # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          - type: excludeMatchingLines
            column: 5
            valueList: absent
          - type: leftConcat
            column: 7
            value: "Vendor: "
          - type: leftConcat
            column: 8
            value: "Model: "
      mapping:
        # The discovery table = source(1)
        # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
        source: "${source::monitors.power_supply.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          info: "${awk::join(\" \", $7, $8, $9)}"
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $4
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Take the component status list from Enclosure 1
          # chassis;id;state;state;rpm;
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep Only Chassis
            # chassis;id;PATROLStatus;state;rpm;
          - type: keepOnlyMatchingLines
            column: 2
            regExp: "psu-[0-9]+$"
            # Translate the first Status code into a PATROLStatus
            # chassis;id;PATROLStatus;state;rpm;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        # chassis;id;PATROLStatus;state;rpm;
        source: "${source::monitors.power_supply.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="power_supply"}: $3
        legacyTextParameters:
          StatusInformation: $4
  other_device:
    discovery:
      sources:
        source(1):
          # Take list of components from Enclosure 1
          # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Keep Only Chassis
            # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: "slot-[0-9]+$"
            # Add Serial Number to Addtional Infomation
            # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          - type: leftConcat
            column: 9
            value: "Serial Number: "
            # Exclude absent instances
            # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          - type: excludeMatchingLines
            column: 5
            valueList: absent
          - type: leftConcat
            column: 7
            value: "Vendor: "
      mapping:
        # The discovery table = source(1)
        # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
        source: "${source::monitors.other_device.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          additional_label: $8
          device_type: Slot
          info: "${awk::join(\" \", $7, $9)}"
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s: %s (%s)\", \"Slot\", $4, $8)}"
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Take the component status list from Enclosure 1
          # chassis;id;state;state;rpm;
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep Only Chassis
            # chassis;id;PATROLStatus;state;rpm;
          - type: keepOnlyMatchingLines
            column: 2
            regExp: "slot-[0-9]+$"
            # Translate the first Status code into a PATROLStatus
            # chassis;id;PATROLStatus;state;rpm;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        # chassis;id;PATROLStatus;state;rpm;
        source: "${source::monitors.other_device.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="other_device"}: $3
        legacyTextParameters:
          StatusInformation: $4
  cpu:
    discovery:
      sources:
        source(1):
          # Take list of components from Enclosure 1
          # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Keep Only Chassis
            # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: "cpu-[0-9]+$"
            # Exclude absent instances
            # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          - type: excludeMatchingLines
            column: 5
            valueList: absent
      mapping:
        # The discovery table = source(1)
        # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
        source: "${source::monitors.cpu.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          model: $8
          vendor: $7
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s (%s - %s)\", $4, $7, $8)}"
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Take the component status list from Enclosure 1
          # chassis;id;state;state;rpm;
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep Only Chassis
            # chassis;id;PATROLStatus;state;rpm;
          - type: keepOnlyMatchingLines
            column: 2
            regExp: "cpu-[0-9]+$"
            # Translate the first Status code into a PATROLStatus
            # chassis;id;PATROLStatus;state;rpm;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        # chassis;id;PATROLStatus;state;rpm;
        source: "${source::monitors.cpu.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="cpu"}: $3
        legacyTextParameters:
          StatusInformation: $4
  memory:
    discovery:
      sources:
        source(1):
          # Take list of components from Enclosure 1
          # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Keep Only Chassis
            # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: "memory-[0-9]+$"
            # Exclude absent instances
            # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          - type: excludeMatchingLines
            column: 5
            valueList: absent
      mapping:
        # The discovery table = source(1)
        # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
        source: "${source::monitors.memory.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          model: $8
          vendor: $7
          serial_number: $9
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s (%s)\", $4, $7)}"
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Take the component status list from Enclosure 1
          # chassis;id;state;state;rpm;
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep Only Chassis
            # chassis;id;PATROLStatus;state;rpm;
          - type: keepOnlyMatchingLines
            column: 2
            regExp: "memory-[0-9]+$"
            # Translate the first Status code into a PATROLStatus
            # chassis;id;PATROLStatus;state;rpm;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        # chassis;id;PATROLStatus;state;rpm;
        source: "${source::monitors.memory.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="memory"}: $3
        legacyTextParameters:
          StatusInformation: $4
  physical_disk:
    discovery:
      sources:
        source(1):
          # Take list of components from Enclosure 1
          # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(1)}"
          computes:
            # Keep Only Chassis
            # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: "disk-[0-9]+$"
            # Exclude absent instances
            # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          - type: excludeMatchingLines
            column: 5
            valueList: absent
            # Convert size from GB to B
            # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
          - type: multiply
            column: 11
            value: 1000000000
            # "RPM: " to the rpm field
            # MSHW;chassis;id;name;state;state;manufacturer;model;serial;RPM: rpm;size;
          - type: leftConcat
            column: 10
            value: "RPM: "
      mapping:
        # The discovery table = source(1)
        # MSHW;chassis;id;name;state;state;manufacturer;model;serial;rpm;size;
        source: "${source::monitors.physical_disk.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          model: $8
          vendor: $7
          serial_number: $9
          info: $10
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s (%s - %s)\", $4, $7, bytes2HumanFormatBase10($11))}"
        metrics:
          hw.physical_disk.size: $11
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Take the component status list from Enclosure 1
          # chassis;id;state;state;rpm;
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep Only Chassis
            # chassis;id;PATROLStatus;state;rpm;
          - type: keepOnlyMatchingLines
            column: 2
            regExp: "disk-[0-9]+$"
            # Translate the first Status code into a PATROLStatus
            # chassis;id;PATROLStatus;state;rpm;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        # chassis;id;PATROLStatus;state;rpm;
        source: "${source::monitors.physical_disk.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="physical_disk"}: $3
        legacyTextParameters:
          StatusInformation: $4
  logical_disk:
    discovery:
      sources:
        source(1):
          # LogicalDisk
          # Run the status storage show command
          type: osCommand
          forceSerialization: true
          commandLine: status storage show
          computes:
            # AWK it
            # pool;Available;
          - type: awk
            script: "${file::embeddedFile-3}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,6"
            # Convert the size into bytes
            # pool;Available;
          - type: multiply
            column: 2
            value: 1073741824
        source(2):
          # Run the configuration storage show command
          type: osCommand
          forceSerialization: true
          commandLine: Configuration storage show
          computes:
            # AWK it
            # pool;RaidLevel;
          - type: awk
            script: "${file::embeddedFile-2}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3"
        source(3):
          # Join 1 & 2
          # pool;Available;pool;RaidLevel;
          type: tableJoin
          leftTable: "${source::monitors.logical_disk.discovery.sources.source(1)}"
          rightTable: "${source::monitors.logical_disk.discovery.sources.source(2)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          defaultRightLine: ;;
          computes:
            # Add PrimaryChassis to the right of the table
            # pool;Available;pool;RaidLevel;PrimaryChassis;
          - type: rightConcat
            column: 4
            value: ;PrimaryChassis
        source(4):
          # Join Logical Disk Source with Enclosure Discovery 1
          # pool;Available;pool;RaidLevel;PrimaryChassis;MSHW;PrimaryChassis;Chassis;
          type: tableJoin
          leftTable: "${source::monitors.logical_disk.discovery.sources.source(3)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(2)}"
          leftKeyColumn: 5
          rightKeyColumn: 2
          defaultRightLine: ;;;
      mapping:
        # InstanceTable = Source(3)
        # pool;Available;pool;RaidLevel;PrimaryChassis;MSHW;PrimaryChassis;Chassis;
        source: "${source::monitors.logical_disk.discovery.sources.source(4)}"
        attributes:
          id: $1
          __display_id: $1
          raid_level: $4
          hw.parent.type: enclosure
          hw.parent.id: $8
          name: "${awk::sprintf(\"%s (%s - %s)\", $1, $4, bytes2HumanFormatBase2($2))}"
        metrics:
          hw.logical_disk.limit: $2
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Run the maintenance hardware show command
          type: osCommand
          forceSerialization: true
          commandLine: status storage show
          computes:
            # AWK it
            # pool;State;State;Free;
          - type: awk
            script: "${file::embeddedFile-3}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,7"
            # Translate the first Status code into a PATROLStatus
            # pool;PatrolStatus;State;Free;
          - type: translate
            column: 2
            translationTable: "${translation::LogicalDiskStatusTranslationTable}"
            # Convert the free space into bytes
            # pool;PatrolStatus;State;Free;
          - type: multiply
            column: 4
            value: 1073741824
      mapping:
        # ValueTable = Source(1)
        # pool;PatrolStatus;State;Free;
        source: "${source::monitors.logical_disk.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="logical_disk"}: $2
          hw.logical_disk.usage{state="free"}: $4
          hw.logical_disk.usage{state="used"}: collectAllocatedSpace()
        legacyTextParameters:
          StatusInformation: $3
  network:
    discovery:
      sources:
        source(1):
          # FC POrts
          # Run the configuration san targets fc list
          type: osCommand
          forceSerialization: true
          commandLine: configuration san targets fc list
          computes:
            # AWK it
            # DeviceID;Address;DisplayID;Mode;AddressType;
          - type: awk
            script: "${file::embeddedFile-4}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,5,6,8"
        source(2):
          # Run the configuration net devices list
          type: osCommand
          forceSerialization: true
          commandLine: configuration net devices list
          computes:
            # AWK it
            # DeviceID;Address;DisplayID;Mode;AddressType;
          - type: awk
            script: "${file::embeddedFile-5}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,5,6,8"
        source(3):
          # Union 1 & 2
          # DeviceID;Address;DisplayID;Mode;AddressType;
          type: tableUnion
          tables:
          - "${source::monitors.network.discovery.sources.source(1)}"
          - "${source::monitors.network.discovery.sources.source(2)}"
          computes:
            # Add PrimaryChassis to the right of the table
            # DeviceID;Address;DisplayID;Mode;AddressType;PrimaryChassis;
          - type: rightConcat
            column: 5
            value: ;PrimaryChassis
        source(4):
          # Join Logical Disk Source with Enclosure Discovery 1
          # DeviceID;Address;DisplayID;Mode;AddressType;PrimaryChassis;MSHW;PrimaryChassis;Chassis;
          type: tableJoin
          leftTable: "${source::monitors.network.discovery.sources.source(3)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(2)}"
          leftKeyColumn: 6
          rightKeyColumn: 2
          defaultRightLine: ;;;
      mapping:
        # InstanceTable = Source(3)
        # DeviceID;Address;DisplayID;Mode;AddressType;PrimaryChassis;MSHW;PrimaryChassis;Chassis;
        source: "${source::monitors.network.discovery.sources.source(4)}"
        attributes:
          id: $1
          __display_id: $3
          physical_address: $2
          physical_address_type: $5
          device_type: $4
          hw.parent.type: enclosure
          hw.parent.id: $9
          name: "${awk::sprintf(\"%s (%s)\", $3, $4)}"
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Run the configuration san targets fc list command
          type: osCommand
          forceSerialization: true
          commandLine: configuration san targets fc list
          computes:
            # AWK it
            # ID;speed;link(speed);
          - type: awk
            script: "${file::embeddedFile-4}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,4,7"
            # Translate the link(speed) code into a LinkStatus
            # ID;speed;LinkStatus;
          - type: translate
            column: 3
            translationTable: "${translation::FCspeedTranslationTable}"
        source(2):
          # Run the configuration net devices list command
          type: osCommand
          forceSerialization: true
          commandLine: configuration net devices list
          computes:
            # AWK it
            # ID;speed;linkUP;
          - type: awk
            script: "${file::embeddedFile-5}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,4,7"
            # Translate the linkUP code into a LinkStatus
            # ID;speed;LinkStatus;
          - type: translate
            column: 3
            translationTable: "${translation::linkUPTranslationTable}"
        source(3):
          # Union 1 & 2
          # ID;speed;LinkStatus;
          type: tableUnion
          tables:
          - "${source::monitors.network.collect.sources.source(1)}"
          - "${source::monitors.network.collect.sources.source(2)}"
      mapping:
        # ValueTable = 3(1)
        # ID;speed;LinkStatus;
        source: "${source::monitors.network.collect.sources.source(3)}"
        deviceId: $1
        metrics:
          hw.network.up: legacyLinkStatus($3)
          hw.network.bandwidth.limit: megaBit2Bit($2)
translations:
  linkUPTranslationTable:
    "true": ok
    "false": degraded
  FCspeedTranslationTable:
    "0": degraded
    Default: ok
  StatusTranslationTable:
    faulted: failed
    absent: failed
    ok: ok
    Default: failed
  LogicalDiskStatusTranslationTable:
    faulted: failed
    online: ok
    Default: failed
