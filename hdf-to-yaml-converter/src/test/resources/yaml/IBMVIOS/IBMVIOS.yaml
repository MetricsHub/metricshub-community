---
extends:
- ../IBMAIXModels-header/IBMAIXModels-header
connector:
  displayName: IBM VIO Server
  platforms: IBM POWER
  reliesOn: "IBM AIX system commands through the IOS interface (lsdev, entstat, etc.)"
  information: "Provides hardware status information (processors, memory modules, network interfaces, HBAs, physical disks) on IBM VIO systems."
  version: 1.3
  detection:
    connectionTypes:
    - remote
    - local
    appliesTo:
    - RS6000
    supersedes:
    - IBMAIX
    - IBMAIXChrpMachstat
    - IBMAIXDisk
    - IBMAIXHBA
    - IBMAIXUeSensor
    criteria:
    # OS should be AIX (whatever version)
    - type: deviceType
      keep:
      - RS6000
    # uname should return vioserver
    - type: osCommand
      commandLine: ioscli uname -a
      expectedResult: AIX
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Source(1) = the output of uname -M
          # MachineIDNumber;ModelCode;SystemID;LPARSystemID;
          type: osCommand
          commandLine: ioscli uname -mMfF
          keep: " IBM,"
          separators: ' '
          selectColumns: "1,2,3,4"
          computes:
            # Duplicate the MachineIDNumber
            # MachineIDNumber;MachineIDNumber;ModelCode;LPARSystemID;SystemID;
          - type: duplicateColumn
            column: 1
            # Remove the IBM,  (We, unfortunately, already know it's an IBM)
            # MachineIDNumber;MachineIDNumber;ModelCode;LPARSystemID;SystemID;
          - type: replace
            column: 3
            existingValue: "IBM,"
            newValue: ""
            # Add descriptive prefixes to the different IDs
            # MachineIDNumber;MachineIDNumber;ModelCode;LPARSystemID;SystemID;
          - type: leftConcat
            column: 2
            value: "Machine ID: "
          - type: leftConcat
            column: 4
            value: "LPAR System ID: "
          - type: leftConcat
            column: 5
            value: "System ID: "
            # Duplicate the ModelCode
            # MachineIDNumber;MachineIDNumber;ModelCode;ModelCode;LPARSystemID;SystemID;
          - type: duplicateColumn
            column: 3
            # Translate the 2nd Model Code into a Model Name
            # The translation table will need to be regularly updated
            # MachineIDNumber;MachineIDNumber;ModelCode;ModelName;LPARSystemID;SystemID;
          - type: translate
            column: 4
            translationTable: ModelTranslationTable
      mapping:
        # The discovery table
        # MachineIDNumber;MachineIDNumber;ModelCode;ModelName;LPARSystemID;SystemID;
        source: $monitors.enclosure.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(3)
          vendor: IBM
          model: $column(4)
          type: Computer
          serial_number: $column(1)
          info: "join(\" \", $column(2), $column(6), $column(5))"
          name: "sprintf(\"Computer: %s (%s %s)\", $column(3), \"IBM\", $column(4))"
  cpu:
    discovery:
      sources:
        source(1):
          # Source(1) = lsdev
          # cpuID;
          type: osCommand
          commandLine: ioscli lsdev -field name
          separators: ","
          keep: ^proc
      mapping:
        # Instance table = source(1)
        source: $monitors.cpu.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          hw.parent.type: enclosure
          name: $column(1)
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          type: osCommand
          commandLine: "ioscli lsdev -fmt : -field name status"
          keep: ^proc
          separators: ':'
          selectColumns: "1,2"
          computes:
            # Duplicate the status column
            # cpuID;cpuStatus;cpuStatus
          - type: duplicateColumn
            column: 2
            # Translate the first status column into a PATROL status
            # cpuID;PATROLStatus;cpuStatus
          - type: translate
            column: 2
            translationTable: cpuStatusTranslationTable
            # Translate the second status column into a more readable string
            # cpuID;PATROLStatus;statusInformation
          - type: translate
            column: 3
            translationTable: cpuStatusInformationTranslationTable
      mapping:
        # ' "ValueTable = source(1)'
        source: $monitors.cpu.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="cpu"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
  memory:
    discovery:
      sources:
        source(1):
          # Source(1) = output of ioscli lsdev -vpd
          type: osCommand
          commandLine: ioscli lsdev -vpd
          computes:
            # Reformat lscfg's output through awk (see EmbeddedFile(6))
            # DeviceID;Size;SerialNumber
          - type: awk
            script: $file("embeddedFile-6")$
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4"
            # Add ";1;" to the DeviceID that will correspond to the Status and ErrorCount ParameterActivation values
            # DeviceID;StatusActivation;ErrorCountActivation;Size;SerialNumber
          - type: rightConcat
            column: 1
            value: ;1;
        source(2):
          # Source(2) = Static table to represent the global memory stuff
          type: static
          value: Memory Controller;;1;;;
        source(3):
          # Source(3) = Union of Source(1) and Source(2)
          # DeviceID;StatusActivation;ErrorCountActivation;Size;SerialNumber
          type: tableUnion
          tables:
          - $monitors.memory.discovery.sources.source(1)$
          - $monitors.memory.discovery.sources.source(2)$
        source(4):
          # Source (4) = Date + Complete Errorlog
          # Not used in Discovery, it is used in the collect.  But as it can be a large file and we don't want to collect it
          # too often, "true" memory collects will only be done once per hour.
          type: osCommand
          commandLine: "ioscli errlog -ls | grep -c -E \"CORRECTED_SCRUB||MEM[0-9]||RECOV_ECC_ERR||CORRECTED_SCRUB\""
          computes:
            # Add the Memory Controller Identifier
            # DeviceID;Status;StatusInformation;ErrorCount
          - type: leftConcat
            column: 1
            value: Memory Controller;;;
      mapping:
        # InstanceTable = Source(1)
        source: $monitors.memory.discovery.sources.source(3)$
        attributes:
          id: $column(1)
          serial_number: $column(5)
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s MB)\", $column(1), $column(4))"
        metrics:
          hw.memory.limit: mebiByte2Byte($column(4))
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = output of ioscli lsdev -vpd
          type: osCommand
          commandLine: ioscli lsdev -vpd
          computes:
            # Reformat lsdev's output through awk (see EmbeddedFile(6))
            # DeviceID;Status;StatusInformation;
          - type: awk
            script: $file("embeddedFile-6")$
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,5,6"
            # Add ";" to the right, as an empty ErrorCount column
            # DeviceID;Status;StatusInformation;ErrorCount
          - type: rightConcat
            column: 3
            value: ;
        source(2):
          # Source(4) = Number of events reported by errlog of type "memory"
          # this is done in discovery
          # DeviceID;Status;StatusInformation;ErrorCount
          type: copy
          from: $monitors.memory.discovery.sources.source(4)$
        source(3):
          # Source(3) = Union of Source(1) and Source(2)
          type: tableUnion
          tables:
          - $monitors.memory.collect.sources.source(1)$
          - $monitors.memory.collect.sources.source(2)$
      mapping:
        # Value table = Source(1)
        source: $monitors.memory.collect.sources.source(3)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="memory"}: $column(2)
          hw.errors{hw.type="memory"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(3)
  disk_controller:
    discovery:
      sources:
        source(1):
          # Source(1) = output of lsdev - list of disk "parents"
          # diskDevicePath
          type: osCommand
          commandLine: ioscli lsdev -field physloc -type disk
          computes:
            # Retrieve the controller device path from the disk device path
            # controllerDevicePath; (may be several identical instances)
          - type: substring
            column: 1
            start: 1
            length: 5
        source(2):
          # Source(2) = output of lsdev -field name physloc description -fmt : -type adapter
          # adapterDevicePath;DeviceID;displayName;
          type: osCommand
          commandLine: "ioscli lsdev -field physloc name description -fmt : -type adapter"
          separators: ':'
          selectColumns: "1,2,3"
          computes:
            # Keep only scsi[0-9]* disk controllers (not RAID or SSA)
            # adapterDevicePath;DeviceID;displayName
          - type: keepOnlyMatchingLines
            column: 2
            regExp: "\\(^sisscsi[A-Za-z0-9]+$\\)\\|\\(^scsi[A-Za-z0-9]+$\\)\\|\\(^sisio[A-Za-z0-9]+$\\)\\|\\(^sissas[A-Za-z0-9]+$\\)"
            # Retrieve the controller device path from the disk device path
            # adapterDevicePath;DeviceID;displayName
          - type: substring
            column: 1
            start: 1
            length: 5
        source(3):
          # Source(3) = Table joint of Source(1) and Source(2)
          # This jointure will make MSHW keep only adapters that are disk controllers
          # with disks attached to them
          # adapterDevicePath;DeviceID;displayName;controllerDevicePath
          type: tableJoin
          leftTable: $monitors.disk_controller.discovery.sources.source(2)$
          rightTable: $monitors.disk_controller.discovery.sources.source(1)$
          leftKeyColumn: 1
          rightKeyColumn: 1
        source(4):
          # Source (4) = Complete Errorlog
          # Not used in Discovery, it is used in the collect.  But as it can be a large file and we don't want to collect it
          # too often, "true" Disk Controller / PhysicalDisk errocount will only be done once per hour.
          type: osCommand
          commandLine: date +MSHW_DATE%%m%%d0000%%y;datestring=`date +%%m%%d`;ioscli errlog | grep $datestring
          computes:
            # Parsing this through an awk script
            # DeviceID;ErrorCount;
          - type: awk
            script: $file("embeddedFile-7")$
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3"
      mapping:
        # InstanceTable = Source(5)
        source: $monitors.disk_controller.discovery.sources.source(3)$
        attributes:
          id: $column(2)
          controller_number: $column(4)
          model: $column(3)
          hw.parent.type: enclosure
          name: "sprintf(\"Disk Controller: %s (%s)\", $column(4), $column(3))"
    collect:
      # Collect type = multi-instance
      type: multiInstance
      sources:
        source(1):
          # Table Join Discovery Source (3) - Instance Table, with Discovery Table (4) - Errorcounts
          # adapterDevicePath;DeviceID;displayName;controllerDevicePath;DeviceID;ErrorCount;
          type: tableJoin
          leftTable: $monitors.disk_controller.discovery.sources.source(3)$
          rightTable: $monitors.disk_controller.discovery.sources.source(4)$
          leftKeyColumn: 2
          rightKeyColumn: 1
          defaultRightLine: ;0;
          computes:
            # Duplicate the ErrorCount Column
            # adapterDevicePath;DeviceID;displayName;controllerDevicePath;DeviceID;ErrorCount;ErrorCount;
          - type: duplicateColumn
            column: 6
            # Translate the errorcount into a status (as errorcount does not exist for Disk Controllers)
            # adapterDevicePath;DeviceID;displayName;controllerDevicePath;DeviceID;PatrolStatus;ErrorCount;
          - type: translate
            column: 6
            translationTable: ErrorcounttoStatusTranslationTable
            # Translate the errorcount into a status (as errorcount does not exist for Disk Controllers)
            # adapterDevicePath;DeviceID;displayName;controllerDevicePath;DeviceID;PatrolStatus;PatrolStatusInfo;
          - type: translate
            column: 7
            translationTable: ErrorcounttoStatusInformationTranslationTable
      mapping:
        # ValueTable = Source(1)
        # adapterDevicePath;DeviceID;displayName;controllerDevicePath;DeviceID;PatrolStatus;PatrolStatusInfo;
        source: $monitors.disk_controller.collect.sources.source(1)$
        metrics:
          hw.status{hw.type="disk_controller"}: $column(6)
        legacyTextParameters:
          StatusInformation: $column(7)
        deviceId: $column(2)
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = output of ioscli lsdev -field physloc -type disk
          # diskName;diskPath
          type: osCommand
          commandLine: "ioscli lsdev -fmt : -field name physloc -type disk"
          keep: ^hdisk
          separators: ':'
          selectColumns: "1,2"
          computes:
            # Keep only the first 5 chars of the diskPath to obtain the diskControllerID
            # DeviceID;controllerID
          - type: substring
            column: 2
            start: 1
            length: 5
        source(2):
          # Source(1) = output of ioscli lsdev -vpd
          type: osCommand
          commandLine: ioscli lsdev -vpd
          computes:
            # Reformat lsdev's output through awk (see EmbeddedFile(3))
            # DeviceID;size;make-model-FRU;Serial;
          - type: awk
            script: $file("embeddedFile-3")$
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5"
        source(3):
          # Source(3) = Table joint of Source(1) and Source(2)
          # DeviceID;controllerID;DeviceID;size;make-model-FRU;Serial;
          type: tableJoin
          leftTable: $monitors.physical_disk.discovery.sources.source(1)$
          rightTable: $monitors.physical_disk.discovery.sources.source(2)$
          leftKeyColumn: 1
          rightKeyColumn: 1
          computes:
            # Translate size into bytes
            # DeviceID;controllerID;DeviceID;size;make-model-FRU;Serial;
          - type: multiply
            column: 4
            value: 1073741824
      mapping:
        # Now we are ready to go
        # InstanceTable = Source(4)
        # DeviceID;controllerID;DeviceID;size;make-model-FRU;Serial;
        source: $monitors.physical_disk.discovery.sources.source(3)$
        attributes:
          id: $column(1)
          vendor: $column(5)
          serial_number: $column(6)
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $column(2))"
          name: "sprintf(\"%s (%s - %s)\", $column(1), $column(5), bytes2HumanFormatBase10($column(4)))"
        metrics:
          hw.physical_disk.size: $column(4)
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          type: osCommand
          commandLine: "ioscli lsdev -fmt : -field name status"
          keep: ^hdisk
          separators: ':'
          selectColumns: "1,2"
          computes:
            # Duplicate the status column
            # PhysicalDiskID;PhysicalDiskStatus;PhysicalDiskStatus
          - type: duplicateColumn
            column: 2
            # Translate the first status column into a PATROL status
            # PhysicalDiskID;PATROLStatus;PhysicalDiskStatus
          - type: translate
            column: 2
            translationTable: PhysicalDiskStatusTranslationTable
            # Translate the second status column into a more readable string
            # PhysicalDiskID;PATROLStatus;statusInformation
          - type: translate
            column: 3
            translationTable: PhysicalDiskStatusInformationTranslationTable
        source(2):
          # Table Join Discovery Source (3) - Instance Table, with Discovery Table (4) - Errorcounts
          # PhysicalDiskID;PATROLStatus;statusInformation;DeviceID;ErrorCount;
          type: tableJoin
          leftTable: $monitors.physical_disk.collect.sources.source(1)$
          rightTable: $monitors.disk_controller.discovery.sources.source(4)$
          leftKeyColumn: 1
          rightKeyColumn: 1
          defaultRightLine: ;0;
      mapping:
        #  "ValueTable = source(1)
        # PhysicalDiskID;PATROLStatus;statusInformation;DeviceID;ErrorCount;
        source: $monitors.physical_disk.collect.sources.source(2)$
        deviceId: $column(1)
        legacyTextParameters:
          StatusInformation: $column(3)
  network:
    discovery:
      sources:
        source(1):
          # Source(1) = output of fcstat (Fiber Cards)
          type: osCommand
          commandLine: "for FCSTAT in $(for NIC in `for a in $(for i in $(ioscli lsdev -type  disk -field name -state Available && ioscli lsdev -type tape -field name |grep \"^hdisk|^rmt\"); do ioscli lsdev -dev $i -parent  ; done |grep ^fs|sort -n |uniq); do ioscli lsdev -dev $a -parent; done |grep ^fc ; ioscli lsmap -all -npiv |awk '{FS=\":\"} /name:fcs/ && /loc/  {print $2}' |awk '{print $1}' |uniq `; do echo $NIC ; done |uniq); do  fcstat $FCSTAT ; done"
          computes:
            # AWK it
            # MSHW;portID;;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;WWPN;AddressType;SerialNumber;
          - type: awk
            script: $file("embeddedFile-4")$
            keep: ^MSHW;
            separators: ;
        source(2):
          # Source(2) = output of netstat (Ethernet Cards)
          type: osCommand
          commandLine: "STR0=$(ioscli lsdev -type adapter -state Available -field name|egrep '^ent'); STR1=$(ioscli lsmap -all -npiv |awk '/FC name:/ {print $2}' |sort |uniq |cut -c '6-10'); STR2=$(ioscli viostat -adapter |awk '/fcs/ {print $1}') ;for i in $(for i in $(echo $STR0 $STR1 $STR2); do echo $i; done |sort |uniq) ; do ioscli netstat -cdlistats $i; done"
          computes:
            # AWK it
            # MSHW;portID;Status;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;WWPN;
          - type: awk
            script: $file("embeddedFile-5")$
            keep: ^MSHW;
            separators: ;
            # Add MAC and blank serial number - This is done so that Embedded File 5 matched the one in IBM AIX Embedded file 3
            # MSHW;portID;Status;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;MAC;AddressType;SerialNumber;
          - type: rightConcat
            column: 13
            value: ;MAC;
        source(3):
          # Source(3) = Union of Source(1) and Source(2)
          # MSHW;portID;;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;MAC;AddressType;SerialNumber;
          type: tableUnion
          tables:
          - $monitors.network.discovery.sources.source(1)$
          - $monitors.network.discovery.sources.source(2)$
      mapping:
        # InstanceTable = Source(1)
        # 1     2     3        # 4        #    5        #    6       7        # 8      9       10   11    12      13    14         15
        # MSHW;portID;Status;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;MAC;AddressType;SerialNumber;
        source: $monitors.network.discovery.sources.source(3)$
        attributes:
          id: $column(2)
          physical_address: $column(13)
          physical_address_type: $column(14)
          device_type: $column(12)
          serial_number: $column(15)
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s)\", $column(2), $column(12))"
    collect:
      # The NetworkCard collect is a "MultiInstance" collect
      type: multiInstance
      sources:
        source(1):
          # Source(1) = output of fcstat (Fiber Cards)
          type: osCommand
          commandLine: "for FCSTAT in $(for NIC in `for a in $(for i in $(ioscli lsdev -type  disk -field name -state Available && ioscli lsdev -type tape -field name |grep \"^hdisk|^rmt\"); do ioscli lsdev -dev $i -parent  ; done |grep ^fs|sort -n |uniq); do ioscli lsdev -dev $a -parent; done |grep ^fc ; ioscli lsmap -all -npiv |awk '{FS=\":\"} /name:fcs/ && /loc/  {print $2}' |awk '{print $1}' |uniq `; do echo $NIC ; done |uniq); do  fcstat $FCSTAT ; done"
          computes:
            # AWK it
            # MSHW;portID;;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;WWPN;AddressType;SerialNumber;
          - type: awk
            script: $file("embeddedFile-4")$
            keep: ^MSHW;
            separators: ;
        source(2):
          # Source(2) = output of netstat (Ethernat Cards)
          type: osCommand
          commandLine: "STR0=$(ioscli lsdev -type adapter -state Available -field name|egrep '^ent'); STR1=$(ioscli lsmap -all -npiv |awk '/FC name:/ {print $2}' |sort |uniq |cut -c '6-10'); STR2=$(ioscli viostat -adapter |awk '/fcs/ {print $1}') ;for i in $(for i in $(echo $STR0 $STR1 $STR2); do echo $i; done |sort |uniq) ; do ioscli netstat -cdlistats $i; done"
          computes:
            # AWK it
            # MSHW;portID;;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;WWPN;
          - type: awk
            script: $file("embeddedFile-5")$
            keep: ^MSHW;
            separators: ;
        source(3):
          # Source(3) = Union of Source(1) and Source(2)
          # MSHW;portID;;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;WWPN;AddressType;SerialNumber;
          type: tableUnion
          tables:
          - $monitors.network.collect.sources.source(1)$
          - $monitors.network.collect.sources.source(2)$
      mapping:
        # ValueTable = Source(1)
        # MSHW;portID;;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;WWPN;AddressType;SerialNumber;
        source: $monitors.network.collect.sources.source(3)$
        deviceId: $column(2)
        metrics:
          hw.network.bandwidth.limit: megaBit2Bit($column(10))
          hw.network.up: legacyLinkStatus($column(4))
          hw.network.packets{direction="receive"}: $column(7)
          hw.network.packets{direction="transmit"}: $column(6)
          hw.errors{hw.type="network"}: $column(5)
          hw.network.io{direction="receive"}: $column(9)
          hw.network.io{direction="transmit"}: $column(8)
          hw.network.full_duplex: legacyFullDuplex($column(11))
  lun:
    discovery:
      sources:
        source(1):
          # Get the list of Ports from lspath
          type: osCommand
          commandLine: ioscli lspath
          computes:
            # AWK it
            # LunName;LunInfo;LunStatus;
          - type: awk
            script: $file("embeddedFile-1")$
            keep: ^MSHW;
            separators: ;
            selectColumns: 2
      mapping:
        # InstanceTable = Source(1)
        # LunName;LunInfo;LunStatus;
        source: $monitors.lun.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          hw.parent.type: enclosure
          name: $column(1)
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Get the list of Ports from multipath -l
          type: osCommand
          commandLine: ioscli lspath
          computes:
            # AWK it
            # LunName;NumberPaths;
          - type: awk
            script: $file("embeddedFile-1")$
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3"
      mapping:
        # ValueTable = Source(1)
        # LunName;NumberPaths;LunStatus;LunStatusInfo;AvailablePathInformation;
        source: $monitors.lun.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.lun.paths: $column(2)
translations:
  PhysicalDiskStatusInformationTranslationTable:
    Stopped: Stopped
    Defined: Defined
    Available: Available
    Default: Unknown Status
  ErrorcounttoStatusTranslationTable:
    "0": ok
    Default: failed
  cpuStatusInformationTranslationTable:
    Stopped: Stopped
    Defined: Defined
    Available: Available
    Default: Unknown Status
  ErrorcounttoStatusInformationTranslationTable:
    "0": No Disk Controller Events found today (Parameter only collects every hour)
    Default: Disk Controller Events found today - Run errlog for more details
  cpuStatusTranslationTable:
    Stopped: degraded
    Defined: ok
    Available: ok
    Default: UNKNOWN
  PhysicalDiskStatusTranslationTable:
    Stopped: degraded
    Defined: ok
    Available: ok
    Default: UNKNOWN
