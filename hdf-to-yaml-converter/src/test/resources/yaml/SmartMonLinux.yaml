---
embedded:
  EmbeddedFile(1): "#!/bin/sh\nSMARTD=$1\nSMARTCTL=$2\nTMPFILE=/tmp/MS_HW_smartmontoolsHDF_$$\n\n$SMARTD -c>$TMPFILE\n$SMARTD -q onecheck>>$TMPFILE\n\nDISKIDLIST=`cat $TMPFILE|awk '/^Device: .* is SMART capable/ {\n\tdeviceID = $2;\n\tif (substr(deviceID, length(deviceID), 1) == \",\")\n\t{\n\t\tdeviceID = substr(deviceID, 1, length(deviceID)-1);\n\t}\n\tprint deviceID\n}'`\n\n/bin/rm -f $TMPFILE\n\nfor DISKID in $DISKIDLIST\ndo\n\t$SMARTCTL -a $DISKID|awk -v deviceID=$DISKID 'BEGIN {\n\t\tvendor = \"\";\n\t\tserialNumber = \"\";\n\t}\n\t{\n\t\tif ($1 == \"Device:\")\n\t\t{\n\t\t\tif ($5 == \"Version:\") { vendor = $2 \" \" $3 \" \" $4; }\n\t\t\telse if ($4 == \"Version:\") { vendor = $2 \" \" $3; }\n\t\t\telse { vendor = $2; }\n\t\t}\n\n\t\tif ($1 == \"Device\" && $2 == \"Model:\")\n\t\t{\n\t\t\tvendor = $3;\n\t\t}\n\n\t\tif ($0 ~ /^Serial [Nn]umber: /)\n\t\t{\n\t\t\tserialNumber = $3;\n\t\t}\n\t}\n\tEND {\n\t\tprint \"MSHW;\" deviceID \";\" vendor \";\" serialNumber\n\t}'\ndone"
  EmbeddedFile(3): "{\n\tif ($0 ~ /Current Drive Temperature: *[0-9]* C$/)\n\t{\n\t\tprint \"MSHW;\" $4\n\t\texit;\n\t}\n\n\tif ($1 == \"194\" && $10 ~ /[0-9]+/)\n\t{\n\t  print \"MSHW;\" $10\n\t  exit;\n\t}\n}"
  EmbeddedFile(2): "#!/bin/sh\nSMARTD=$1\nSMARTCTL=$2\nTMPFILE=/tmp/MS_HW_smartmontoolsHDF_$$\n\n$SMARTD -c>$TMPFILE\n$SMARTD -q onecheck>>$TMPFILE\n\nDISKIDLIST=`cat $TMPFILE|awk '/^Device: .* is SMART capable/ {\n\tdeviceID = $2;\n\tif (substr(deviceID, length(deviceID), 1) == \",\")\n\t{\n\t\tdeviceID = substr(deviceID, 1, length(deviceID)-1);\n\t}\n\tprint deviceID\n}'`\n\n/bin/rm -f $TMPFILE\n\nfor DISKID in $DISKIDLIST\ndo\n\t$SMARTCTL -a $DISKID|awk -v deviceID=$DISKID 'BEGIN {\n\t\tfoundTemperature = 0;\n\t\twarningThreshold = \"\";\n\t}\n\t{\n\t\tif ($0 ~ /^Current Drive Temperature: *[0-9]* C$/)\n\t\t{\n\t\t\tfoundTemperature = 1;\n\t\t}\n\n\t\tif ($1 == \"194\" && $10 ~ /[0-9]+/)\n\t\t{\n\t\t  foundTemperature = 1;\n\t\t  warningThreshold = 53;\n\t\t}\n\n\t\tif ($0 ~ /^Drive Trip Temperature: /)\n\t\t{\n\t\t\twarningThreshold = $4;\n\t\t}\n\t}\n\tEND {\n\t\tif (foundTemperature == 1)\n\t\t{\n\t\t\tprint \"MSHW;\" deviceID \";\" warningThreshold\n\t\t}\n\t}'\ndone"
  EmbeddedFile(5): "#!/bin/sh\nERRORMESSAGE=`%{SUDO:/bin/dd}/bin/dd if=$1 of=/dev/null count=20 2>&1`\nif [ \"$?\" = \"0\" ]; then\n\t/bin/echo \"MSHW;1;OK;Working\";\nelse\n\tERRORMESSAGE=`/bin/echo $ERRORMESSAGE|/bin/awk -F: '($4 !~ /denied/ && $4 !~ /[Nn]o such file/) {print $4}'`\n\tif [ -z \"$ERRORMESSAGE\" ]; then\n\t\t/bin/echo \"MSHW;1;UNKNOWN;Unknown Status\";\n\telse\n\t\t/bin/echo \"MSHW;1;ALARM;$ERRORMESSAGE\";\n\tfi\nfi"
  EmbeddedFile(4): "{\n\tif ($0 ~ /^SMART Sense: /)\n\t{\n\t\tprint \"MSHW;\" $3\n\t\texit;\n\t}\n\n\tif ($0 ~ /^SMART Health Status: /)\n\t{\n\t\tprint \"MSHW;\" $4\n\t\texit;\n\t}\n\n\tif ($0 ~ /^SMART overall-health self-assessment test result: /)\n\t{\n\t\tprint \"MSHW;\" $6\n\t\texit;\n\t}\n\n}"
translations:
  PhysicalDiskPredictedFailureTranslationTable:
    default: 1;true
    ok!: 1;false
    passed: 1;false
    ok: 1;false
connector:
  displayName: SmartMon Tools
  platforms: Any system with SmartMon
  reliesOn: SmartMon Tools
  information: Gives S.M.A.R.T.-enabled physical disk information through the smartd/smartctl utility under Linux.
  version: 1.1
  detection:
    connectionTypes:
    - remote
    appliesTo:
    - Linux
    criteria:
    - type: deviceType
      keep:
      - Linux
    - type: osCommand
      commandLine: /bin/ls /usr/sbin/smartd
      expectedResult: ^/usr/sbin/smartd$
      errorMessage: Unable to find the smartd program in /usr/sbin
    - type: osCommand
      commandLine: /bin/ls /usr/sbin/smartctl
      expectedResult: ^/usr/sbin/smartctl$
      errorMessage: Unable to find the smartctl program in /usr/sbin
    - type: osCommand
      commandLine: "%{SUDO:/usr/sbin/smartctl}/usr/sbin/smartd -c;%{SUDO:/usr/sbin/smartctl}/usr/sbin/smartd -q onecheck"
      expectedResult: "Device: .* opened"
      errorMessage: Unable to run the smartd/smartctl utility (not enough privilege?)
    - type: osCommand
      commandLine: "%{SUDO:/usr/sbin/smartctl}/usr/sbin/smartd -c;%{SUDO:/usr/sbin/smartctl}/usr/sbin/smartd -q onecheck"
      expectedResult: "Device: .* is SMART capable"
      errorMessage: No S.M.A.R.T-capable disk found.
sudoCommands:
- /usr/sbin/smartctl
- /bin/dd
monitors:
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = output of smartd -c + smartctl reformatted by awk (see EmbeddedFile(1))
          # DeviceID;Vendor;SerialNumber
          type: osCommand
          commandLine: "sh %EmbeddedFile(1)% \"%{SUDO:/usr/sbin/smartctl}/usr/sbin/smartd\" \"%{SUDO:/usr/sbin/smartctl}/usr/sbin/smartctl\""
          keep: ^MSHW;
          separators: ;
          selectColumns: "2,3,4"
          computes:
            # Exclude Disks Whose vendor is listed as "Virtual"
            # This was added because IBM's drivers are badly written.
            # DeviceID;Vendor;Size
          - type: excludeMatchingLines
            column: 2
            regExp: "[Vv]irtual"
      mapping:
        # InstanceTable = Source(1)
        source: $monitors.physical_disk.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          serial_number: $column(3)
          vendor: $column(2)
          hw.parent.type: enclosure
          name: "sprintf(\"%s, $column(1))"
    collect:
      # Collect type is "one instance per instance
      type: monoInstance
      sources:
        source(1):
          # Source(1) = output of smartctl
          type: osCommand
          commandLine: "%{SUDO:/usr/sbin/smartctl}/usr/sbin/smartctl -H %PhysicalDisk.Collect.DeviceID%"
          computes:
            # Process smartctl's output through awk EmbeddedFile(4)
            # SMARTstatus
          - type: awk
            script: EmbeddedFile(4)
            keep: ^MSHW;
            separators: ;
            selectColumns: 2
            # Translate the SMARTstatus into a PredictedFailure value
            # 1;PredictedFailure
          - type: translate
            column: 1
            translationTable: PhysicalDiskPredictedFailureTranslationTable
        source(2):
          # Source(2) = output of the shell script based on dd
          # 1;Status;StatusInformation
          type: osCommand
          commandLine: /bin/sh %EmbeddedFile(5)% %PhysicalDisk.Collect.DeviceID%
          keep: ^MSHW;
          separators: ;
          selectColumns: "2,3,4"
        source(3):
          # Source(3) = Table joint of Source(1) and Source(2)
          # 1;PredictedFailure;1;Status;StatusInformation
          type: tableJoin
          leftTable: $monitors.physical_disk.collect.sources.source(1)$
          rightTable: $monitors.physical_disk.collect.sources.source(2)$
          leftKeyColumn: 1
          rightKeyColumn: 1
      mapping:
        # ValueTable = Source(1)
        source: $monitors.physical_disk.collect.sources.source(3)$
        metrics:
          hw.status{hw.type="physical_disk", state="predicted_failure"}: boolean($column(2))
          hw.status{hw.type="physical_disk"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(5)
  temperature:
    discovery:
      sources:
        source(1):
          # Source(1) = output of EmbeddedFile(2)
          # DeviceID;WarningThreshold
          type: osCommand
          commandLine: "sh %EmbeddedFile(2)% \"%{SUDO:/usr/sbin/smartctl}/usr/sbin/smartd\" \"%{SUDO:/usr/sbin/smartctl}/usr/sbin/smartctl\""
          keep: ^MSHW;
          separators: ;
          selectColumns: "2,3"
      mapping:
        # InstanceTable = Source(1)
        source: $monitors.temperature.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          temperature_type: Harddisk
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s)\", $column(1), \"Harddisk\")"
        metrics:
          hw.temperature.limit{limit_type="high.degraded"}: $column(2)
    collect:
      # Collect type is mono-instance (one instance per collect)
      type: monoInstance
      sources:
        source(1):
          # Source(1) = output of smartctl
          type: osCommand
          commandLine: "%{SUDO:/usr/sbin/smartctl}/usr/sbin/smartctl -a %PhysicalDisk.Collect.DeviceID%"
          computes:
            # Process smartctl's output through awk EmbeddedFile(3)
            # Temperature
          - type: awk
            script: EmbeddedFile(3)
            keep: ^MSHW;
            separators: ;
            selectColumns: 2
      mapping:
        # ValueTable = Source(1)
        source: $monitors.temperature.collect.sources.source(1)$
        metrics:
          hw.temperature: $column(1)
