---
connector:
  detection:
    supersedes:
    - SMISDiskArray
    criteria:
    - type: wbem
      namespace: HITACHI_NAMESPACE
      query: "SELECT Name,Dedicated FROM HITACHI_StorageSystem"
    # There also must be disk drives declared in this namespace
    - type: wbem
      query: SELECT DeviceID FROM HITACHI_DiskDrive
      namespace: HITACHI_NAMESPACE
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Source(1) = HITACHI_StorageSystem
          # Name,Caption,HITACHI_StorageSystem
          type: wbem
          query: "SELECT Name,Caption,__Path FROM HITACHI_StorageSystem"
          namespace: HITACHI_NAMESPACE
          computes:
            # caption is model@ipaddr-hostname so we keep only fqdn ;)
            # Name,Caption,HITACHI_StorageSystem
          - type: extract
            column: 2
            subColumn: 2
            subSeparators: '@'
        source(2):
          # Source(2) = HITACHI_StorageSystem
          # Manufacturer,Model,SerialNumber,HITACHI_DKCChassis
          type: wbem
          query: "SELECT Manufacturer,Model,SerialNumber,__Path FROM HITACHI_DKCChassis"
          namespace: HITACHI_NAMESPACE
        source(3):
          # Source (3) = Association Table HITACHI_StorageSystemPackageDKC
          # HITACHI_DKCChassis,HITACHI_StorageSystem
          type: wbem
          query: "SELECT Antecedent,Dependent FROM HITACHI_StorageSystemPackageDKC"
          namespace: HITACHI_NAMESPACE
        source(4):
          # Source (4) = Union of Storage System with Association Table
          # Name,Caption,HITACHI_StorageSystem,HITACHI_DKCChassis,HITACHI_StorageSystem
          type: tableJoin
          leftTable: "${source::monitors.enclosure.discovery.sources.source(1)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(3)}"
          leftKeyColumn: 3
          rightKeyColumn: 2
          keyType: Wbem
          defaultRightLine: ;;
        source(5):
          # Source (5) = Union of "Storage System and Association Table" and Chassis
          # Name,Caption,HITACHI_StorageSystem,HITACHI_DKCChassis,HITACHI_StorageSystem,Manufacturer,Model,SerialNumber,HITACHI_DKCChassis
          type: tableJoin
          leftTable: "${source::monitors.enclosure.discovery.sources.source(4)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(2)}"
          leftKeyColumn: 4
          rightKeyColumn: 4
          keyType: Wbem
          defaultRightLine: ;;;;
          computes:
            # Remove Path Columns as they are no longer needed.
            #   1      2             3            #       4            #       5            #  6         7       8            9
            # Name,Caption,HITACHI_StorageSystem,HITACHI_DKCChassis,HITACHI_StorageSystem,Manufacturer,Model,SerialNumber,HITACHI_DKCChassis
            # Name,Caption,            #             #             #             #        Manufacturer,Model,SerialNumber
          - type: keepColumns
            columnNumbers: "1,2,6,7,8"
        source(6):
          # Source(6) = HITACHI_StorageSystem
          # Name,HITACHI_StorageProcessorSystem
          type: wbem
          query: "SELECT Name,__Path FROM HITACHI_StorageProcessorSystem"
          namespace: HITACHI_NAMESPACE
        source(7):
          # Source (7) = Association Table HITACHI_StorageSystemPackageDKC
          # HITACHI_StorageSystem,HITACHI_StorageProcessorSystem
          type: wbem
          query: "SELECT GroupComponent,PartComponent FROM HITACHI_ComponentCS"
          namespace: HITACHI_NAMESPACE
        source(8):
          # Source (8) = Union of Storage System and Association Table
          # HITACHI_StorageSystem,HITACHI_StorageProcessorSystem,Name,Caption,HITACHI_StorageSystem
          type: tableJoin
          leftTable: "${source::monitors.enclosure.discovery.sources.source(7)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(1)}"
          leftKeyColumn: 1
          rightKeyColumn: 3
          keyType: Wbem
        source(9):
          # Source (9) = Union of "Storage System with Association Table" and Storage Processor System
          # Name,HITACHI_StorageProcessorSystem,HITACHI_StorageSystem,HITACHI_StorageProcessorSystem,Name,Caption,HITACHI_StorageSystem
          type: tableJoin
          leftTable: "${source::monitors.enclosure.discovery.sources.source(6)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(8)}"
          leftKeyColumn: 2
          rightKeyColumn: 2
          keyType: Wbem
          computes:
            # Remove Path Columns as they are no longer needed.
            #   1            #        2            #             # 3            #  4            #       5      6         7
            # Name,HITACHI_StorageProcessorSystem,HITACHI_StorageSystem,HITACHI_StorageProcessorSystem,Name,Caption,HITACHI_StorageSystem
            # StorageProcessorSystemName,        StorageSystemName,
          - type: keepColumns
            columnNumbers: "1,5"
      mapping:
        # Instance Table
        # Name,Caption,Manufacturer,Model,SerialNumber
        source: "${source::monitors.enclosure.discovery.sources.source(5)}"
        attributes:
          id: $1
          __display_id: $2
          vendor: $3
          model: $4
          serial_number: $5
          type: Storage
          name: "${awk::sprintf(\"Storage: %s (%s %s)\", $2, $3, $4)}"
    collect:
      # Collect type is multiinstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = CIM_ComputerSystem
          # Name;OperationalStatus;
          type: wbem
          query: "SELECT Name,OperationalStatus,HealthState FROM HITACHI_StorageSystem"
          namespace: HITACHI_NAMESPACE
          computes:
            # add health to health state in order to make it unique
            # systemname, operationalstatus, healthstate
          - type: leftConcat
            column: 3
            value: Health
            # add HealthState to operationalStatus
            # systemname, operationalstatus, healthstate
          - type: rightConcat
            column: 2
            value: $3
            # Duplicate the "OperationalStatus" column
            # SystemName,PatrolStatus,HealthState
          - type: duplicateColumn
            column: 2
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # SystemName,PATROLStatusArray,OperationalStatus,HealthState
          - type: arrayTranslate
            column: 2
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # SystemName,PATROLStatusArray,StatusInformation,HealthState
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # SystemName,PATROLStatus,StatusInformation,HealthState
          - type: convert
            column: 2
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # Name;PATROLStatus;StatusDescriptions;HealthState
        source: "${source::monitors.enclosure.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="enclosure"}: $2
        legacyTextParameters:
          StatusInformation: $3
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = HITACHI_DiskDrive
          # SystemName,Caption,MaxMediaSizeKB,HITACHI_DiskDrive
          type: wbem
          query: "SELECT SystemName,Caption,MaxMediaSize,__Path FROM HITACHI_DiskDrive"
          namespace: HITACHI_NAMESPACE
          computes:
            # Convert SizeK from 1000 of bytes to bytes
            # SystemName,Caption,MaxMediaSizeB,HITACHI_DiskDrive
          - type: multiply
            column: 3
            value: 1000
            # Duplicate the "Caption" column
            # SystemName,Caption,DisplayID,MaxMediaSizeB,HITACHI_DiskDrive
          - type: duplicateColumn
            column: 2
            # Add ":" And SystemaName to Caption to make ID unique
            # SystemName,DeviceID,DisplayID,MaxMediaSizeB,HITACHI_DiskDrive
          - type: leftConcat
            column: 2
            value: ':'
          - type: leftConcat
            column: 2
            value: $1
        source(2):
          # Source (2) = HITACHI_PhysicalDisk (FRU info)
          # Manufacturer,Model,HITACHI_PhysicalDisk
          type: wbem
          query: "SELECT SerialNumber,Manufacturer,Model,__Path FROM HITACHI_PhysicalDisk"
          namespace: HITACHI_NAMESPACE
        source(3):
          # Source (3) = Association Table HITACHI_StorageSystemPackageDKC
          # HITACHI_PhysicalDisk,HITACHI_DiskDrive
          type: wbem
          query: "SELECT Antecedent,Dependent FROM HITACHI_PhysicalDiskRealizesDiskDrive"
          namespace: HITACHI_NAMESPACE
        source(4):
          # Source (4) = Union of HITACHI_DiskDrive and Association Table
          # SystemName,DeviceID,DisplayID,MaxMediaSizeB,HITACHI_DiskDrive,HITACHI_PhysicalDisk,HITACHI_DiskDrive
          type: tableJoin
          leftTable: "${source::monitors.physical_disk.discovery.sources.source(1)}"
          rightTable: "${source::monitors.physical_disk.discovery.sources.source(3)}"
          leftKeyColumn: 5
          rightKeyColumn: 2
          keyType: Wbem
          defaultRightLine: ;;
        source(5):
          # Source (5) = Union of "Storage System and Association Table" and Chassis
          # SystemName,DeviceID,DisplayID,MaxMediaSizeB,HITACHI_DiskDrive,HITACHI_PhysicalDisk,HITACHI_DiskDrive,SerialNumber,Manufacturer,Model,HITACHI_PhysicalDisk
          type: tableJoin
          leftTable: "${source::monitors.physical_disk.discovery.sources.source(4)}"
          rightTable: "${source::monitors.physical_disk.discovery.sources.source(2)}"
          leftKeyColumn: 6
          rightKeyColumn: 4
          keyType: Wbem
          defaultRightLine: ;;
          computes:
            # Remove Path Columns as they are no longer needed.
            #        1      2          3             4            #   5            #  6            #    7            8            9     10
            # SystemName,DeviceID,DisplayID,MaxMediaSizeB,HITACHI_DiskDrive,HITACHI_PhysicalDisk,HITACHI_DiskDrive,SerialNumber,Manufacturer,Model,HITACHI_PhysicalDisk
            # SystemName,DeviceID,DisplayID,MaxMediaSizeB,            #             #             #             #  Manufacturer,Model
          - type: keepColumns
            columnNumbers: "1,2,3,4,8,9,10"
      mapping:
        # Instance Table
        # SystemName,DeviceID,DisplayID,MaxMediaSizeB,Serialnumber,Manufacturer,Model
        source: "${source::monitors.physical_disk.discovery.sources.source(5)}"
        attributes:
          id: $2
          __display_id: $3
          vendor: $6
          model: $7
          serial_number: $5
          hw.parent.type: enclosure
          hw.parent.id: $1
          name: "${awk::sprintf(\"%s (%s - %s)\", $3, $6, bytes2HumanFormatBase10($4))}"
        metrics:
          hw.physical_disk.size: $4
    collect:
      # Collect type is multiinstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = HITACHI_DiskDrive
          # SystemName;Caption;OperationalStatus;
          type: wbem
          query: "SELECT SystemName,Caption,OperationalStatus,HealthState FROM HITACHI_DiskDrive"
          namespace: HITACHI_NAMESPACE
          computes:
            # Add ":" And SystemaName to Caption to make ID unique
            # SystemName,Caption,OperationalStatus
          - type: leftConcat
            column: 2
            value: ':'
          - type: leftConcat
            column: 2
            value: $1
          - type: leftConcat
            column: 4
            value: Health
          - type: rightConcat
            column: 3
            value: $4
            # Duplicate the "OperationalStatus" column
            # SystemName,DeviceID,PatrolStatus,HealthState
          - type: duplicateColumn
            column: 3
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # SystemName,DeviceID,PATROLStatusArray,OperationalStatus,HealthState
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # SystemName,DeviceID,PATROLStatusArray,StatusInformation
          - type: arrayTranslate
            column: 4
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # SystemName,DeviceID,PATROLStatus,StatusInformation
          - type: convert
            column: 3
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # SystemName,Caption,PATROLStatus,StatusDescriptions
        source: "${source::monitors.physical_disk.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="physical_disk"}: $3
        legacyTextParameters:
          StatusInformation: $4
  network:
    discovery:
      sources:
        source(1):
          # Source(1) = HITACHI_FCPort
          # DeviceWWNID,Caption,Speedbps,PermanentAddress,StorageProcessorSystemTag,PortNumber,UsageRestriction,PortType;wwn/mac,linkstatusactivation
          type: wbem
          query: "SELECT DeviceID,Caption,Speed,PermanentAddress,SystemName,PortNumber,UsageRestriction,PortType FROM HITACHI_FCPort"
          namespace: HITACHI_NAMESPACE
          computes:
          - type: rightConcat
            column: 8
            value: ;WWN;true
        source(2):
          # Source(2) = HITACHI_EthernetPort
          # DeviceWWNID,Caption,Speedbps,PermanentAddress,StorageProcessorSystemTag,PortNumber,UsageRestriction,PortType,wwn/mac,linkstatusactivation
          type: wbem
          query: "SELECT DeviceID,Caption,Speed,PermanentAddress,SystemName,PortNumber,UsageRestriction,PortType FROM HITACHI_EthernetPort"
          namespace: HITACHI_NAMESPACE
          computes:
          - type: rightConcat
            column: 8
            value: ;MAC;
        source(3):
          # Source 3 = Union of 1 & 2
          type: tableUnion
          tables:
          - "${source::monitors.network.discovery.sources.source(1)}"
          - "${source::monitors.network.discovery.sources.source(2)}"
          computes:
            # convert from bit per second to mega bytes per second
            # DeviceWWNID,Caption,SpeedMBps,PermanentAddress,StorageProcessorSystemTag,PortNumber,UsageRestriction,PortType,MAC/WWN,linkstatusactivation
          - type: divide
            column: 3
            value: 1062500
            # Translate the Port Type (FC Only)
            # DeviceWWNID,Caption,SpeedMBps,PermanentAddress,StorageProcessorSystemTag,PortNumber,UsageRestriction,PortType,MAC/WWN,linkstatusactivation
          - type: translate
            column: 8
            translationTable: "${translation::PortTypeTranslationTable}"
            # Translate the Port Direction
            # DeviceWWNID,Caption,SpeedMBps,PermanentAddress,StorageProcessorSystemTag,PortNumber,UsageRestriction,PortType,linkstatusactivation
          - type: translate
            column: 7
            translationTable: "${translation::UsageRestrictionTranslationTable}"
        source(4):
          # Use the Enclosure table to get from StorageProcessorSystemTag to StorageSystemName:
          # DeviceWWNID,Caption,SpeedMBps,PermanentAddress,StorageProcessorSystemTag,PortNumber,UsageRestriction,PortType,wwn/mac,linkstatusactivation,StorageProcessorSystemTag,StorageSystemName
          type: tableJoin
          leftTable: "${source::monitors.network.discovery.sources.source(3)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(9)}"
          leftKeyColumn: 5
          rightKeyColumn: 1
          defaultRightLine: ;;
          computes:
            # Duplicate Caption to make Display ID
            # DeviceWWNID,DisplayID,Caption,SpeedMBps,PermanentAddress,StorageProcessorSystemTag,PortNumber,UsageRestriction,PortType,wwn/mac,linkstatusactivation,StorageProcessorSystemTag,StorageSystemName
          - type: duplicateColumn
            column: 2
            # Add ":" And SystemaName to Caption to make DeviceID unique
            # DeviceWWNID,DisplayID,DeviceID,SpeedMBps,PermanentAddress,StorageProcessorSystemTag,PortNumber,UsageRestriction,PortType,wwn/mac,linkstatusactivation,StorageProcessorSystemTag,StorageSystemName
          - type: leftConcat
            column: 3
            value: ':'
          - type: leftConcat
            column: 3
            value: $13
          - type: leftConcat
            column: 7
            value: "Port Number: "
          - type: leftConcat
            column: 8
            value: "Usage Restriction: "
      mapping:
        # Instance Table
        # DeviceWWNID,DisplayID,DeviceID,SpeedMBps,PermanentAddress,StorageProcessorSystemTag,PortNumber,UsageRestriction,PortType,wwn/mac,linkstatusactivation,StorageProcessorSystemTag,StorageSystemName
        source: "${source::monitors.network.discovery.sources.source(4)}"
        attributes:
          id: $3
          __display_id: $2
          physical_address: $5
          physical_address_type: $10
          device_type: $9
          info: "${awk::join(\" \", $7, $8)}"
          hw.parent.type: enclosure
          hw.parent.id: $13
          name: "${awk::sprintf(\"%s (%s)\", $2, $9)}"
    collect:
      # Collect type is multiinstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = HITACHI_FCPort
          # DeviceWWNID,Speed,OperationalStatus,StatusDescriptions
          type: wbem
          query: "SELECT DeviceID,Speed,OperationalStatus,HealthState FROM HITACHI_FCPort"
          namespace: HITACHI_NAMESPACE
        source(2):
          # Source(2) = HITACHI_EthernetPort
          # DeviceWWNID,Speed,OperationalStatus,StatusDescriptions
          type: wbem
          query: "SELECT DeviceID,Speed,OperationalStatus,HealthState FROM HITACHI_EthernetPort"
          namespace: HITACHI_NAMESPACE
        source(3):
          # Source 3 = Union of 1 & 2
          type: tableUnion
          tables:
          - "${source::monitors.network.collect.sources.source(1)}"
          - "${source::monitors.network.collect.sources.source(2)}"
          computes:
            # Duplicate the "OperationalStatus" column
            # DeviceWWNID,Speed,OperationalStatus,HealthState
          - type: leftConcat
            column: 4
            value: Health
          - type: rightConcat
            column: 3
            value: $4
            # duplicate column
            # DeviceWWNID,Speed,PATROLStatusArray,OperationalStatus,healthState
          - type: duplicateColumn
            column: 3
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # DeviceWWNID,Speed,PATROLStatusArray,OperationalStatus,healthState
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # DeviceWWNID,Speed,PATROLStatusArray,StatusInformation,healthstate
          - type: arrayTranslate
            column: 4
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # DeviceWWNID,Speed,PATROLStatus,StatusInformation,healthstate
          - type: convert
            column: 3
            conversion: array2SimpleStatus
            # now convert speed to link status
            # first let's duplicate speed column
            # DeviceWWNID,Speed,linkstatus,PATROLStatus,StatusInformation,healthstate
          - type: duplicateColumn
            column: 2
            # now translate the speed
            # DeviceWWNID,Speed,linkstatus,PATROLStatus,StatusInformation,healthstate
          - type: translate
            column: 3
            translationTable: "${translation::PortStateToLinkStatusTranslationTable}"
        source(4):
          # Table Joint Collect to Discovery 2 to get DeviceID from DeviceWWNID
          # DeviceWWNID,Speed,PATROLStatus,StatusInformation,DeviceWWNID,DisplayID,DeviceID,SpeedMBps,PermanentAddress,StorageProcessorSystemTag,PortNumber,UsageRestriction,PortType,StorageProcessorSystemTag,StorageSystemName
          # DeviceWWNID,Speed,linkstatus,PATROLStatus,StatusInformation,healthstate,DeviceWWNID,DisplayID,DeviceID,SpeedMBps,PermanentAddress,StorageProcessorSystemTag,PortNumber,UsageRestriction,PortType,mac/wwn,StorageProcessorSystemTag,StorageSystemName
          type: tableJoin
          leftTable: "${source::monitors.network.collect.sources.source(3)}"
          rightTable: "${source::monitors.network.discovery.sources.source(4)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          defaultRightLine: ;;
          computes:
          - type: divide
            column: 2
            value: 1062500
      mapping:
        # ValueTable = Source(1)
        # DeviceWWNID,Speed,PATROLStatus,StatusInformation,DeviceWWNID,DisplayID,DeviceID,SpeedMBps,PermanentAddress,StorageProcessorSystemTag,PortNumber,UsageRestriction,PortType,StorageProcessorSystemTag,StorageSystemName
        # DeviceWWNID,Speed,linkstatus,PATROLStatus,StatusInformation,healthstate,DeviceWWNID,DisplayID,DeviceID,SpeedMBps,PermanentAddress,StorageProcessorSystemTag,PortNumber,UsageRestriction,PortType,mac/wwn,StorageProcessorSystemTag,StorageSystemName
        source: "${source::monitors.network.collect.sources.source(4)}"
        deviceId: $9
        metrics:
          hw.network.bandwidth.limit: megaBit2Bit($2)
          hw.network.up: legacyLinkStatus($3)
          hw.status{hw.type="network"}: $4
        legacyTextParameters:
          StatusInformation: $5
  fan:
    discovery:
      sources:
        source(1):
          # Source(1) = HITACHI_DiskDrive
          # SystemName,DeviceID
          type: wbem
          query: "SELECT SystemName,DeviceID FROM HITACHI_Fan"
          namespace: HITACHI_NAMESPACE
          computes:
            # Duplicate the DeviceID to make DeviceID and DisplayID
            # SystemName,DeviceID,DisplayID
          - type: duplicateColumn
            column: 2
            # Add ":" And SystemaName to DeviceID to make ID unique
            # SystemName,DeviceID,DisplayID
          - type: leftConcat
            column: 2
            value: ':'
          - type: leftConcat
            column: 2
            value: $1
      mapping:
        # Instance Table
        # SystemName,DeviceID,DisplayID
        source: "${source::monitors.fan.discovery.sources.source(1)}"
        attributes:
          id: $2
          __display_id: $3
          hw.parent.type: enclosure
          hw.parent.id: $1
          name: $3
    collect:
      # Collect type is multiinstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = HITACHI_Fan
          # SystemName;DeviceID;OperationalStatus;
          type: wbem
          query: "SELECT SystemName,DeviceID,OperationalStatus,HealthState FROM HITACHI_Fan"
          namespace: HITACHI_NAMESPACE
          computes:
            # Add ":" And SystemaName to Caption to make ID unique
            # SystemName,DeviceID,OperationalStatus
          - type: leftConcat
            column: 2
            value: ':'
          - type: leftConcat
            column: 2
            value: $1
          - type: leftConcat
            column: 4
            value: Health
          - type: rightConcat
            column: 3
            value: $4
            # Duplicate the "OperationalStatus" column
            # SystemName,DeviceID,PatrolStatus,HealthState
          - type: duplicateColumn
            column: 3
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # SystemName,DeviceID,PATROLStatusArray,OperationalStatus,HealthState
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # SystemName,DeviceID,PATROLStatusArray,StatusInformation
          - type: arrayTranslate
            column: 4
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # SystemName,DeviceID,PATROLStatus,StatusInformation
          - type: convert
            column: 3
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # SystemName,Caption,PATROLStatus,StatusDescriptions
        source: "${source::monitors.fan.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="fan"}: $3
        legacyTextParameters:
          StatusInformation: $4
  power_supply:
    discovery:
      sources:
        source(1):
          # Source(1) = HITACHI_PowerSupply
          # SystemName,DeviceID
          type: wbem
          query: "SELECT SystemName,DeviceID FROM HITACHI_PowerSupply"
          namespace: HITACHI_NAMESPACE
          computes:
            # Duplicate the DeviceID to make DeviceID and DisplayID
            # SystemName,DeviceID,DisplayID
          - type: duplicateColumn
            column: 2
            # Add ":" And SystemaName to DeviceID to make ID unique
            # SystemName,DeviceID,DisplayID
          - type: leftConcat
            column: 2
            value: ':'
          - type: leftConcat
            column: 2
            value: $1
      mapping:
        # Instance Table
        # SystemName,DeviceID,DisplayID
        source: "${source::monitors.power_supply.discovery.sources.source(1)}"
        attributes:
          id: $2
          __display_id: $3
          hw.parent.type: enclosure
          hw.parent.id: $1
          name: $3
    collect:
      # Collect type is multiinstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = HITACHI_PowerSupply
          # SystemName;DeviceID;OperationalStatus;
          type: wbem
          query: "SELECT SystemName,DeviceID,OperationalStatus,HealthState FROM HITACHI_PowerSupply"
          namespace: HITACHI_NAMESPACE
          computes:
            # Add ":" And SystemaName to Caption to make ID unique
            # SystemName,DeviceID,OperationalStatus
          - type: leftConcat
            column: 2
            value: ':'
          - type: leftConcat
            column: 2
            value: $1
          - type: leftConcat
            column: 4
            value: Health
          - type: rightConcat
            column: 3
            value: $4
            # Duplicate the "OperationalStatus" column
            # SystemName,DeviceID,PatrolStatus,HealthState
          - type: duplicateColumn
            column: 3
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # SystemName,DeviceID,PATROLStatusArray,OperationalStatus,HealthState
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # SystemName,DeviceID,PATROLStatusArray,StatusInformation
          - type: arrayTranslate
            column: 4
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # SystemName,DeviceID,PATROLStatus,StatusInformation
          - type: convert
            column: 3
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # SystemName,Caption,PATROLStatus,StatusDescriptions
        source: "${source::monitors.power_supply.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="power_supply"}: $3
        legacyTextParameters:
          StatusInformation: $4
  memory:
    discovery:
      sources:
        source(1):
          # Source(1) = HITACHI_CacheMemory
          # SystemName,DeviceID
          type: wbem
          query: "SELECT SystemName,DeviceID FROM HITACHI_CacheMemory"
          namespace: HITACHI_NAMESPACE
          computes:
            # Duplicate the DeviceID to make DeviceID and DisplayID
            # SystemName,DeviceID,DisplayID
          - type: duplicateColumn
            column: 2
            # Add ":" And SystemaName to DeviceID to make ID unique
            # SystemName,DeviceID,DisplayID
          - type: leftConcat
            column: 2
            value: ':'
          - type: leftConcat
            column: 2
            value: $1
      mapping:
        # Instance Table
        # SystemName,DeviceID,DisplayID
        source: "${source::monitors.memory.discovery.sources.source(1)}"
        attributes:
          id: $2
          __display_id: $3
          hw.parent.type: enclosure
          hw.parent.id: $1
          name: $3
    collect:
      # Collect type is multiinstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = HITACHI_CacheMemory
          # SystemName;DeviceID;OperationalStatus;
          type: wbem
          query: "SELECT SystemName,DeviceID,OperationalStatus,HealthState FROM HITACHI_CacheMemory"
          namespace: HITACHI_NAMESPACE
          computes:
            # Add ":" And SystemaName to Caption to make ID unique
            # SystemName,DeviceID,OperationalStatus
          - type: leftConcat
            column: 2
            value: ':'
          - type: leftConcat
            column: 2
            value: $1
          - type: leftConcat
            column: 4
            value: Health
          - type: rightConcat
            column: 3
            value: $4
            # Duplicate the "OperationalStatus" column
            # SystemName,DeviceID,PatrolStatus,HealthState
          - type: duplicateColumn
            column: 3
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # SystemName,DeviceID,PATROLStatusArray,OperationalStatus,HealthState
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # SystemName,DeviceID,PATROLStatusArray,StatusInformation
          - type: arrayTranslate
            column: 4
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # SystemName,DeviceID,PATROLStatus,StatusInformation
          - type: convert
            column: 3
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # SystemName,Caption,PATROLStatus,StatusDescriptions
        source: "${source::monitors.memory.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="memory"}: $3
        legacyTextParameters:
          StatusInformation: $4
  battery:
    discovery:
      sources:
        source(1):
          # Source(1) = HITACHI_Battery
          # SystemName,DeviceID
          type: wbem
          query: "SELECT SystemName,DeviceID FROM HITACHI_Battery"
          namespace: HITACHI_NAMESPACE
          computes:
            # Duplicate the DeviceID to make DeviceID and DisplayID
            # SystemName,DeviceID,DisplayID
          - type: duplicateColumn
            column: 2
            # Add ":" And SystemaName to DeviceID to make ID unique
            # SystemName,DeviceID,DisplayID
          - type: leftConcat
            column: 2
            value: ':'
          - type: leftConcat
            column: 2
            value: $1
      mapping:
        # Instance Table
        # SystemName,DeviceID,DisplayID
        source: "${source::monitors.battery.discovery.sources.source(1)}"
        attributes:
          id: $2
          __display_id: $3
          hw.parent.type: enclosure
          hw.parent.id: $1
          name: $3
    collect:
      # Collect type is multiinstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = HITACHI_Battery
          # SystemName;DeviceID;OperationalStatus;
          type: wbem
          query: "SELECT SystemName,DeviceID,OperationalStatus,HealthState FROM HITACHI_Battery"
          namespace: HITACHI_NAMESPACE
          computes:
            # Add ":" And SystemaName to Caption to make ID unique
            # SystemName,DeviceID,OperationalStatus
          - type: leftConcat
            column: 2
            value: ':'
          - type: leftConcat
            column: 2
            value: $1
          - type: leftConcat
            column: 4
            value: Health
          - type: rightConcat
            column: 3
            value: $4
            # Duplicate the "OperationalStatus" column
            # SystemName,DeviceID,PatrolStatus,HealthState
          - type: duplicateColumn
            column: 3
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # SystemName,DeviceID,PATROLStatusArray,OperationalStatus,HealthState
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # SystemName,DeviceID,PATROLStatusArray,StatusInformation
          - type: arrayTranslate
            column: 4
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # SystemName,DeviceID,PATROLStatus,StatusInformation
          - type: convert
            column: 3
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # SystemName,Caption,PATROLStatus,StatusDescriptions
        source: "${source::monitors.battery.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="battery"}: $3
        legacyTextParameters:
          StatusInformation: $4
  logical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = HITACHI_DiskDrive
          # SystemName,DeviceID,BlockSize,NumberOfBlocks,ErrorMethodology
          type: wbem
          query: "SELECT SystemName,DeviceID,BlockSize,NumberOfBlocks,ErrorMethodology FROM HITACHI_ArrayGroup"
          namespace: HITACHI_NAMESPACE
          computes:
            # Duplicate the DeviceID to make DeviceID and DisplayID
            # SystemName,DeviceID,DisplayID,BlockSize,NumberOfBlocks,ErrorMethodology
          - type: duplicateColumn
            column: 2
            # Add ":" And SystemaName to DeviceID to make ID unique
            # SystemName,DeviceID,DisplayID,BlockSize,NumberOfBlocks,ErrorMethodology
          - type: leftConcat
            column: 2
            value: ':'
          - type: leftConcat
            column: 2
            value: $1
            # Multiply BlockSize by Number of Blocks to Get Size
            # SystemName,DeviceID,DisplayID,BlockSize,NumberOfBlocks,ErrorMethodology
          - type: multiply
            column: 4
            value: $5
      mapping:
        # Instance Table
        # SystemName,DeviceID,DisplayID,BlockSize,NumberOfBlocks,ErrorMethodology
        source: "${source::monitors.logical_disk.discovery.sources.source(1)}"
        attributes:
          id: $2
          __display_id: $3
          raid_level: $6
          hw.parent.type: enclosure
          hw.parent.id: $1
          name: "${awk::sprintf(\"%s (%s - %s)\", $3, $6, bytes2HumanFormatBase2($4))}"
        metrics:
          hw.logical_disk.limit: $4
    collect:
      # Collect type is multiinstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = HITACHI_Fan
          # SystemName;DeviceID;OperationalStatus;
          type: wbem
          query: "SELECT SystemName,DeviceID,OperationalStatus,HealthState FROM HITACHI_ArrayGroup"
          namespace: HITACHI_NAMESPACE
          computes:
            # Add ":" And SystemaName to Caption to make ID unique
            # SystemName,DeviceID,OperationalStatus,HealthState
          - type: leftConcat
            column: 2
            value: ':'
          - type: leftConcat
            column: 2
            value: $1
          - type: leftConcat
            column: 4
            value: Health
          - type: rightConcat
            column: 3
            value: $4
            # Duplicate the "OperationalStatus" column
            # SystemName,DeviceID,PatrolStatus,HealthState
          - type: duplicateColumn
            column: 3
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # SystemName,DeviceID,PATROLStatusArray,OperationalStatus,HealthState
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # SystemName,DeviceID,PATROLStatusArray,StatusInformation
          - type: arrayTranslate
            column: 4
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # SystemName,DeviceID,PATROLStatus,StatusInformation
          - type: convert
            column: 3
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # SystemName,Caption,PATROLStatus,StatusDescriptions
        source: "${source::monitors.logical_disk.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="logical_disk"}: $3
        legacyTextParameters:
          StatusInformation: $4
  other_device:
    discovery:
      sources:
        source(1):
          # Source(1) = HITACHI_StorageProcessorSystem
          # DeviceID;DisplayID;
          type: wbem
          query: "SELECT Name,Caption FROM HITACHI_StorageProcessorSystem"
          namespace: HITACHI_NAMESPACE
        source(2):
          # Source (2) = Joint of 1 and the Enclosure 9 table
          # DeviceID;DisplayID;DeviceID;StorageSystemName;
          type: tableJoin
          leftTable: "${source::monitors.other_device.discovery.sources.source(1)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(9)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          computes:
            # Add a device type
            # DeviceID,DisplayID,DeviceID,StorageSystemName,DeviceType
          - type: rightConcat
            column: 4
            value: ;Controller
            # Keep only useful columns
            # DeviceID,DisplayID,StorageSystemName,DeviceType
          - type: keepColumns
            columnNumbers: "1,2,4,5"
        source(3):
          # Source(2) = Protocol Processor
          # DeviceID,StorageSystemName
          type: wbem
          query: "SELECT DeviceID,SystemName FROM HITACHI_SCSIArbitraryLogicalUnit"
          namespace: HITACHI_NAMESPACE
          computes:
            # Add a device type
            # DeviceID,StorageSystemName,DeviceType
          - type: rightConcat
            column: 2
            value: ;Protocol Processor
            # Remove Hitachi from the Device ID
            # DeviceID,StorageSystemName,DeviceType
          - type: replace
            column: 1
            existingValue: 'HITACHI '
            newValue: ""
            # Duplicate the Device ID
            # DeviceID,DisplayID,StorageSystemName,DeviceType
          - type: duplicateColumn
            column: 1
        source(4):
          # Source 4 = Union of 2 & 3
          # DeviceID,DisplayID,StorageSystemName,DeviceType
          type: tableUnion
          tables:
          - "${source::monitors.other_device.discovery.sources.source(2)}"
          - "${source::monitors.other_device.discovery.sources.source(3)}"
          computes:
            # Add ":" And SystemaName to Caption to make ID unique
            # DeviceID,DisplayID,StorageSystemName,DeviceType
          - type: leftConcat
            column: 2
            value: ':'
          - type: leftConcat
            column: 2
            value: $3
      mapping:
        # Instance Table
        # DeviceID,DisplayID,StorageSystemName,DeviceType
        source: "${source::monitors.other_device.discovery.sources.source(4)}"
        attributes:
          id: $1
          __display_id: $2
          device_type: $4
          hw.parent.type: enclosure
          hw.parent.id: $3
          name: "${awk::sprintf(\"%s: %s\", $4, $2)}"
    collect:
      # Collect type is multiinstance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = HITACHI_StorageProcessorSystem
          # DeviceID;OperationalStatus;healthstate
          type: wbem
          query: "SELECT Name,OperationalStatus,HealthState FROM HITACHI_StorageProcessorSystem"
          namespace: HITACHI_NAMESPACE
        source(2):
          # Source (2) = Joint of 1 and the Enclosure 9 table
          # DeviceID;OperationalStatus;healthstate;DeviceID;StorageSystemName;
          type: tableJoin
          leftTable: "${source::monitors.other_device.collect.sources.source(1)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(9)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          computes:
            # Keep only useful columns
            # DeviceID;OperationalStatus;healthstate;StorageSystemName;
          - type: keepColumns
            columnNumbers: "1,2,3,4"
        source(3):
          # Source(3) = HITACHI_StorageProcessorSystem
          # DeviceID;OperationalStatus;HealthState;StorageSystemName;
          type: wbem
          query: "SELECT DeviceID,OperationalStatus,HealthState,SystemName FROM HITACHI_SCSIArbitraryLogicalUnit"
          namespace: HITACHI_NAMESPACE
          computes:
            # Remove Hitachi from the Device ID
            # DeviceID;OperationalStatus;healthstate;StorageSystemName;
          - type: replace
            column: 1
            existingValue: 'HITACHI '
            newValue: ""
        source(4):
          # Source 4 = Union of 2 & 3
          # DeviceID;OperationalStatus;healthstate;StorageSystemName;
          type: tableUnion
          tables:
          - "${source::monitors.other_device.collect.sources.source(2)}"
          - "${source::monitors.other_device.collect.sources.source(3)}"
          computes:
            # Duplicate the "OperationalStatus" column
            # DeviceID;OperationalStatus;healthstate;StorageSystemName;
          - type: leftConcat
            column: 4
            value: Health
            # add HealthState to operationalStatus
            # Duplicate the "OperationalStatus" column
            # DeviceID;OperationalStatus;healthstate;StorageSystemName;
          - type: rightConcat
            column: 3
            value: $4
            # Duplicate the "OperationalStatus" column
            # DeviceID;patrolStatus;statusinformation;healthstate;StorageSystemName;
          - type: duplicateColumn
            column: 3
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # DeviceID,PATROLStatusArray,OperationalStatus,healthstate,StorageSystemName
          - type: arrayTranslate
            column: 2
            translationTable: "${translation::DMTFOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # DeviceID,PATROLStatusArray,StatusInformation,healthstate,SystemName
          - type: arrayTranslate
            column: 3
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # DeviceID,PATROLStatus,StatusInformation,healthstate,SystemName
          - type: convert
            column: 2
            conversion: array2SimpleStatus
      mapping:
        # ValueTable = Source(1)
        # DeviceID,PATROLStatus,StatusDescriptions,healthstate,SystemName
        source: "${source::monitors.other_device.collect.sources.source(4)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="other_device"}: $2
        legacyTextParameters:
          StatusInformation: $3
translations:
  DMTFOperationStatusTranslationTable:
    Health30: failed
    Health10: degraded
    Health0: UNKNOWN
    Health5: ok
    "10": failed
    "11": degraded
    "12": failed
    "13": failed
    Health20: failed
    "14": failed
    "15": ok
    "16": degraded
    "17": ok
    "18": ok
    Health25: failed
    Default: UNKNOWN
    "2": ok
    "3": degraded
    "4": degraded
    "5": degraded
    Heatlh15: degraded
    "6": failed
    "7": failed
    "8": degraded
    "9": degraded
  PortStateToLinkStatusTranslationTable:
    "0": degraded
    ? ""
    : degraded
    Default: ok
  PortTypeTranslationTable:
    "0": Ethernet Port
    "11": FC Port NL
    "12": FC Port F/NL
    "13": FC Port Nx
    "14": FC Port E
    "15": FC Port F
    "16": FC Port FL
    "17": FC Port B
    "18": FC Port G
    "19": FC Port GL
    Default: FC Port
    "10": FC Port N
  UsageRestrictionTranslationTable:
    "2": Front-end Port
    "3": Back-end Port
    Default: ""
  DMTFOperationStatusInformationTranslationTable:
    Health30: Non-Recoverable Error
    Health10: Degraded
    Health0: Unknown
    Health5: ""
    "10": Stopped
    "11": In Service
    "12": No Contact
    "13": Lost Communication
    Health20: Major Failure
    "14": Aborted
    "15": Dormant
    "16": Supporting Entity in Error
    "17": Completed
    "18": Power Mode
    Health25: Critical Failure
    Default: ""
    "2": ""
    "3": Degraded
    "4": Stressed
    "5": Predicted Failure
    Heatlh15: Minor Failure
    "6": Error
    "7": Non-Recoverable Error
    "8": Starting
    "9": Stopping
