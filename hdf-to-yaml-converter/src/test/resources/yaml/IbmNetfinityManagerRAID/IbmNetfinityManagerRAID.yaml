---
connector:
  displayName: IBM Netfinity Manager 5.20.x - Disks
  platforms: IBM Netfinity
  reliesOn: IBM Netfinity Manager 5.20.x
  version: 1.0
  information: This connector provides IBM ServerRAID monitoring through the IBM Netfinity Manager Services SNMP sub-agent which supports almost all old IBM servers (Netfinity) under Windows.
  detection:
    connectionTypes:
    - remote
    - local
    appliesTo:
    - NT
    criteria:
    # Check that there is something behing the SNMP OID: ....ibm(2).ibmProd(6).netFinity(71).DmiMibs(200).NetFinitySystemsMIB(1).dmtfGroups(1).tRaidAdapterInformation(38).eRaidAdapterInformation(1)
    - type: snmpGetNext
      oid: 1.3.6.1.4.1.2.6.71.200.1.1.38.1
monitors:
  disk_controller:
    discovery:
      sources:
        source(1):
          # Source(1) = the tRaidAdapterInformation SNMP table
          # DeviceID;AdapterIndex
          type: snmpTable
          oid: 1.3.6.1.4.1.2.6.71.200.1.1.38.1
          selectColumns: "ID,1"
      mapping:
        # InstanceTable = Source(1)
        source: "${source::monitors.disk_controller.discovery.sources.source(1)}"
        attributes:
          vendor: IBM
          model: ServeRAID
          controller_number: $2
          id: $1
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"Disk Controller: %s (%s %s)\", $2, \"IBM\", \"ServeRAID\")}"
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = the tRaidPhysicalDriveInformation SNMP table
          # DeviceID;ControllerNumber;SizeKB
          type: snmpTable
          oid: 1.3.6.1.4.1.2.6.71.200.1.1.40.1
          selectColumns: "ID,2,3"
          computes:
            # Multiply the size column by 1024 to obtain bytes
            # DeviceID;ControllerNumber;Size
          - type: multiply
            column: 3
            value: 1024
      mapping:
        # InstanceTable = Source(1)
        source: "${source::monitors.physical_disk.discovery.sources.source(1)}"
        attributes:
          id: $1
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $2)"
          name: "${awk::sprintf(\"%s (%s)\", $1, bytes2HumanFormatBase10($3))}"
        metrics:
          hw.physical_disk.size: $3
    collect:
      # Collect-type = mono-instance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = the tRaidPhysicalDriveInformation SNMP table
          # ID;a40RaidAdapterIndex;a40ChannelNumber;a40TargetNumber
          type: snmpTable
          oid: 1.3.6.1.4.1.2.6.71.200.1.1.40.1
          selectColumns: "ID,2,4,5"
          computes:
            # Build a string like "Physical Disk (Adapter 1, Channel 1, Device 6) Status"
            # from the AdapterIndex, ChannelNumber and TargetNumber numbers
            # This will match with the a40AttributeName of the tNetfinityAttributeGroups table
            # ID;a4AttributeName;a40ChannelNumber;a40TargetNumber
          - type: leftConcat
            column: 2
            value: 'Physical Disk (Adapter '
          - type: rightConcat
            column: 2
            value: ", Channel "
          - type: rightConcat
            column: 2
            value: $3
          - type: rightConcat
            column: 2
            value: ", Device "
          - type: rightConcat
            column: 2
            value: $4
          - type: rightConcat
            column: 2
            value: ) Status
        source(2):
          # Source(2) = the tNetfinityAttributeGroups table
          # a4AttributeName;a4CurrentValueTextual
          type: snmpTable
          oid: 1.3.6.1.4.1.2.6.71.200.2.1.4.1
          selectColumns: "4,5"
        source(3):
          # Source(3) = table joint between Source(1) and Source(2) on the a4AttributeName
          # ID;a4AttributeName;a40ChannelNumber;a40TargetNumber;a4AttributeName;a4CurrentValueTextual
          type: tableJoin
          leftTable: "${source::monitors.physical_disk.collect.sources.source(1)}"
          rightTable: "${source::monitors.physical_disk.collect.sources.source(2)}"
          leftKeyColumn: 2
          rightKeyColumn: 1
          computes:
            # Duplicate the a4CurrentValueTextual column
            # ID;a4AttributeName;a40ChannelNumber;a40TargetNumber;a4AttributeName;a4CurrentValueTextual;a4CurrentValueTextual
          - type: duplicateColumn
            column: 6
            # Translate the first a4CurrentValueTextual into a PATROL status
            # ID;a4AttributeName;a40ChannelNumber;a40TargetNumber;a4AttributeName;PATROLStatus;a4CurrentValueTextual
          - type: translate
            column: 6
            translationTable: "${translation::PhysicalDiskStatusTranslationTable}"
            # Translate the second status column into a more readable PATROL status
            # PATROLstatus;StatusInformation;
          - type: translate
            column: 7
            translationTable: "${translation::PhysicalDiskStatusInformationTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        source: "${source::monitors.physical_disk.collect.sources.source(3)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="physical_disk"}: $6
        legacyTextParameters:
          StatusInformation: $7
  logical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = the tRaidVirtualDrivesInformation
          # DeviceID;ControllerNumber;SizeKB
          type: snmpTable
          oid: 1.3.6.1.4.1.2.6.71.200.1.1.39.1
          selectColumns: "ID,2,4"
          computes:
            # Multiply the size by 1024 to obtain bytes
            # DeviceID;ControllerNumber;Size
          - type: multiply
            column: 3
            value: 1024
      mapping:
        # InstanceTable = Source(1)
        source: "${source::monitors.logical_disk.discovery.sources.source(1)}"
        attributes:
          id: $1
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $2)"
          name: "${awk::sprintf(\"%s (%s)\", $1, bytes2HumanFormatBase2($3))}"
        metrics:
          hw.logical_disk.limit: $3
    collect:
      # Collect type is: mono-instance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = the tRaidVirtualDrivesInformation table
          # DeviceID;a39RaidVirtualDriveIndex;a39RaidAdapterIndex
          type: snmpTable
          oid: 1.3.6.1.4.1.2.6.71.200.1.1.39.1
          selectColumns: "ID,1,2"
          computes:
            # Build a string like "System Drive x (Adapter y) Status"
            # from the Drive Index and the Adapter Index
            # This string will match with entries in the tNetfinityAttributeGroups table
            # DeviceID;AttributeName;RaidIndex
          - type: leftConcat
            column: 2
            value: 'System Drive '
          - type: rightConcat
            column: 2
            value: ' (Adapter '
          - type: rightConcat
            column: 2
            value: $3
          - type: rightConcat
            column: 2
            value: ) Status
        source(2):
          # Source(2) = the tNetfinityAttributeGroups table
          # a4AttributeName;a4CurrentValueTextual
          type: snmpTable
          oid: 1.3.6.1.4.1.2.6.71.200.2.1.4.1
          selectColumns: "4,5"
        source(3):
          # Source(3) = table jointure between Source(1) and Source(2)
          # The key is the AttributeName (that is hopefully unique...)
          # DeviceID;AttributeName;RaidIndex;a4AttributeName;a4CurrentValueTextual
          type: tableJoin
          leftTable: "${source::monitors.logical_disk.collect.sources.source(1)}"
          rightTable: "${source::monitors.logical_disk.collect.sources.source(2)}"
          leftKeyColumn: 2
          rightKeyColumn: 1
          computes:
            # Duplicate the CurrentValueTextual column
            # DeviceID;AttributeName;RaidIndex;a4AttributeName;a4CurrentValueTextual;a4CurrentValueTextual
          - type: duplicateColumn
            column: 5
            # Translate the first CurrentValueTextual into a PATROL Status
            # DeviceID;AttributeName;RaidIndex;a4AttributeName;PATROLStatus;a4CurrentValueTextual
          - type: translate
            column: 5
            translationTable: "${translation::LogicalDiskStatusTranslationTable}"
            # Translate the second CurrentValueTextual into a more readable string
            # DeviceID;AttributeName;RaidIndex;a4AttributeName;PATROLStatus;StatusInformation
          - type: translate
            column: 6
            translationTable: "${translation::LogicalDiskStatusInformationTranslationTable}"
      mapping:
        # The ValueTable = Source(3)
        source: "${source::monitors.logical_disk.collect.sources.source(3)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="logical_disk"}: $5
        legacyTextParameters:
          StatusInformation: $6
translations:
  PhysicalDiskStatusInformationTranslationTable:
    Hot Spare: Hot Spare
    Ready: Ready
    Standby Hot Spare: Standby Hot Spare
    Defunct: Defunct
    PFA: Predicted failure
    Defunct Hot Spare: Defunct Hot Spare
    Online: ""
    Standby: Standby
    Default: Unknown Status
    Rebuild: Rebuild
  LogicalDiskStatusInformationTranslationTable:
    Offline: Offline
    Critical: Critical
    Online: ""
    Default: Unknown Status
  LogicalDiskStatusTranslationTable:
    Offline: failed
    Critical: degraded
    Online: ok
    Default: UNKNOWN
  PhysicalDiskStatusTranslationTable:
    Hot Spare: ok
    Ready: ok
    Standby Hot Spare: ok
    Defunct: failed
    PFA: degraded
    Defunct Hot Spare: degraded
    Online: ok
    Standby: ok
    Default: UNKNOWN
    Rebuild: degraded
