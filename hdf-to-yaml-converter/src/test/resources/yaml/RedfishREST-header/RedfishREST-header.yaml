---
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          type: http
          method: GET
          url: redfish/v1/Chassis/
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
            # Extract data
            # JSONID;@odata.id;
          - type: json2csv
            entryKey: /Members
            properties: /@odata.id;
          # remove empty URLs to avoid empty redirection
          - type: keepOnlyMatchingLines
            column: 2
            regExp: .
        source(2):
          # Query /Chassis/?/
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(1)}"
            concatMethod: json_array_extended
          url: $2
          header: "${file::embeddedFile-1}"
          resultContent: body
        source(3):
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(2)}"
          computes:
            # Extract data
            #   1      2         3            4            #   5            #     6            # 7            #  8
            # JSONID;ChassisID;SystemId;ChassisName;ChassisModel;ChassisSerialNumber;ChassisManufacturer;PowerMetrics;ThermalMetrics;
          - type: json2csv
            entryKey: Entry/Value/links/ComputerSystems
            properties: ../../../Column(2);/_REF;../../Name;../../Model;../../SerialNumber;../../Manufacturer;../../Power/@odata.id;../../Thermal/@odata.id;
        source(4):
          # Query
          # Systems/?/SmartStorage/ArrayControllers/
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(3)}"
            concatMethod: json_array_extended
          url: $3SmartStorage/ArrayControllers/
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
            # Extract data
            # JSONID;ChassisID;DiskControllerID;
          - type: json2csv
            entryKey: /Entry/Value/Members
            properties: ../../Column(2);/@odata.id;
          # remove empty URLs to avoid empty redirection
          - type: keepOnlyMatchingLines
            column: 3
            regExp: .
        source(5):
          # Query
          # /Systems/?/SmartStorage/ArrayControllers/?/
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(4)}"
            concatMethod: json_array_extended
          url: $3
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
            # Extract data
            # JSONID;ChassisID;ControllerID;LogicalDiskURL;PhysicalDiskURL;Name;Model;SerialNumber;FirmwareVersion;
          - type: json2csv
            entryKey: /Entry/Value
            properties: ../Column(2);/@odata.id;/Links/LogicalDrives/_REF;/Links/PhysicalDrives/_REF;/Name;/Model;/SerialNumber;/FirmwareVersion/Current/VersionString;
        source(6):
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(3)}"
            concatMethod: json_array_extended
          url: $9
          header: "${file::embeddedFile-1}"
          resultContent: body
      mapping:
        # Enclosure Instance Table
        # JSONID;ChassisID;SystemId;ChassisName;ChassisModel;ChassisSerialNumber;ChassisManufacturer;PowerMetrics;ThermalMetrics;
        source: "${source::monitors.enclosure.discovery.sources.source(3)}"
        attributes:
          id: $2
          __display_id: $4
          model: $5
          serial_number: $6
          vendor: $7
          type: Server
          name: "${awk::sprintf(\"Enclosure: %s (%s %s)\", $4, $7, $5)}"
    collect:
      type: multiInstance
      sources:
        source(1):
          # For each Chassis found; Query it's specific address.
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(1)}"
            concatMethod: json_array
          url: $2
          header: "${file::embeddedFile-1}"
          resultContent: body
        source(2):
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
          # Collect @odata.id, StatusHealth from Chassis
          - type: json2csv
            entryKey: /
            properties: '@odata.id;/Status/Health;/Status/Health;'
            separator: ;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTranslationTable}"
          - type: translate
            column: 4
            translationTable: "${translation::StatusInformationTranslationTable}"
        source(3):
          # For each Chassis found; Query it's Power address.
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(3)}"
            concatMethod: json_array_extended
          url: $8
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          - type: json2csv
            entryKey: /Entry/Value/PowerSupplies
            properties: ../../Column(2);../_POWER_CONSUMPTION_PATH;/_PS_ID;/Status/Health;/Status/Health;
            separator: ;
        source(4):
          # JSONID;ChassisID;Status;Status;JSONID;ChassisID;PowerConsumption;
          type: tableJoin
          leftTable: "${source::monitors.enclosure.collect.sources.source(2)}"
          rightTable: "${source::monitors.enclosure.collect.sources.source(3)}"
          leftKeyColumn: 2
          rightKeyColumn: 2
        source(5):
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(3)}"
            concatMethod: json_array
          url: $9
          header: "${file::embeddedFile-1}"
          resultContent: body
      mapping:
        # Enclosure Value Table
        # JSONID;ChassisID;Status;Status;JSONID;ChassisID;PowerConsumption;
        source: "${source::monitors.enclosure.collect.sources.source(4)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="enclosure"}: $3
          hw.enclosure.power: $7
          hw.enclosure.energy: fakeCounter($7)
        legacyTextParameters:
          StatusInformation: $4
  memory:
    discovery:
      sources:
        source(1):
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(3)}"
            concatMethod: json_array_extended
          url: $3Memory/
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
            # extract odata.id for each instance
            # JSONID;ChassisID;MemoryID;
          - type: json2csv
            entryKey: /Entry/Value/Members
            properties: ../../Column(2);/@odata.id;
            separator: ;
          # remove empty URLs to avoid empty redirection
          - type: keepOnlyMatchingLines
            column: 3
            regExp: .
        source(2):
          # query odata.id from previous results
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.memory.discovery.sources.source(1)}"
            concatMethod: json_array_extended
          url: $3
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
            # extract data
            # JSONID;ChassisId;MemoryID;Name;PartNumber;Manufacturer;Size;
          - type: json2csv
            entryKey: /Entry/Value
            properties: ../Column(2);/@odata.id;/Name;/SerialNumber;/PartNumber;/Manufacturer;/_MEMORY_SIZE_PARAMETER;/Status/State;
          - type: excludeMatchingLines
            column: 9
            regExp: Absent
          # Exclude entries where Manufacturer is empty
          - type: keepOnlyMatchingLines
            column: 7
            regExp: .
      mapping:
        # Memory Instance Table
        # JsonId;ChassisID;MemoryID;Name;SerialNumber;PartNumber;Manufacturer;sizeParameter;
        source: "${source::monitors.memory.discovery.sources.source(2)}"
        attributes:
          id: $3
          __display_id: $4
          serial_number: $5
          model: $6
          vendor: $7
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s (%s - %s MB)\", $4, $7, $8)}"
        metrics:
          hw.memory.limit: mebiByte2Byte($8)
    collect:
      type: multiInstance
      sources:
        source(1):
          # Query /Systems/?/Memory/?
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.memory.discovery.sources.source(1)}"
            concatMethod: json_array
          url: $3
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
          # Extract odata.id
          - type: json2csv
            entryKey: /
            properties: /@odata.id;_MEMORY_STATUS_PATH;_MEMORY_STATUS_PATH;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTranslationTable}"
          - type: translate
            column: 4
            translationTable: "${translation::StatusInformationTranslationTable}"
      mapping:
        source: "${source::monitors.memory.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="memory"}: $3
        legacyTextParameters:
          StatusInformation: $4
  disk_controller:
    discovery:
      mapping:
        # DiskController Instance Table
        # JSONID;ChassisID;ControllerID;LogicalDiskURL;PhysicalDiskURL;Name;Model;SerialNumber;FirmwareVersion;
        source: "${source::monitors.enclosure.discovery.sources.source(5)}"
        attributes:
          id: $3
          __display_id: $6
          model: $7
          serial_number: $8
          firmware_version: $9
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: "${awk::sprintf(\"Disk Controller: %s (%s)\", $6, $7)}"
    collect:
      type: multiInstance
      sources:
        source(1):
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(4)}"
            concatMethod: json_array
          url: $3
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
            # Extract data
            # JSONID;id;Health;Health;
          - type: json2csv
            entryKey: /
            properties: /@odata.id;/Status/Health;/Status/Health;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTranslationTable}"
          - type: translate
            column: 4
            translationTable: "${translation::StatusInformationTranslationTable}"
      mapping:
        # DiskController Value Table
        # JsonID;Id;PatrolStatus;StatusInformation;
        source: "${source::monitors.disk_controller.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="disk_controller"}: $3
        legacyTextParameters:
          StatusInformation: $4
  physical_disk:
    discovery:
      sources:
        source(1):
          # Query /Systems/?/SmartStorage/ArrayControllers/?/PhysicalDrives
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(5)}"
            concatMethod: json_array_extended
          url: $5
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
            # Extract data
            # JSONID;ControllerID;odata.id
          - type: json2csv
            entryKey: /Entry/Value/Members
            properties: ../../Column(3);/@odata.id;
          # remove empty URLs to avoid empty redirection
          - type: keepOnlyMatchingLines
            column: 3
            regExp: .
        source(2):
          # Query /Systems/?/SmartStorage/ArrayControllers/?/DiskDrives/?
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.physical_disk.discovery.sources.source(1)}"
            concatMethod: json_array_extended
          url: $3
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
            # Extract data
            # JSONID;Controller;DiskID;Name;Model;SerialNumber;FirmwareVersion;MediaType;CapacityMiB;
          - type: json2csv
            entryKey: /Entry/Value
            properties: ../Column(2);/@odata.id;/Name;/Model;/SerialNumber;/FirmwareVersion/Current/VersionString;/MediaType;/CapacityMiB;/Id;
            separator: ;
          # Add label for DiskType
          - type: leftConcat
            column: 8
            value: "Disk Type: "
          # Convert from MiB to Bytes
          - type: multiply
            column: 9
            value: 1048576
          # PhysicalDisk Name fix.
          - type: rightConcat
            column: 4
            value: ' '
          - type: rightConcat
            column: 4
            value: $10
      mapping:
        # PhysicalDisk Instance Table
        # JSONID;Controller;DiskID;Name;Model;SerialNumber;FirmwareVersion;MediaType;CapacityMiB;
        source: "${source::monitors.physical_disk.discovery.sources.source(2)}"
        attributes:
          id: $3
          __display_id: $4
          model: $5
          serial_number: $6
          firmware_version: $7
          info: $8
          hw.parent.type: disk_controller
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s (%s)\", $4, bytes2HumanFormatBase10($9))}"
        metrics:
          hw.physical_disk.size: $9
    collect:
      type: multiInstance
      sources:
        source(1):
          # Query /Systems/?/SmartStorage/ArrayControllers/?/DiskDrives
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.physical_disk.discovery.sources.source(1)}"
            concatMethod: json_array
          url: $3
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
            # Extract data
            # JSONID;DiskID;Health;Health;SSDEnduranceUtilizationPercentage
          - type: json2csv
            entryKey: /
            properties: /@odata.id;/Status/Health;/Status/Health;/SSDEnduranceUtilizationPercentage;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTranslationTable}"
          - type: translate
            column: 4
            translationTable: "${translation::StatusInformationTranslationTable}"
          # JSONID;DiskID;Health;Health;SSDEnduranceUtilizationPercentage;100
          - type: rightConcat
            column: 5
            value: ;100
          # JSONID;DiskID;Health;Health;SSDEnduranceUtilizationPercentage;EnduranceRemaining
          - type: subtract
            column: 6
            value: $5
      mapping:
        # PhysicalDisk Value Table
        # JsonID;Name;PatrolStatus;StatusInformation;
        source: "${source::monitors.physical_disk.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="physical_disk"}: $3
          hw.physical_disk.endurance_utilization{state="remaining"}: percent2Ratio($6)
        legacyTextParameters:
          StatusInformation: $4
  logical_disk:
    discovery:
      sources:
        source(1):
          # Query /Systems/?/SmartStorage/ArrayControllers/?/LogicalDrives
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(5)}"
            concatMethod: json_array_extended
          url: $4
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
            # Extract data
            # JSONID;ControllerID;odata.id
          - type: json2csv
            entryKey: /Entry/Value/Members
            properties: ../../Column(3);/@odata.id;
          # remove empty URLs to avoid empty redirection
          - type: keepOnlyMatchingLines
            column: 3
            regExp: .
        source(2):
          # Query /Systems/?/SmartStorage/ArrayControllers/?/DiskDrives/?
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.logical_disk.discovery.sources.source(1)}"
            concatMethod: json_array_extended
          url: $3
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
            # Extract data
            # JSONID;Controller;Name;Model;SerialNumber;FirmwareVersion;MediaType;
          - type: json2csv
            entryKey: /Entry/Value
            properties: ../Column(2);/@odata.id;/Name;/Raid;/CapacityMiB;
          - type: multiply
            column: 6
            value: 1048576
      mapping:
        # LogicalDisk Instance Table
        # JSONID;Controller;Name;RaidLevel;CapacityMiB;
        source: "${source::monitors.logical_disk.discovery.sources.source(2)}"
        attributes:
          id: $3
          __display_id: $4
          raid_level: $5
          hw.parent.type: disk_controller
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s (%s - %s)\", $4, $5, bytes2HumanFormatBase2($6))}"
        metrics:
          hw.logical_disk.limit: $6
    collect:
      type: multiInstance
      sources:
        source(1):
          # Query /Systems/?/SmartStorage/ArrayControllers/?/DiskDrives/?
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.logical_disk.discovery.sources.source(1)}"
            concatMethod: json_array
          url: $3
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
            # Extract data
            # JSONID;Controller;Name;Model;SerialNumber;FirmwareVersion;MediaType;
          - type: json2csv
            entryKey: /
            properties: /@odata.id;/Status/Health;/Status/Health;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTranslationTable}"
          - type: translate
            column: 4
            translationTable: "${translation::StatusInformationTranslationTable}"
      mapping:
        # LogicalDisk Value Table
        # JsonID;Name;PatrolStatus;StatusInformation;
        source: "${source::monitors.logical_disk.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="logical_disk"}: $3
        legacyTextParameters:
          StatusInformation: $4
  cpu:
    discovery:
      sources:
        source(1):
          # Query each instance of Systems/?/Processors
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(3)}"
            concatMethod: json_array_extended
          url: $3Processors/
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
            # Extract odata.id
            # JSONID;ChassisID;ProcessorURL
          - type: json2csv
            entryKey: /Entry/Value/Members
            properties: ../../Column(2);/@odata.id;
          # remove empty URLs to avoid empty redirection
          - type: keepOnlyMatchingLines
            column: 3
            regExp: .
        source(2):
          # Query each odata.id
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.cpu.discovery.sources.source(1)}"
            concatMethod: json_array_extended
          url: $3
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
            # Extract data
            # ChassisID, Id, Manufacturer, Model, Name, MaxSpeedMHz
          - type: json2csv
            entryKey: /Entry/Value
            properties: ../Column(2);/@odata.id;/Manufacturer;/Model;/Name;/MaxSpeedMHz;
      mapping:
        # CPU Instance Table
        # JsonID;<System>;Manufacturer;Model;Name;CurrentClockSpeedMhz;
        source: "${source::monitors.cpu.discovery.sources.source(2)}"
        attributes:
          id: $3
          vendor: $4
          model: $5
          __display_id: $6
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: "${awk::sprintf(\"%s (%s - %s - %s)\", $6, $4, $5, megaHertz2HumanFormat($7))}"
        metrics:
          hw.cpu.speed.limit{limit_type="max"}: megaHertz2Hertz($7)
    collect:
      type: multiInstance
      sources:
        source(1):
          # Query Systems/?/Processors
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.cpu.discovery.sources.source(1)}"
            concatMethod: json_array
          url: $3
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
            # Extract data
            # Id, StatusHealth
          - type: json2csv
            entryKey: /
            properties: /@odata.id;/Status/Health;/Status/Health;
            separator: ;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTranslationTable}"
          - type: translate
            column: 4
            translationTable: "${translation::StatusInformationTranslationTable}"
      mapping:
        # CPU collect value table
        # JsonId;Id;PatrolStatus;StatusInformation;
        source: "${source::monitors.cpu.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="cpu"}: $3
        legacyTextParameters:
          StatusInformation: $4
  fan:
    discovery:
      sources:
        source(1):
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(6)}"
          computes:
            # Extract data
            # JSONID;ChassisID;MemberId;Name;Location;State;
          - type: json2csv
            entryKey: /Entry/Value/Fans
            properties: ../../Column(2);/_FAN_ID;/_FAN_LOCATION;/Status/State;
          - type: excludeMatchingLines
            column: 5
            regExp: Absent
          # Add Location label
          - type: leftConcat
            column: 4
            value: "Location: "
      mapping:
        # Fan Instance Table
        # JsonID;ChassisID;FanName;Location;
        source: "${source::monitors.fan.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $3
          info: $4
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $3
    collect:
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(5)}"
          computes:
            # Extract data
            # JSONID;MemberId;Health;Health;
          - type: json2csv
            entryKey: /Fans
            properties: /_FAN_ID;/Status/Health;/Status/Health;
            separator: ;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTranslationTable}"
          - type: translate
            column: 4
            translationTable: "${translation::StatusInformationTranslationTable}"
      mapping:
        # Fan Value Table
        # JsonID;PatrolStatus;StatusInformation
        source: "${source::monitors.fan.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="fan"}: $3
        legacyTextParameters:
          StatusInformation: $4
  temperature:
    discovery:
      sources:
        source(1):
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(6)}"
          computes:
            # Extract data
            # JSONID;ChassisID;MemberId;Name;Location;State;
          - type: json2csv
            entryKey: /Entry/Value/Temperatures
            properties: ../../Column(2);/_TEMP_ID;/Name;/PhysicalContext;/Status/State;/UpperThresholdCritical;/UpperThresholdFatal;/UpperThresholdCritical;
          - type: excludeMatchingLines
            column: 6
            regExp: Absent
          # Add Location label
          - type: leftConcat
            column: 5
            value: "Location: "
          # When threshold is 0, deactivate Temperature reading
          - type: replace
            column: 8
            existingValue: 0
            newValue: ""
      mapping:
        # Temperature Instance Table
        # JSONID;ChassisID;MemberId;Name;Location;State;
        source: "${source::monitors.temperature.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          info: $5
          hw.parent.type: enclosure
          hw.parent.id: $2
          name: $4
        metrics:
          hw.temperature.limit{limit_type="high.degraded"}: $6
          hw.temperature.limit{limit_type="high.critical"}: $7
        conditionalCollection:
          hw.temperature: $8
    collect:
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(5)}"
          computes:
            # Extract data
            # JSONID;MemberId;Health;Health;
          - type: json2csv
            entryKey: /Temperatures
            properties: /_TEMP_ID;/Status/Health;/Status/Health;/ReadingCelsius;
            separator: ;
          - type: translate
            column: 3
            translationTable: "${translation::StatusTranslationTable}"
          - type: translate
            column: 4
            translationTable: "${translation::StatusInformationTranslationTable}"
      mapping:
        # Temperature Value Table
        # JsonID;PatrolStatus;StatusInformation
        source: "${source::monitors.temperature.collect.sources.source(1)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="temperature"}: $3
          hw.temperature: $5
        legacyTextParameters:
          StatusInformation: $4
  power_supply:
    discovery:
      sources:
        source(1):
          # Query /Chassis/?/Power/
          type: http
          method: GET
          executeForEachEntryOf:
            source: "${source::monitors.enclosure.discovery.sources.source(3)}"
            concatMethod: json_array_extended
          url: $8
          header: "${file::embeddedFile-1}"
          resultContent: body
          computes:
            # Extract Data
            # JSONID;ChassisID;Name;Model;SerialNumber;PowerSupplyType;PowerSupplyPower;Part Number;
          - type: json2csv
            entryKey: /Entry/Value/PowerSupplies
            properties: ../../Column(2);/_PS_ID;/Name;/Model;/SerialNumber;/PowerSupplyType;/PowerCapacityWatts;/SparePartNumber;
            separator: ;
          # Add Model label
          - type: leftConcat
            column: 5
            value: "Model: "
          # Add Part Number label
          - type: leftConcat
            column: 9
            value: "Part Number: "
          # Add Serial Number label
          - type: leftConcat
            column: 6
            value: "Serial Number: "
      mapping:
        # PowerSupply Instance Table
        # JsonID;<System>;Name;SerialNumber;PowerCapacityWatts;InputType;"
        source: "${source::monitors.power_supply.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $4
          power_supply_type: $7
          info: "${awk::join(\" \", $5, $6, $9)}"
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s - %s W)\", $4, $7, $8)}"
        metrics:
          hw.power_supply.limit: $8
    collect:
      type: multiInstance
      sources:
        source(1):
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(3)}"
          computes:
          - type: translate
            column: 5
            translationTable: "${translation::StatusTranslationTable}"
          - type: translate
            column: 6
            translationTable: "${translation::StatusInformationTranslationTable}"
      mapping:
        # Power Supply Value Table
        # JsonID;PatrolStatus;StatusInformation;
        source: "${source::monitors.power_supply.collect.sources.source(1)}"
        deviceId: $4
        metrics:
          hw.status{hw.type="power_supply"}: $5
        legacyTextParameters:
          StatusInformation: $6
translations:
  NetworkCardStatusInformationTranslationTable:
    StandbyOffline: StandbyOffline
    "null": None
    Enabled: Enabled
    Offline: Offline
    Critical: Failed
    none: None
    up: Up
    failed: Failed
    OK: ok
    down: Administratively Down
    Default: Unknown Status
  LinkStatusTranslationTable:
    ? ""
    : degraded
    StandbyOffline: degraded
    "null": degraded
    Enabled: ok
    Offline: degraded
    none: degraded
    up: ok
    Up: ok
    failed: failed
    down: degraded
    Default: UNKNOWN
    LinkUp: ok
  StatusInformationTranslationTable:
    Warning: The device is in a warning state.
    optimal: The device is running normal.
    needsAttn: The device needs attention.
    GoodInUse: The device is running normal.
    Error: The device is in a critical state.
    Critical: The device is in critical state.
    Default: The device is not reporting a status
    Degraded: The device needs attention.
    "null": The device is not reporting a status.
    Unknown: The device is not reporting a status.
    maintenanceCharging: The device is performing routine maintenance.
    OK: The device is running normal.
    Good: The device is running normal.
  StatusTranslationTable:
    Warning: degraded
    Degraded: degraded
    optimal: ok
    "null": UNKNOWN
    Unknown: degraded
    needsAttn: degraded
    maintenanceCharging: ok
    GoodInUse: ok
    Error: failed
    Critical: failed
    OK: ok
    Default: UNKNOWN
  NetworkCardStatusTranslationTable:
    StandbyOffline: ok
    "null": UNKNOWN
    Enabled: ok
    Offline: ok
    Critical: failed
    none: ok
    up: ok
    failed: failed
    OK: ok
    down: ok
    Default: UNKNOWN
