---
extends:
- IBMAIXModels-header
embedded:
  EmbeddedFile(1): "$2 ~ /hdisk[0-9]+/ && $3 ~ /fscsi/ {if ($2 in LUN == 0) {LUN[$2] = 0}\n\t                                  if ($1 ~ /[Ee]nabled/) {LUN[$2] = LUN[$2] + 1}\n\t                                 }\nEND {for (id in LUN) {print \"MSHW;\" id \";\" LUN[id] \";\"} }"
  EmbeddedFile(3): "($1 ~ /hdisk[0-9]/) {\n\tID=$1;\n\tsize = $(NF-1);\n\tgsub(\"[^0-9.]\", \"\", size);\n\tif ($NF ~ /MB/) { size = size / 1024; }\n\tif ($NF ~ /TB/) { size = size * 1024; }\n}\n\n(ID != \"\" && $1 ~ /Manufacturer/) { make = $1; gsub (\".+\\\\.\", \"\", make); }\n\n(ID != \"\" && $1 ~ /Machine/ && $2 ~ /Type/) { model = $NF; gsub(\".+\\\\.\", \"\", model); }\n\n(ID != \"\" && $1 ~ /FRU/ && $2 ~ /Number/) { FRU = $NF; gsub(\".+\\\\.\", \"\", FRU); }\n\n(ID != \"\" && $1 ~ /Serial/ && $2 ~ /Number/) {\n\tSerial = $NF;\n\tgsub(\".+\\\\.\", \"\", Serial);\n\tif (FRU != \"\")\n\t{\n\t\tprint (\"MSHW;\" ID \";\" size \";\" make \"-\" model \" FRU: \" FRU \";\" Serial \";\");\n\t}\n\tID=\"\"; size=\"\"; make=\"\"; model=\"\"; FRU=\"\"; Serial=\"\";\n}"
  EmbeddedFile(2): "BEGIN {\n\tnicUp = 0;\n\tnicSpeed = \"\";\n}\n/^Driver Flags:.*Up/ {\n\tnicUp = 1;\n}\n\n/^Media Speed Running: +[0-9]+ / {\n\tnicSpeed = $4;\n}\n\n/^Hardware Address:/ {\n\taddress = $3;\n}\n\nEND {\n\tif (nicUp == 1)\n\t{\n\t\tprint \"MSHW;\" nicId \";\" nicSpeed \";\" address \";\"\n\t}\n}"
  EmbeddedFile(5): "/^ETHERNET STATISTICS/ { nicdevice = $3; gsub (/[\\050\\051]/,\"\",nicdevice); nicdevices[nicdevice]=nicdevice }\n\n/^Device Type:/ {\n                 if ( ($3 ~ /EtherChannel/ || $3 ~ /Virtual/) || ($0 ~ /Shared Ethernet Adapter/) || ($0 ~ /Link Aggregation/) || ($0 ~ /VLAN/)) { EtherT[nicdevice] = \"Logical\"; lastLogical = nicdevice }\n                    else { EtherT[nicdevice] = \"Physical\" }\n                }\n\n/^Driver Flags:/ {\n                  if ($0 ~ /Running/) { nicStatus[nicdevice] = \"OK\";}\n                  else {\n                        nicStatus[nicdevice] = \"ALARM\";\n                        getline\n                        if ($0 ~ /Running/) { nicStatus[nicdevice] = \"OK\";}\n                       }\n                 }\n\n$1 == \"Hardware\" && $2 == \"Address:\" { mac[nicdevice] = $3 ; gsub (/:/,\"\",mac[nicdevice])}\n\n# Link\n/Physical Port Link Stat/ {\n                           if ($NF == \"up\" || $NF == \"Up\" || $NF == \"UP\") {\n                                                                           linkStatus[nicdevice] = \"OK\";\n                                                                           if ( linkStatus[lastLogical] == \"WARN\" ) { linkStatus[lastLogical] = \"OK\" ; nicStatus[lastLogical] = \"WARN\" ; }\n                                                                          }\n                              else {\n                                    linkStatus[nicdevice] = \"WARN\"; nicStatus[nicdevice] = \"OK\";\n                                    if (linkStatus[lastLogical] == \"OK\") { nicStatus[lastLogical] = \"WARN\" }\n                                    if (linkStatus[lastLogical] == \"\") { linkStatus[lastLogical] = \"WARN\" ; nicStatus[lastLogical] = \"ALARM\" }\n                                   }\n                          }\n\n$1 == \"Link\" && $2 == \"Status\" { if ($4 == \"up\" || $4 == \"Up\" || $4 == \"UP\") { linkStatus[nicdevice] = \"OK\"; }\n                                      else {linkStatus[nicdevice] = \"WARN\"; nicStatus[nicdevice] = \"OK\";}\n                                 }\n\n$1 == \"Link\" && $2 == \"Status:\" { if ($3 == \"up\" || $3 == \"Up\" || $3 == \"UP\") { linkStatus[nicdevice] = \"OK\";}\n                                       else { linkStatus[nicdevice] = \"WARN\"; nicStatus[nicdevice] = \"OK\"; }\n                                  }\n\n# Speed\n$0 ~ /Media Speed Running:/ || $0 ~ /Physical Port Speed:/ {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ($4 ~ /^[0-9]+$/) {linkSpeed[nicdevice] = $4 $5; gsub(/Gbps/,\"000\",linkSpeed[nicdevice]);gsub(/Mbps/,\"\",linkSpeed[nicdevice]);}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {linkSpeed[nicdevice] = $4; gsub(/Gbps/,\"000\",linkSpeed[nicdevice]);gsub(/Mbps/,\"\",linkSpeed[nicdevice]);}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t if ($0 ~ /[Hh]alf [Dd]uplex/) { duplexMode[nicdevice] = \"half\"; }\n                                    else { duplexMode[nicdevice] = \"full\"; }\n                                 }\n\n# Statistics\n$1 == \"Packets:\" && $3 == \"Packets:\" { transmitPackets[nicdevice] = $2; receivePackets[nicdevice] = $4; }\n\n$1 == \"Bytes:\" && $3 == \"Bytes:\" {transmitBytes[nicdevice] = $2;receiveBytes[nicdevice] = $4; }\n\n$1 == \"Transmit\" && $2 == \"Errors:\" && $4 == \"Receive\" && $5 == \"Errors:\" { transmitErrors[nicdevice] = $3; receiveErrors[nicdevice] = $6; totalErrors[nicdevice] = transmitErrors[nicdevice] + receiveErrors[nicdevice] ; }\n\nEND { for (nic in nicdevices) {\n          if (EtherT[nic] == \"Logical\") {\n             printf(\"MSHW;%s;%s;%s;%.0f;%.0f;%.0f;%.0f;%.0f;;;%s;;\\n\", nicdevices[nic],nicStatus[nic],linkStatus[nic],totalErrors[nic],transmitPackets[nic],receivePackets[nic],transmitBytes[nic],receiveBytes[nic],\"Logical\");\n             }\n             else {printf(\"MSHW;%s;%s;%s;%.0f;%.0f;%.0f;%.0f;%.0f;%s;%s;%s;%s;\\n\",nicdevices[nic],nicStatus[nic],linkStatus[nic],totalErrors[nic],transmitPackets[nic],receivePackets[nic],transmitBytes[nic],receiveBytes[nic],linkSpeed[nic],duplexMode[nic],\"Physical\", mac[nic]);\n                  }\n\n          }\n    }"
  EmbeddedFile(4): "BEGIN { portID = \"\"; WWPN = \"\"; linkStatus = \"WARN\"; TxPackets = \"\"; RxPackets = \"\"; TxBytes = \"\"; RxBytes = \"\"; ErrorCountFrames = \"\"; PortType = \"\"; speed = \"\"; SerialNumber = \"\"; }\n\n($1 == \"FIBRE\" && $2 == \"CHANNEL\" && $3 == \"STATISTICS\") {\n\n\t# If portID != \"\", it means we're starting the section for a new port, so report the one that we've just processed\n  \tif (portID != \"\") { print(\"MSHW;\" portID \";\"  \";\" linkStatus \";\" ErrorCountFrames \";\" TxPackets \";\" RxPackets \";\" TxBytes \";\" RxBytes \";\" speed \";Full;\" PortType \";\" WWPN \";WWN;\"  SerialNumber \";\" ); }\n    portID = \"\"; WWPN = \"\"; linkStatus = \"WARN\"; TxPackets = \"\"; RxPackets = \"\"; TxBytes = \"\"; RxBytes = \"\"; ErrorCountFrames = \"\"; PortType = \"\"; speed = \"\"; SerialNumber = \"\";\n\n\tportID = $NF;\n}\n\n($1 == \"World\" && $2 == \"Wide\" && $3 == \"Port\") { WWPN = $NF; gsub(/^0x/, \"\" , WWPN); }\n($1 == \"Port\" && $2 == \"WWN\") { WWPN=$NF; gsub(/^0x/, \"\" , WWPN); }\n\n$0 ~ /[Aa]ttention.*[Tt]ype.*[Ll]ink.*[Uu]p/ {linkStatus = \"OK\"}\n$0 ~ /[Aa]ttention.*[Tt]ype.*[Ll]ink.*[Dd]own/ {linkStatus = \"WARN\"}\n($1 == \"Port\" && $2 == \"Speed\" && $3 ~ /running/) { speed = $(NF-1); speed = speed * 1000; linkStatus = \"OK\"; }\n\n($1 == \"Port\" && $2 == \"Type:\") { PortType = \"HBA FC Port (\" $3 \")\"; }\n\n($1 == \"Serial\" && $2 == \"Number:\") { SerialNumber = $NF; }\n\n($1 ~ /^Frames/ && $2 ~ /^[0-9]+$/ && $3 ~ /^[0-9]+$/) { TxPackets = $2; RxPackets = $3; }\n($1 ~ /^Frames/ && $2 ~ /^[0-9]+$/ && $3 ~ /^Frames/ && $4 ~ /^[0-9]+$/) { TxPackets = $2; RxPackets = $4; }\n\n($1 ~ /Error/ && $2 ~ /Frames/ && $3 ~ /^[0-9]+$/) { if (ErrorCountFrames == \"\") { ErrorCountFrames = $3; } else { ErrorCountFrames = ErrorCountFrames + $3;} }\n\n($1 ~ /Dumped/ && $2 ~ /Frames/ && $3 ~ /^[0-9]+$/) { if (ErrorCountFrames == \"\") { ErrorCountFrames = $3; } else { ErrorCountFrames = ErrorCountFrames + $3;} }\n\n($1 ~ /Input/ && $2 ~ /Bytes/ && $3 ~ /^[0-9]+$/) { if (RxBytes == \"\") { RxBytes = $3; } else { RxBytes = RxBytes + $3;} }\n\n($1 ~ /Output/ && $2 ~ /Bytes/ && $3 ~ /^[0-9]+$/) { if (TxBytes == \"\") { TxBytes = $3; } else { TxBytes = TxBytes + $3;} }\n\nEND {\n\tif (portID != \"\") { print(\"MSHW;\" portID \";\"  \";\" linkStatus \";\" ErrorCountFrames \";\" TxPackets \";\" RxPackets \";\" TxBytes \";\" RxBytes \";\" speed \";Full;\" PortType \";\" WWPN \";WWN;\"  SerialNumber \";\" ); }\n}"
  EmbeddedFile(7): "$1 ~ /MSHW_DATE[0-9]+/ {mmdd = substr($1,10,4) ; yy = substr ($1,18,2)}\n# Match the date\nsubstr($2,1,4) == mmdd &&  substr($2,9,2) == yy { if ($5 in DeviceErrorCount == 0) {DeviceErrorCount[$5] = 1}\n\t                                                else {DeviceErrorCount[$5] = DeviceErrorCount[$5] + 1 }\n\t                                               }\nEND {for (id in DeviceErrorCount) {print \"MSHW;\" id \";\" DeviceErrorCount[id] \";\"} }"
  EmbeddedFile(6): "BEGIN {\n\tMemoryObject = 0;\n\tDeviceID = \"\";\n\tSize = \"\";\n\tSerialNumber = \"\";\n\tPartNumber = \"\";\n}\n/Memory [DS]IMM:/ {\n\tMemoryObject = 1;\n}\n\n/Size\\.+/ {\n\tSize = $0;\n\tgsub(\" +Size\\\\.+\", \"\", Size);\n}\n/Serial Number\\.+/ {\n\tSerialNumber = $0;\n\tgsub(\" +Serial Number\\\\.+\", \"\", SerialNumber);\n}\n/Part Number\\.+/ {\n\tPartNumber = $0;\n\tgsub(\" +Part Number\\\\.+\", \"\", PartNumber);\n}\n/Physical Location:/ {\n\tif (MemoryObject == 1)\n\t{\n\t\tDeviceID = $3;\n\n\t\tif (Size == 0)\n\t\t{\n\t\t\tStatus = \"ALARM\";\n\t\t\tStatusInformation = \"Failed\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStatus = \"OK\";\n\t\t\tStatusInformation = \"\";\n\t\t}\n\t\tprint \"MSHW;\" DeviceID \";\" Size \";\" SerialNumber \" - FRU: \" PartNumber \";\" Status \";\" StatusInformation \";\"\n\t}\n\tDeviceID = \"\";\n\tMemoryObject = 0;\n\tSerialNumber = \"\";\n\tPartNumber = \"\";\n}"
translations:
  PhysicalDiskStatusInformationTranslationTable:
    stopped: Stopped
    default: Unknown Status
    available: Available
    defined: Defined
  ErrorcounttoStatusTranslationTable:
    "0": ok
    default: failed
  cpuStatusInformationTranslationTable:
    stopped: Stopped
    default: Unknown Status
    available: Available
    defined: Defined
  ErrorcounttoStatusInformationTranslationTable:
    "0": No Disk Controller Events found today (Parameter only collects every hour)
    default: Disk Controller Events found today - Run errlog for more details
  cpuStatusTranslationTable:
    stopped: degraded
    default: UNKNOWN
    available: ok
    defined: ok
  PhysicalDiskStatusTranslationTable:
    stopped: degraded
    default: UNKNOWN
    available: ok
    defined: ok
connector:
  displayName: IBM VIO Server
  platforms: IBM POWER
  reliesOn: "IBM AIX system commands through the IOS interface (lsdev, entstat, etc.)"
  information: "Provides hardware status information (processors, memory modules, network interfaces, HBAs, physical disks) on IBM VIO systems."
  version: 1.3
  detection:
    connectionTypes:
    - remote
    appliesTo:
    - RS6000
    supersedes:
    - IBMAIX
    - IBMAIXChrpMachstat
    - IBMAIXDisk
    - IBMAIXHBA
    - IBMAIXUeSensor
    criteria:
    # OS should be AIX (whatever version)
    - type: deviceType
      keep:
      - RS6000
    # uname should return vioserver
    - type: osCommand
      commandLine: ioscli uname -a
      expectedResult: AIX
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Source(1) = the output of uname -M
          # MachineIDNumber;ModelCode;SystemID;LPARSystemID;
          type: osCommand
          commandLine: ioscli uname -mMfF
          keep: " IBM,"
          separators: ' '
          selectColumns: "1,2,3,4"
          computes:
            # Duplicate the MachineIDNumber
            # MachineIDNumber;MachineIDNumber;ModelCode;LPARSystemID;SystemID;
          - type: duplicateColumn
            column: 1
            # Remove the IBM,  (We, unfortunately, already know it's an IBM)
            # MachineIDNumber;MachineIDNumber;ModelCode;LPARSystemID;SystemID;
          - type: replace
            column: 3
            existingValue: "IBM,"
            newValue: ""
            # Add descriptive prefixes to the different IDs
            # MachineIDNumber;MachineIDNumber;ModelCode;LPARSystemID;SystemID;
          - type: leftConcat
            column: 2
            value: "Machine ID: "
          - type: leftConcat
            column: 4
            value: "LPAR System ID: "
          - type: leftConcat
            column: 5
            value: "System ID: "
            # Duplicate the ModelCode
            # MachineIDNumber;MachineIDNumber;ModelCode;ModelCode;LPARSystemID;SystemID;
          - type: duplicateColumn
            column: 3
            # Translate the 2nd Model Code into a Model Name
            # The translation table will need to be regularly updated
            # MachineIDNumber;MachineIDNumber;ModelCode;ModelName;LPARSystemID;SystemID;
          - type: translate
            column: 4
            translationTable: ModelTranslationTable
      mapping:
        # The discovery table
        # MachineIDNumber;MachineIDNumber;ModelCode;ModelName;LPARSystemID;SystemID;
        source: $monitors.enclosure.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(3)
          vendor: IBM
          model: $column(4)
          type: Computer
          serial_number: $column(1)
          info: "join($column(2), $column(6), $column(5), \" \")"
          name: "sprintf(\"%s (%s %s - %s)\", $column(3), \"IBM\", $column(4), \"Computer\")"
  cpu:
    discovery:
      sources:
        source(1):
          # Source(1) = lsdev
          # cpuID;
          type: osCommand
          commandLine: ioscli lsdev -field name
          separators: ","
          keep: ^proc
      mapping:
        # Instance table = source(1)
        source: $monitors.cpu.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          hw.parent.type: enclosure
          name: $column(1)
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          type: osCommand
          commandLine: "ioscli lsdev -fmt : -field name status"
          keep: ^proc
          separators: ':'
          selectColumns: "1,2"
          computes:
            # Duplicate the status column
            # cpuID;cpuStatus;cpuStatus
          - type: duplicateColumn
            column: 2
            # Translate the first status column into a PATROL status
            # cpuID;PATROLStatus;cpuStatus
          - type: translate
            column: 2
            translationTable: cpuStatusTranslationTable
            # Translate the second status column into a more readable string
            # cpuID;PATROLStatus;statusInformation
          - type: translate
            column: 3
            translationTable: cpuStatusInformationTranslationTable
      mapping:
        # ' "ValueTable = source(1)'
        source: $monitors.cpu.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="cpu"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
  memory:
    discovery:
      sources:
        source(1):
          # Source(1) = output of ioscli lsdev -vpd
          type: osCommand
          commandLine: ioscli lsdev -vpd
          computes:
            # Reformat lscfg's output through awk (see EmbeddedFile(6))
            # DeviceID;Size;SerialNumber
          - type: awk
            script: EmbeddedFile(6)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4"
            # Add ";1;" to the DeviceID that will correspond to the Status and ErrorCount ParameterActivation values
            # DeviceID;StatusActivation;ErrorCountActivation;Size;SerialNumber
          - type: rightConcat
            column: 1
            value: ;1;
        source(2):
          # Source(2) = Static table to represent the global memory stuff
          type: static
          value: Memory Controller;;1;;;
        source(3):
          # Source(3) = Union of Source(1) and Source(2)
          # DeviceID;StatusActivation;ErrorCountActivation;Size;SerialNumber
          type: tableUnion
          tables:
          - $monitors.memory.discovery.sources.source(1)$
          - $monitors.memory.discovery.sources.source(2)$
        source(4):
          # Source (4) = Date + Complete Errorlog
          # Not used in Discovery, it is used in the collect.  But as it can be a large file and we don't want to collect it
          # too often, "true" memory collects will only be done once per hour.
          type: osCommand
          commandLine: "ioscli errlog -ls | grep -c -E \"CORRECTED_SCRUB||MEM[0-9]||RECOV_ECC_ERR||CORRECTED_SCRUB\""
          computes:
            # Add the Memory Controller Identifier
            # DeviceID;Status;StatusInformation;ErrorCount
          - type: leftConcat
            column: 1
            value: Memory Controller;;;
      mapping:
        # InstanceTable = Source(1)
        source: $monitors.memory.discovery.sources.source(3)$
        attributes:
          id: $column(1)
          serial_number: $column(5)
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s)\", $column(1), $column(4))"
        metrics:
          hw.memory.limit: mebiByte2Byte($column(4))
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = output of ioscli lsdev -vpd
          type: osCommand
          commandLine: ioscli lsdev -vpd
          computes:
            # Reformat lsdev's output through awk (see EmbeddedFile(6))
            # DeviceID;Status;StatusInformation;
          - type: awk
            script: EmbeddedFile(6)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,5,6"
            # Add ";" to the right, as an empty ErrorCount column
            # DeviceID;Status;StatusInformation;ErrorCount
          - type: rightConcat
            column: 3
            value: ;
        source(2):
          # Source(4) = Number of events reported by errlog of type "memory"
          # this is done in discovery
          # DeviceID;Status;StatusInformation;ErrorCount
          type: copy
          from: $monitors.memory.discovery.sources.source(4)$
        source(3):
          # Source(3) = Union of Source(1) and Source(2)
          type: tableUnion
          tables:
          - $monitors.memory.collect.sources.source(1)$
          - $monitors.memory.collect.sources.source(2)$
      mapping:
        # Value table = Source(1)
        source: $monitors.memory.collect.sources.source(3)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="memory"}: $column(2)
          hw.errors{hw.type="memory"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(3)
  disk_controller:
    discovery:
      sources:
        source(1):
          # Source(1) = output of lsdev - list of disk "parents"
          # diskDevicePath
          type: osCommand
          commandLine: ioscli lsdev -field physloc -type disk
          computes:
            # Retrieve the controller device path from the disk device path
            # controllerDevicePath; (may be several identical instances)
          - type: substring
            column: 1
            start: 1
            length: 5
        source(2):
          # Source(2) = output of lsdev -field name physloc description -fmt : -type adapter
          # adapterDevicePath;DeviceID;displayName;
          type: osCommand
          commandLine: "ioscli lsdev -field physloc name description -fmt : -type adapter"
          separators: ':'
          selectColumns: "1,2,3"
          computes:
            # Keep only scsi[0-9]* disk controllers (not RAID or SSA)
            # adapterDevicePath;DeviceID;displayName
          - type: keepOnlyMatchingLines
            column: 2
            regExp: "\\(^sisscsi[A-Za-z0-9]+$\\)\\|\\(^scsi[A-Za-z0-9]+$\\)\\|\\(^sisio[A-Za-z0-9]+$\\)\\|\\(^sissas[A-Za-z0-9]+$\\)"
            # Retrieve the controller device path from the disk device path
            # adapterDevicePath;DeviceID;displayName
          - type: substring
            column: 1
            start: 1
            length: 5
        source(3):
          # Source(3) = Table joint of Source(1) and Source(2)
          # This jointure will make MSHW keep only adapters that are disk controllers
          # with disks attached to them
          # adapterDevicePath;DeviceID;displayName;controllerDevicePath
          type: tableJoin
          leftTable: $monitors.disk_controller.discovery.sources.source(2)$
          rightTable: $monitors.disk_controller.discovery.sources.source(1)$
          leftKeyColumn: 1
          rightKeyColumn: 1
        source(4):
          # Source (4) = Complete Errorlog
          # Not used in Discovery, it is used in the collect.  But as it can be a large file and we don't want to collect it
          # too often, "true" Disk Controller / PhysicalDisk errocount will only be done once per hour.
          type: osCommand
          commandLine: date +MSHW_DATE%%m%%d0000%%y;datestring=`date +%%m%%d`;ioscli errlog | grep $datestring
          computes:
            # Parsing this through an awk script
            # DeviceID;ErrorCount;
          - type: awk
            script: EmbeddedFile(7)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3"
      mapping:
        # InstanceTable = Source(5)
        source: $monitors.disk_controller.discovery.sources.source(3)$
        attributes:
          id: $column(2)
          controller_number: $column(4)
          model: $column(3)
          hw.parent.type: enclosure
          name: "sprintf(\"%s %s (%s)\"), \"Disk Controller\", $column(2), $column(3))"
    collect:
      # Collect type = multi-instance
      type: multiInstance
      sources:
        source(1):
          # Table Join Discovery Source (3) - Instance Table, with Discovery Table (4) - Errorcounts
          # adapterDevicePath;DeviceID;displayName;controllerDevicePath;DeviceID;ErrorCount;
          type: tableJoin
          leftTable: $monitors.disk_controller.discovery.sources.source(3)$
          rightTable: $monitors.disk_controller.discovery.sources.source(4)$
          leftKeyColumn: 2
          rightKeyColumn: 1
          defaultRightLine: ;0;
          computes:
            # Duplicate the ErrorCount Column
            # adapterDevicePath;DeviceID;displayName;controllerDevicePath;DeviceID;ErrorCount;ErrorCount;
          - type: duplicateColumn
            column: 6
            # Translate the errorcount into a status (as errorcount does not exist for Disk Controllers)
            # adapterDevicePath;DeviceID;displayName;controllerDevicePath;DeviceID;PatrolStatus;ErrorCount;
          - type: translate
            column: 6
            translationTable: ErrorcounttoStatusTranslationTable
            # Translate the errorcount into a status (as errorcount does not exist for Disk Controllers)
            # adapterDevicePath;DeviceID;displayName;controllerDevicePath;DeviceID;PatrolStatus;PatrolStatusInfo;
          - type: translate
            column: 7
            translationTable: ErrorcounttoStatusInformationTranslationTable
      mapping:
        # ValueTable = Source(1)
        # adapterDevicePath;DeviceID;displayName;controllerDevicePath;DeviceID;PatrolStatus;PatrolStatusInfo;
        source: $monitors.disk_controller.collect.sources.source(1)$
        metrics:
          hw.status{hw.type="disk_controller"}: $column(6)
        legacyTextParameters:
          StatusInformation: $column(7)
        deviceId: $column(2)
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = output of ioscli lsdev -field physloc -type disk
          # diskName;diskPath
          type: osCommand
          commandLine: "ioscli lsdev -fmt : -field name physloc -type disk"
          keep: ^hdisk
          separators: ':'
          selectColumns: "1,2"
          computes:
            # Keep only the first 5 chars of the diskPath to obtain the diskControllerID
            # DeviceID;controllerID
          - type: substring
            column: 2
            start: 1
            length: 5
        source(2):
          # Source(1) = output of ioscli lsdev -vpd
          type: osCommand
          commandLine: ioscli lsdev -vpd
          computes:
            # Reformat lsdev's output through awk (see EmbeddedFile(3))
            # DeviceID;size;make-model-FRU;Serial;
          - type: awk
            script: EmbeddedFile(3)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5"
        source(3):
          # Source(3) = Table joint of Source(1) and Source(2)
          # DeviceID;controllerID;DeviceID;size;make-model-FRU;Serial;
          type: tableJoin
          leftTable: $monitors.physical_disk.discovery.sources.source(1)$
          rightTable: $monitors.physical_disk.discovery.sources.source(2)$
          leftKeyColumn: 1
          rightKeyColumn: 1
          computes:
            # Translate size into bytes
            # DeviceID;controllerID;DeviceID;size;make-model-FRU;Serial;
          - type: multiply
            column: 4
            value: 1073741824
      mapping:
        # Now we are ready to go
        # InstanceTable = Source(4)
        # DeviceID;controllerID;DeviceID;size;make-model-FRU;Serial;
        source: $monitors.physical_disk.discovery.sources.source(3)$
        attributes:
          id: $column(1)
          vendor: $column(5)
          serial_number: $column(6)
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $column(2))"
          name: "sprintf(\"%s (%s)\", $column(1), $column(4))"
        metrics:
          hw.physical_disk.size: $column(4)
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          type: osCommand
          commandLine: "ioscli lsdev -fmt : -field name status"
          keep: ^hdisk
          separators: ':'
          selectColumns: "1,2"
          computes:
            # Duplicate the status column
            # PhysicalDiskID;PhysicalDiskStatus;PhysicalDiskStatus
          - type: duplicateColumn
            column: 2
            # Translate the first status column into a PATROL status
            # PhysicalDiskID;PATROLStatus;PhysicalDiskStatus
          - type: translate
            column: 2
            translationTable: PhysicalDiskStatusTranslationTable
            # Translate the second status column into a more readable string
            # PhysicalDiskID;PATROLStatus;statusInformation
          - type: translate
            column: 3
            translationTable: PhysicalDiskStatusInformationTranslationTable
        source(2):
          # Table Join Discovery Source (3) - Instance Table, with Discovery Table (4) - Errorcounts
          # PhysicalDiskID;PATROLStatus;statusInformation;DeviceID;ErrorCount;
          type: tableJoin
          leftTable: $monitors.physical_disk.collect.sources.source(1)$
          rightTable: $monitors.disk_controller.discovery.sources.source(4)$
          leftKeyColumn: 1
          rightKeyColumn: 1
          defaultRightLine: ;0;
      mapping:
        #  "ValueTable = source(1)
        # PhysicalDiskID;PATROLStatus;statusInformation;DeviceID;ErrorCount;
        source: $monitors.physical_disk.collect.sources.source(2)$
        deviceId: $column(1)
        legacyTextParameters:
          StatusInformation: $column(3)
  network:
    discovery:
      sources:
        source(1):
          # Source(1) = output of fcstat (Fiber Cards)
          type: osCommand
          commandLine: "for FCSTAT in $(for NIC in `for a in $(for i in $(ioscli lsdev -type  disk -field name -state Available && ioscli lsdev -type tape -field name |grep \"^hdisk|^rmt\"); do ioscli lsdev -dev $i -parent  ; done |grep ^fs|sort -n |uniq); do ioscli lsdev -dev $a -parent; done |grep ^fc ; ioscli lsmap -all -npiv |awk '{FS=\":\"} /name:fcs/ && /loc/  {print $2}' |awk '{print $1}' |uniq `; do echo $NIC ; done |uniq); do  fcstat $FCSTAT ; done"
          computes:
            # AWK it
            # MSHW;portID;;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;WWPN;AddressType;SerialNumber;
          - type: awk
            script: EmbeddedFile(4)
            keep: ^MSHW;
            separators: ;
        source(2):
          # Source(2) = output of netstat (Ethernet Cards)
          type: osCommand
          commandLine: "STR0=$(ioscli lsdev -type adapter -state Available -field name|egrep '^ent'); STR1=$(ioscli lsmap -all -npiv |awk '/FC name:/ {print $2}' |sort |uniq |cut -c '6-10'); STR2=$(ioscli viostat -adapter |awk '/fcs/ {print $1}') ;for i in $(for i in $(echo $STR0 $STR1 $STR2); do echo $i; done |sort |uniq) ; do ioscli netstat -cdlistats $i; done"
          computes:
            # AWK it
            # MSHW;portID;Status;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;WWPN;
          - type: awk
            script: EmbeddedFile(5)
            keep: ^MSHW;
            separators: ;
            # Add MAC and blank serial number - This is done so that Embedded File 5 matched the one in IBM AIX Embedded file 3
            # MSHW;portID;Status;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;MAC;AddressType;SerialNumber;
          - type: rightConcat
            column: 13
            value: ;MAC;
        source(3):
          # Source(3) = Union of Source(1) and Source(2)
          # MSHW;portID;;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;MAC;AddressType;SerialNumber;
          type: tableUnion
          tables:
          - $monitors.network.discovery.sources.source(1)$
          - $monitors.network.discovery.sources.source(2)$
      mapping:
        # InstanceTable = Source(1)
        # 1     2     3        # 4        #    5        #    6       7        # 8      9       10   11    12      13    14         15
        # MSHW;portID;Status;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;MAC;AddressType;SerialNumber;
        source: $monitors.network.discovery.sources.source(3)$
        attributes:
          id: $column(2)
          physical_address: $column(13)
          physical_address_type: $column(14)
          device_type: $column(12)
          serial_number: $column(15)
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s)\", $column(2), $column(12))"
    collect:
      # The NetworkCard collect is a "MultiInstance" collect
      type: multiInstance
      sources:
        source(1):
          # Source(1) = output of fcstat (Fiber Cards)
          type: osCommand
          commandLine: "for FCSTAT in $(for NIC in `for a in $(for i in $(ioscli lsdev -type  disk -field name -state Available && ioscli lsdev -type tape -field name |grep \"^hdisk|^rmt\"); do ioscli lsdev -dev $i -parent  ; done |grep ^fs|sort -n |uniq); do ioscli lsdev -dev $a -parent; done |grep ^fc ; ioscli lsmap -all -npiv |awk '{FS=\":\"} /name:fcs/ && /loc/  {print $2}' |awk '{print $1}' |uniq `; do echo $NIC ; done |uniq); do  fcstat $FCSTAT ; done"
          computes:
            # AWK it
            # MSHW;portID;;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;WWPN;AddressType;SerialNumber;
          - type: awk
            script: EmbeddedFile(4)
            keep: ^MSHW;
            separators: ;
        source(2):
          # Source(2) = output of netstat (Ethernat Cards)
          type: osCommand
          commandLine: "STR0=$(ioscli lsdev -type adapter -state Available -field name|egrep '^ent'); STR1=$(ioscli lsmap -all -npiv |awk '/FC name:/ {print $2}' |sort |uniq |cut -c '6-10'); STR2=$(ioscli viostat -adapter |awk '/fcs/ {print $1}') ;for i in $(for i in $(echo $STR0 $STR1 $STR2); do echo $i; done |sort |uniq) ; do ioscli netstat -cdlistats $i; done"
          computes:
            # AWK it
            # MSHW;portID;;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;WWPN;
          - type: awk
            script: EmbeddedFile(5)
            keep: ^MSHW;
            separators: ;
        source(3):
          # Source(3) = Union of Source(1) and Source(2)
          # MSHW;portID;;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;WWPN;AddressType;SerialNumber;
          type: tableUnion
          tables:
          - $monitors.network.collect.sources.source(1)$
          - $monitors.network.collect.sources.source(2)$
      mapping:
        # ValueTable = Source(1)
        # MSHW;portID;;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;WWPN;AddressType;SerialNumber;
        source: $monitors.network.collect.sources.source(3)$
        deviceId: $column(2)
        metrics:
          hw.network.bandwidth.limit: megaBit2Bit($column(10))
          hw.network.up: legacyLinkStatus($column(4))
          hw.network.packets{direction="receive"}: $column(7)
          hw.network.packets{direction="transmit"}: $column(6)
          hw.errors{hw.type="network"}: $column(5)
          hw.network.io{direction="receive"}: $column(9)
          hw.network.io{direction="transmit"}: $column(8)
          hw.network.full_duplex: legacyFullDuplex($column(11))
  lun:
    discovery:
      sources:
        source(1):
          # Get the list of Ports from lspath
          type: osCommand
          commandLine: ioscli lspath
          computes:
            # AWK it
            # LunName;LunInfo;LunStatus;
          - type: awk
            script: EmbeddedFile(1)
            keep: ^MSHW;
            separators: ;
            selectColumns: 2
      mapping:
        # InstanceTable = Source(1)
        # LunName;LunInfo;LunStatus;
        source: $monitors.lun.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          hw.parent.type: enclosure
          name: $column(1)
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Get the list of Ports from multipath -l
          type: osCommand
          commandLine: ioscli lspath
          computes:
            # AWK it
            # LunName;NumberPaths;
          - type: awk
            script: EmbeddedFile(1)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3"
      mapping:
        # ValueTable = Source(1)
        # LunName;NumberPaths;LunStatus;LunStatusInfo;AvailablePathInformation;
        source: $monitors.lun.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.lun.paths: $column(2)
