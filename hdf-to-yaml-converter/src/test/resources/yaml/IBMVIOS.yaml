---
extends:
- IBMAIXModels-header
embedded:
  EmbeddedFile(1): |-
    $2 ~ /hdisk[0-9]+/ && $3 ~ /fscsi/ {if ($2 in LUN == 0) {LUN[$2] = 0}
                                          if ($1 ~ /[Ee]nabled/) {LUN[$2] = LUN[$2] + 1}
                                         }
    END {for (id in LUN) {print "MSHW;" id ";" LUN[id] ";"} }
  EmbeddedFile(3): |-
    ($1 ~ /hdisk[0-9]/) {
        ID=$1;
        size = $(NF-1);
        gsub("[^0-9.]", "", size);
        if ($NF ~ /MB/) { size = size / 1024; }
        if ($NF ~ /TB/) { size = size * 1024; }
    }

    (ID != "" && $1 ~ /Manufacturer/) { make = $1; gsub (".+\\.", "", make); }

    (ID != "" && $1 ~ /Machine/ && $2 ~ /Type/) { model = $NF; gsub(".+\\.", "", model); }

    (ID != "" && $1 ~ /FRU/ && $2 ~ /Number/) { FRU = $NF; gsub(".+\\.", "", FRU); }

    (ID != "" && $1 ~ /Serial/ && $2 ~ /Number/) {
        Serial = $NF;
        gsub(".+\\.", "", Serial);
        if (FRU != "")
        {
            print ("MSHW;" ID ";" size ";" make "-" model " FRU: " FRU ";" Serial ";");
        }
        ID=""; size=""; make=""; model=""; FRU=""; Serial="";
    }
  EmbeddedFile(2): |-
    BEGIN {
        nicUp = 0;
        nicSpeed = "";
    }
    /^Driver Flags:.*Up/ {
        nicUp = 1;
    }

    /^Media Speed Running: +[0-9]+ / {
        nicSpeed = $4;
    }

    /^Hardware Address:/ {
        address = $3;
    }

    END {
        if (nicUp == 1)
        {
            print "MSHW;" nicId ";" nicSpeed ";" address ";"
        }
    }
  EmbeddedFile(5): |-
    /^ETHERNET STATISTICS/ { nicdevice = $3; gsub (/[\050\051]/,"",nicdevice); nicdevices[nicdevice]=nicdevice }

    /^Device Type:/ {
                     if ( ($3 ~ /EtherChannel/ || $3 ~ /Virtual/) || ($0 ~ /Shared Ethernet Adapter/) || ($0 ~ /Link Aggregation/) || ($0 ~ /VLAN/)) { EtherT[nicdevice] = "Logical"; lastLogical = nicdevice }
                        else { EtherT[nicdevice] = "Physical" }
                    }

    /^Driver Flags:/ {
                      if ($0 ~ /Running/) { nicStatus[nicdevice] = "OK";}
                      else {
                            nicStatus[nicdevice] = "ALARM";
                            getline
                            if ($0 ~ /Running/) { nicStatus[nicdevice] = "OK";}
                           }
                     }

    $1 == "Hardware" && $2 == "Address:" { mac[nicdevice] = $3 ; gsub (/:/,"",mac[nicdevice])}

    # Link
    /Physical Port Link Stat/ {
                               if ($NF == "up" || $NF == "Up" || $NF == "UP") {
                                                                               linkStatus[nicdevice] = "OK";
                                                                               if ( linkStatus[lastLogical] == "WARN" ) { linkStatus[lastLogical] = "OK" ; nicStatus[lastLogical] = "WARN" ; }
                                                                              }
                                  else {
                                        linkStatus[nicdevice] = "WARN"; nicStatus[nicdevice] = "OK";
                                        if (linkStatus[lastLogical] == "OK") { nicStatus[lastLogical] = "WARN" }
                                        if (linkStatus[lastLogical] == "") { linkStatus[lastLogical] = "WARN" ; nicStatus[lastLogical] = "ALARM" }
                                       }
                              }

    $1 == "Link" && $2 == "Status" { if ($4 == "up" || $4 == "Up" || $4 == "UP") { linkStatus[nicdevice] = "OK"; }
                                          else {linkStatus[nicdevice] = "WARN"; nicStatus[nicdevice] = "OK";}
                                     }

    $1 == "Link" && $2 == "Status:" { if ($3 == "up" || $3 == "Up" || $3 == "UP") { linkStatus[nicdevice] = "OK";}
                                           else { linkStatus[nicdevice] = "WARN"; nicStatus[nicdevice] = "OK"; }
                                      }

    # Speed
    $0 ~ /Media Speed Running:/ || $0 ~ /Physical Port Speed:/ {
                                                                        if ($4 ~ /^[0-9]+$/) {linkSpeed[nicdevice] = $4 $5; gsub(/Gbps/,"000",linkSpeed[nicdevice]);gsub(/Mbps/,"",linkSpeed[nicdevice]);}
                                                                            else {linkSpeed[nicdevice] = $4; gsub(/Gbps/,"000",linkSpeed[nicdevice]);gsub(/Mbps/,"",linkSpeed[nicdevice]);}
                                                                     if ($0 ~ /[Hh]alf [Dd]uplex/) { duplexMode[nicdevice] = "half"; }
                                        else { duplexMode[nicdevice] = "full"; }
                                     }

    # Statistics
    $1 == "Packets:" && $3 == "Packets:" { transmitPackets[nicdevice] = $2; receivePackets[nicdevice] = $4; }

    $1 == "Bytes:" && $3 == "Bytes:" {transmitBytes[nicdevice] = $2;receiveBytes[nicdevice] = $4; }

    $1 == "Transmit" && $2 == "Errors:" && $4 == "Receive" && $5 == "Errors:" { transmitErrors[nicdevice] = $3; receiveErrors[nicdevice] = $6; totalErrors[nicdevice] = transmitErrors[nicdevice] + receiveErrors[nicdevice] ; }

    END { for (nic in nicdevices) {
              if (EtherT[nic] == "Logical") {
                 printf("MSHW;%s;%s;%s;%.0f;%.0f;%.0f;%.0f;%.0f;;;%s;;\n", nicdevices[nic],nicStatus[nic],linkStatus[nic],totalErrors[nic],transmitPackets[nic],receivePackets[nic],transmitBytes[nic],receiveBytes[nic],"Logical");
                 }
                 else {printf("MSHW;%s;%s;%s;%.0f;%.0f;%.0f;%.0f;%.0f;%s;%s;%s;%s;\n",nicdevices[nic],nicStatus[nic],linkStatus[nic],totalErrors[nic],transmitPackets[nic],receivePackets[nic],transmitBytes[nic],receiveBytes[nic],linkSpeed[nic],duplexMode[nic],"Physical", mac[nic]);
                      }

              }
        }
  EmbeddedFile(4): |-
    BEGIN { portID = ""; WWPN = ""; linkStatus = "WARN"; TxPackets = ""; RxPackets = ""; TxBytes = ""; RxBytes = ""; ErrorCountFrames = ""; PortType = ""; speed = ""; SerialNumber = ""; }

    ($1 == "FIBRE" && $2 == "CHANNEL" && $3 == "STATISTICS") {

        # If portID != "", it means we're starting the section for a new port, so report the one that we've just processed
          if (portID != "") { print("MSHW;" portID ";"  ";" linkStatus ";" ErrorCountFrames ";" TxPackets ";" RxPackets ";" TxBytes ";" RxBytes ";" speed ";Full;" PortType ";" WWPN ";WWN;"  SerialNumber ";" ); }
        portID = ""; WWPN = ""; linkStatus = "WARN"; TxPackets = ""; RxPackets = ""; TxBytes = ""; RxBytes = ""; ErrorCountFrames = ""; PortType = ""; speed = ""; SerialNumber = "";

        portID = $NF;
    }

    ($1 == "World" && $2 == "Wide" && $3 == "Port") { WWPN = $NF; gsub(/^0x/, "" , WWPN); }
    ($1 == "Port" && $2 == "WWN") { WWPN=$NF; gsub(/^0x/, "" , WWPN); }

    $0 ~ /[Aa]ttention.*[Tt]ype.*[Ll]ink.*[Uu]p/ {linkStatus = "OK"}
    $0 ~ /[Aa]ttention.*[Tt]ype.*[Ll]ink.*[Dd]own/ {linkStatus = "WARN"}
    ($1 == "Port" && $2 == "Speed" && $3 ~ /running/) { speed = $(NF-1); speed = speed * 1000; linkStatus = "OK"; }

    ($1 == "Port" && $2 == "Type:") { PortType = "HBA FC Port (" $3 ")"; }

    ($1 == "Serial" && $2 == "Number:") { SerialNumber = $NF; }

    ($1 ~ /^Frames/ && $2 ~ /^[0-9]+$/ && $3 ~ /^[0-9]+$/) { TxPackets = $2; RxPackets = $3; }
    ($1 ~ /^Frames/ && $2 ~ /^[0-9]+$/ && $3 ~ /^Frames/ && $4 ~ /^[0-9]+$/) { TxPackets = $2; RxPackets = $4; }

    ($1 ~ /Error/ && $2 ~ /Frames/ && $3 ~ /^[0-9]+$/) { if (ErrorCountFrames == "") { ErrorCountFrames = $3; } else { ErrorCountFrames = ErrorCountFrames + $3;} }

    ($1 ~ /Dumped/ && $2 ~ /Frames/ && $3 ~ /^[0-9]+$/) { if (ErrorCountFrames == "") { ErrorCountFrames = $3; } else { ErrorCountFrames = ErrorCountFrames + $3;} }

    ($1 ~ /Input/ && $2 ~ /Bytes/ && $3 ~ /^[0-9]+$/) { if (RxBytes == "") { RxBytes = $3; } else { RxBytes = RxBytes + $3;} }

    ($1 ~ /Output/ && $2 ~ /Bytes/ && $3 ~ /^[0-9]+$/) { if (TxBytes == "") { TxBytes = $3; } else { TxBytes = TxBytes + $3;} }

    END {
        if (portID != "") { print("MSHW;" portID ";"  ";" linkStatus ";" ErrorCountFrames ";" TxPackets ";" RxPackets ";" TxBytes ";" RxBytes ";" speed ";Full;" PortType ";" WWPN ";WWN;"  SerialNumber ";" ); }
    }
  EmbeddedFile(7): |-
    $1 ~ /MSHW_DATE[0-9]+/ {mmdd = substr($1,10,4) ; yy = substr ($1,18,2)}
    # Match the date
    substr($2,1,4) == mmdd &&  substr($2,9,2) == yy { if ($5 in DeviceErrorCount == 0) {DeviceErrorCount[$5] = 1}
                                                        else {DeviceErrorCount[$5] = DeviceErrorCount[$5] + 1 }
                                                       }
    END {for (id in DeviceErrorCount) {print "MSHW;" id ";" DeviceErrorCount[id] ";"} }
  EmbeddedFile(6): |-
    BEGIN {
        MemoryObject = 0;
        DeviceID = "";
        Size = "";
        SerialNumber = "";
        PartNumber = "";
    }
    /Memory [DS]IMM:/ {
        MemoryObject = 1;
    }

    /Size\.+/ {
        Size = $0;
        gsub(" +Size\\.+", "", Size);
    }
    /Serial Number\.+/ {
        SerialNumber = $0;
        gsub(" +Serial Number\\.+", "", SerialNumber);
    }
    /Part Number\.+/ {
        PartNumber = $0;
        gsub(" +Part Number\\.+", "", PartNumber);
    }
    /Physical Location:/ {
        if (MemoryObject == 1)
        {
            DeviceID = $3;

            if (Size == 0)
            {
                Status = "ALARM";
                StatusInformation = "Failed";
            }
            else
            {
                Status = "OK";
                StatusInformation = "";
            }
            print "MSHW;" DeviceID ";" Size ";" SerialNumber " - FRU: " PartNumber ";" Status ";" StatusInformation ";"
        }
        DeviceID = "";
        MemoryObject = 0;
        SerialNumber = "";
        PartNumber = "";
    }
translations:
  PhysicalDiskStatusInformationTranslationTable:
    stopped: Stopped
    default: Unknown Status
    available: Available
    defined: Defined
  ErrorcounttoStatusTranslationTable:
    "0": ok
    default: failed
  cpuStatusInformationTranslationTable:
    stopped: Stopped
    default: Unknown Status
    available: Available
    defined: Defined
  ErrorcounttoStatusInformationTranslationTable:
    "0": No Disk Controller Events found today (Parameter only collects every hour)
    default: Disk Controller Events found today - Run errlog for more details
  cpuStatusTranslationTable:
    stopped: degraded
    default: UNKNOWN
    available: ok
    defined: ok
  PhysicalDiskStatusTranslationTable:
    stopped: degraded
    default: UNKNOWN
    available: ok
    defined: ok
connector:
  displayName: IBM VIO Server
  platforms: IBM POWER
  reliesOn: "IBM AIX system commands through the IOS interface (lsdev, entstat, etc.)"
  information: "Provides hardware status information (processors, memory modules, network interfaces, HBAs, physical disks) on IBM VIO systems."
  version: 1.3
  detection:
    connectionTypes:
    - remote
    appliesTo:
    - RS6000
    supersedes:
    - IBMAIX
    - IBMAIXChrpMachstat
    - IBMAIXDisk
    - IBMAIXHBA
    - IBMAIXUeSensor
    criteria:
    # OS should be AIX (whatever version)
    - type: deviceType
      keep:
      - RS6000
    # uname should return vioserver
    - type: osCommand
      commandLine: ioscli uname -a
      expectedResult: AIX
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Source(1) = the output of uname -M
          # MachineIDNumber;ModelCode;SystemID;LPARSystemID;
          type: osCommand
          commandLine: ioscli uname -mMfF
          keep: " IBM,"
          separators: ' '
          selectColumns: "1,2,3,4"
          computes:
            # Duplicate the MachineIDNumber
            # MachineIDNumber;MachineIDNumber;ModelCode;LPARSystemID;SystemID;
          - type: duplicateColumn
            column: 1
            # Remove the IBM,  (We, unfortunately, already know it's an IBM)
            # MachineIDNumber;MachineIDNumber;ModelCode;LPARSystemID;SystemID;
          - type: replace
            column: 3
            existingValue: "IBM,"
            newValue: ""
            # Add descriptive prefixes to the different IDs
            # MachineIDNumber;MachineIDNumber;ModelCode;LPARSystemID;SystemID;
          - type: leftConcat
            column: 2
            value: "Machine ID: "
          - type: leftConcat
            column: 4
            value: "LPAR System ID: "
          - type: leftConcat
            column: 5
            value: "System ID: "
            # Duplicate the ModelCode
            # MachineIDNumber;MachineIDNumber;ModelCode;ModelCode;LPARSystemID;SystemID;
          - type: duplicateColumn
            column: 3
            # Translate the 2nd Model Code into a Model Name
            # The translation table will need to be regularly updated
            # MachineIDNumber;MachineIDNumber;ModelCode;ModelName;LPARSystemID;SystemID;
          - type: translate
            column: 4
            translationTable: ModelTranslationTable
      mapping:
        # The discovery table
        # MachineIDNumber;MachineIDNumber;ModelCode;ModelName;LPARSystemID;SystemID;
        source: $monitors.enclosure.discovery.sources.source(1)$
        attributes:
          id: $column(3)
          __display_id: $column(3)
          vendor: IBM
          model: $column(4)
          type: Computer
          serial_number: $column(1)
          info: "join($column(2), $column(6), $column(5), \" \")"
          name: "sprintf(\"%s (%s %s - %s)\", $column(3), \"IBM\", $column(4), \"Computer\")"
  cpu:
    discovery:
      sources:
        source(1):
          # Source(1) = lsdev
          # cpuID;
          type: osCommand
          commandLine: ioscli lsdev -field name
          separators: ","
          keep: ^proc
      mapping:
        # Instance table = source(1)
        source: $monitors.cpu.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          hw.parent.type: enclosure
          name: $column(1)
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          type: osCommand
          commandLine: "ioscli lsdev -fmt : -field name status"
          keep: ^proc
          separators: ':'
          selectColumns: "1,2"
          computes:
            # Duplicate the status column
            # cpuID;cpuStatus;cpuStatus
          - type: duplicateColumn
            column: 2
            # Translate the first status column into a PATROL status
            # cpuID;PATROLStatus;cpuStatus
          - type: translate
            column: 2
            translationTable: cpuStatusTranslationTable
            # Translate the second status column into a more readable string
            # cpuID;PATROLStatus;statusInformation
          - type: translate
            column: 3
            translationTable: cpuStatusInformationTranslationTable
      mapping:
        # ' "ValueTable = source(1)'
        source: $monitors.cpu.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="cpu"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
  memory:
    discovery:
      sources:
        source(1):
          # Source(1) = output of ioscli lsdev -vpd
          type: osCommand
          commandLine: ioscli lsdev -vpd
          computes:
            # Reformat lscfg's output through awk (see EmbeddedFile(6))
            # DeviceID;Size;SerialNumber
          - type: awk
            script: EmbeddedFile(6)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4"
            # Add ";1;" to the DeviceID that will correspond to the Status and ErrorCount ParameterActivation values
            # DeviceID;StatusActivation;ErrorCountActivation;Size;SerialNumber
          - type: rightConcat
            column: 1
            value: ;1;
        source(2):
          # Source(2) = Static table to represent the global memory stuff
          type: static
          value: Memory Controller;;1;;;
        source(3):
          # Source(3) = Union of Source(1) and Source(2)
          # DeviceID;StatusActivation;ErrorCountActivation;Size;SerialNumber
          type: tableUnion
          tables:
          - $monitors.memory.discovery.sources.source(1)$
          - $monitors.memory.discovery.sources.source(2)$
        source(4):
          # Source (4) = Date + Complete Errorlog
          # Not used in Discovery, it is used in the collect.  But as it can be a large file and we don't want to collect it
          # too often, "true" memory collects will only be done once per hour.
          type: osCommand
          commandLine: "ioscli errlog -ls | grep -c -E \"CORRECTED_SCRUB||MEM[0-9]||RECOV_ECC_ERR||CORRECTED_SCRUB\""
          computes:
            # Add the Memory Controller Identifier
            # DeviceID;Status;StatusInformation;ErrorCount
          - type: leftConcat
            column: 1
            value: Memory Controller;;;
      mapping:
        # InstanceTable = Source(1)
        source: $monitors.memory.discovery.sources.source(3)$
        attributes:
          id: $column(1)
          serial_number: $column(5)
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s)\", $column(1), $column(4))"
        metrics:
          hw.memory.limit: mebiByte2Byte($column(4))
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = output of ioscli lsdev -vpd
          type: osCommand
          commandLine: ioscli lsdev -vpd
          computes:
            # Reformat lsdev's output through awk (see EmbeddedFile(6))
            # DeviceID;Status;StatusInformation;
          - type: awk
            script: EmbeddedFile(6)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,5,6"
            # Add ";" to the right, as an empty ErrorCount column
            # DeviceID;Status;StatusInformation;ErrorCount
          - type: rightConcat
            column: 3
            value: ;
        source(2):
          # Source(4) = Number of events reported by errlog of type "memory"
          # this is done in discovery
          # DeviceID;Status;StatusInformation;ErrorCount
          type: copy
          from: $monitors.memory.discovery.sources.source(4)$
        source(3):
          # Source(3) = Union of Source(1) and Source(2)
          type: tableUnion
          tables:
          - $monitors.memory.collect.sources.source(1)$
          - $monitors.memory.collect.sources.source(2)$
      mapping:
        # Value table = Source(1)
        source: $monitors.memory.collect.sources.source(3)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="memory"}: $column(2)
          hw.errors{hw.type="memory"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(3)
  disk_controller:
    discovery:
      sources:
        source(1):
          # Source(1) = output of lsdev - list of disk "parents"
          # diskDevicePath
          type: osCommand
          commandLine: ioscli lsdev -field physloc -type disk
          computes:
            # Retrieve the controller device path from the disk device path
            # controllerDevicePath; (may be several identical instances)
          - type: substring
            column: 1
            start: 1
            length: 5
        source(2):
          # Source(2) = output of lsdev -field name physloc description -fmt : -type adapter
          # adapterDevicePath;DeviceID;displayName;
          type: osCommand
          commandLine: "ioscli lsdev -field physloc name description -fmt : -type adapter"
          separators: ':'
          selectColumns: "1,2,3"
          computes:
            # Keep only scsi[0-9]* disk controllers (not RAID or SSA)
            # adapterDevicePath;DeviceID;displayName
          - type: keepOnlyMatchingLines
            column: 2
            regExp: "\\(^sisscsi[A-Za-z0-9]+$\\)\\|\\(^scsi[A-Za-z0-9]+$\\)\\|\\(^sisio[A-Za-z0-9]+$\\)\\|\\(^sissas[A-Za-z0-9]+$\\)"
            # Retrieve the controller device path from the disk device path
            # adapterDevicePath;DeviceID;displayName
          - type: substring
            column: 1
            start: 1
            length: 5
        source(3):
          # Source(3) = Table joint of Source(1) and Source(2)
          # This jointure will make MSHW keep only adapters that are disk controllers
          # with disks attached to them
          # adapterDevicePath;DeviceID;displayName;controllerDevicePath
          type: tableJoin
          leftTable: $monitors.disk_controller.discovery.sources.source(2)$
          rightTable: $monitors.disk_controller.discovery.sources.source(1)$
          leftKeyColumn: 1
          rightKeyColumn: 1
        source(4):
          # Source (4) = Complete Errorlog
          # Not used in Discovery, it is used in the collect.  But as it can be a large file and we don't want to collect it
          # too often, "true" Disk Controller / PhysicalDisk errocount will only be done once per hour.
          type: osCommand
          commandLine: date +MSHW_DATE%%m%%d0000%%y;datestring=`date +%%m%%d`;ioscli errlog | grep $datestring
          computes:
            # Parsing this through an awk script
            # DeviceID;ErrorCount;
          - type: awk
            script: EmbeddedFile(7)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3"
      mapping:
        # InstanceTable = Source(5)
        source: $monitors.disk_controller.discovery.sources.source(3)$
        attributes:
          id: $column(2)
          controller_number: $column(4)
          model: $column(3)
          hw.parent.type: enclosure
          name: "sprintf(\"Disk Controller: %s (%s)\", $column(4), $column(3))"
    collect:
      # Collect type = multi-instance
      type: multiInstance
      sources:
        source(1):
          # Table Join Discovery Source (3) - Instance Table, with Discovery Table (4) - Errorcounts
          # adapterDevicePath;DeviceID;displayName;controllerDevicePath;DeviceID;ErrorCount;
          type: tableJoin
          leftTable: $monitors.disk_controller.discovery.sources.source(3)$
          rightTable: $monitors.disk_controller.discovery.sources.source(4)$
          leftKeyColumn: 2
          rightKeyColumn: 1
          defaultRightLine: ;0;
          computes:
            # Duplicate the ErrorCount Column
            # adapterDevicePath;DeviceID;displayName;controllerDevicePath;DeviceID;ErrorCount;ErrorCount;
          - type: duplicateColumn
            column: 6
            # Translate the errorcount into a status (as errorcount does not exist for Disk Controllers)
            # adapterDevicePath;DeviceID;displayName;controllerDevicePath;DeviceID;PatrolStatus;ErrorCount;
          - type: translate
            column: 6
            translationTable: ErrorcounttoStatusTranslationTable
            # Translate the errorcount into a status (as errorcount does not exist for Disk Controllers)
            # adapterDevicePath;DeviceID;displayName;controllerDevicePath;DeviceID;PatrolStatus;PatrolStatusInfo;
          - type: translate
            column: 7
            translationTable: ErrorcounttoStatusInformationTranslationTable
      mapping:
        # ValueTable = Source(1)
        # adapterDevicePath;DeviceID;displayName;controllerDevicePath;DeviceID;PatrolStatus;PatrolStatusInfo;
        source: $monitors.disk_controller.collect.sources.source(1)$
        metrics:
          hw.status{hw.type="disk_controller"}: $column(6)
        legacyTextParameters:
          StatusInformation: $column(7)
        deviceId: $column(2)
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = output of ioscli lsdev -field physloc -type disk
          # diskName;diskPath
          type: osCommand
          commandLine: "ioscli lsdev -fmt : -field name physloc -type disk"
          keep: ^hdisk
          separators: ':'
          selectColumns: "1,2"
          computes:
            # Keep only the first 5 chars of the diskPath to obtain the diskControllerID
            # DeviceID;controllerID
          - type: substring
            column: 2
            start: 1
            length: 5
        source(2):
          # Source(1) = output of ioscli lsdev -vpd
          type: osCommand
          commandLine: ioscli lsdev -vpd
          computes:
            # Reformat lsdev's output through awk (see EmbeddedFile(3))
            # DeviceID;size;make-model-FRU;Serial;
          - type: awk
            script: EmbeddedFile(3)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5"
        source(3):
          # Source(3) = Table joint of Source(1) and Source(2)
          # DeviceID;controllerID;DeviceID;size;make-model-FRU;Serial;
          type: tableJoin
          leftTable: $monitors.physical_disk.discovery.sources.source(1)$
          rightTable: $monitors.physical_disk.discovery.sources.source(2)$
          leftKeyColumn: 1
          rightKeyColumn: 1
          computes:
            # Translate size into bytes
            # DeviceID;controllerID;DeviceID;size;make-model-FRU;Serial;
          - type: multiply
            column: 4
            value: 1073741824
      mapping:
        # Now we are ready to go
        # InstanceTable = Source(4)
        # DeviceID;controllerID;DeviceID;size;make-model-FRU;Serial;
        source: $monitors.physical_disk.discovery.sources.source(3)$
        attributes:
          id: $column(1)
          vendor: $column(5)
          serial_number: $column(6)
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $column(2))"
          name: "sprintf(\"%s (%s)\", $column(1), $column(4))"
        metrics:
          hw.physical_disk.size: $column(4)
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          type: osCommand
          commandLine: "ioscli lsdev -fmt : -field name status"
          keep: ^hdisk
          separators: ':'
          selectColumns: "1,2"
          computes:
            # Duplicate the status column
            # PhysicalDiskID;PhysicalDiskStatus;PhysicalDiskStatus
          - type: duplicateColumn
            column: 2
            # Translate the first status column into a PATROL status
            # PhysicalDiskID;PATROLStatus;PhysicalDiskStatus
          - type: translate
            column: 2
            translationTable: PhysicalDiskStatusTranslationTable
            # Translate the second status column into a more readable string
            # PhysicalDiskID;PATROLStatus;statusInformation
          - type: translate
            column: 3
            translationTable: PhysicalDiskStatusInformationTranslationTable
        source(2):
          # Table Join Discovery Source (3) - Instance Table, with Discovery Table (4) - Errorcounts
          # PhysicalDiskID;PATROLStatus;statusInformation;DeviceID;ErrorCount;
          type: tableJoin
          leftTable: $monitors.physical_disk.collect.sources.source(1)$
          rightTable: $monitors.disk_controller.discovery.sources.source(4)$
          leftKeyColumn: 1
          rightKeyColumn: 1
          defaultRightLine: ;0;
      mapping:
        #  "ValueTable = source(1)
        # PhysicalDiskID;PATROLStatus;statusInformation;DeviceID;ErrorCount;
        source: $monitors.physical_disk.collect.sources.source(2)$
        deviceId: $column(1)
        legacyTextParameters:
          StatusInformation: $column(3)
  network:
    discovery:
      sources:
        source(1):
          # Source(1) = output of fcstat (Fiber Cards)
          type: osCommand
          commandLine: "for FCSTAT in $(for NIC in `for a in $(for i in $(ioscli lsdev -type  disk -field name -state Available && ioscli lsdev -type tape -field name |grep \"^hdisk|^rmt\"); do ioscli lsdev -dev $i -parent  ; done |grep ^fs|sort -n |uniq); do ioscli lsdev -dev $a -parent; done |grep ^fc ; ioscli lsmap -all -npiv |awk '{FS=\":\"} /name:fcs/ && /loc/  {print $2}' |awk '{print $1}' |uniq `; do echo $NIC ; done |uniq); do  fcstat $FCSTAT ; done"
          computes:
            # AWK it
            # MSHW;portID;;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;WWPN;AddressType;SerialNumber;
          - type: awk
            script: EmbeddedFile(4)
            keep: ^MSHW;
            separators: ;
        source(2):
          # Source(2) = output of netstat (Ethernet Cards)
          type: osCommand
          commandLine: "STR0=$(ioscli lsdev -type adapter -state Available -field name|egrep '^ent'); STR1=$(ioscli lsmap -all -npiv |awk '/FC name:/ {print $2}' |sort |uniq |cut -c '6-10'); STR2=$(ioscli viostat -adapter |awk '/fcs/ {print $1}') ;for i in $(for i in $(echo $STR0 $STR1 $STR2); do echo $i; done |sort |uniq) ; do ioscli netstat -cdlistats $i; done"
          computes:
            # AWK it
            # MSHW;portID;Status;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;WWPN;
          - type: awk
            script: EmbeddedFile(5)
            keep: ^MSHW;
            separators: ;
            # Add MAC and blank serial number - This is done so that Embedded File 5 matched the one in IBM AIX Embedded file 3
            # MSHW;portID;Status;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;MAC;AddressType;SerialNumber;
          - type: rightConcat
            column: 13
            value: ;MAC;
        source(3):
          # Source(3) = Union of Source(1) and Source(2)
          # MSHW;portID;;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;MAC;AddressType;SerialNumber;
          type: tableUnion
          tables:
          - $monitors.network.discovery.sources.source(1)$
          - $monitors.network.discovery.sources.source(2)$
      mapping:
        # InstanceTable = Source(1)
        # 1     2     3        # 4        #    5        #    6       7        # 8      9       10   11    12      13    14         15
        # MSHW;portID;Status;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;MAC;AddressType;SerialNumber;
        source: $monitors.network.discovery.sources.source(3)$
        attributes:
          id: $column(2)
          physical_address: $column(13)
          physical_address_type: $column(14)
          device_type: $column(12)
          serial_number: $column(15)
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s)\", $column(2), $column(12))"
    collect:
      # The NetworkCard collect is a "MultiInstance" collect
      type: multiInstance
      sources:
        source(1):
          # Source(1) = output of fcstat (Fiber Cards)
          type: osCommand
          commandLine: "for FCSTAT in $(for NIC in `for a in $(for i in $(ioscli lsdev -type  disk -field name -state Available && ioscli lsdev -type tape -field name |grep \"^hdisk|^rmt\"); do ioscli lsdev -dev $i -parent  ; done |grep ^fs|sort -n |uniq); do ioscli lsdev -dev $a -parent; done |grep ^fc ; ioscli lsmap -all -npiv |awk '{FS=\":\"} /name:fcs/ && /loc/  {print $2}' |awk '{print $1}' |uniq `; do echo $NIC ; done |uniq); do  fcstat $FCSTAT ; done"
          computes:
            # AWK it
            # MSHW;portID;;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;WWPN;AddressType;SerialNumber;
          - type: awk
            script: EmbeddedFile(4)
            keep: ^MSHW;
            separators: ;
        source(2):
          # Source(2) = output of netstat (Ethernat Cards)
          type: osCommand
          commandLine: "STR0=$(ioscli lsdev -type adapter -state Available -field name|egrep '^ent'); STR1=$(ioscli lsmap -all -npiv |awk '/FC name:/ {print $2}' |sort |uniq |cut -c '6-10'); STR2=$(ioscli viostat -adapter |awk '/fcs/ {print $1}') ;for i in $(for i in $(echo $STR0 $STR1 $STR2); do echo $i; done |sort |uniq) ; do ioscli netstat -cdlistats $i; done"
          computes:
            # AWK it
            # MSHW;portID;;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;WWPN;
          - type: awk
            script: EmbeddedFile(5)
            keep: ^MSHW;
            separators: ;
        source(3):
          # Source(3) = Union of Source(1) and Source(2)
          # MSHW;portID;;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;WWPN;AddressType;SerialNumber;
          type: tableUnion
          tables:
          - $monitors.network.collect.sources.source(1)$
          - $monitors.network.collect.sources.source(2)$
      mapping:
        # ValueTable = Source(1)
        # MSHW;portID;;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;WWPN;AddressType;SerialNumber;
        source: $monitors.network.collect.sources.source(3)$
        deviceId: $column(2)
        metrics:
          hw.network.bandwidth.limit: megaBit2Bit($column(10))
          hw.network.up: legacyLinkStatus($column(4))
          hw.network.packets{direction="receive"}: $column(7)
          hw.network.packets{direction="transmit"}: $column(6)
          hw.errors{hw.type="network"}: $column(5)
          hw.network.io{direction="receive"}: $column(9)
          hw.network.io{direction="transmit"}: $column(8)
          hw.network.full_duplex: legacyFullDuplex($column(11))
  lun:
    discovery:
      sources:
        source(1):
          # Get the list of Ports from lspath
          type: osCommand
          commandLine: ioscli lspath
          computes:
            # AWK it
            # LunName;LunInfo;LunStatus;
          - type: awk
            script: EmbeddedFile(1)
            keep: ^MSHW;
            separators: ;
            selectColumns: 2
      mapping:
        # InstanceTable = Source(1)
        # LunName;LunInfo;LunStatus;
        source: $monitors.lun.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          hw.parent.type: enclosure
          name: $column(1)
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Get the list of Ports from multipath -l
          type: osCommand
          commandLine: ioscli lspath
          computes:
            # AWK it
            # LunName;NumberPaths;
          - type: awk
            script: EmbeddedFile(1)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3"
      mapping:
        # ValueTable = Source(1)
        # LunName;NumberPaths;LunStatus;LunStatusInfo;AvailablePathInformation;
        source: $monitors.lun.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.lun.paths: $column(2)
