---
embedded:
  EmbeddedFile(1): |-
    BEGIN {
        hardwarePath = "";
        productName = "";
    }
    /^Product +:/ {
        colonIndex = index($0, ":");
        if (colonIndex > 10)
        {
            productName = substr($0, colonIndex + 2)
        }
    }
    /^Hardware [pP]ath +:/ {
        hardwarePath = $4
        if (productName != "")
        {
            print "MSHW;" hardwarePath ";" productName;
            productName = "";
        }
    }
  EmbeddedFile(3): |-
    BEGIN {
        readErrors = 0;
        writeErrors = 0;
        readReverseErrors = 0;
        verifyErrors = 0;
        status = "";
    }
    /^ *Read Errors: +[0-9]+/ {
        readErrors = $3;
    }
    /^ *Read Reverse Errors: +[0-9]+/ {
        readReverseErrors = $4;
    }
    /^ *Write Errors: +[0-9]+/ {
        writeErrors = $3;
    }
    /^ *Verify Errors: +[0-9]+/ {
        verifyErrors = $3;
    }
    /^Current [Ss]tatus +:/ {
        status = $4;

        totalErrors = readErrors + readReverseErrors + writeErrors + verifyErrors;
        print "MSHW;" totalErrors ";" status ";";
    }
  EmbeddedFile(2): |-
    BEGIN {
        hardwarePath = "";
        productID = "";
        vendor = "";
        serialNumber = "";
        size = "";
        controllerPath = "";
    }
    /^Hardware [Pp]ath:/ {
        hardwarePath = $3;
    }
    /^Product Id:/ {
        productID = $3;
        vendor = $5;
    }
    /^Serial [Nn]umber:/ {
        serialNumber = $3;
    }
    /^Capacity \(M Byte\): +[0-9\.]+/ {
        size = $4;
    }
    /^ *Verify Errors: +[0-9]+/ {

        if (hardwarePath != "" && productID != "" && size > 0)
        {
            n = split(hardwarePath, controllerPathArray, "[\.]");
            controllerPath = controllerPathArray[1];
            for (i=2 ; i<=n ; i++)
            {
                print "MSHW;" hardwarePath ";" controllerPath ";" vendor " " productID ";" size ";" serialNumber ";";
                controllerPath = controllerPath "." controllerPathArray[i];
            }
            hardwarePath = "";
            productID = "";
            vendor = "";
            serialNumber = "";
            size = "";
            controllerPath = "";
        }
    }
  EmbeddedFile(5): |-
    BEGIN {
        pdtUsed = "";
        pdtTotal = "";
    }
    /^ *Memory Error Log Summary *$/,/^ *Page Deallocation Table \(PDT\) *$/ {
        if ($NF ~ /^[0-9]+$/)
        {
            if ($2 ~ /^0x[0-9a-fA-F]+$/)
            {
                print "MSHW;" $1 ";OK;" $3 " Errors Occured;" $NF
            }
            else if ($3 ~ /^0x[0-9a-fA-F]+$/)
            {
                print "MSHW;" $1 " " $2 ";OK;" $4 " Errors Occured;" $NF
            }
        }
    }
    /^ *PDT Entries Used: +[0-9]+ *$/ {
        pdtUsed = $NF;
    }
    /^ *PDT Total Size: +[0-9]+ *$/ {
        pdtTotal = $NF;
    }
    END {
        if (pdtUsed != "" && pdtTotal != "")
        {
            pdtPercentUsed = pdtUsed / pdtTotal * 100;
            if (pdtPercentUsed > 70)
            {
                pdtStatus = "ALARM";
            }
            else if (pdtPercentUsed > 50)
            {
                pdtStatus = "WARN";
            }
            else
            {
                pdtStatus = "OK";
            }
            printf("MSHW;PDT;%s;%d%% Used;%d\n", pdtStatus, pdtPercentUsed, pdtUsed);
        }
    }
  EmbeddedFile(4): |-
    BEGIN {
        prefixLetter = "";
        cabCell = "";
        matrixFormat = 0;
    }
    /^ *Memory [Bb]oard [Ii]nventory *$/,/^ *Memory [Ee]rror [Ll]og [Ss]ummary *$/ {
        if ($0 ~ /Total/)
        {
            next;
        }

        if ($0 ~ "^ *CAB/CELL:")
        {
            cabCell = $2;
            matrixFormat = 1;
            split("A B C D E F G H", slotLabel);
        }

        if ($0 ~ /Note: The first letter in all DIMM slots start with a/)
        {
            split($0, prefixArray, "\"");
            prefixLetter = prefixArray[2];
        }

        if ($0 ~ /Configured and Slot label for each DIMM/)
        {
            getline
            getline
            split($0, slotLabel);
            matrixFormat = 1;
        }

        if (matrixFormat)
        {
            if ($0 ~ /^ *[0-9A-Za-z]+ +[0-9]+ +[0-9]+/)
            {
                if (tolower($1) == "ext")
                {
                    bank = $1 " " $2 " DIMM ";
                    startAt = 3;
                }
                else
                {
                    bank = $1;
                    startAt = 2;
                }

                if (cabCell != "")
                {
                    bank = cabCell " " bank;
                }

                if (prefixLetter != "")
                {
                    bank = bank "/" prefixLetter;
                }

                for (i=startAt ; i<=NF ; i++)
                {
                    if ($i == 64 || $i == 128 || $i == 256 || $i == 512 || $i == 1024 || $i == 2048 || $i == 4096)
                    {
                        print "MSHW;" bank slotLabel[(i - startAt + 1)] ";" $i ";"
                    }
                }
            }
        }
        else
        {
            lastMBColumn = 0;
            for (i=2 ; i<=NF ; i++)
            {
                if ($i == 64 || $i == 128 || $i == 256 || $i == 512 || $i == 1024 || $i == 2048 || $i == 4096)
                {
                    result = "MSHW;"
                    for (j=lastMBColumn + 1 ; j<i-1 ; j++)
                    {
                        result = result $j " "
                    }
                    result = result $(i-1) ";" $i ";"
                    print result
                    lastMBColumn = i;
                }
            }
        }

    }
    END {
        print "MSHW;PDT;;Page Deallocation Table"
    }
  EmbeddedFile(6): |-
    BEGIN {Cabinet="";IDIndex="";Present=0;Failure=0;State=0;fans="";powerSupplies=""}
    /Cabinet [0-9]+ Hardware Inventory/,/=-+-=-+-=-+-=-+-=-+/ {

    # Processes the "Overall Table"
    if ($1 ~ /Cabinet/ && $2 ~ /[0-9]+/ && $3 ~ /Hardware/) {Cabinet = $2}
    if ($1 ~ /Component/ && $(NF-2) ~ /Present/ && $(NF-1) ~ /Failure/ && $NF ~ /State/) {IDIndex = match($0,$2)
                                                                                           }
    if (IDIndex != "" && NF > 2 && $(NF-1) ~ /^[0-9]+$/) {
                          DeviceID = substr($0,1,IDIndex) ; gsub (/^ +/,"",DeviceID);gsub (/ +$/,"",DeviceID);
                        if (DeviceID ~ /[Ff]an/) {type = "FAN-Global" ; if ($NF !~ /[Uu]nknown/) {fans = "Monitored" }}
                             else if (DeviceID ~ /[Pp]ower/) {type = "PSU-Global"; if ($NF !~ /[Uu]nknown/) {powerSupplies = "Monitored"}}
                                 else {type = "OTHER"}
                        if ($Failure > 0) {status = "ALARM"; statusInformation = $Failure " Failed"}
                            else {status = "OK" ; statusInformation = ""}
                        print ("MSHW;" type ";CAB-" Cabinet " " DeviceID ";" status ";" statusInformation ";")
                       }

    if (NF < 2) {IDIndex="";Present=0;Failure=0;State=0;}

    # Processes the "Individual Components" - only if the Fans / Power Supplies are being monitored in the table above (not "unknown")  Flag fans & powerSupplies are used.

    if ($0 ~ /\|[0-9]\|[0-9]/) {
                              ArrayLength=split($0,OutputArray,/\|/);
                              getline;
                              split($0,LineArray,/\|/);
                              for (i=2;i<=ArrayLength-1;i++) {OutputArray[i]=OutputArray[i] LineArray[i];}
                              getline;
                              getline;
                              while ($0 !~ /------------/) {
                                                            split($0,LineArray,/\|/);
                                                            gsub(/ /,"",LineArray[1]);
                                                            for (i=2;i<=ArrayLength-1;i++) {
                                                                                              gsub(/ /,"",LineArray[i]);
                                                                                              if (LineArray[1] ~ /^cf/ && fans != "") {type = "FAN"}
                                                                                                  else if (LineArray[1] ~ /^cp/ && powerSupplies != "") {type = "PSU"}
                                                                                                      else {type = ""}
                                                                                              if ( LineArray[i] == "p" ) {status="OK";statusInformation=""}
                                                                                                  else if ( LineArray[i] == "F" ) {status="ALARM";statusInformation="Failed"}
                                                                                                      else {status="";statusInformation=""}
                                                                                              if (type != "" && status != "") {print ("MSHW;"type";CAB-" Cabinet " " LineArray[1]"-" OutputArray[i] ";" status ";" statusInformation";");}
                                                                                              }
                                                            getline;
                                                           }
                              }
                           }
translations:
  PhysicalDiskStatusInformationTranslationTable:
    incomplete: Testing Incomplete
    default: Unknown Status
    aborted: Testing Aborted
    failure: Testing Failed
    success: ""
    testing: Testing in Progress
    hung: Testing Hung
    warning: Testing Warning
    query pending: User Input Expected
    suspended: Testing Suspended
  PhysicalDiskStatusTranslationTable:
    incomplete: failed
    default: UNKNOWN
    failure: failed
    success: ok
    hung: degraded
    warning: degraded
connector:
  displayName: HP-UX (STM)
  platforms: "HP 9000,HP Integrity,HP SuperDome"
  reliesOn: HP-UX Support Tools Manager (STM)
  information: Provides physical disks and memory monitoring on HP-UX systems through the Support Tools Manager utilities (stm).
  version: 1.1
  detection:
    connectionTypes:
    - remote
    appliesTo:
    - HP
    criteria:
    # OS should be HP (for HP-UX, whatever version)
    - type: deviceType
      keep:
      - HP
    # The stm executable needs to be present
    - type: osCommand
      commandLine: /bin/ls /usr/bin/stm
      expectedResult: ^/usr/bin/stm$
    # stm must return something
    - type: osCommand
      commandLine: /bin/echo "map"|/usr/bin/stm -c
      expectedResult: Active Tool
monitors:
  disk_controller:
    discovery:
      sources:
        source(1):
          # Source(1) = output of echo ""selclass type interface;cds""|stm -c
          type: osCommand
          commandLine: /bin/echo "selclass type interface;cds"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process output of cstom through awk EmbeddedFile(1)
            # This contains the list of all interfaces in the system, which happen
            # to include disk controllers
            # DeviceID;Model
          - type: awk
            script: EmbeddedFile(1)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3"
        source(2):
          # Source(2) = output of echo ""selclass type Disk;wait;information;wait;infolog""|stm -c
          type: osCommand
          commandLine: /bin/echo "selclass type Disk;wait;information;wait;infolog"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process the output of cstm throughawk EmbeddedFile(2)
            # DeviceID;ControllerID;Vendor Model;sizeMB;SerialNumber
          - type: awk
            script: EmbeddedFile(2)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5,6"
        source(3):
          # Source(3) = table joint of Source(1) and Source(2)
          # This is to keep only interfaces that are disk controllers in fact,
          # and among those disk controllers, the ones that actually have disks
          # ControllerDeviceID;Model;DiskDeviceID;ControllerID;Vendor Model;sizeMB;SerialNumber
          type: tableJoin
          leftTable: $monitors.disk_controller.discovery.sources.source(1)$
          rightTable: $monitors.disk_controller.discovery.sources.source(2)$
          leftKeyColumn: 1
          rightKeyColumn: 2
      mapping:
        # InstanceTable = Source(3)
        source: $monitors.disk_controller.discovery.sources.source(3)$
        attributes:
          id: $column(1)
          controller_number: $column(1)
          model: $column(2)
          hw.parent.type: enclosure
          name: "sprintf(\"Disk Controller: %s (%s)\", $column(1), $column(2))"
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = table joint of DiskController.Discovery.Source(2) and DiskController.Discovery.Source(3)
          # in order to keep only disks that are attached to an existing disk controller
          # DeviceID;ControllerID;Vendor Model;sizeMB;SerialNumber;ControllerDeviceID;Model;DiskDeviceID;ControllerID;Vendor Model;sizeMB;SerialNumber
          type: tableJoin
          leftTable: $monitors.disk_controller.discovery.sources.source(2)$
          rightTable: $monitors.disk_controller.discovery.sources.source(3)$
          leftKeyColumn: 2
          rightKeyColumn: 1
          computes:
            # Convert SizeMB into bytes
            # DeviceID;ControllerID;Vendor Model;size;SerialNumber
          - type: multiply
            column: 4
            value: 1048576
      mapping:
        # InstanceTable = Source(1)
        source: $monitors.physical_disk.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          vendor: $column(3)
          serial_number: $column(5)
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $column(2))"
          name: "sprintf(\"%s (%s)\", $column(1), $column(4))"
        metrics:
          hw.physical_disk.size: $column(4)
    collect:
      # Collect type is "multi-instance
      type: monoInstance
      sources:
        source(1):
          # Source(1) = output of cstm echo ""selclass type Disk;wait;information;wait;infolog""|stm -c
          type: osCommand
          commandLine: |-
            /bin/echo "select path %PhysicalDisk.Collect.DeviceID%;wait;information;wait;infolog"|/usr/bin/stm -c
            /bin/echo "select path %PhysicalDisk.Collect.DeviceID%;wait;veroptions execctrl iterations 1 behavior errorcount 10 testcoverage mincoverage gentactlog no reporterrors reportwarnings queries querynondes;verify;wait;currdevstatus"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process output of cstm through awk EmbeddedFile(2)
            # ErrorCount;Status;
          - type: awk
            script: EmbeddedFile(3)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3"
            # Duplicate the status column
            # ErrorCount;Status;Status
          - type: duplicateColumn
            column: 2
            # Translate the first status into a PATROL status
            # ErrorCount;PATROLStatus;Status
          - type: translate
            column: 2
            translationTable: PhysicalDiskStatusTranslationTable
            # Translate the second Status into a more readable string
            # ErrorCount;PATROLStatus;StatusInformation
          - type: translate
            column: 3
            translationTable: PhysicalDiskStatusInformationTranslationTable
      mapping:
        # ValueTable = Source(1)
        source: $monitors.physical_disk.collect.sources.source(1)$
        metrics:
          hw.status{hw.type="physical_disk"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
  memory:
    discovery:
      sources:
        source(1):
          # Source(1) = output of echo ""selclass type memory;wait;information;wait;infolog""|stm -c
          type: osCommand
          commandLine: /bin/echo "selclass type memory;wait;information;wait;infolog"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process cstm output through awk EmbeddedFile(4)
            # Memory modules' IDs and sizes and the "Page Deallocation Table (PDT)"
            # DeviceID;Size;Type
          - type: awk
            script: EmbeddedFile(4)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4"
      mapping:
        # InstanceTable = Source(&)
        source: $monitors.memory.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          type: $column(3)
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s - %s)\", $column(1), $column(3), $column(2))"
        metrics:
          hw.memory.limit: mebiByte2Byte($column(2))
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = output of echo ""selclass type memory;wait;information;wait;infolog""|stm -c
          type: osCommand
          commandLine: /bin/echo "selclass type memory;wait;information;wait;infolog"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process output of cstm through awk EmbeddedFile(5)
            # Memory modules error count and status (as well as for the "Page Deallocation Table (PDT)")
            # DeviceID;Status;StatusInformation;ErrorCount
          - type: awk
            script: EmbeddedFile(5)
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5"
        source(2):
          # Source(2) = copy of discovery.source(1)
          # Yeah, that's because our source(1) does contain lines only about memory modules
          # that encountered some errors. So we need to add the entire list of modules with
          # an error count of zero. The collection process will keep only the first line
          # DeviceID;Size;Type
          type: copy
          from: $monitors.memory.discovery.sources.source(1)$
          computes:
            # Remove size and type (keep only device ID)
            # DeviceID
          - type: keepColumns
            columnNumbers: 1
            # Add fake OK and ErrorCount=0 columns
            # DeviceID;OK;;0
          - type: rightConcat
            column: 1
            value: ;OK;;0
        source(3):
          # Source(3) = union of Source(1) and Source(2)
          # DeviceID;Status;StatusInformation;ErrorCount
          type: tableUnion
          tables:
          - $monitors.memory.collect.sources.source(1)$
          - $monitors.memory.collect.sources.source(2)$
      mapping:
        # Okay, we have everything now (hope so)
        # ValueTable = Source(3)
        source: $monitors.memory.collect.sources.source(3)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="memory"}: $column(2)
          hw.errors{hw.type="memory"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(3)
  fan:
    discovery:
      sources:
        source(1):
          # Source(1) = output of /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
          type: osCommand
          commandLine: /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process cstm output through awk EmbeddedFile(6)
            # Type;DeviceID
          - type: awk
            script: EmbeddedFile(6)
            keep: ^MSHW;FAN
            separators: ;
            selectColumns: "2,3"
      mapping:
        # InstanceTable = Source(1)
        source: $monitors.fan.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          hw.parent.type: enclosure
          name: $column(2)
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = output of /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
          type: osCommand
          commandLine: /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process cstm output through awk EmbeddedFile(6)
            # DeviceID;Status;StatusInformation
          - type: awk
            script: EmbeddedFile(6)
            keep: ^MSHW;FAN
            separators: ;
            selectColumns: "3,4,5"
      mapping:
        # ValueTable = Source(1)
        source: $monitors.fan.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="fan"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
  power_supply:
    discovery:
      sources:
        source(1):
          # Source(1) = output of /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
          type: osCommand
          commandLine: /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process cstm output through awk EmbeddedFile(6)
            # Type;DeviceID
          - type: awk
            script: EmbeddedFile(6)
            keep: ^MSHW;PSU
            separators: ;
            selectColumns: "2,3"
      mapping:
        # InstanceTable = Source(1)
        source: $monitors.power_supply.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          power_supply_type: $column(1)
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s)\", $column(2), $column(1))"
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = output of /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
          type: osCommand
          commandLine: /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process cstm output through awk EmbeddedFile(6)
            # DeviceID;Status;StatusInformation
          - type: awk
            script: EmbeddedFile(6)
            keep: ^MSHW;PSU
            separators: ;
            selectColumns: "3,4,5"
      mapping:
        # ValueTable = Source(1)
        source: $monitors.power_supply.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="power_supply"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
