---
embedded:
  EmbeddedFile(1): "BEGIN { FS = \"=\"; model = \"\"; serialNumber = \"\"; }\n$1 ~ /^System Model *$/ { model = \"Dell\" $2 $3; }\n$1 ~ /^Service Tag *$/ { serialNumber = $2; }\nEND { gsub (/Power[Ee]dge ?/,\"PE-\",model);gsub (/Control ?[Pp]anel/,\"\",model);\n\t    print \"MSHW;\" model \";\" serialNumber\";\" }"
  EmbeddedFile(11): "$NF ~ /Disk.Virtual./ {DeviceID = $NF ; gsub (/Disk.Virtual./,\"\",DeviceID) }\ntolower($1) ~ /^status$/ {if ($3~ \"^[Nn]/[Aa]$\" ) { status = \"UNKNOWN\"; statusInformation = \"Unknown Status\"; }\n\t                      else if ($3 ~ /^[Oo][Kk]$/) { status = \"OK\"; statusInformation = \"\"; }\n\t                      else if ($3 ~ /^[Nn]ot$/ && $4 ~ /^[Oo][Kk]$/) { status = \"ALARM\"; statusInformation = \"Not OK\"; }\n\t                      else { status = \"UNKNOWN\"; statusInformation = \"Unknown Status\"; }\n                       }\ntolower($1) ~ /name/ {Name = $3}\ntolower($1) ~ /layout/ {RaidLevel = $3}\ntolower($1) ~ /^size$/ && DeviceID != \"\" {\n\t                      Size = $3 ; if (toupper($4) ~ /TB/) {size = size * 1024}\n# DeviceID;Status;StatusInformation;Name;RaidLevel;Size;\n\t                      print \"MSHW;\" DeviceID \";\" status \";\" statusInformation \";\" Name \";\" RaidLevel \";\" Size \";\"\n\t                      DeviceID=\"\" ; status=\"\" ; statusInformation=\"\" ; Name = \"\" ; RaidLevel = \"\" ; Size = \"\" ;\n\t                     }"
  EmbeddedFile(12): |-
    # MSHW;BladeID;SlotName;HostName;
    $1 ~ /^[0-9]+$/ {print "MSHW;" $1 ";" $2 ";" $3 ";" }
  EmbeddedFile(3): "# m1000e / MX7000\n# Find the location of the rawStatus and sensorName as they now contain spaces\n$4 ~ /.status./ { rawStatusStart = index($0,\"status\") - 1  ; rawStatusLength = index($0,$5) - rawStatusStart  }\n$3 ~ /.sensorName./ { sensorNameStart = index($0,\"sensorName\") - 1 ; sensorNameLength = index($0,$4) - sensorNameStart  }\n\n# Extract the rawStatus and sensorName\n($1 == \"Temp\" && $(NF-2) ~ /[Cc]el[cs]ius/ && NF > 7) {\n\trawStatus = substr($0,rawStatusStart,rawStatusLength) ; gsub(/ *$/,\"\",rawStatus)\n\tsensorName = substr($0,sensorNameStart ,sensorNameLength ) ; gsub(/ *$/,\"\",sensorName)\n\tif (rawStatus  ~ \"^[Nn]/[Aa]$\" ) { status = \"UNKNOWN\"; statusInformation = \"Unknown Status\"; }\n\telse if (rawStatus  ~ /^[Oo][Kk]$/) { status = \"OK\"; statusInformation = \"\"; }\n\telse if (rawStatus  ~ /^[Nn]ot [Oo][Kk]$/ ) { status = \"ALARM\"; statusInformation = \"Not OK\"; }\n\telse { status = \"WARN\"; statusInformation = rawStatus; }\n\n  # TemperatureID;Location;WarningThreshold;AlarmThreshold;Temperature;Status;StatusInformation;\n  print (\"MSHW;\" $2 \";\" sensorName  \";;\" $NF \";\" $(NF-3) \";\" status \";\" statusInformation \";\")\n}\n\n\n# VRTX\n$1 ~ /Sensor/ && $2 ~ /Type/ && $4 ~ /Temperature/ {Section = \"VRTX_TEMP\"}\nNF < 2 {Section = \"\"}\n$1 ~ \"<Sensor\" && $2 ~ \"Name>\" && Section == \"VRTX_TEMP\" {statusOffset = index ($0,\"<Status>\")\n\t                              readingOffset = index ($0,\"<Reading>\")\n\t                              UWOffset = index ($0,\"<UW>\")\n\t                              UCOffset = index ($0,\"<UC>\")\n\t                              getline\n\t                             }\nSection == \"VRTX_TEMP\"  && statusOffset != \"\" {\n\t                              deviceID = substr ($0,1,statusOffset-2) ; gsub(/ *$/,\"\",deviceID)\n\t                              status = substr ($0,statusOffset,6)\n\t\t                            if (status ~ \"^[Nn]/[Aa]$\" ) { status = \"UNKNOWN\"; statusInformation = \"Unknown Status\"; }\n\t\t                            else if (status ~ /^[Oo][Kk]/) { status = \"OK\"; statusInformation = \"\"; }\n\t\t                            else if (status ~ /[^Nn]ot [Oo][Kk]/) { status = \"ALARM\"; statusInformation = \"Not OK\"; }\n\t\t                            else { status = \"UNKNOWN\"; statusInformation = \"Unknown Status\"; }\n\t\t                            Reading = substr ($0,readingOffset,4) ; gsub (/ /,\"\",Reading); gsub (\"^[Nn]/[Aa]$\",\"\",Reading)\n\t\t                            UW = substr ($0,UWOffset,4) ; gsub (/ /,\"\",UW);\n\t\t                            UC = substr ($0,UCOffset,4) ; gsub (/ /,\"\",UC);\n# TemperatureID;Location;WarningThreshold;AlarmThreshold;Temperature;Status;StatusInformation;\n\t\t                            print \"MSHW;\" deviceID \";\" \";\" UW \";\" UC \";\" Reading \";\" status \";\" statusInformation \";\"\n\t\t                            deviceID=\"\"; UW =\"\"; UC=\"\"; Reading=\"\"; status=\"\"; statusInformation=\"\";\n\t\t                           }\n# VRTX RAID\n$1 ~ /TempSensor./ {DeviceID = $1 ; gsub (/TempSensor.Embedded./,\"\",DeviceID) }\ntolower($1) ~ /name/ {Location = $0 ;  gsub (/.*= /,\"\",Location) }\ntolower($1) ~ /status/ {if ($3~ \"^[Nn]/[Aa]$\" ) { status = \"UNKNOWN\"; statusInformation = \"Unknown Status\"; }\n\t                      else if ($3 ~ /^[Oo][Kk]$/) { status = \"OK\"; statusInformation = \"\"; }\n\t                      else if ($3 ~ /^[Nn]ot$/ && $4 ~ /^[Oo][Kk]$/) { status = \"ALARM\"; statusInformation = \"Not OK\"; }\n\t                      else { status = \"UNKNOWN\"; statusInformation = \"Unknown Status\"; }\n\t                     }\ntolower($1) ~ /readingdegreecelcius/ && ($3 > 0) {Temperature = $3 ;}\ntolower($1) ~ /maximumwarningthreshold/ && ($3 > 0) {WarningThreshold = $3 ; }\ntolower($1) ~ /maximumfailurethreshold/ && DeviceID != \"\" {\n\t                                       if ($3 > 0) {AlarmThreshold = $3 }\n# TemperatureID;Location;WarningThreshold;AlarmThreshold;Temperature;Status;StatusInformation;\n\t                                       print \"MSHW;\" DeviceID \";\" Location \";\" WarningThreshold \";\" AlarmThreshold \";\" Temperature \";\" status \";\" statusInformation \";\"\n\t                                       DeviceID=\"\" ; Location=\"\" ; WarningThreshold=\"\" ; AlarmThreshold=\"\" ; Temperature=\"\" ; status=\"\" ; statusInformation=\"\" ;\n\t                                      }"
  EmbeddedFile(2): "($1 == \"Chassis\" && $2 == \"Present\") {\n\tif ($4 ~ \"^[Nn]/[Aa]$\" ) { status = \"UNKNOWN\"; statusInformation = \"Unknown Status\"; }\n\telse if ($4 ~ /^[Oo][Kk]$/) { status = \"OK\"; statusInformation = \"\"; }\n\telse if ($4 ~ /^[Nn]ot$/ && $5 ~ /^[Oo][Kk]$/) { status = \"ALARM\"; statusInformation = \"Not OK\"; }\n\telse { status = \"UNKNOWN\"; statusInformation = \"Unknown Status\"; }\n}\n/^ *System Input Power/ && $5 ~ /[0-9][0-9]/ {powerConsumption = $5}\nEND {\n\tprint \"MSHW;\" status \";\" statusInformation \";\" powerConsumption \";\"\n}"
  EmbeddedFile(5): "# m1000e\n($1 == \"PWR\" && $3 ~ /^PS-[0-9]$/ && NF > 4) {\n  if ($4 ~ /^Slot$/ && $5 ~ /^Empty$/) {next}\n  else if ($4 ~ /^Redundant$/) {status=\"OK\";statusInformation=\"Redundant\"}\n  else if ($4 ~ /^Online$/) {status=\"OK\";statusInformation=\"Online\"}\n  else if ($4 ~ /^Failed$/) {status=\"ALARM\";statusInformation=\"Failed\"}\n  else { status = \"UNKNOWN\"; statusInformation = \"Unknown Status\"; }\n\tif ($(NF-1) ~ /^[Nn]ot$/ && $NF ~ /^[Oo][Kk]$/) { status = \"ALARM\"; statusInformation = statusInformation \" - No AC\"; }\n# PowerSupplyID;Status;StatusInformation\n\tprint \"MSHW;\" $3 \";\" status \";\" statusInformation \";\"\n}\n\n# Both VRTX and M1000e\n$0 ~ /^Overall Power Health/ {deviceID = \"Overall Power Health\"\n                              if ($NF ~ \"^[Nn]/[Aa]$\" ) { status = \"UNKNOWN\"; statusInformation = \"Unknown Status\"; }\n                            \telse if ($(NF-1) ~ /^[Nn]ot$/ && $NF ~ /^[Oo][Kk]$/) { status = \"ALARM\"; statusInformation = \"Not OK\"; }\n                              else if ($NF ~ /^[Oo][Kk]$/) { status = \"OK\"; statusInformation = \"\"; }\n                            \telse { status = \"UNKNOWN\"; statusInformation = \"Unknown Status\"; } ;\n                            \tprint \"MSHW;\" deviceID \";\" status \";\" statusInformation \";\"\n                             }\n\n# VRTX\n$1 ~ /Sensor/ && $2 ~ /Type/ && $4 ~ /Power/ {Section = \"VRTX_PSU\"}\nNF < 2 {Section = \"\"}\n$1 ~ \"<Sensor\" && $2 ~ \"Name>\" && Section == \"VRTX_PSU\" {statusOffset = index ($0,\"<Status>\")\n\t                              getline\n\t                             }\nSection == \"VRTX_PSU\"  && statusOffset != \"\" {\n\t                              deviceID = substr ($0,1,statusOffset-2) ; gsub(/ *$/,\"\",deviceID)\n\t                              status = substr ($0,statusOffset,10)\n\t                              if (status ~ /^Slot Empty/) {next}\n                                else if (status ~ /^Redundant/) {status=\"OK\";statusInformation=\"Redundant\"}\n                                else if (status ~ /^Online/) {status=\"OK\";statusInformation=\"Online\"}\n                                else if (status ~ /^Failed/) {status=\"ALARM\";statusInformation=\"Failed\"}\n                                else { status = \"UNKNOWN\"; statusInformation = \"Unknown Status\"; }\n                                if ($(NF-1) ~ /^[Nn]ot$/ && $NF ~ /^[Oo][Kk]$/) { status = \"ALARM\"; statusInformation = statusInformation \" - No AC\"; }\n# PowerSupplyID;Status;StatusInformation\n\t\t                            print \"MSHW;\" deviceID \";\" status \";\" statusInformation \";\"\n\t\t                           }"
  EmbeddedFile(4): "# m1000e\n($1 == \"FanSpeed\" && $(NF-2) ~ /rpm/ && NF > 7) {\n\tif ($4 ~ \"^[Nn]/[Aa]$\" ) { status = \"UNKNOWN\"; statusInformation = \"Unknown Status\"; }\n\telse if ($4 ~ /^[Oo][Kk]$/) { status = \"OK\"; statusInformation = \"\"; }\n\telse if ($4 ~ /^[Nn]ot$/ && $5 ~ /^[Oo][Kk]$/) { status = \"ALARM\"; statusInformation = \"Not OK\"; }\n\telse { status = \"UNKNOWN\"; statusInformation = \"Unknown Status\"; }\n\tWarningThreshold = $(NF-1) ; gsub(/N.A/,\"\",WarningThreshold )\n\tAlarmThreshold = $(NF-3) ; gsub(/N.A/,\"\",AlarmThreshold )\n\t# FanID;Location;WarningThreshold;AlarmThreshold;Speed;Status;StatusInformation;\n\tprint (\"MSHW;\" $2 \";\" $3 \";;\" WarningThreshold  \";\" AlarmThreshold \";\" status \";\" statusInformation \";\")\n}\n\n# MX7000\n($1 == \"FanSpeed\" && $(NF-3) ~ /rpm/ && NF > 7) {\n\tif ($4 ~ \"^[Nn]/[Aa]$\" ) { status = \"UNKNOWN\"; statusInformation = \"Unknown Status\"; }\n\telse if ($4 ~ /^[Oo][Kk]$/) { status = \"OK\"; statusInformation = \"\"; }\n\telse if ($4 ~ /^[Nn]ot$/ && $5 ~ /^[Oo][Kk]$/) { status = \"ALARM\"; statusInformation = \"Not OK\"; }\n\telse { status = \"WARN\"; statusInformation = $4 ; }\n\tWarningThreshold = $(NF-2) ; gsub(/N.A/,\"\",WarningThreshold)\n\tAlarmThreshold = $(NF-4) ; gsub(/N.A/,\"\",AlarmThreshold )\n\t# FanID;Location;WarningThreshold;AlarmThreshold;Speed;Status;StatusInformation;\n\tprint (\"MSHW;\" $2 \";\" $3 \";;\" WarningThreshold \";\" AlarmThreshold \";\" status \";\" statusInformation \";\")\n}\n\n# VRTX\n$1 ~ /Sensor/ && $2 ~ /Type/ && $4 ~ /FanSpeed/ {Section = \"VRTX_FAN\"}\nNF < 2 {Section = \"\"}\n$1 ~ \"<Sensor\" && $2 ~ \"Name>\" && Section == \"VRTX_FAN\" {statusOffset = index ($0,\"<Status>\")\n\t                              readingOffset = index ($0,\"<Reading>\")\n\t                              LWOffset = index ($0,\"<LW>\")\n\t                              LCOffset = index ($0,\"<LC>\")\n\t                              getline\n\t                             }\nSection == \"VRTX_FAN\"  && statusOffset != \"\" {\n\t                              deviceID = substr ($0,1,statusOffset-2) ; gsub(/ *$/,\"\",deviceID)\n\t                              status = substr ($0,statusOffset,6)\n\t\t                            if (status ~ \"^[Nn]/[Aa]$\" ) { status = \"UNKNOWN\"; statusInformation = \"Unknown Status\"; }\n\t\t                            else if (status ~ /^[Oo][Kk]/) { status = \"OK\"; statusInformation = \"\"; }\n\t\t                            else if (status ~ /[^Nn]ot [Oo][Kk]/) { status = \"ALARM\"; statusInformation = \"Not OK\"; }\n\t\t                            else { status = \"UNKNOWN\"; statusInformation = \"Unknown Status\"; }\n\t\t                            Reading = substr ($0,readingOffset,4) ; gsub (/ /,\"\",Reading); gsub (\"^[Nn]/[Aa]$\",\"\",Reading)\n\t\t                            LW = substr ($0,LWOffset,4) ; gsub (/ /,\"\",LW);\n\t\t                            LC = substr ($0,LCOffset,4) ; gsub (/ /,\"\",LC);\n# FanID;Location;WarningThreshold;AlarmThreshold;Speed;Status;StatusInformation;\n\t\t                            print \"MSHW;\" deviceID \";\" \";\" LW \";\" LC \";\" Reading \";\" status \";\" statusInformation \";\"\n\t\t                           }"
  EmbeddedFile(7): "($1 ~ /Server-[0-9]+/ && $2 == \"Present\") {\n\tServerID = $1 ; gsub (/Server-/,\"\",ServerID);\n\tif ($4 ~ \"^[Nn]/[Aa]$\" ) { status[ServerID] = \"UNKNOWN\"; statusInformation[ServerID] = \"Unknown Status\"; }\n\telse if ($4 ~ /^[Oo][Kk]$/) { status[ServerID] = \"OK\"; statusInformation[ServerID] = \"\"; }\n\telse if ($4 ~ /^[Nn]ot$/ || $5 ~ /^[Oo][Kk]$/) { status[ServerID] = \"ALARM\"; statusInformation[ServerID] = \"Not OK\"; }\n\telse { status[ServerID] = \"UNKNOWN\"; statusInformation[ServerID] = \"Unknown Status\"; } ;\n  deviceType[ServerID] = $1 ; gsub (/-[0-9]+/,\"\",deviceType[ServerID]) ;\n  powerstate[ServerID] = tolower($3);\n  }\n\n($1 ~ /^[0-9]+$/ && $5 ~ /^W$/) && $6 ~ /^[0-9]+$/ {\n\tServerID = $1\n\tBladeModel[ServerID] = $7\n\tif ($NF != $7) {BladeModel[ServerID] = BladeModel[ServerID] \" \" $NF}\n  }\n($1 ~ /^[0-9]+$/ && $4 ~ /^W$/) && $5 ~ /^[0-9]+$/ {\n\tServerID = $1\n\tBladeModel[ServerID] = $6\n\tif ($NF != $6) {BladeModel[ServerID] = BladeModel[ServerID] \" \" $NF}\n  }\nEND {for (ServerID in status) {\n\t       print\"MSHW;\" ServerID \";\" status[ServerID] \";\" statusInformation[ServerID] \";\" powerstate[ServerID] \";\" BladeModel[ServerID] \";\"\n\t       }\n\t  }"
  EmbeddedFile(6): "BEGIN {chassislogStatus = \"\" ; chassislogStatusInformation = \"Event Messages\" ; EventTrigger = 0 }\n$0 ~ /^[ ]*No records available to display[ ]*$/ {chassislogStatus = \"OK\"}\n\n$1 ~ /Severity/ && $3 ~ /[Cc]ritical/ {chassislogStatus = \"ALARM\" ; EventTrigger = 1}\n$0 ~ /^Message[ ]*=[ ]*/ && EventTrigger == 1  {Message = $0 ; gsub(/^Message[ ]*=[ ]*/,\"\",Message) ;\n\t                                   if ( Message !~ /log *in/ && Message !~ /user/) {chassislogStatusInformation = chassislogStatusInformation \" - \" Message}\n\t                                   EventTrigger = 0\n\t                                  }\n\n# VRTX and M1000e\n(($1 ~ /Storage-[0-9]+/ || $1 ~ /MM-[0-9]+/ || $1 ~ /CMC-[0-9]+/ || $1 ~ /Switch-[0-9]+/ || $1 ~ /KVM/ || $1 ~ /DVD/ || $1 ~ /IO-Cable/ || $1 ~ /FPC-Cable/ || $1 ~ /Main-Board/ ) && $2 ~ /Present/ ) {\n\tif ($4 ~ \"^[Nn]/[Aa]$\" ) { status = \"UNKNOWN\"; statusInformation = \"Unknown Status\"; }\n\telse if ($4 ~ /^[Oo][Kk]$/) { status = \"OK\"; statusInformation = \"\"; }\n\telse if ($4 ~ /^[Nn]ot$/ || $5 ~ /^[Oo][Kk]$/) { status = \"ALARM\"; statusInformation = \"Not OK\"; }\n\telse { status = \"UNKNOWN\"; statusInformation = \"Unknown Status\"; } ;\n\tdeviceType = $1 ; gsub (/-[0-9]+/,\"\",deviceType) ;\n\tprint \"MSHW;\" $1 \";\" deviceType \";\" status \";\" statusInformation \";\"\n}\n\n#ChassisLog Section (VRTX / MX7000 only)\nEND {  # if no true events were found reset the status\n\tif ( chassislogStatusInformation ~ /^Event Messages$/ ) {chassislogStatus = \"OK\" ;  chassislogStatusInformation = \"No Critical Events Found (Login / User events ignored)\" }\n\t# print\n\tif (chassislogStatus != \"\") {print \"MSHW;ChassisLog;EventLog;\"chassislogStatus\";\" chassislogStatusInformation \";\"}\n\t}"
  EmbeddedFile(10): "$1 ~ /^Battery.Integrated./ {DeviceID = $1 ; gsub (/Battery.Integrated./,\"\",DeviceID) }\ntolower($1) ~ /^status$/ && DeviceID != \"\" {\n\t                      if ($3~ \"^[Nn]/[Aa]$\" ) { status = \"UNKNOWN\"; statusInformation = \"Unknown Status\"; }\n\t                      else if ($3 ~ /^[Oo][Kk]$/) { status = \"OK\"; statusInformation = \"\"; }\n\t                      else if ($3 ~ /^[Nn]ot$/ && $4 ~ /^[Oo][Kk]$/) { status = \"ALARM\"; statusInformation = \"Not OK\"; }\n\t                      else { status = \"UNKNOWN\"; statusInformation = \"Unknown Status\"; }\n# DeviceID;Status;StatusInformation;\n\t                      print \"MSHW;\" DeviceID \";\" status \";\" statusInformation \";\"\n\t                      DeviceID=\"\" ; status=\"\" ; statusInformation=\"\" ;\n\t                     }"
  EmbeddedFile(9): "$1 ~ /RAID.ChassisIntegrated/ {DeviceID = $1 ; gsub (/RAID.ChassisIntegrated./,\"\",DeviceID) }\ntolower($1) ~ /status/ {if ($3~ \"^[Nn]/[Aa]$\" ) { status = \"UNKNOWN\"; statusInformation = \"Unknown Status\"; }\n\t                      else if ($3 ~ /^[Oo][Kk]$/) { status = \"OK\"; statusInformation = \"\"; }\n\t                      else if ($3 ~ /^[Nn]ot$/ && $4 ~ /^[Oo][Kk]$/) { status = \"ALARM\"; statusInformation = \"Not OK\"; }\n\t                      else { status = \"UNKNOWN\"; statusInformation = \"Unknown Status\"; }\n\t                     }\n\ntolower($1) ~ /name/ {Model = $0 ;  gsub (/.*= /,\"\",Model) }\ntolower($1) ~ /firmwareversion/ && DeviceID != \"\" {\n\t                               Firmware = $3\n\t                               print \"MSHW;\" DeviceID \";\" status \";\" statusInformation \";\" Model \";\" Firmware \";\"\n\t                               DeviceID = \"\" ; status = \"\" ; statusInformation = \"\" ; Model = \"\" ; Firmware = \"\" ;\n\t                              }"
  EmbeddedFile(8): "$1 ~ /Disk.Bay./ {DeviceID = $1 ; DisplayID = DeviceID ; gsub (/:.*/,\"\",DisplayID) ;}\ntolower($1) ~ /^status$/ {if ($3~ \"^[Nn]/[Aa]$\" ) { status = \"UNKNOWN\"; statusInformation = \"Unknown Status\"; }\n\t                      else if ($3 ~ /^[Oo][Kk]$/) { status = \"OK\"; statusInformation = \"\"; }\n\t                      else if ($3 ~ /^[Nn]ot$/ && $4 ~ /^[Oo][Kk]$/) { status = \"ALARM\"; statusInformation = \"Not OK\"; }\n\t                      else { status = \"UNKNOWN\"; statusInformation = \"Unknown Status\"; }\n                         }\ntolower($1) ~ /^size$/ {Size = $3 ; if (toupper($4) ~ /TB/) {size = size * 1024} }\ntolower($1) ~ /failurepredicted/ { if ($3 ~ /NO/) {FailurePredicted = \"FALSE\"}\n                                   else {FailurePredicted = \"TRUE\" }\n                                 }\ntolower($1) ~ /productid/ {Model = $3}\ntolower($1) ~ /serialnumber/ && DeviceID != \"\" {\n\t                      SerialNumber = $3\n# DeviceID;DisplayID;Status;StatusInformation;size;failurepredicted;Model;SerialNumber;\n\t                      print \"MSHW;\" DeviceID \";\" DisplayID \";\" status \";\" statusInformation \";\" Size \";\" FailurePredicted \";\" Model \";\" SerialNumber \";\"\n\t                      DeviceID=\"\" ; DisplayID=\"\" ; status=\"\" ; statusInformation=\"\" ; Size=\"\"; FailurePredicted=\"\"; Model=\"\"; SerialNumber=\"\";\n\t                     }"
monitors:
  enclosure:
    discovery:
      mapping:
        # The discovery table = source(1)
        source: "$monitors.enclosure.discovery.sources.source(1)$"
        attributes:
          id: "DellBladeChassis"
          __display_id: "Dell Blade Chassis"
          model: "$column(1)"
          serial_number: "$column(2)"
          type: "Chassis"
          name: "sprintf(\"%s (%s - %s)\", \"Dell Blade Chassis\", $column(1), \"Chassis\")"
    collect:
      sources:
        source(2):
          # Source(2) = copy of Enclosure.Collect.Source(1)
          type: "copy"
          from: "$monitors.enclosure.collect.sources.source(1)$"
          computes:
            # Retrieve the overall status of the chassis and its power consumption with a smart AWK script
            # Status;StatusInformation;PowerConsumption
          - type: "awk"
            script: "EmbeddedFile(2)"
            keep: "MSHW;"
            separators: ";"
            selectColumns: "2,3,4"
      mapping:
        # ValueTable = Source(1)
        source: "$monitors.enclosure.collect.sources.source(2)$"
        metrics:
          hw.status{hw.type="enclosure"}: "$column(1)"
          hw.enclosure.power: "$column(3)"
          hw.enclosure.energy: "fakeCounter($column(3))"
        legacyTextParameters:
          StatusInformation: "$column(2)"
  blade:
    discovery:
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Discovery.Source(2)
          type: "static"
          value: "ENCLO_SOURCE_DISCO"
          computes:
            # Now, extract the blades thanks to a smart AWK script
            # BladeID;BladeModel;
          - type: "awk"
            script: "EmbeddedFile(7)"
            separators: ";"
            keep: "^MSHW;"
            selectColumns: "2,6"
        source(3):
          # Source 3 = Join of Blade info and host info
          # BladeID;BladeModel;BladeID;SlotName;HostName;
          type: "tableJoin"
          leftTable: "$monitors.blade.discovery.sources.source(1)$"
          rightTable: "$monitors.blade.discovery.sources.source(2)$"
          leftKeyColumn: 1
          rightKeyColumn: 1
          defaultRightLine: ";;;"
      source(2):
        computes:
          # Now, extract the blades hostnames
          # BladeID;SlotName;HostName;
        - type: "awk"
      mapping:
        # InstanceTable = Source(3)
        # BladeID;BladeModel;BladeID;SlotName;HostName;
        source: "$monitors.blade.discovery.sources.source(3)$"
        attributes:
          id: "$column(1)"
          __display_id: "$column(1)"
          blade_name: "$column(5)"
          model: "$column(2)"
          hw.parent.type: "enclosure"
          hw.parent.id: "DellBladeChassis"
          name: "sprintf(\"%s (%s - %s)\", $column(1), $column(5), $column(2))"
    collect:
      # Collect type is multi-instance
      type: "multiInstance"
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Collect.Source(1)
          type: "static"
          value: "ENCLO_SOURCE_COL"
          computes:
            # Now, extract the power supplies status thanks to a smart AWK script
            # PowerSupplyID;Status;StatusInformation;PowerState
          - type: "awk"
            script: "EmbeddedFile(7)"
            separators: ";"
            keep: "^MSHW;"
            selectColumns: "2,3,4,5"
      mapping:
        # ValueTable = Source(1)
        source: "$monitors.blade.collect.sources.source(1)$"
        deviceId: "$column(1)"
        metrics:
          hw.status{hw.type="blade"}: "$column(2)"
          hw.blade.power_state: "$column(4)"
        legacyTextParameters:
          StatusInformation: "$column(3)"
  temperature:
    discovery:
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Discovery.Source(2)
          type: "static"
          value: "ENCLO_SOURCE_DISCO"
          computes:
            # Now, extract the temperatures thanks to a smart AWK script
            # TemperatureID;Location;WarningThreshold;AlarmThreshold;Temperature;Status;
          - type: "awk"
            script: "EmbeddedFile(3)"
            separators: ";"
            keep: "^MSHW;"
            selectColumns: "2,3,4,5,6,7"
            # Replace "Unknown" status with blank to deactivate teh parameter
            # TemperatureID;Location;WarningThreshold;AlarmThreshold;Temperature;Status;
          - type: "replace"
            column: 6
            existingValue: "UNKNOWN"
            newValue: ""
      mapping:
        # InstanceTable = Source(1)
        source: "$monitors.temperature.discovery.sources.source(1)$"
        attributes:
          id: "$column(1)"
          __display_id: "$column(1)"
          temperature_type: "$column(2)"
          hw.parent.type: "enclosure"
          hw.parent.id: "DellBladeChassis"
          name: "sprintf(\"%s (%s)\", $column(1), $column(2))"
        metrics:
          hw.temperature.limit{limit_type="high.degraded"}: "$column(3)"
          hw.temperature.limit{limit_type="high.critical"}: "$column(4)"
    collect:
      # Collect type is multi-instance
      type: "multiInstance"
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Collect.Source(1)
          type: "static"
          value: "ENCLO_SOURCE_COL"
          computes:
            # Now, extract the temperatures thanks to a smart AWK script
            # TemperatureID;Temperature;Status;StatusInformation;
          - type: "awk"
            script: "EmbeddedFile(3)"
            separators: ";"
            keep: "^MSHW;"
            selectColumns: "2,6,7,8"
      mapping:
        # ValueTable = Source(1)
        source: "$monitors.temperature.collect.sources.source(1)$"
        deviceId: "$column(1)"
        metrics:
          hw.temperature: "$column(2)"
          hw.status{hw.type="temperature"}: "$column(3)"
        legacyTextParameters:
          StatusInformation: "$column(4)"
  fan:
    discovery:
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Discovery.Source(2)
          type: "static"
          value: "ENCLO_SOURCE_DISCO"
          computes:
            # Now, extract the fans thanks to a smart AWK script
            # FanID;Location;WarningThreshold;AlarmThreshold
          - type: "awk"
            script: "EmbeddedFile(4)"
            separators: ";"
            keep: "^MSHW;"
            selectColumns: "2,3,4,5"
      mapping:
        # InstanceTable = Source(1)
        source: "$monitors.fan.discovery.sources.source(1)$"
        attributes:
          id: "$column(1)"
          __display_id: "$column(1)"
          hw.parent.type: "enclosure"
          hw.parent.id: "DellBladeChassis"
          name: "$column(1)"
        metrics:
          hw.fan.speed.limit{limit_type="low.degraded"}: "$column(3)"
          hw.fan.speed.limit{limit_type="low.critical"}: "$column(4)"
    collect:
      # Collect type is multi-instance
      type: "multiInstance"
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Collect.Source(1)
          type: "static"
          value: "ENCLO_SOURCE_COL"
          computes:
            # Now, extract the fans thanks to a smart AWK script
            # FanID;Speed;Status;StatusInformation;
          - type: "awk"
            script: "EmbeddedFile(4)"
            separators: ";"
            keep: "^MSHW;"
            selectColumns: "2,6,7,8"
      mapping:
        # ValueTable = Source(1)
        source: "$monitors.fan.collect.sources.source(1)$"
        deviceId: "$column(1)"
        metrics:
          hw.fan.speed: "$column(2)"
          hw.status{hw.type="fan"}: "$column(3)"
        legacyTextParameters:
          StatusInformation: "$column(4)"
  power_supply:
    discovery:
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Discovery.Source(2)
          type: "static"
          value: "ENCLO_SOURCE_DISCO"
          computes:
            # Now, extract the power supplies thanks to a smart AWK script
            # PowerSupplyID;
          - type: "awk"
            script: "EmbeddedFile(5)"
            separators: ";"
            keep: "^MSHW;"
            selectColumns: "2"
      mapping:
        # InstanceTable = Source(1)
        source: "$monitors.power_supply.discovery.sources.source(1)$"
        attributes:
          id: "$column(1)"
          __display_id: "$column(1)"
          hw.parent.type: "enclosure"
          hw.parent.id: "DellBladeChassis"
          name: "sprintf(\"%s, $column(1))"
    collect:
      # Collect type is multi-instance
      type: "multiInstance"
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Collect.Source(1)
          type: "static"
          value: "ENCLO_SOURCE_COL"
          computes:
            # Now, extract the power supplies status thanks to a smart AWK script
            # PowerSupplyID;Status;StatusInformation
          - type: "awk"
            script: "EmbeddedFile(5)"
            separators: ";"
            keep: "^MSHW;"
            selectColumns: "2,3,4"
      mapping:
        # ValueTable = Source(1)
        source: "$monitors.power_supply.collect.sources.source(1)$"
        deviceId: "$column(1)"
        metrics:
          hw.status{hw.type="power_supply"}: "$column(2)"
        legacyTextParameters:
          StatusInformation: "$column(3)"
  other_device:
    discovery:
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Discovery.Source(2)
          type: "static"
          value: "ENCLO_SOURCE_DISCO"
          computes:
            # Now, extract the switches, DRAC and KVM modules thanks to a smart AWK script
            # OtherDeviceID;DeviceType;
          - type: "awk"
            script: "EmbeddedFile(6)"
            separators: ";"
            keep: "^MSHW;"
            selectColumns: "2,3"
      mapping:
        # InstanceTable = Source(1)
        source: "$monitors.other_device.discovery.sources.source(1)$"
        attributes:
          id: "$column(1)"
          __display_id: "$column(1)"
          device_type: "$column(2)"
          hw.parent.type: "enclosure"
          hw.parent.id: "DellBladeChassis"
          name: "sprintf(\"%s: %s\", $column(2), $column(1))"
    collect:
      # Collect type is multi-instance
      type: "multiInstance"
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Collect.Source(1)
          type: "static"
          value: "ENCLO_SOURCE_COL"
          computes:
            # Now, extract the switches, DRAC and KVM status thanks to a smart AWK script
            # OtherDeviceID;Status;StatusInformation
          - type: "awk"
            script: "EmbeddedFile(6)"
            separators: ";"
            keep: "^MSHW;"
            selectColumns: "2,4,5"
      mapping:
        # ValueTable = Source(1)
        source: "$monitors.other_device.collect.sources.source(1)$"
        deviceId: "$column(1)"
        metrics:
          hw.status{hw.type="other_device"}: "$column(2)"
        legacyTextParameters:
          StatusInformation: "$column(3)"
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Discovery.Source(2)
          type: "static"
          value: "ENCLO_SOURCE_DISCO"
          computes:
            # Now, extract the power supplies thanks to a smart AWK script
            # MSHW;DeviceID;DisplayID;Status;StatusInformation;size;failurepredicted;Model;SerialNumber;
            # DeviceID;DisplayID;size;Model;SerialNumber;
          - type: "awk"
            script: "EmbeddedFile(8)"
            separators: ";"
            keep: "^MSHW;"
            selectColumns: "2,3,6,8,9"
            # Convert the size into bytes
            # DeviceID;DisplayID;size;Model;SerialNumber;
          - type: "multiply"
            column: 3
            value: "1073741824"
      mapping:
        # InstanceTable = Source(1)
        # DeviceID;DisplayID;size;Model;SerialNumber;
        source: "$monitors.physical_disk.discovery.sources.source(1)$"
        attributes:
          id: "$column(1)"
          __display_id: "$column(2)"
          vendor: "$column(4)"
          serial_number: "$column(5)"
          hw.parent.type: "enclosure"
          hw.parent.id: "DellBladeChassis"
          name: "sprintf(\"%s (%s)\", $column(2), $column(3))"
        metrics:
          hw.physical_disk.size: "$column(3)"
    collect:
      # Collect type is multi-instance
      type: "multiInstance"
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Collect.Source(1)
          type: "static"
          value: "ENCLO_SOURCE_COL"
          computes:
            # Now, extract the power supplies status thanks to a smart AWK script
            # MSHW;DeviceID;DisplayID;Status;StatusInformation;size;failurepredicted;Model;SerialNumber;
            # DeviceID;Status;StatusInformation;PredictedFailure
          - type: "awk"
            script: "EmbeddedFile(8)"
            separators: ";"
            keep: "^MSHW;"
            selectColumns: "2,4,5,7"
      mapping:
        # ValueTable = Source(1)
        source: "$monitors.physical_disk.collect.sources.source(1)$"
        deviceId: "$column(1)"
        metrics:
          hw.status{hw.type="physical_disk"}: "$column(2)"
          hw.status{hw.type="physical_disk", state="predicted_failure"}: "boolean($column(4))"
        legacyTextParameters:
          StatusInformation: "$column(3)"
  disk_controller:
    discovery:
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Discovery.Source(2)
          type: "static"
          value: "ENCLO_SOURCE_DISCO"
          computes:
            # Now, extract the power supplies thanks to a smart AWK script
            # MSHW;DeviceID;status;statusInformation;Model;Firmware;
            # DeviceID;Model;Firmware;
          - type: "awk"
            script: "EmbeddedFile(9)"
            separators: ";"
            keep: "^MSHW;"
            selectColumns: "2,5,6"
      mapping:
        # InstanceTable = Source(1)
        source: "$monitors.disk_controller.discovery.sources.source(1)$"
        attributes:
          id: "$column(1)"
          __display_id: "$column(1)"
          model: "$column(2)"
          hw.parent.type: "enclosure"
          hw.parent.id: "DellBladeChassis"
          name: "sprintf(\"%s %s (%s)\"), \"Disk Controller\", $column(1), $column(2))"
    collect:
      # Collect type is multi-instance
      type: "multiInstance"
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Collect.Source(1)
          type: "static"
          value: "ENCLO_SOURCE_COL"
          computes:
            # Now, extract the power supplies status thanks to a smart AWK script
            # MSHW;DeviceID;status;statusInformation;Model;Firmware;
            # DeviceID;Status;StatusInformation;
          - type: "awk"
            script: "EmbeddedFile(9)"
            separators: ";"
            keep: "^MSHW;"
            selectColumns: "2,3,4"
      mapping:
        # ValueTable = Source(1)
        source: "$monitors.disk_controller.collect.sources.source(1)$"
        deviceId: "$column(1)"
        metrics:
          hw.status{hw.type="disk_controller"}: "$column(2)"
        legacyTextParameters:
          StatusInformation: "$column(3)"
  battery:
    discovery:
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Discovery.Source(2)
          type: "static"
          value: "ENCLO_SOURCE_DISCO"
          computes:
            # Now, extract the power supplies thanks to a smart AWK script
            # DeviceID;Status;StatusInformation;
            # DeviceID;
          - type: "awk"
            script: "EmbeddedFile(10)"
            separators: ";"
            keep: "^MSHW;"
            selectColumns: "2"
      mapping:
        # InstanceTable = Source(1)
        source: "$monitors.battery.discovery.sources.source(1)$"
        attributes:
          id: "$column(1)"
          __display_id: "$column(1)"
          hw.parent.type: "enclosure"
          hw.parent.id: "DellBladeChassis"
          name: "$column(1)"
    collect:
      # Collect type is multi-instance
      type: "multiInstance"
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Collect.Source(1)
          type: "static"
          value: "ENCLO_SOURCE_COL"
          computes:
            # Now, extract the power supplies status thanks to a smart AWK script
            # DeviceID;Status;StatusInformation;
          - type: "awk"
            script: "EmbeddedFile(10)"
            separators: ";"
            keep: "^MSHW;"
            selectColumns: "2,3,4"
      mapping:
        # ValueTable = Source(1)
        source: "$monitors.battery.collect.sources.source(1)$"
        deviceId: "$column(1)"
        metrics:
          hw.status{hw.type="battery"}: "$column(2)"
        legacyTextParameters:
          StatusInformation: "$column(3)"
  logical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Discovery.Source(2)
          type: "static"
          value: "ENCLO_SOURCE_DISCO"
          computes:
            # Now, extract the power supplies thanks to a smart AWK script
            # MSHW;DeviceID;Status;StatusInformation;Name;RaidLevel;Size;
            # DeviceID;Name;RaidLevel;Size;
          - type: "awk"
            script: "EmbeddedFile(11)"
            separators: ";"
            keep: "^MSHW;"
            selectColumns: "2,5,6,7"
            # Convert the size into bytes
            # DeviceID;Name;RaidLevel;Size;
          - type: "multiply"
            column: 4
            value: "1073741824"
      mapping:
        # InstanceTable = Source(1)
        source: "$monitors.logical_disk.discovery.sources.source(1)$"
        attributes:
          id: "$column(1)"
          __display_id: "$column(2)"
          hw.logical_disk.limit: "$column(4)"
          raid_level: "$column(3)"
          hw.parent.type: "enclosure"
          hw.parent.id: "DellBladeChassis"
          name: "sprintf(\"%s (%s - %s)\", $column(2), $column(3), $column(4))"
    collect:
      # Collect type is multi-instance
      type: "multiInstance"
      sources:
        source(1):
          # Source(1) = copy of Enclosure.Collect.Source(1)
          type: "static"
          value: "ENCLO_SOURCE_COL"
          computes:
            # Now, extract the power supplies status thanks to a smart AWK script
            # DeviceID;Status;StatusInformation;
          - type: "awk"
            script: "EmbeddedFile(11)"
            separators: ";"
            keep: "^MSHW;"
            selectColumns: "2,3,4"
      mapping:
        # ValueTable = Source(1)
        source: "$monitors.logical_disk.collect.sources.source(1)$"
        deviceId: "$column(1)"
        metrics:
          hw.status{hw.type="logical_disk"}: "$column(2)"
        legacyTextParameters:
          StatusInformation: "$column(3)"
