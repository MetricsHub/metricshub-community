---
connector:
  displayName: HP-UX (STM)
  platforms: "HP 9000,HP Integrity,HP SuperDome"
  reliesOn: HP-UX Support Tools Manager (STM)
  information: Provides physical disks and memory monitoring on HP-UX systems through the Support Tools Manager utilities (stm).
  version: 1.1
  detection:
    connectionTypes:
    - remote
    - local
    appliesTo:
    - HP
    criteria:
    # OS should be HP (for HP-UX, whatever version)
    - type: deviceType
      keep:
      - HP
    # The stm executable needs to be present
    - type: osCommand
      commandLine: /bin/ls /usr/bin/stm
      expectedResult: ^/usr/bin/stm$
    # stm must return something
    - type: osCommand
      commandLine: /bin/echo "map"|/usr/bin/stm -c
      expectedResult: Active Tool
monitors:
  disk_controller:
    discovery:
      sources:
        source(1):
          # Source(1) = output of echo ""selclass type interface;cds""|stm -c
          type: osCommand
          commandLine: /bin/echo "selclass type interface;cds"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process output of cstom through awk EmbeddedFile(1)
            # This contains the list of all interfaces in the system, which happen
            # to include disk controllers
            # DeviceID;Model
          - type: awk
            script: $file("embeddedFile-1")$
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3"
        source(2):
          # Source(2) = output of echo ""selclass type Disk;wait;information;wait;infolog""|stm -c
          type: osCommand
          commandLine: /bin/echo "selclass type Disk;wait;information;wait;infolog"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process the output of cstm throughawk EmbeddedFile(2)
            # DeviceID;ControllerID;Vendor Model;sizeMB;SerialNumber
          - type: awk
            script: $file("embeddedFile-2")$
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5,6"
        source(3):
          # Source(3) = table joint of Source(1) and Source(2)
          # This is to keep only interfaces that are disk controllers in fact,
          # and among those disk controllers, the ones that actually have disks
          # ControllerDeviceID;Model;DiskDeviceID;ControllerID;Vendor Model;sizeMB;SerialNumber
          type: tableJoin
          leftTable: $monitors.disk_controller.discovery.sources.source(1)$
          rightTable: $monitors.disk_controller.discovery.sources.source(2)$
          leftKeyColumn: 1
          rightKeyColumn: 2
      mapping:
        # InstanceTable = Source(3)
        source: $monitors.disk_controller.discovery.sources.source(3)$
        attributes:
          id: $column(1)
          controller_number: $column(1)
          model: $column(2)
          hw.parent.type: enclosure
          name: "sprintf(\"Disk Controller: %s (%s)\", $column(1), $column(2))"
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = table joint of DiskController.Discovery.Source(2) and DiskController.Discovery.Source(3)
          # in order to keep only disks that are attached to an existing disk controller
          # DeviceID;ControllerID;Vendor Model;sizeMB;SerialNumber;ControllerDeviceID;Model;DiskDeviceID;ControllerID;Vendor Model;sizeMB;SerialNumber
          type: tableJoin
          leftTable: $monitors.disk_controller.discovery.sources.source(2)$
          rightTable: $monitors.disk_controller.discovery.sources.source(3)$
          leftKeyColumn: 2
          rightKeyColumn: 1
          computes:
            # Convert SizeMB into bytes
            # DeviceID;ControllerID;Vendor Model;size;SerialNumber
          - type: multiply
            column: 4
            value: 1048576
      mapping:
        # InstanceTable = Source(1)
        source: $monitors.physical_disk.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          vendor: $column(3)
          serial_number: $column(5)
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $column(2))"
          name: "sprintf(\"%s (%s - %by10hf.s)\", $column(1), $column(3), $column(4))"
        metrics:
          hw.physical_disk.size: $column(4)
    collect:
      # Collect type is "multi-instance
      type: monoInstance
      sources:
        source(1):
          # Source(1) = output of cstm echo ""selclass type Disk;wait;information;wait;infolog""|stm -c
          type: osCommand
          commandLine: |-
            /bin/echo "select path $physical_disk.id$;wait;information;wait;infolog"|/usr/bin/stm -c
            /bin/echo "select path $physical_disk.id$;wait;veroptions execctrl iterations 1 behavior errorcount 10 testcoverage mincoverage gentactlog no reporterrors reportwarnings queries querynondes;verify;wait;currdevstatus"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process output of cstm through awk EmbeddedFile(2)
            # ErrorCount;Status;
          - type: awk
            script: $file("embeddedFile-3")$
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3"
            # Duplicate the status column
            # ErrorCount;Status;Status
          - type: duplicateColumn
            column: 2
            # Translate the first status into a PATROL status
            # ErrorCount;PATROLStatus;Status
          - type: translate
            column: 2
            translationTable: PhysicalDiskStatusTranslationTable
            # Translate the second Status into a more readable string
            # ErrorCount;PATROLStatus;StatusInformation
          - type: translate
            column: 3
            translationTable: PhysicalDiskStatusInformationTranslationTable
      mapping:
        # ValueTable = Source(1)
        source: $monitors.physical_disk.collect.sources.source(1)$
        metrics:
          hw.status{hw.type="physical_disk"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
  memory:
    discovery:
      sources:
        source(1):
          # Source(1) = output of echo ""selclass type memory;wait;information;wait;infolog""|stm -c
          type: osCommand
          commandLine: /bin/echo "selclass type memory;wait;information;wait;infolog"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process cstm output through awk EmbeddedFile(4)
            # Memory modules' IDs and sizes and the "Page Deallocation Table (PDT)"
            # DeviceID;Size;Type
          - type: awk
            script: $file("embeddedFile-4")$
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4"
      mapping:
        # InstanceTable = Source(&)
        source: $monitors.memory.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          type: $column(3)
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s - %s MB)\", $column(1), $column(3), $column(2))"
        metrics:
          hw.memory.limit: mebiByte2Byte($column(2))
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = output of echo ""selclass type memory;wait;information;wait;infolog""|stm -c
          type: osCommand
          commandLine: /bin/echo "selclass type memory;wait;information;wait;infolog"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process output of cstm through awk EmbeddedFile(5)
            # Memory modules error count and status (as well as for the "Page Deallocation Table (PDT)")
            # DeviceID;Status;StatusInformation;ErrorCount
          - type: awk
            script: $file("embeddedFile-5")$
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5"
        source(2):
          # Source(2) = copy of discovery.source(1)
          # Yeah, that's because our source(1) does contain lines only about memory modules
          # that encountered some errors. So we need to add the entire list of modules with
          # an error count of zero. The collection process will keep only the first line
          # DeviceID;Size;Type
          type: copy
          from: $monitors.memory.discovery.sources.source(1)$
          computes:
            # Remove size and type (keep only device ID)
            # DeviceID
          - type: keepColumns
            columnNumbers: 1
            # Add fake OK and ErrorCount=0 columns
            # DeviceID;OK;;0
          - type: rightConcat
            column: 1
            value: ;OK;;0
        source(3):
          # Source(3) = union of Source(1) and Source(2)
          # DeviceID;Status;StatusInformation;ErrorCount
          type: tableUnion
          tables:
          - $monitors.memory.collect.sources.source(1)$
          - $monitors.memory.collect.sources.source(2)$
      mapping:
        # Okay, we have everything now (hope so)
        # ValueTable = Source(3)
        source: $monitors.memory.collect.sources.source(3)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="memory"}: $column(2)
          hw.errors{hw.type="memory"}: $column(4)
        legacyTextParameters:
          StatusInformation: $column(3)
  fan:
    discovery:
      sources:
        source(1):
          # Source(1) = output of /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
          type: osCommand
          commandLine: /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process cstm output through awk EmbeddedFile(6)
            # Type;DeviceID
          - type: awk
            script: $file("embeddedFile-6")$
            keep: ^MSHW;FAN
            separators: ;
            selectColumns: "2,3"
      mapping:
        # InstanceTable = Source(1)
        source: $monitors.fan.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          sensor_location: $column(1)
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s)\", $column(2), $column(1))"
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = output of /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
          type: osCommand
          commandLine: /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process cstm output through awk EmbeddedFile(6)
            # DeviceID;Status;StatusInformation
          - type: awk
            script: $file("embeddedFile-6")$
            keep: ^MSHW;FAN
            separators: ;
            selectColumns: "3,4,5"
      mapping:
        # ValueTable = Source(1)
        source: $monitors.fan.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="fan"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
  power_supply:
    discovery:
      sources:
        source(1):
          # Source(1) = output of /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
          type: osCommand
          commandLine: /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process cstm output through awk EmbeddedFile(6)
            # Type;DeviceID
          - type: awk
            script: $file("embeddedFile-6")$
            keep: ^MSHW;PSU
            separators: ;
            selectColumns: "2,3"
      mapping:
        # InstanceTable = Source(1)
        source: $monitors.power_supply.discovery.sources.source(1)$
        attributes:
          id: $column(2)
          power_supply_type: $column(1)
          hw.parent.type: enclosure
          name: "sprintf(\"%s (%s)\", $column(2), $column(1))"
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = output of /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
          type: osCommand
          commandLine: /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process cstm output through awk EmbeddedFile(6)
            # DeviceID;Status;StatusInformation
          - type: awk
            script: $file("embeddedFile-6")$
            keep: ^MSHW;PSU
            separators: ;
            selectColumns: "3,4,5"
      mapping:
        # ValueTable = Source(1)
        source: $monitors.power_supply.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="power_supply"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
translations:
  PhysicalDiskStatusInformationTranslationTable:
    HUNG: Testing Hung
    SUSPENDED: Testing Suspended
    QUERY PENDING: User Input Expected
    INCOMPLETE: Testing Incomplete
    ABORTED: Testing Aborted
    WARNING: Testing Warning
    FAILURE: Testing Failed
    Default: Unknown Status
    Success: ""
    Testing: Testing in Progress
  PhysicalDiskStatusTranslationTable:
    HUNG: degraded
    INCOMPLETE: failed
    WARNING: degraded
    FAILURE: failed
    Default: UNKNOWN
    Success: ok
