---
connector:
  displayName: HP-UX (STM)
  platforms: "HP 9000,HP Integrity,HP SuperDome"
  reliesOn: HP-UX Support Tools Manager (STM)
  information: Provides physical disks and memory monitoring on HP-UX systems through the Support Tools Manager utilities (stm).
  version: 1.1
  detection:
    connectionTypes:
    - remote
    - local
    appliesTo:
    - HP
    criteria:
    # OS should be HP (for HP-UX, whatever version)
    - type: deviceType
      keep:
      - HP
    # The stm executable needs to be present
    - type: osCommand
      commandLine: /bin/ls /usr/bin/stm
      expectedResult: ^/usr/bin/stm$
    # stm must return something
    - type: osCommand
      commandLine: /bin/echo "map"|/usr/bin/stm -c
      expectedResult: Active Tool
monitors:
  disk_controller:
    discovery:
      sources:
        source(1):
          # Source(1) = output of echo ""selclass type interface;cds""|stm -c
          type: osCommand
          commandLine: /bin/echo "selclass type interface;cds"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process output of cstom through awk EmbeddedFile(1)
            # This contains the list of all interfaces in the system, which happen
            # to include disk controllers
            # DeviceID;Model
          - type: awk
            script: "${file::embeddedFile-1}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3"
        source(2):
          # Source(2) = output of echo ""selclass type Disk;wait;information;wait;infolog""|stm -c
          type: osCommand
          commandLine: /bin/echo "selclass type Disk;wait;information;wait;infolog"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process the output of cstm throughawk EmbeddedFile(2)
            # DeviceID;ControllerID;Vendor Model;sizeMB;SerialNumber
          - type: awk
            script: "${file::embeddedFile-2}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5,6"
        source(3):
          # Source(3) = table joint of Source(1) and Source(2)
          # This is to keep only interfaces that are disk controllers in fact,
          # and among those disk controllers, the ones that actually have disks
          # ControllerDeviceID;Model;DiskDeviceID;ControllerID;Vendor Model;sizeMB;SerialNumber
          type: tableJoin
          leftTable: "${source::monitors.disk_controller.discovery.sources.source(1)}"
          rightTable: "${source::monitors.disk_controller.discovery.sources.source(2)}"
          leftKeyColumn: 1
          rightKeyColumn: 2
      mapping:
        # InstanceTable = Source(3)
        source: "${source::monitors.disk_controller.discovery.sources.source(3)}"
        attributes:
          id: $1
          controller_number: $1
          model: $2
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"Disk Controller: %s (%s)\", $1, $2)}"
  physical_disk:
    discovery:
      sources:
        source(1):
          # Source(1) = table joint of DiskController.Discovery.Source(2) and DiskController.Discovery.Source(3)
          # in order to keep only disks that are attached to an existing disk controller
          # DeviceID;ControllerID;Vendor Model;sizeMB;SerialNumber;ControllerDeviceID;Model;DiskDeviceID;ControllerID;Vendor Model;sizeMB;SerialNumber
          type: tableJoin
          leftTable: "${source::monitors.disk_controller.discovery.sources.source(2)}"
          rightTable: "${source::monitors.disk_controller.discovery.sources.source(3)}"
          leftKeyColumn: 2
          rightKeyColumn: 1
          computes:
            # Convert SizeMB into bytes
            # DeviceID;ControllerID;Vendor Model;size;SerialNumber
          - type: multiply
            column: 4
            value: 1048576
      mapping:
        # InstanceTable = Source(1)
        source: "${source::monitors.physical_disk.discovery.sources.source(1)}"
        attributes:
          id: $1
          vendor: $3
          serial_number: $5
          hw.parent.type: disk_controller
          hw.parent.id: "lookup(\"disk_controller\", \"id\", \"controller_number\", $2)"
          name: "${awk::sprintf(\"%s (%s - %s)\", $1, $3, bytes2HumanFormatBase10($4))}"
        metrics:
          hw.physical_disk.size: $4
    collect:
      # Collect type is "multi-instance
      type: monoInstance
      sources:
        source(1):
          # Source(1) = output of cstm echo ""selclass type Disk;wait;information;wait;infolog""|stm -c
          type: osCommand
          commandLine: |-
            /bin/echo "select path ${physical_disk::id};wait;information;wait;infolog"|/usr/bin/stm -c
            /bin/echo "select path ${physical_disk::id};wait;veroptions execctrl iterations 1 behavior errorcount 10 testcoverage mincoverage gentactlog no reporterrors reportwarnings queries querynondes;verify;wait;currdevstatus"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process output of cstm through awk EmbeddedFile(2)
            # ErrorCount;Status;
          - type: awk
            script: "${file::embeddedFile-3}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3"
            # Duplicate the status column
            # ErrorCount;Status;Status
          - type: duplicateColumn
            column: 2
            # Translate the first status into a PATROL status
            # ErrorCount;PATROLStatus;Status
          - type: translate
            column: 2
            translationTable: "${translation::PhysicalDiskStatusTranslationTable}"
            # Translate the second Status into a more readable string
            # ErrorCount;PATROLStatus;StatusInformation
          - type: translate
            column: 3
            translationTable: "${translation::PhysicalDiskStatusInformationTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        source: "${source::monitors.physical_disk.collect.sources.source(1)}"
        metrics:
          hw.status{hw.type="physical_disk"}: $2
          hw.errors{hw.type="physical_disk"}: $1
        legacyTextParameters:
          StatusInformation: $3
  memory:
    discovery:
      sources:
        source(1):
          # Source(1) = output of echo ""selclass type memory;wait;information;wait;infolog""|stm -c
          type: osCommand
          commandLine: /bin/echo "selclass type memory;wait;information;wait;infolog"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process cstm output through awk EmbeddedFile(4)
            # Memory modules' IDs and sizes and the "Page Deallocation Table (PDT)"
            # DeviceID;Size;Type
          - type: awk
            script: "${file::embeddedFile-4}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4"
      mapping:
        # InstanceTable = Source(&)
        source: "${source::monitors.memory.discovery.sources.source(1)}"
        attributes:
          id: $1
          type: $3
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s - %s MB)\", $1, $3, $2)}"
        metrics:
          hw.memory.limit: mebiByte2Byte($2)
    collect:
      # Collect type is multi-instance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = output of echo ""selclass type memory;wait;information;wait;infolog""|stm -c
          type: osCommand
          commandLine: /bin/echo "selclass type memory;wait;information;wait;infolog"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process output of cstm through awk EmbeddedFile(5)
            # Memory modules error count and status (as well as for the "Page Deallocation Table (PDT)")
            # DeviceID;Status;StatusInformation;ErrorCount
          - type: awk
            script: "${file::embeddedFile-5}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5"
        source(2):
          # Source(2) = copy of discovery.source(1)
          # Yeah, that's because our source(1) does contain lines only about memory modules
          # that encountered some errors. So we need to add the entire list of modules with
          # an error count of zero. The collection process will keep only the first line
          # DeviceID;Size;Type
          type: copy
          from: "${source::monitors.memory.discovery.sources.source(1)}"
          computes:
            # Remove size and type (keep only device ID)
            # DeviceID
          - type: keepColumns
            columnNumbers: 1
            # Add fake OK and ErrorCount=0 columns
            # DeviceID;OK;;0
          - type: rightConcat
            column: 1
            value: ;OK;;0
        source(3):
          # Source(3) = union of Source(1) and Source(2)
          # DeviceID;Status;StatusInformation;ErrorCount
          type: tableUnion
          tables:
          - "${source::monitors.memory.collect.sources.source(1)}"
          - "${source::monitors.memory.collect.sources.source(2)}"
      mapping:
        # Okay, we have everything now (hope so)
        # ValueTable = Source(3)
        source: "${source::monitors.memory.collect.sources.source(3)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="memory"}: $2
          hw.errors{hw.type="memory"}: $4
        legacyTextParameters:
          StatusInformation: $3
  fan:
    discovery:
      sources:
        source(1):
          # Source(1) = output of /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
          type: osCommand
          commandLine: /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process cstm output through awk EmbeddedFile(6)
            # Type;DeviceID
          - type: awk
            script: "${file::embeddedFile-6}"
            keep: ^MSHW;FAN
            separators: ;
            selectColumns: "2,3"
      mapping:
        # InstanceTable = Source(1)
        source: "${source::monitors.fan.discovery.sources.source(1)}"
        attributes:
          id: $2
          sensor_location: $1
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s)\", $2, $1)}"
    collect:
      # Collect type is multi-instance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = output of /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
          type: osCommand
          commandLine: /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process cstm output through awk EmbeddedFile(6)
            # DeviceID;Status;StatusInformation
          - type: awk
            script: "${file::embeddedFile-6}"
            keep: ^MSHW;FAN
            separators: ;
            selectColumns: "3,4,5"
      mapping:
        # ValueTable = Source(1)
        source: "${source::monitors.fan.collect.sources.source(1)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="fan"}: $2
        legacyTextParameters:
          StatusInformation: $3
  power_supply:
    discovery:
      sources:
        source(1):
          # Source(1) = output of /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
          type: osCommand
          commandLine: /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process cstm output through awk EmbeddedFile(6)
            # Type;DeviceID
          - type: awk
            script: "${file::embeddedFile-6}"
            keep: ^MSHW;PSU
            separators: ;
            selectColumns: "2,3"
      mapping:
        # InstanceTable = Source(1)
        source: "${source::monitors.power_supply.discovery.sources.source(1)}"
        attributes:
          id: $2
          power_supply_type: $1
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s)\", $2, $1)}"
    collect:
      # Collect type is multi-instance
      type: multiInstance
      keys:
      - id
      sources:
        source(1):
          # Source(1) = output of /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
          type: osCommand
          commandLine: /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
          timeout: 60
          forceSerialization: true
          computes:
            # Process cstm output through awk EmbeddedFile(6)
            # DeviceID;Status;StatusInformation
          - type: awk
            script: "${file::embeddedFile-6}"
            keep: ^MSHW;PSU
            separators: ;
            selectColumns: "3,4,5"
      mapping:
        # ValueTable = Source(1)
        source: "${source::monitors.power_supply.collect.sources.source(1)}"
        attributes:
          id: $1
        metrics:
          hw.status{hw.type="power_supply"}: $2
        legacyTextParameters:
          StatusInformation: $3
translations:
  PhysicalDiskStatusInformationTranslationTable:
    HUNG: Testing Hung
    SUSPENDED: Testing Suspended
    QUERY PENDING: User Input Expected
    INCOMPLETE: Testing Incomplete
    ABORTED: Testing Aborted
    WARNING: Testing Warning
    FAILURE: Testing Failed
    Default: Unknown Status
    Success: ""
    Testing: Testing in Progress
  PhysicalDiskStatusTranslationTable:
    HUNG: degraded
    INCOMPLETE: failed
    WARNING: degraded
    FAILURE: failed
    Default: UNKNOWN
    Success: ok
