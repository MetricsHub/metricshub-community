---
connector:
  displayName: IBM XIV (xcli)
  platforms: IBM XiV Storage System
  reliesOn: xcli command line utility
  version: 1.0
  information: This connector provides hardware monitoring for IBM XIV Storage Systems through the xcli command line utility.
  detection:
    appliesTo:
    - Storage
    connectionTypes:
    - remote
    supersedes:
    - SMISDiskArray
    criteria:
    # Only for type storage
    - type: deviceType
      keep:
      - Storage
    # Checks that xcli is on the local machine - in Portal smcli is run from the RSM
    - type: osCommand
      commandLine: xcli -v
      forceSerialization: true
      executeLocally: true
      expectedResult: 'xcli version:'
      errorMessage: xcli not installed or not in path.
    # Checks that xcli returns a system name
    - type: osCommand
      commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all cod_list"
      forceSerialization: true
      executeLocally: true
      expectedResult: system_name
      errorMessage: xcli could not connect or did not find a system.
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Source(1) = list of components
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -t \"component_id\" component_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
          computes:
            # Remove spaces
            # DeviceID
          - type: replace
            column: 1
            existingValue: ' '
            newValue: ""
            # Exclude the header
            # DeviceID
          - type: excludeMatchingLines
            column: 1
            valueList: ComponentID
        source(2):
          # Source(2) = ATS XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all ats_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(3):
          # Source(3) = Module XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all module_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(4):
          # Source(4) = Disk XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all disk_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(5):
          # Source(5) = MM XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all mm_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(6):
          # Source(6) = UPS XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all ups_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(7):
          # Source(7) = Fan XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all fan_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(8):
          # Source(8) = PSU XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all psu_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(9):
          # Source(9) = DIMM XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all dimm_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(10):
          # Source(10) = CF XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all cf_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(11):
          # Join all the XML into one table
          # XML
          type: tableUnion
          tables:
          - $monitors.enclosure.discovery.sources.source(2)$
          - $monitors.enclosure.discovery.sources.source(3)$
          - $monitors.enclosure.discovery.sources.source(4)$
          - $monitors.enclosure.discovery.sources.source(5)$
          - $monitors.enclosure.discovery.sources.source(6)$
        source(12):
          type: tableUnion
          tables:
          - $monitors.enclosure.discovery.sources.source(11)$
          - $monitors.enclosure.discovery.sources.source(7)$
          - $monitors.enclosure.discovery.sources.source(8)$
          - $monitors.enclosure.discovery.sources.source(9)$
          - $monitors.enclosure.discovery.sources.source(10)$
        source(13):
          # COD XML
          # Source(13) = COD XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all cod_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(14):
          # One final table, the System Information
          # Source(13) = Switch XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all switch_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(15):
          # Join union again
          # XML
          type: tableUnion
          tables:
          - $monitors.enclosure.discovery.sources.source(12)$
          - $monitors.enclosure.discovery.sources.source(13)$
          - $monitors.enclosure.discovery.sources.source(14)$
          computes:
            # Run all the XML through an awk script
            # MSHW...
          - type: awk
            script: $file("embeddedFile-1")$
            keep: ^MSHW
            separators: ;
        source(16):
          # Join the processed XML to the main component discovery
          # DeviceID;MSHW;Type;EnclosureID;DeviceID;....
          type: tableJoin
          leftTable: $monitors.enclosure.discovery.sources.source(1)$
          rightTable: $monitors.enclosure.discovery.sources.source(15)$
          leftKeyColumn: 1
          rightKeyColumn: 4
          defaultRightLine: Default;OTHER;UNKNOWN;UNKNOWN;UNKNOWN;;;;
        source(17):
          # Make a copy to use for enclosure discovery
          # DeviceID;MSHW;Type;EnclosureID;DisplayID;....
          type: copy
          from: $monitors.enclosure.discovery.sources.source(16)$
          computes:
            # Keep Only Enclosures
            # DeviceID;MSHW;ENCLOSURE;EnclosureID;DisplayID;serial;part_number;bios_version;Module Part Number;System Model;System Name/Serial Number;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: ^ENCLOSURE$
          - type: leftConcat
            column: 8
            value: "FirmwareVersion: "
      mapping:
        #  1        2         3       4        #    5     6        #   7        #  8        #    9        #       10        # 11
        # DeviceID;MSHW;ENCLOSURE;EnclosureID;DisplayID;serial;part_number;bios_version;Module Part Number;System Model;System Name/Serial Number;
        source: $monitors.enclosure.discovery.sources.source(17)$
        attributes:
          id: $column(4)
          __display_id: $column(5)
          vendor: IBM
          model: $column(7)
          serial_number: $column(6)
          bios_version: $column(8)
          type: Storage
          info: "join(\" \", $column(9), $column(10), $column(11))"
          name: "sprintf(\"Storage: %s (%s %s)\", $column(5), \"IBM\", $column(7))"
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = list of components
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all component_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
          computes:
            # Parse the XML through an awk script
            # DeviceID;Status;StatusInformation;
          - type: awk
            script: $file("embeddedFile-2")$
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4"
            # Now translate into OK/Warning/Alarm
            # DeviceID;Status;StatusInformation;
          - type: translate
            column: 2
            translationTable: statusTranslationTable
        source(2):
          # Copy the table
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep Only Switches
            # Name;PATROLStatus;StatusDescriptions;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: Module
            # Extract the enclosure number from the device ID
            # Name;PATROLStatus;StatusDescriptions;
          - type: extract
            column: 1
            subColumn: 3
            subSeparators: ':'
        source(3):
          # Copy the Table Again
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
          computes:
            # Keep Only Switches
            # Name;PATROLStatus;StatusDescriptions;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: \(:Switch:\)\|\(:UPS:\)
        source(4):
          # Union 2 and 3
          type: tableUnion
          tables:
          - $monitors.enclosure.collect.sources.source(2)$
          - $monitors.enclosure.collect.sources.source(3)$
      mapping:
        # ValueTable = Source(1)
        # Name;PATROLStatus;StatusDescriptions;
        source: $monitors.enclosure.collect.sources.source(4)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="enclosure"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
  physical_disk:
    discovery:
      sources:
        source(1):
          # Make a copy to use for enclosure discovery
          # DeviceID;MSHW;Type;EnclosureID;DeviceID;....
          type: copy
          from: $monitors.enclosure.discovery.sources.source(16)$
          computes:
            # Keep Only PhysicalDisks
            # DeviceID;MSHW;PHYS_DISK;enclosureID;ID;size;model;serial;firmware;part_number;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: ^PHYS_DISK$
            # Convert from whatever unit IBM uses to bytes
            # DeviceID;MSHW;PHYS_DISK;enclosureID;ID;size;model;serial;firmware;part_number;
          - type: multiply
            column: 6
            value: 1081348
      mapping:
        # The discovery table
        # DeviceID;MSHW;PHYS_DISK;enclosureID;ID;size;model;serial;firmware;part_number;
        source: $monitors.physical_disk.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          __display_id: $column(1)
          vendor: $column(7)
          model: $column(10)
          serial_number: $column(8)
          firmware_version: $column(9)
          hw.parent.type: enclosure
          hw.parent.id: $column(4)
          name: "sprintf(\"%s (%s - %s)\", $column(1), $column(7), bytes2HumanFormatBase10($column(6)))"
        metrics:
          hw.physical_disk.size: $column(6)
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Copy Enclosure Collect
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
      mapping:
        # ValueTable = Source(1)
        # Name;PATROLStatus;StatusDescriptions;
        source: $monitors.physical_disk.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="physical_disk"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
  memory:
    discovery:
      sources:
        source(1):
          # Make a copy to use for enclosure discovery
          # DeviceID;MSHW;Type;EnclosureID;DeviceID;....
          type: copy
          from: $monitors.enclosure.discovery.sources.source(16)$
          computes:
            # Keep Only Memorys
            # DeviceID;MSHW;MEMORY;enclosureID;ID;serial;manufacturer;part_number;location;speed;size;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: ^MEMORY$
      mapping:
        # The discovery table
        # DeviceID;MSHW;Memory;enclosureID;ID;serial;manufacturer;part_number;location;speed;size;
        source: $monitors.memory.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          __display_id: $column(1)
          vendor: $column(7)
          serial_number: $column(6)
          info: "join(\" \", $column(8), $column(9), $column(10))"
          hw.parent.type: enclosure
          hw.parent.id: $column(4)
          name: "sprintf(\"%s (%s - %s MB)\", $column(1), $column(7), $column(11))"
        metrics:
          hw.memory.limit: mebiByte2Byte($column(11))
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Copy Enclosure Collect
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
      mapping:
        # ValueTable = Source(1)
        # Name;PATROLStatus;StatusDescriptions;
        source: $monitors.memory.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="memory"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
  fan:
    discovery:
      sources:
        source(1):
          # Make a copy to use for enclosure discovery
          # DeviceID;MSHW;Type;EnclosureID;DeviceID;....
          type: copy
          from: $monitors.enclosure.discovery.sources.source(16)$
          computes:
            # Keep Only Fans
            # DeviceID;MSHW;FAN;enclosureID;ID;;;;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: ^FAN$
      mapping:
        # The discovery table
        # DeviceID;MSHW;FAN;enclosureID;ID;;;;
        source: $monitors.fan.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          __display_id: $column(1)
          hw.parent.type: enclosure
          hw.parent.id: $column(4)
          name: $column(1)
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Copy Enclosure Collect
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
      mapping:
        # ValueTable = Source(1)
        # Name;PATROLStatus;StatusDescriptions;
        source: $monitors.fan.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="fan"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
  power_supply:
    discovery:
      sources:
        source(1):
          # Make a copy to use for enclosure discovery
          # DeviceID;MSHW;Type;EnclosureID;DeviceID;....
          type: copy
          from: $monitors.enclosure.discovery.sources.source(16)$
          computes:
            # Keep Only PowerSupplys
            # DeviceID;MSHW;PowerSupply;enclosureID;ID;SerialNumber;Firmware;PartNumber;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: ^PSU$
      mapping:
        # The discovery table
        # DeviceID;MSHW;PowerSupply;enclosureID;ID;SerialNumber;Firmware;PartNumber;
        source: $monitors.power_supply.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          __display_id: $column(1)
          info: "join(\" \", $column(6), $column(7), $column(8))"
          hw.parent.type: enclosure
          hw.parent.id: $column(4)
          name: $column(1)
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Copy Enclosure Collect
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
      mapping:
        # ValueTable = Source(1)
        # Name;PATROLStatus;StatusDescriptions;
        source: $monitors.power_supply.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="power_supply"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
  other_device:
    discovery:
      sources:
        source(1):
          # Make a copy to use for enclosure discovery
          # DeviceID;MSHW;Type;EnclosureID;DeviceID;....
          type: copy
          from: $monitors.enclosure.discovery.sources.source(16)$
          computes:
            # Keep Only OtherDevices
            # DeviceID;MSHW;OtherDevice;enclosureID;ID;DeviceType;AddInfo1;AddInfo2;AddInfo3;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: ^OTHER$
            # Copy the deviceID into the ID field
            # DeviceID;MSHW;OtherDevice;enclosureID;DeviceID;DeviceType;AddInfo1;AddInfo2;AddInfo3;
          - type: replace
            column: 5
            existingValue: column(5)
            newValue: column(1)
            # Extract the enclosure from the deviceID
            # DeviceID;MSHW;OtherDevice;enclosureID;enclosureID-Extracted;DeviceType;AddInfo1;AddInfo2;AddInfo3;
          - type: extract
            column: 5
            subColumn: 3
            subSeparators: ':'
            # Replace an Unknown Enclosure with the Enclosure extracted from the ID
            # DeviceID;MSHW;OtherDevice;enclosureID;enclosureID-Extracted;DeviceType;AddInfo1;AddInfo2;AddInfo3;
          - type: replace
            column: 4
            existingValue: UNKNOWN
            newValue: column(5)
            # Copy the deviceID into the ID field
            # DeviceID;MSHW;OtherDevice;enclosureID;DeviceID;DeviceType;AddInfo1;AddInfo2;AddInfo3;
          - type: replace
            column: 5
            existingValue: column(5)
            newValue: column(1)
            # Extract the type from the deviceID
            # DeviceID;MSHW;OtherDevice;enclosureID;Type;DeviceType;AddInfo1;AddInfo2;AddInfo3;
          - type: extract
            column: 5
            subColumn: 2
            subSeparators: ':'
            # Replace an Unknown type with the type extracted from the ID
            # DeviceID;MSHW;OtherDevice;enclosureID;Type;DeviceType;AddInfo1;AddInfo2;AddInfo3;
          - type: replace
            column: 6
            existingValue: UNKNOWN
            newValue: column(5)
            # Exclude certain classes
            # DeviceID;MSHW;OtherDevice;enclosureID;ID;DeviceType;AddInfo1;AddInfo2;AddInfo3;
          - type: excludeMatchingLines
            column: 6
            valueList: "SWITCH,UPS,NIC,DIMM,PSU,FC_Port,Ethernet_Cable,MaintenanceModule,Switch,Disk,Interface,Remote,Data,Module"
      mapping:
        # The discovery table
        # DeviceID;MSHW;OtherDevice;enclosureID;ID;DeviceType;AddInfo1;AddInfo2;AddInfo3;
        source: $monitors.other_device.discovery.sources.source(1)$
        attributes:
          id: $column(1)
          __display_id: $column(1)
          device_type: $column(6)
          info: "join(\" \", $column(7), $column(8), $column(9))"
          hw.parent.type: enclosure
          hw.parent.id: $column(4)
          name: "sprintf(\"%s: %s\", $column(6), $column(1))"
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Copy Enclosure Collect
          type: copy
          from: $monitors.enclosure.collect.sources.source(1)$
      mapping:
        # ValueTable = Source(1)
        # Name;PATROLStatus;StatusDescriptions;
        source: $monitors.other_device.collect.sources.source(1)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="other_device"}: $column(2)
        legacyTextParameters:
          StatusInformation: $column(3)
  network:
    discovery:
      sources:
        source(1):
          # List of Cards
          # Source(1) = Ethernet XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all ipinterface_list_ports"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(2):
          # Source(2) = FC XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all fc_port_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(3):
          # Source(3) = IB XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all ib_port_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(4):
          # Union all the Port XML
          # XML...
          type: tableUnion
          tables:
          - $monitors.network.discovery.sources.source(1)$
          - $monitors.network.discovery.sources.source(2)$
          - $monitors.network.discovery.sources.source(3)$
          computes:
            # Run all the XML through an awk script
            # MSHW;portType;deviceID;enclosureID;speed;status;address;addressType;linkstatus;serial;model;firmware;
          - type: awk
            script: $file("embeddedFile-3")$
            keep: ^MSHW
            separators: ;
      mapping:
        # Instance Table
        # MSHW;portType;deviceID;enclosureID;speed;status;address;addressType;linkstatus;serial;model;firmware;
        source: $monitors.network.discovery.sources.source(4)$
        attributes:
          id: $column(3)
          __display_id: $column(3)
          device_type: $column(2)
          physical_address: $column(7)
          physical_address_type: $column(8)
          model: $column(11)
          serial_number: $column(10)
          info: $column(12)
          hw.parent.type: enclosure
          hw.parent.id: $column(4)
          name: "sprintf(\"%s (%s - %s)\", $column(3), $column(2), $column(11))"
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # List of Cards
          # Source(1) = Ethernet XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all ipinterface_list_ports"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(2):
          # Source(2) = FC XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all fc_port_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(3):
          # Source(3) = IB XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all ib_port_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(4):
          # Union all the Port XML
          # XML...
          type: tableUnion
          tables:
          - $monitors.network.collect.sources.source(1)$
          - $monitors.network.collect.sources.source(2)$
          - $monitors.network.collect.sources.source(3)$
          computes:
            # Parse the XML through an awk script
            # MSHW;portType;deviceID;enclosureID;speed;status;address;addressType;linkstatus;serial;model;firmware;
            #             # deviceID;            speed;status;            #       linkstatus;
          - type: awk
            script: $file("embeddedFile-3")$
            keep: ^MSHW;
            separators: ;
            selectColumns: "3,5,6,9"
            # Now translate into OK/Warning/Alarm
            # DeviceID;Speed;Status;LinkStatus;
          - type: translate
            column: 3
            translationTable: statusTranslationTable
            # Now translate linkStatus
            # DeviceID;Speed;Status;LinkStatus;
          - type: translate
            column: 4
            translationTable: linkStatusTranslationTable
      mapping:
        # ValueTable = Source(1)
        # DeviceID;Speed;Status;LinkStatus;
        source: $monitors.network.collect.sources.source(4)$
        deviceId: $column(1)
        metrics:
          hw.status{hw.type="network"}: $column(3)
          hw.network.up: legacyLinkStatus($column(4))
          hw.network.bandwidth.limit: megaBit2Bit($column(2))
translations:
  linkStatusTranslationTable:
    "yes": ok
    online: ok
    Default: degraded
  statusTranslationTable:
    failed: failed
    ok: ok
    notok: degraded
    Default: failed
