---
connector:
  displayName: IBM XIV (xcli)
  platforms: IBM XiV Storage System
  reliesOn: xcli command line utility
  version: 1.0
  information: This connector provides hardware monitoring for IBM XIV Storage Systems through the xcli command line utility.
  detection:
    appliesTo:
    - Storage
    connectionTypes:
    - remote
    supersedes:
    - SMISDiskArray
    criteria:
    # Only for type storage
    - type: deviceType
      keep:
      - Storage
    # Checks that xcli is on the local machine - in Portal smcli is run from the RSM
    - type: osCommand
      commandLine: xcli -v
      forceSerialization: true
      executeLocally: true
      expectedResult: 'xcli version:'
      errorMessage: xcli not installed or not in path.
    # Checks that xcli returns a system name
    - type: osCommand
      commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all cod_list"
      forceSerialization: true
      executeLocally: true
      expectedResult: system_name
      errorMessage: xcli could not connect or did not find a system.
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Source(1) = list of components
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -t \"component_id\" component_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
          computes:
            # Remove spaces
            # DeviceID
          - type: replace
            column: 1
            existingValue: ' '
            newValue: ""
            # Exclude the header
            # DeviceID
          - type: excludeMatchingLines
            column: 1
            valueList: ComponentID
        source(2):
          # Source(2) = ATS XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all ats_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(3):
          # Source(3) = Module XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all module_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(4):
          # Source(4) = Disk XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all disk_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(5):
          # Source(5) = MM XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all mm_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(6):
          # Source(6) = UPS XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all ups_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(7):
          # Source(7) = Fan XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all fan_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(8):
          # Source(8) = PSU XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all psu_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(9):
          # Source(9) = DIMM XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all dimm_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(10):
          # Source(10) = CF XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all cf_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(11):
          # Join all the XML into one table
          # XML
          type: tableUnion
          tables:
          - "${source::monitors.enclosure.discovery.sources.source(2)}"
          - "${source::monitors.enclosure.discovery.sources.source(3)}"
          - "${source::monitors.enclosure.discovery.sources.source(4)}"
          - "${source::monitors.enclosure.discovery.sources.source(5)}"
          - "${source::monitors.enclosure.discovery.sources.source(6)}"
        source(12):
          type: tableUnion
          tables:
          - "${source::monitors.enclosure.discovery.sources.source(11)}"
          - "${source::monitors.enclosure.discovery.sources.source(7)}"
          - "${source::monitors.enclosure.discovery.sources.source(8)}"
          - "${source::monitors.enclosure.discovery.sources.source(9)}"
          - "${source::monitors.enclosure.discovery.sources.source(10)}"
        source(13):
          # COD XML
          # Source(13) = COD XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all cod_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(14):
          # One final table, the System Information
          # Source(13) = Switch XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all switch_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(15):
          # Join union again
          # XML
          type: tableUnion
          tables:
          - "${source::monitors.enclosure.discovery.sources.source(12)}"
          - "${source::monitors.enclosure.discovery.sources.source(13)}"
          - "${source::monitors.enclosure.discovery.sources.source(14)}"
          computes:
            # Run all the XML through an awk script
            # MSHW...
          - type: awk
            script: "${file::embeddedFile-1}"
            keep: ^MSHW
            separators: ;
        source(16):
          # Join the processed XML to the main component discovery
          # DeviceID;MSHW;Type;EnclosureID;DeviceID;....
          type: tableJoin
          leftTable: "${source::monitors.enclosure.discovery.sources.source(1)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(15)}"
          leftKeyColumn: 1
          rightKeyColumn: 4
          defaultRightLine: Default;OTHER;UNKNOWN;UNKNOWN;UNKNOWN;;;;
        source(17):
          # Make a copy to use for enclosure discovery
          # DeviceID;MSHW;Type;EnclosureID;DisplayID;....
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(16)}"
          computes:
            # Keep Only Enclosures
            # DeviceID;MSHW;ENCLOSURE;EnclosureID;DisplayID;serial;part_number;bios_version;Module Part Number;System Model;System Name/Serial Number;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: ^ENCLOSURE$
          - type: leftConcat
            column: 8
            value: "FirmwareVersion: "
      mapping:
        #  1        2         3       4        #    5     6        #   7        #  8        #    9        #       10        # 11
        # DeviceID;MSHW;ENCLOSURE;EnclosureID;DisplayID;serial;part_number;bios_version;Module Part Number;System Model;System Name/Serial Number;
        source: "${source::monitors.enclosure.discovery.sources.source(17)}"
        attributes:
          id: $4
          __display_id: $5
          vendor: IBM
          model: $7
          serial_number: $6
          bios_version: $8
          type: Storage
          info: "${awk::join(\" \", $9, $10, $11)}"
          name: "${awk::sprintf(\"Storage: %s (%s %s)\", $5, \"IBM\", $7)}"
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Source(1) = list of components
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all component_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
          computes:
            # Parse the XML through an awk script
            # DeviceID;Status;StatusInformation;
          - type: awk
            script: "${file::embeddedFile-2}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4"
            # Now translate into OK/Warning/Alarm
            # DeviceID;Status;StatusInformation;
          - type: translate
            column: 2
            translationTable: "${translation::statusTranslationTable}"
        source(2):
          # Copy the table
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep Only Switches
            # Name;PATROLStatus;StatusDescriptions;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: Module
            # Extract the enclosure number from the device ID
            # Name;PATROLStatus;StatusDescriptions;
          - type: extract
            column: 1
            subColumn: 3
            subSeparators: ':'
        source(3):
          # Copy the Table Again
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
          computes:
            # Keep Only Switches
            # Name;PATROLStatus;StatusDescriptions;
          - type: keepOnlyMatchingLines
            column: 1
            regExp: \(:Switch:\)\|\(:UPS:\)
        source(4):
          # Union 2 and 3
          type: tableUnion
          tables:
          - "${source::monitors.enclosure.collect.sources.source(2)}"
          - "${source::monitors.enclosure.collect.sources.source(3)}"
      mapping:
        # ValueTable = Source(1)
        # Name;PATROLStatus;StatusDescriptions;
        source: "${source::monitors.enclosure.collect.sources.source(4)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="enclosure"}: $2
        legacyTextParameters:
          StatusInformation: $3
  physical_disk:
    discovery:
      sources:
        source(1):
          # Make a copy to use for enclosure discovery
          # DeviceID;MSHW;Type;EnclosureID;DeviceID;....
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(16)}"
          computes:
            # Keep Only PhysicalDisks
            # DeviceID;MSHW;PHYS_DISK;enclosureID;ID;size;model;serial;firmware;part_number;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: ^PHYS_DISK$
            # Convert from whatever unit IBM uses to bytes
            # DeviceID;MSHW;PHYS_DISK;enclosureID;ID;size;model;serial;firmware;part_number;
          - type: multiply
            column: 6
            value: 1081348
      mapping:
        # The discovery table
        # DeviceID;MSHW;PHYS_DISK;enclosureID;ID;size;model;serial;firmware;part_number;
        source: "${source::monitors.physical_disk.discovery.sources.source(1)}"
        attributes:
          id: $1
          __display_id: $1
          vendor: $7
          model: $10
          serial_number: $8
          firmware_version: $9
          hw.parent.type: enclosure
          hw.parent.id: $4
          name: "${awk::sprintf(\"%s (%s - %s)\", $1, $7, bytes2HumanFormatBase10($6))}"
        metrics:
          hw.physical_disk.size: $6
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Copy Enclosure Collect
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
      mapping:
        # ValueTable = Source(1)
        # Name;PATROLStatus;StatusDescriptions;
        source: "${source::monitors.physical_disk.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="physical_disk"}: $2
        legacyTextParameters:
          StatusInformation: $3
  memory:
    discovery:
      sources:
        source(1):
          # Make a copy to use for enclosure discovery
          # DeviceID;MSHW;Type;EnclosureID;DeviceID;....
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(16)}"
          computes:
            # Keep Only Memorys
            # DeviceID;MSHW;MEMORY;enclosureID;ID;serial;manufacturer;part_number;location;speed;size;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: ^MEMORY$
      mapping:
        # The discovery table
        # DeviceID;MSHW;Memory;enclosureID;ID;serial;manufacturer;part_number;location;speed;size;
        source: "${source::monitors.memory.discovery.sources.source(1)}"
        attributes:
          id: $1
          __display_id: $1
          vendor: $7
          serial_number: $6
          info: "${awk::join(\" \", $8, $9, $10)}"
          hw.parent.type: enclosure
          hw.parent.id: $4
          name: "${awk::sprintf(\"%s (%s - %s MB)\", $1, $7, $11)}"
        metrics:
          hw.memory.limit: mebiByte2Byte($11)
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Copy Enclosure Collect
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
      mapping:
        # ValueTable = Source(1)
        # Name;PATROLStatus;StatusDescriptions;
        source: "${source::monitors.memory.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="memory"}: $2
        legacyTextParameters:
          StatusInformation: $3
  fan:
    discovery:
      sources:
        source(1):
          # Make a copy to use for enclosure discovery
          # DeviceID;MSHW;Type;EnclosureID;DeviceID;....
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(16)}"
          computes:
            # Keep Only Fans
            # DeviceID;MSHW;FAN;enclosureID;ID;;;;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: ^FAN$
      mapping:
        # The discovery table
        # DeviceID;MSHW;FAN;enclosureID;ID;;;;
        source: "${source::monitors.fan.discovery.sources.source(1)}"
        attributes:
          id: $1
          __display_id: $1
          hw.parent.type: enclosure
          hw.parent.id: $4
          name: $1
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Copy Enclosure Collect
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
      mapping:
        # ValueTable = Source(1)
        # Name;PATROLStatus;StatusDescriptions;
        source: "${source::monitors.fan.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="fan"}: $2
        legacyTextParameters:
          StatusInformation: $3
  power_supply:
    discovery:
      sources:
        source(1):
          # Make a copy to use for enclosure discovery
          # DeviceID;MSHW;Type;EnclosureID;DeviceID;....
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(16)}"
          computes:
            # Keep Only PowerSupplys
            # DeviceID;MSHW;PowerSupply;enclosureID;ID;SerialNumber;Firmware;PartNumber;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: ^PSU$
      mapping:
        # The discovery table
        # DeviceID;MSHW;PowerSupply;enclosureID;ID;SerialNumber;Firmware;PartNumber;
        source: "${source::monitors.power_supply.discovery.sources.source(1)}"
        attributes:
          id: $1
          __display_id: $1
          info: "${awk::join(\" \", $6, $7, $8)}"
          hw.parent.type: enclosure
          hw.parent.id: $4
          name: $1
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Copy Enclosure Collect
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
      mapping:
        # ValueTable = Source(1)
        # Name;PATROLStatus;StatusDescriptions;
        source: "${source::monitors.power_supply.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="power_supply"}: $2
        legacyTextParameters:
          StatusInformation: $3
  other_device:
    discovery:
      sources:
        source(1):
          # Make a copy to use for enclosure discovery
          # DeviceID;MSHW;Type;EnclosureID;DeviceID;....
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(16)}"
          computes:
            # Keep Only OtherDevices
            # DeviceID;MSHW;OtherDevice;enclosureID;ID;DeviceType;AddInfo1;AddInfo2;AddInfo3;
          - type: keepOnlyMatchingLines
            column: 3
            regExp: ^OTHER$
            # Copy the deviceID into the ID field
            # DeviceID;MSHW;OtherDevice;enclosureID;DeviceID;DeviceType;AddInfo1;AddInfo2;AddInfo3;
          - type: replace
            column: 5
            existingValue: $5
            newValue: $1
            # Extract the enclosure from the deviceID
            # DeviceID;MSHW;OtherDevice;enclosureID;enclosureID-Extracted;DeviceType;AddInfo1;AddInfo2;AddInfo3;
          - type: extract
            column: 5
            subColumn: 3
            subSeparators: ':'
            # Replace an Unknown Enclosure with the Enclosure extracted from the ID
            # DeviceID;MSHW;OtherDevice;enclosureID;enclosureID-Extracted;DeviceType;AddInfo1;AddInfo2;AddInfo3;
          - type: replace
            column: 4
            existingValue: UNKNOWN
            newValue: $5
            # Copy the deviceID into the ID field
            # DeviceID;MSHW;OtherDevice;enclosureID;DeviceID;DeviceType;AddInfo1;AddInfo2;AddInfo3;
          - type: replace
            column: 5
            existingValue: $5
            newValue: $1
            # Extract the type from the deviceID
            # DeviceID;MSHW;OtherDevice;enclosureID;Type;DeviceType;AddInfo1;AddInfo2;AddInfo3;
          - type: extract
            column: 5
            subColumn: 2
            subSeparators: ':'
            # Replace an Unknown type with the type extracted from the ID
            # DeviceID;MSHW;OtherDevice;enclosureID;Type;DeviceType;AddInfo1;AddInfo2;AddInfo3;
          - type: replace
            column: 6
            existingValue: UNKNOWN
            newValue: $5
            # Exclude certain classes
            # DeviceID;MSHW;OtherDevice;enclosureID;ID;DeviceType;AddInfo1;AddInfo2;AddInfo3;
          - type: excludeMatchingLines
            column: 6
            valueList: "SWITCH,UPS,NIC,DIMM,PSU,FC_Port,Ethernet_Cable,MaintenanceModule,Switch,Disk,Interface,Remote,Data,Module"
      mapping:
        # The discovery table
        # DeviceID;MSHW;OtherDevice;enclosureID;ID;DeviceType;AddInfo1;AddInfo2;AddInfo3;
        source: "${source::monitors.other_device.discovery.sources.source(1)}"
        attributes:
          id: $1
          __display_id: $1
          device_type: $6
          info: "${awk::join(\" \", $7, $8, $9)}"
          hw.parent.type: enclosure
          hw.parent.id: $4
          name: "${awk::sprintf(\"%s: %s\", $6, $1)}"
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # Copy Enclosure Collect
          type: copy
          from: "${source::monitors.enclosure.collect.sources.source(1)}"
      mapping:
        # ValueTable = Source(1)
        # Name;PATROLStatus;StatusDescriptions;
        source: "${source::monitors.other_device.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="other_device"}: $2
        legacyTextParameters:
          StatusInformation: $3
  network:
    discovery:
      sources:
        source(1):
          # List of Cards
          # Source(1) = Ethernet XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all ipinterface_list_ports"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(2):
          # Source(2) = FC XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all fc_port_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(3):
          # Source(3) = IB XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all ib_port_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(4):
          # Union all the Port XML
          # XML...
          type: tableUnion
          tables:
          - "${source::monitors.network.discovery.sources.source(1)}"
          - "${source::monitors.network.discovery.sources.source(2)}"
          - "${source::monitors.network.discovery.sources.source(3)}"
          computes:
            # Run all the XML through an awk script
            # MSHW;portType;deviceID;enclosureID;speed;status;address;addressType;linkstatus;serial;model;firmware;
          - type: awk
            script: "${file::embeddedFile-3}"
            keep: ^MSHW
            separators: ;
      mapping:
        # Instance Table
        # MSHW;portType;deviceID;enclosureID;speed;status;address;addressType;linkstatus;serial;model;firmware;
        source: "${source::monitors.network.discovery.sources.source(4)}"
        attributes:
          id: $3
          __display_id: $3
          device_type: $2
          physical_address: $7
          physical_address_type: $8
          model: $11
          serial_number: $10
          info: $12
          hw.parent.type: enclosure
          hw.parent.id: $4
          name: "${awk::sprintf(\"%s (%s - %s)\", $3, $2, $11)}"
    collect:
      # Collect type is multi-instance
      type: multiInstance
      sources:
        source(1):
          # List of Cards
          # Source(1) = Ethernet XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all ipinterface_list_ports"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(2):
          # Source(2) = FC XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all fc_port_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(3):
          # Source(3) = IB XML
          type: osCommand
          commandLine: "xcli -u %{USERNAME} -p %{PASSWORD} -m %{HOSTNAME} -x -t all ib_port_list"
          executeLocally: true
          timeout: 60
          forceSerialization: true
        source(4):
          # Union all the Port XML
          # XML...
          type: tableUnion
          tables:
          - "${source::monitors.network.collect.sources.source(1)}"
          - "${source::monitors.network.collect.sources.source(2)}"
          - "${source::monitors.network.collect.sources.source(3)}"
          computes:
            # Parse the XML through an awk script
            # MSHW;portType;deviceID;enclosureID;speed;status;address;addressType;linkstatus;serial;model;firmware;
            #             # deviceID;            speed;status;            #       linkstatus;
          - type: awk
            script: "${file::embeddedFile-3}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "3,5,6,9"
            # Now translate into OK/Warning/Alarm
            # DeviceID;Speed;Status;LinkStatus;
          - type: translate
            column: 3
            translationTable: "${translation::statusTranslationTable}"
            # Now translate linkStatus
            # DeviceID;Speed;Status;LinkStatus;
          - type: translate
            column: 4
            translationTable: "${translation::linkStatusTranslationTable}"
      mapping:
        # ValueTable = Source(1)
        # DeviceID;Speed;Status;LinkStatus;
        source: "${source::monitors.network.collect.sources.source(4)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="network"}: $3
          hw.network.up: legacyLinkStatus($4)
          hw.network.bandwidth.limit: megaBit2Bit($2)
translations:
  linkStatusTranslationTable:
    "yes": ok
    online: ok
    Default: degraded
  statusTranslationTable:
    failed: failed
    ok: ok
    notok: degraded
    Default: failed
