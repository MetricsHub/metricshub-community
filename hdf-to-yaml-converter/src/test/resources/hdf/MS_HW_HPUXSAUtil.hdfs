//
//
//                 													 C O N N E C T O R
//
//                       													f o r
//
//           														Hardware Sentry KM for PATROL
//
//                 													by Sentry Software (c)
//
//                  											  MS_HW_HPUXsautil.hdf
//
//      Supports: HP/9000, HP SuperDome, HP Integrity running HP-UX
//			Monitors: physical disks connected to a Smart Array Controller and any configured logical
// 			drives and spare drives.
//
//

//
// HEADER
//

hdf.DisplayName="HP-UX - Smart Array RAID"
hdf.TypicalPlatform="HP 9000,HP Integrity,HP SuperDome"
hdf.ReliesOn="HP-UX Smart Array Configuration Utility"
hdf.Comments="Display the physical disks connected to a Smart Array Controller and any configured logical drive and spare drive."
hdf.Version="1.1"
hdf.RemoteSupport="true"
hdf.AppliesToOS="HP"

//
// DETECTION
//

// OS should be HP (for HP-UX, whatever version)
Detection.Criteria(1).Type="OS"
Detection.Criteria(1).KeepOnly="HP"

// The sautil should exist
Detection.Criteria(2).Type="OSCommand"
Detection.Criteria(2).CommandLine="ls /opt/raidsa/bin/sautil"
Detection.Criteria(2).ExpectedResult="sautil$"
Detection.Criteria(2).ErrorMessage="The Smart Array RAID Controller Utility is not present on this system."

// We should find disks attached to one controller
Detection.Criteria(3).Type="OSCommand"
Detection.Criteria(3).CommandLine="/bin/sh %EmbeddedFile(1)%"
Detection.Criteria(3).ExpectedResult="[GgTtMm][Bb]"
Detection.Criteria(3).ForceSerialization=1
Detection.Criteria(3).ErrorMessage="There are not enough rights to execute the sautil utility, or no disks are listed."


//
// SUDO-able commands
//
Sudo(1).Command="/opt/raidsa/bin/sautil"


////////////////////
// DISK CONTROLLER
////////////////////

//
// Discovery
//

// Source (1) : Contains the list of all Disk Controllers
// /opt/raidsa/bin/sautil /dev/cissx -s output
// DeviceFile;
DiskController.Discovery.Source(1).Type="OsCommand"
DiskController.Discovery.Source(1).CommandLine="/bin/sh %EmbeddedFile(1)%"
DiskController.Discovery.Source(1).ForceSerialization=1

// Source(2) = Copy of source(1)
// DeviceFile;
DiskController.Discovery.Source(2)=%DiskController.Discovery.Source(1)%

// Source(3) = Copy of source(1)
// DeviceFile;
DiskController.Discovery.Source(3)=%DiskController.Discovery.Source(1)%

// Run Source(1) through an AWK script
// MSHW;Controller;Model;SerialNumber;DeviceID;Firmware
DiskController.Discovery.Source(2).Compute(1).Type="Awk"
DiskController.Discovery.Source(2).Compute(1).AwkScript=EmbeddedFile(2)
DiskController.Discovery.Source(2).Compute(1).Separators=";"
DiskController.Discovery.Source(2).Compute(1).KeepOnlyRegExp="^MSHW;"
DiskController.Discovery.Source(2).Compute(1).SelectColumns="2,3,4,5,6"


// Reformat Source(2) output to create a dependency table to link controllers to disks to arrays
// MSHW;Controller;Location;DeviceID;Size;Status;
DiskController.Discovery.Source(3).Compute(1).Type="Awk"
DiskController.Discovery.Source(3).Compute(1).AwkScript=EmbeddedFile(3)
DiskController.Discovery.Source(3).Compute(1).KeepOnlyRegExp="^MSHW;"
DiskController.Discovery.Source(3).Compute(1).Separators=";"
DiskController.Discovery.Source(3).Compute(1).SelectColumns="2,3,4,5,6,7"

// Source (4) Table Join of Source (2) and Source (3) to keep only controllers that have physical disks  associated with them
// (2) Controller;Model;SerialNumber;DeviceID;Firmware
// (3) Controller;Location;DeviceID;Size;Status;
// (4) Controller;Model;SerialNumber;DeviceID;Firmware;Controller;Location;DeviceID;Size;Status;
DiskController.Discovery.Source(4).Type="TableJoint"
DiskController.Discovery.Source(4).LeftTable=%DiskController.Discovery.Source(2)%
DiskController.Discovery.Source(4).RightTable=%DiskController.Discovery.Source(3)%
DiskController.Discovery.Source(4).LeftKeyColumn="1"
DiskController.Discovery.Source(4).RightKeyColumn="1"

// InstanceTable = Source(4)
// Controller;Model;SerialNumber;DeviceID;Firmware;Controller;Location;DeviceID;Size;Status;
DiskController.Discovery.InstanceTable=%DiskController.Discovery.Source(4)%
DiskController.Discovery.Instance.DeviceID=InstanceTable.Column(4)
DiskController.Discovery.Instance.ControllerNumber=InstanceTable.Column(1)
DiskController.Discovery.Instance.Model=InstanceTable.Column(2)
DiskController.Discovery.Instance.FirmwareVersion=InstanceTable.Column(5)


////////////////////
// PHYSICAL DISKS
////////////////////

//
// Discovery
//

// Source(1) %DiskController.Discovery.Source(1)
// DeviceFile;
PhysicalDisk.Discovery.Source(1)=%DiskController.Discovery.Source(1)%


// Reformat Source(1) output via EmbeddedFile(3)
// Contains the list of all External and Internal Physical Disks in the system
// MSHW;Controller;Location;DeviceID;Size;Status;
PhysicalDisk.Discovery.Source(1).Compute(1).Type="Awk"
PhysicalDisk.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(3)
PhysicalDisk.Discovery.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
PhysicalDisk.Discovery.Source(1).Compute(1).Separators=";"
PhysicalDisk.Discovery.Source(1).Compute(1).SelectColumns="2,3,4,5"

// Multiply to get Bytes
//  Controller;Location;DeviceID;SizeBytes
PhysicalDisk.Discovery.Source(1).Compute(2).Type="Multiply"
PhysicalDisk.Discovery.Source(1).Compute(2).Column="4"
PhysicalDisk.Discovery.Source(1).Compute(2).MultiplyBy=1073741824

PhysicalDisk.Discovery.Source(1).Compute(3).Type=LeftConcat
PhysicalDisk.Discovery.Source(1).Compute(3).Column="2"
PhysicalDisk.Discovery.Source(1).Compute(3).String="Location: "


// The InstanceTable
// Controller;Location;DeviceID;SizeBytes
PhysicalDisk.Discovery.InstanceTable=%PhysicalDisk.Discovery.Source(1)%
PhysicalDisk.Discovery.Instance.DeviceID=InstanceTable.Column(3)
PhysicalDisk.Discovery.Instance.Size=InstanceTable.Column(4)
PhysicalDisk.Discovery.Instance.ControllerNumber=InstanceTable.Column(1)
PhysicalDisk.Discovery.Instance.AdditionalInformation1=InstanceTable.Column(2)

//
// Collect
//

// Collect type: MultiInstance
PhysicalDisk.Collect.Type="MultiInstance"


// Source(1) = Runs /opt/raidsa/bin/sautil /dev/cissx -s
// DeviceFile;
PhysicalDisk.Collect.Source(1).Type="OsCommand"
PhysicalDisk.Collect.Source(1).CommandLine="/bin/sh %EmbeddedFile(1)%"
PhysicalDisk.Collect.Source(1).ForceSerialization=1

// Reformat Source(1) = List all Internal Physical Disks in the system and their status
// The status can be either OK, FAILED, SPARE or UNASSIGNED.
// MSHW;Controller;Location;DeviceID;Size;Status;
PhysicalDisk.Collect.Source(1).Compute(1).Type="Awk"
PhysicalDisk.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(3)
PhysicalDisk.Collect.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
PhysicalDisk.Collect.Source(1).Compute(1).Separators=";"
PhysicalDisk.Collect.Source(1).Compute(1).SelectColumns="4,6"

// Duplicate the status column
// DeviceID;Status;Status;
PhysicalDisk.Collect.Source(1).Compute(2).Type="DuplicateColumn"
PhysicalDisk.Collect.Source(1).Compute(2).Column="2"

// Translate the first status column into a PATROL status
// DeviceID;PatrolStatus;Status;
PhysicalDisk.Collect.Source(1).Compute(3).Type="Translate"
PhysicalDisk.Collect.Source(1).Compute(3).Column="2"
PhysicalDisk.Collect.Source(1).Compute(3).TranslationTable="PhysicalDiskStatusTranslationTable"

// The PhysicalDiskStatusTranslationTable --> PatrolStatus
PhysicalDiskStatusTranslationTable("OK")="OK"
PhysicalDiskStatusTranslationTable("FAILED")="ALARM"
PhysicalDiskStatusTranslationTable("SPARE")="OK"
PhysicalDiskStatusTranslationTable("UNASSIGNED")="OK"
PhysicalDiskStatusTranslationTable(Default)="UNKNOWN"

// Translate the second status column into a Status Information
// DeviceID;PatrolStatus;StatusInformation;
PhysicalDisk.Collect.Source(1).Compute(4).Type="Translate"
PhysicalDisk.Collect.Source(1).Compute(4).Column="3"
PhysicalDisk.Collect.Source(1).Compute(4).TranslationTable="PhysicalDiskStatusInformationTranslationTable"

// The PhysicalDiskStatusInformationTranslationTable --> Status Information
PhysicalDiskStatusInformationTranslationTable("OK")=""
PhysicalDiskStatusInformationTranslationTable("FAILED")="Failed"
PhysicalDiskStatusInformationTranslationTable("SPARE")="Spare"
PhysicalDiskStatusInformationTranslationTable("UNASSIGNED")="Unassigned"
PhysicalDiskStatusInformationTranslationTable(Default)="UNKNOWN"

// The ValueTable = source(1)
//  DeviceID;PatrolStatus;StatusInformation;
PhysicalDisk.Collect.ValueTable=%PhysicalDisk.Collect.Source(1)%
PhysicalDisk.Collect.DeviceID=ValueTable.Column(1)
PhysicalDisk.Collect.Status=ValueTable.Column(2)
PhysicalDisk.Collect.StatusInformation=ValueTable.Column(3)


////////////////////
//  LOGICAL DISKS
////////////////////

//
// Discovery
//

// Source(1) = %DiskController.Discovery.Source(1)%
// DeviceFile;
LogicalDisk.Discovery.Source(1)=%DiskController.Discovery.Source(1)%


// Reformat Source(1) = Builds logical drives Table
// MSHW;controller;deviceID;raidlevel;size;status;location;
LogicalDisk.Discovery.Source(1).Compute(1).Type="Awk"
LogicalDisk.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(4)
LogicalDisk.Discovery.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
LogicalDisk.Discovery.Source(1).Compute(1).Separators=";"
LogicalDisk.Discovery.Source(1).Compute(1).SelectColumns="2,3,4,5,7"

// Multiply to get Bytes
// controller;deviceID;raidlevel;sizebytes;location;
LogicalDisk.Discovery.Source(1).Compute(2).Type="Multiply"
LogicalDisk.Discovery.Source(1).Compute(2).Column="4"
LogicalDisk.Discovery.Source(1).Compute(2).MultiplyBy=1073741824

LogicalDisk.Discovery.Source(1).Compute(3).Type=LeftConcat
LogicalDisk.Discovery.Source(1).Compute(3).Column="5"
LogicalDisk.Discovery.Source(1).Compute(3).String="Location: "

// The InstanceTable
// controller;deviceID;raidlevel;sizebytes;location;
LogicalDisk.Discovery.InstanceTable=%LogicalDisk.Discovery.Source(1)%
LogicalDisk.Discovery.Instance.ControllerNumber=InstanceTable.Column(1)
LogicalDisk.Discovery.Instance.DeviceID=InstanceTable.Column(2)
LogicalDisk.Discovery.Instance.RAIDLevel=InstanceTable.Column(3)
LogicalDisk.Discovery.Instance.Size=InstanceTable.Column(4)
LogicalDisk.Discovery.Instance.AdditionalInformation1=InstanceTable.Column(5)


//
// Collect
//


// Collect type: MultiInstance
LogicalDisk.Collect.Type="MultiInstance"

// Collect type = Source(1) = Runs /opt/raidsa/bin/sautil /dev/cissx -s
LogicalDisk.Collect.Source(1).Type="OsCommand"
LogicalDisk.Collect.Source(1).CommandLine="/bin/sh %EmbeddedFile(1)%"
LogicalDisk.Collect.Source(1).ForceSerialization=1

// Reformat Source(1) = List all logical drives and their status
// The status can be either OK, FAILED, SPARE or UNASSIGNED.
// MSHW;controller;deviceID;raidlevel;size;status;location;
LogicalDisk.Collect.Source(1).Compute(1).Type="Awk"
LogicalDisk.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(4)
LogicalDisk.Collect.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
LogicalDisk.Collect.Source(1).Compute(1).Separators=";"
LogicalDisk.Collect.Source(1).Compute(1).SelectColumns="3,6"

// Duplicate the status column
// deviceID;status;
LogicalDisk.Collect.Source(1).Compute(2).Type="DuplicateColumn"
LogicalDisk.Collect.Source(1).Compute(2).Column="2"

// Translate the first status column into a PATROL status
// deviceID;Patrolstatus;status
LogicalDisk.Collect.Source(1).Compute(3).Type="Translate"
LogicalDisk.Collect.Source(1).Compute(3).Column="2"
LogicalDisk.Collect.Source(1).Compute(3).TranslationTable="LogicalDiskStatusTranslationTable"

// The LogicalDiskStatusTranslationTable
LogicalDiskStatusTranslationTable("OK")="OK"
LogicalDiskStatusTranslationTable("FAILED")="ALARM"
LogicalDiskStatusTranslationTable("USING")="WARN"
LogicalDiskStatusTranslationTable("READY")="WARN"
LogicalDiskStatusTranslationTable("RECOVERING")="WARN"
LogicalDiskStatusTranslationTable("WRONG")="ALARM"
LogicalDiskStatusTranslationTable("PHYSICAL")="ALARM"
LogicalDiskStatusTranslationTable("EXPANDING")="OK"
LogicalDiskStatusTranslationTable("NOT")="WARN"
LogicalDiskStatusTranslationTable("QUEUED")="OK"
LogicalDiskStatusTranslationTable(Default)="UNKNOWN"

// Translate the first status column into a PATROL status
// deviceID;Patrolstatus;StatusInformation
LogicalDisk.Collect.Source(1).Compute(4).Type="Translate"
LogicalDisk.Collect.Source(1).Compute(4).Column="3"
LogicalDisk.Collect.Source(1).Compute(4).TranslationTable="LogicalDiskStatusInformationTranslationTable"


// The LogicalDiskStatusTranslationTable
LogicalDiskStatusInformationTranslationTable("OK")=""
LogicalDiskStatusInformationTranslationTable("FAILED")="Failed"
LogicalDiskStatusInformationTranslationTable("USING")="Using Interim Recovery Mode"
LogicalDiskStatusInformationTranslationTable("READY")="Ready for Recovery Operation"
LogicalDiskStatusInformationTranslationTable("RECOVERING")="Recovering"
LogicalDiskStatusInformationTranslationTable("WRONG")="Wrong Physical Disk was Replaced"
LogicalDiskStatusInformationTranslationTable("PHYSICAL")="Physical Disk not Properly Connected"
LogicalDiskStatusInformationTranslationTable("EXPANDING")="Expanding"
LogicalDiskStatusInformationTranslationTable("NOT")="Not Yet Available"
LogicalDiskStatusInformationTranslationTable("QUEUED")="Queued for Expanding"
LogicalDiskStatusInformationTranslationTable(Default)="UNKNOWN"

// The ValueTable = source(1)
// deviceID;Patrolstatus;StatusInformation
LogicalDisk.Collect.ValueTable=%LogicalDisk.Collect.Source(1)%
LogicalDisk.Collect.DeviceID=ValueTable.Column(1)
LogicalDisk.Collect.Status=ValueTable.Column(2)
LogicalDisk.Collect.StatusInformation=ValueTable.Column(3)




//
//
// Batteries
//

//
// Discovery


// Source(1) = Disk Controller Source (1)
Battery.Discovery.Source(1)=%DiskController.Discovery.Source(1)%

// Process sautil output through awk EmbeddedFile(5)
// MSHW;controllerdeviceID;deviceID;location;status;

Battery.Discovery.Source(1).Compute(1).Type="Awk"
Battery.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(5)
Battery.Discovery.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
Battery.Discovery.Source(1).Compute(1).Separators=";"
Battery.Discovery.Source(1).Compute(1).SelectColumns="2,3,4"

Battery.Discovery.Source(1).Compute(2).Type=LeftConcat
Battery.Discovery.Source(1).Compute(2).Column="3"
Battery.Discovery.Source(1).Compute(2).String="Location: "

// The discovery table
// controllerdeviceID;deviceID;location;
Battery.Discovery.InstanceTable=%Battery.Discovery.Source(1)%
Battery.Discovery.Instance.DeviceID=InstanceTable.Column(2)
Battery.Discovery.Instance.AdditionalInformation1=InstanceTable.Column(3)
Battery.Discovery.Instance.AttachedToDeviceID=InstanceTable.Column(1)
Battery.Discovery.Instance.AttachedToDeviceType="DiskController"

//
// Collect
//

// Collect type: MultiInstance
Battery.Collect.Type="MultiInstance"


// Source(1) = Runs /opt/raidsa/bin/sautil /dev/cissx -s
// DeviceFile;
Battery.Collect.Source(1).Type="OsCommand"
Battery.Collect.Source(1).CommandLine="/bin/sh %EmbeddedFile(1)%"
Battery.Collect.Source(1).ForceSerialization=1

// Process sautil output through awk embeddedfile(5)
// MSHW;controllerdeviceID;deviceID;location;status;
Battery.Collect.Source(1).Compute(1).Type="Awk"
Battery.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(5)
Battery.Collect.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
Battery.Collect.Source(1).Compute(1).Separators=";"
Battery.Collect.Source(1).Compute(1).SelectColumns="3,5"

// Duplicate the status column
// DeviceID;Status;Status;
Battery.Collect.Source(1).Compute(2).Type="DuplicateColumn"
Battery.Collect.Source(1).Compute(2).Column="2"

// Translate the first status column into a PATROL status
// DeviceID;PatrolStatus;Status;
Battery.Collect.Source(1).Compute(3).Type="Translate"
Battery.Collect.Source(1).Compute(3).Column="2"
Battery.Collect.Source(1).Compute(3).TranslationTable="BatteryStatusTranslationTable"

// The PhysicalDiskStatusTranslationTable --> PatrolStatus
BatteryStatusTranslationTable("OK")="OK"
BatteryStatusTranslationTable("FAILED")="ALARM"
BatteryStatusTranslationTable(Default)="UNKNOWN"

// Translate the second status column into a Status Information
// DeviceID;PatrolStatus;StatusInformation;
Battery.Collect.Source(1).Compute(4).Type="Translate"
Battery.Collect.Source(1).Compute(4).Column="3"
Battery.Collect.Source(1).Compute(4).TranslationTable="BatteryStatusInformationTranslationTable"

// The PhysicalDiskStatusInformationTranslationTable --> Status Information
BatteryStatusInformationTranslationTable("OK")=""
BatteryStatusInformationTranslationTable("FAILED")="Failed"
BatteryStatusInformationTranslationTable(Default)="UNKNOWN"

// The ValueTable = source(1)
//  DeviceID;PatrolStatus;StatusInformation;
Battery.Collect.ValueTable=%Battery.Collect.Source(1)%
Battery.Collect.DeviceID=ValueTable.Column(1)
Battery.Collect.Status=ValueTable.Column(2)
Battery.Collect.StatusInformation=ValueTable.Column(3)




////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(1) = awk script that extract
///    the information from sautil for each controller
///		 /opt/raidsa/bin/saconfig /dev/ciss* output file
///
/////////////////////////////////////////////////////////
EmbeddedFile(1):
DEVICES=`/usr/bin/ls -1 /dev/ | /usr/bin/egrep ^ciss[0-9]$`
for VOLUME in $DEVICES
                do
                %{SUDO:/opt/raidsa/bin/sautil}/opt/raidsa/bin/sautil /dev/$VOLUME -s
                done
EmbeddedFile(1).End

////////////////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(2) = awk script that extract disks controllers
///    information and build a proper list with it
///		 MSHW;Controller;Model;SerialNumber;DeviceID;Firmware
///
////////////////////////////////////////////////////////////////////
EmbeddedFile(2):
BEGIN {
        controller = "";
        model = "";
        modelnumber = "";
        serialnbr = "";
        devicefile = "";
        firmware = "";
}
$1 ~ /Controller/ && $2 ~ /Product/ && $3 ~ /Number/   {modelnumber=$NF}
$1 ~ /Controller/ && $2 ~ /Product/ && $3 ~ /Name/     {model=substr($0,index($0,$4)); model=model " (" modelnumber")"}
$1 ~ /Adapter/ && model == ""                          {model=substr($0,index($0,$2))}
$1 ~ /Serial/ && $2 ~ /Number/                         {serialnbr=$NF}
$1 ~ /Device/ && $2 ~ /File/                           {devicefile=$NF;controller=$NF;gsub(/\057dev\057ciss/,"",controller);}
$1 ~ /Firmware/ && $2 ~ /Revision/ && controller != "" {firmware=$NF;
	                                                      print ("MSHW;"controller";"model";"serialnbr";"devicefile";"firmware";")
	                                                      controller = "";model = "";modelnumber = "";serialnbr = "";devicefile = "";firmware = "";
	                                                     }
EmbeddedFile(2).End
////////////////////////////////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(3) = awk script that extract physical disks
///    information and build a proper list with it
///		 MSHW;Controller;Location;DeviceID;Size;Status;
///
///////////////////////////////////////////////////////////////////////////////////
EmbeddedFile(3):
BEGIN {
	controller = "";
	size = "";
	mode = "";
}

$1 ~ /Device/ && $2 ~ /File/ {controller=$NF;gsub(/\057dev\057ciss/,"",controller);}


/SCSI DEVICE SUMMARY/,/(SCSI BUS)|(LOGICAL DRIVE)/ {if (NF > 5) {
             if ($(NF-1) ~ /[GgTtMm][Bb]/ && $(NF-5) ~ /[0-9]+/ && $(NF-4) ~ /[0-9]+/) {
	                                               size=$(NF-2) ;
	                                               if ($NF-1 ~ /[Mm][Bb]/) {size=size/1024}
		                                                 else if ($NF-1 ~ /[Tt][Bb]/) {size=size*1024} ;
		                                             ID = ("C" controller "-CH"$(NF-5) "-ID" $(NF-4));
		                                             location = ("Controller-ciss" controller " Channel-" $(NF-5) " ID-"$(NF-4));
		                                             if (NF > 6) {location = (location " (" $(NF-6)")")};
		                                             {print "MSHW;"controller";"location";"ID";"size";"$NF";"}
                                                                                       }
                                              }
                                 }

/SATA DEVICE SUMMARY/,/SATA ENCLOSURE SUMMARY/    {if (NF > 8) {
             if ($(NF-1)||$(NF-2)  ~ /[GgTtMm][Bb]/ && $3 ~ /[0-9]+/ && $4 ~ /[0-9]+/) {
	                                               size=$(NF-2) ;
	                                               if ($NF-1 ~ /[Mm][Bb]/) {size=size/1024}
		                                                 else if ($NF-1 ~ /[Tt][Bb]/) {size=size*1024} ;
		                                             ID = ("C" controller "-Ct"$2 "-E"$3"-B"$4);
		                                             location = ("Controller-ciss" controller " Ct-" $2 " Enc-" $3 " Bay-" $4 );
		                                             print "MSHW;"controller";"location";"ID";"size";"$NF";"
                                                 }
                                              }
                                 }
EmbeddedFile(3).End


////////////////////////////////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(4) = awk script that extract logical disks
///    information and build a proper list with it
///		 MSHW;controller;deviceID;raidlevel;size;status;location;
///
///////////////////////////////////////////////////////////////////////////////////
EmbeddedFile(4):
BEGIN {controller = "";
	     volume = ""; raid = ""; size = ""; status = "";
       }

$1 ~ /Device/ && $2 ~ /File/ {controller=$NF;gsub(/\057dev\057ciss/,"",controller);}

/LOGICAL DRIVE SUMMARY/,/SCSI DEVICE SUMMARY/ {
	       if ($1 ~ /([0-9]+)/ && $2 ~ /[0-9+]+|([Aa][Dd][Gg])/ && $4 ~ /[TtGgMm][Bb]/) {size=$3; if ($4 ~ /[Mm][Bb]/) {size=size/1024}
	 	                                                                          else if ($4 ~ /[Tt][Bb]/) {size=size*1024} ;
	       	                                                           print ("MSHW;"controller";C" controller"-LD"$1";"$2";"size";"$5";Controller ciss"controller" - Logical Disk " $1";");}
	                                            }
EmbeddedFile(4).End
/////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(5) = awk script that extract logical disks
///    information and build a proper list with it
///		 MSHW;controllerdeviceID;deviceID;location;status;
///
///////////////////////////////////////////////////////////////////////////////////
EmbeddedFile(5):
BEGIN { controller="";}

$1 ~ /Device/ && $2 ~ /File/        {controller=$NF;gsub(/\057dev\057ciss/,"",controller);}

/ARRAY ACCELERATOR/,/LOGICAL DRIVE/ {
  if ($1 ~ /[Bb]attery/ && $2 ~ /[Ss]tatus/ && $3 ~ /[Pp]ack/) { status = toupper ($NF);
  	                                                             batteryID = $4 ; gsub (/[^0-9]/,"",batteryID);
  	                                                             print ("MSHW;/dev/ciss"controller";C" controller"-BP" batteryID ";Controller ciss" controller " - Battery Pack #" batteryID";" status ";");

                                                              }
                                    }
EmbeddedFile(5).End
/////////////////////////////////////////////////////////////////////
