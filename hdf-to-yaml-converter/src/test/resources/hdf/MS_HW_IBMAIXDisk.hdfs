//
//
//                 C O N N E C T O R
//
//                       f o r
//
//                 Hardware Sentry
//
//                 by Sentry Software (c)
//
//                   MS_HW_AIXDisk.hdf
//
//      Supports: IBM AIX machines
//		Monitors: standard non-RAID SCSI hard disks
//      Connects to: different AIX standard tools
//
//

//
// HEADER
//

hdf.DisplayName="IBM AIX - SCSI disks"
hdf.TypicalPlatform="IBM POWER"
hdf.ReliesOn="IBM AIX system commands (lsdev, pvdisplay, etc.)"
hdf.Comments="Provides hardware status information of the non-RAID SCSI physical disks on IBM AIX systems."
hdf.Version="1.2"
hdf.RemoteSupport="true"
hdf.AppliesToOS="RS6000"

//
// Sudo-able commands
//
Sudo(1).Command="/usr/bin/dd"

//
// DETECTION
//

// OS should be RS6000 (for AIX, whatever version)
Detection.Criteria(1).Type="OS"
Detection.Criteria(1).KeepOnly="RS6000"

// The various following tools have to be present
Detection.Criteria(2).Type="OSCommand"
Detection.Criteria(2).CommandLine="which lsdev"
Detection.Criteria(2).ExpectedResult="/lsdev$"


//
// NO COMPUTER
//

//
// DISK CONTROLLERS
//

//
// Discovery

// Source(1) = output of lsdev -c disk
// diskDevicePath
DiskController.Discovery.Source(1).Type="OsCommand"
DiskController.Discovery.Source(1).CommandLine="/usr/sbin/lsdev -C -c disk -F 'class;location'"
DiskController.Discovery.Source(1).KeepOnlyRegExp="^disk;"
DiskController.Discovery.Source(1).Separators=";"
DiskController.Discovery.Source(1).SelectColumns="2"

// Retrieve the controller device path from the disk device path
// controllerDevicePath; (may be several identical instances)
DiskController.Discovery.Source(1).Compute(1).Type="SubString"
DiskController.Discovery.Source(1).Compute(1).Column=1
DiskController.Discovery.Source(1).Compute(1).Start=1
DiskController.Discovery.Source(1).Compute(1).Length=5

// Source(2) = output of lsdev -c adapter
// adapterDevicePath;DeviceID;HardwareLocationCode;displayName
DiskController.Discovery.Source(2).Type="OsCommand"
DiskController.Discovery.Source(2).CommandLine="/usr/sbin/lsdev -C -c adapter -F 'class;location;name;physloc;description'"
DiskController.Discovery.Source(2).KeepOnlyRegExp="^[Aa]dapter;"
DiskController.Discovery.Source(2).Separators=";"
DiskController.Discovery.Source(2).SelectColumns="2,3,4,5"

// Keep only scsi[0-9]* disk controllers (not RAID or SSA)
// adapterDevicePath;DeviceID;HardwareLocationCode;displayName
DiskController.Discovery.Source(2).Compute(1).Type="KeepOnlyMatchingLines"
DiskController.Discovery.Source(2).Compute(1).Column="2"
DiskController.Discovery.Source(2).Compute(1).RegExp="\(^sisscsi[A-Za-z0-9]+$\)\|\(^scsi[A-Za-z0-9]+$\)\|\(^sisio[A-Za-z0-9]+$\)\|\(^sissas[A-Za-z0-9]+$\)"

// Add "Hardware Location Code: " to the HardwareLocationCode column
// adapterDevicePath;DeviceID;HardwareLocationCode;displayName
DiskController.Discovery.Source(2).Compute(2).Type="LeftConcat"
DiskController.Discovery.Source(2).Compute(2).Column=3
DiskController.Discovery.Source(2).Compute(2).String="Location: "


// Source(3) = Table joint of Source(1) and Source(2)
// This jointure will make MSHW keep only adapters that are disk controllers
// with disks attached to them
// adapterDevicePath;DeviceID;HardwareLocationCode;displayName;controllerDevicePath
DiskController.Discovery.Source(3).Type="TableJoint"
DiskController.Discovery.Source(3).LeftTable=%DiskController.Discovery.Source(2)%
DiskController.Discovery.Source(3).RightTable=%DiskController.Discovery.Source(1)%
DiskController.Discovery.Source(3).LeftKeyColumn=1
DiskController.Discovery.Source(3).RightKeyColumn=1

// InstanceTable = Source(5)
DiskController.Discovery.InstanceTable=%DiskController.Discovery.Source(3)%
DiskController.Discovery.Instance.DeviceID=InstanceTable.Column(2)
DiskController.Discovery.Instance.ControllerNumber=InstanceTable.Column(5)
DiskController.Discovery.Instance.Model=InstanceTable.Column(4)
DiskController.Discovery.Instance.AdditionalInformation1=InstanceTable.Column(3)

//
// Collect

// Collect type is "mono-instance"
DiskController.Collect.Type="MonoInstance"

// Source(1) = output of the pvdisplay command
// ErrorCount;LastError;
DiskController.Collect.Source(1).Type="OsCommand"
DiskController.Collect.Source(1).CommandLine="/bin/sh %EmbeddedFile(4)% %DiskController.Collect.DeviceID%"
DiskController.Collect.Source(1).KeepOnlyRegExp="^MSHW;"
DiskController.Collect.Source(1).Separators=";"
DiskController.Collect.Source(1).SelectColumns="2,3,4,5"

// Translate the errorcount into a status (as errorcount does not exist for Disk Controllers)
// ErrorCount;LastError;
DiskController.Collect.Source(1).Compute(1).Type="Translate"
DiskController.Collect.Source(1).Compute(1).Column=1
DiskController.Collect.Source(1).Compute(1).TranslationTable="ErrorcounttoStatusTranslationTable"

// The PhysicalDiskStatusTranslationTable
ErrorcounttoStatusTranslationTable(0)="OK"
ErrorcounttoStatusTranslationTable(Default)="ALARM"

// ValueTable = Source(1)
DiskController.Collect.ValueTable=%DiskController.Collect.Source(1)%
DiskController.Collect.ControllerStatus=ValueTable.Column(1)
DiskController.Collect.StatusInformation=ValueTable.Column(2)
// DiskController.Collect.ErrorCount=ValueTable.Column(3)


//
// PHYSICAL DISKS
//

//
// Discovery

// Source(1) = output of lsdev -C -c disk
// diskName;diskPath;HardwareLocationCode
PhysicalDisk.Discovery.Source(1).Type="OsCommand"
PhysicalDisk.Discovery.Source(1).CommandLine="/usr/sbin/lsdev -C -c disk -F 'class;name;location;physloc'"
PhysicalDisk.Discovery.Source(1).KeepOnlyRegExp="^disk;"
PhysicalDisk.Discovery.Source(1).Separators=";"
PhysicalDisk.Discovery.Source(1).SelectColumns="2,3,4"

// Keep only the first 5 chars of the diskPath to obtain the diskControllerID
// DeviceID;controllerID;HardwareLocationCode
PhysicalDisk.Discovery.Source(1).Compute(1).Type="Substring"
PhysicalDisk.Discovery.Source(1).Compute(1).Column=2
PhysicalDisk.Discovery.Source(1).Compute(1).Start=1
PhysicalDisk.Discovery.Source(1).Compute(1).Length=5

// Add "Hardware Location Code:" to the HardwareLocationCode column
// DeviceID;controllerID;HardwareLocationCode
PhysicalDisk.Discovery.Source(1).Compute(2).Type="LeftConcat"
PhysicalDisk.Discovery.Source(1).Compute(2).Column=3
PhysicalDisk.Discovery.Source(1).Compute(2).String="Location: "

// Source(2) = output of EmbeddedFile(1)
// DeviceID;Manufacturer;SerialNumber
PhysicalDisk.Discovery.Source(2).Type="OsCommand"
PhysicalDisk.Discovery.Source(2).CommandLine="/bin/sh %EmbeddedFile(1)%"
PhysicalDisk.Discovery.Source(2).KeepOnlyRegExp="^MSHW;"
PhysicalDisk.Discovery.Source(2).Separators=";"
PhysicalDisk.Discovery.Source(2).SelectColumns="2,3,4"
PhysicalDisk.Discovery.Source(2).Timeout=180

// Source(3) = Table joint of Source(1) and Source(2)
// DeviceID;controllerID;HardwareLocationCode;DeviceID;Manufacturer;SerialNumber
PhysicalDisk.Discovery.Source(3).Type="TableJoint"
PhysicalDisk.Discovery.Source(3).LeftTable=%PhysicalDisk.Discovery.Source(1)%
PhysicalDisk.Discovery.Source(3).RightTable=%PhysicalDisk.Discovery.Source(2)%
PhysicalDisk.Discovery.Source(3).LeftKeyColumn=1
PhysicalDisk.Discovery.Source(3).RightKeyColumn=1
PhysicalDisk.Discovery.Source(3).DefaultRightLine=";;;"

// Source(4) = output of EmbeddedFile(2)
// DeviceID;SizeMB
PhysicalDisk.Discovery.Source(4).Type="OsCommand"
PhysicalDisk.Discovery.Source(4).CommandLine="/bin/sh %EmbeddedFile(2)%"
PhysicalDisk.Discovery.Source(4).KeepOnlyRegExp="^MSHW;"
PhysicalDisk.Discovery.Source(4).Separators=";"
PhysicalDisk.Discovery.Source(4).SelectColumns="2,3"
PhysicalDisk.Discovery.Source(4).Timeout=180

// Convert SizeMB into bytes
// DeviceID;Size
PhysicalDisk.Discovery.Source(4).Compute(1).Type="Multiply"
PhysicalDisk.Discovery.Source(4).Compute(1).Column=2
PhysicalDisk.Discovery.Source(4).Compute(1).MultiplyBy="1000000"

// Source(5) = Table joint of Source(3) and Source(4)
// DeviceID;controllerID;HardwareLocationCode;DeviceID;Manufacturer;SerialNumber;DeviceID;Size
PhysicalDisk.Discovery.Source(5).Type="TableJoint"
PhysicalDisk.Discovery.Source(5).LeftTable=%PhysicalDisk.Discovery.Source(3)%
PhysicalDisk.Discovery.Source(5).RightTable=%PhysicalDisk.Discovery.Source(4)%
PhysicalDisk.Discovery.Source(5).LeftKeyColumn=1
PhysicalDisk.Discovery.Source(5).RightKeyColumn=1
PhysicalDisk.Discovery.Source(5).DefaultRightLine=";;"

// Source(6) = Table joint of Source(5) and DiskController.Discovery.Source(3)
// To keep only disks that have an existing disk controller
// DeviceID;controllerID;HardwareLocationCode;DeviceID;Manufacturer;SerialNumber;DeviceID;Size;controllerDevicePath;adapterDevicePath;DeviceID;ControllerHardwareLocationCode;displayName
PhysicalDisk.Discovery.Source(6).Type="TableJoint"
PhysicalDisk.Discovery.Source(6).LeftTable=%PhysicalDisk.Discovery.Source(5)%
PhysicalDisk.Discovery.Source(6).RightTable=%DiskController.Discovery.Source(3)%
PhysicalDisk.Discovery.Source(6).LeftKeyColumn=2
PhysicalDisk.Discovery.Source(6).RightKeyColumn=1

// Now we are ready to go
// InstanceTable = Source(5)
PhysicalDisk.Discovery.InstanceTable=%PhysicalDisk.Discovery.Source(6)%
PhysicalDisk.Discovery.Instance.DeviceID=InstanceTable.Column(1)
PhysicalDisk.Discovery.Instance.DisplayID=InstanceTable.Column(1)
PhysicalDisk.Discovery.Instance.ControllerNumber=InstanceTable.Column(2)
PhysicalDisk.Discovery.Instance.Size=InstanceTable.Column(8)
PhysicalDisk.Discovery.Instance.Vendor=InstanceTable.Column(5)
PhysicalDisk.Discovery.Instance.SerialNumber=InstanceTable.Column(6)
PhysicalDisk.Discovery.Instance.AdditionalInformation1=InstanceTable.Column(3)


//
// Collect

// Collect type is "mono-instance"
PhysicalDisk.Collect.Type="MonoInstance"

// Source(1) = output of the pvdisplay command
// Status;StatusInformation;ErrorCount;LastError
PhysicalDisk.Collect.Source(1).Type="OsCommand"
PhysicalDisk.Collect.Source(1).CommandLine="/bin/sh %EmbeddedFile(3)% %PhysicalDisk.Collect.DeviceID%"
PhysicalDisk.Collect.Source(1).KeepOnlyRegExp="^MSHW;"
PhysicalDisk.Collect.Source(1).Separators=";"
PhysicalDisk.Collect.Source(1).SelectColumns="2,3,4,5"

// ValueTable = Source(1)
PhysicalDisk.Collect.ValueTable=%PhysicalDisk.Collect.Source(1)%
PhysicalDisk.Collect.Status=ValueTable.Column(1)
PhysicalDisk.Collect.StatusInformation=ValueTable.Column(2)
PhysicalDisk.Collect.ErrorCount=ValueTable.Column(3)
PhysicalDisk.Collect.LastError=ValueTable.Column(4)


////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(1) = shell script that gives the characteristics of each real physical disks
///
/////////////////////////////////////////////////////////
EmbeddedFile(1):
#!/bin/sh
for DISK in `/usr/sbin/lsdev -C -c disk -F 'name'`
do
	/usr/sbin/lscfg -vp -l $DISK|/bin/tr "." " "|/usr/bin/awk -v diskId=$DISK 'BEGIN {
		manufacturer = "";
		fruNumber = "";
		serialNumber = "";
	}
	/.*/ {
		if ($1 == "Manufacturer")
		{
			manufacturer = $2;
		}

		if ($1 == "FRU" && $2 == "Number")
		{
			fruNumber = $3;
		}

		if ($1 == "Serial" && $2 == "Number")
		{
			serialNumber = $3;
		}
	}
	END {
		print "MSHW;" diskId ";" manufacturer ";" serialNumber " (FRU: " fruNumber ")"
	}'
done
EmbeddedFile(1).End
/////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(2) = shell script that gives the size of each physical disk
///
/////////////////////////////////////////////////////////
EmbeddedFile(2):
#!/bin/sh
for DISK in `/usr/sbin/lsdev -C -c disk -F 'name'`
do
	SIZE=`/usr/sbin/lscfg -vp -l $DISK|/usr/bin/awk -F "[() ]" '/hdisk.*[0-9]+ MB)/ { print $(NF-2) }'`
	/bin/echo "MSHW;$DISK;$SIZE"
done
EmbeddedFile(2).End
////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(3) = shell script that gives the status and
///    the errorcount of the disk (lspv and errpt) since midnight today
///
/////////////////////////////////////////////////////////
EmbeddedFile(3):
#!/bin/sh
LANG=C
export LANG

ERRORMESSAGE=`%{SUDO:/usr/bin/dd}/usr/bin/dd if=/dev/r$1 of=/dev/null count=20 2>&1`
if /usr/bin/test "$?" = "0" ; then
	STATUS="OK;Working"
else
	STATUS=`/usr/bin/echo $ERRORMESSAGE|/usr/bin/awk -F: '{
			if ($3 ~ /ermission/)
			{
				print "UNKNOWN;Insufficient privileges"
			}
			else if ($3 ~ /o such file/)
			{
				print "UNKNOWN;" $3
			}
			else
			{
				print "ALARM;" $3
			}
		}'`
fi
TODAY=`/usr/bin/date +%m%d0000%y`
ERRORCOUNT=`/usr/bin/errpt -d H -s $TODAY -N $1|/usr/bin/tail -n +2|/usr/bin/wc -l|/usr/bin/awk '{print $1}'`
if /usr/bin/test $ERRORCOUNT -gt 0 ; then
	LASTERROR=`/usr/bin/errpt -d H -s $TODAY -N $1|/usr/bin/head -n 2|/usr/bin/tail -n 1|/usr/bin/awk '{printf $1 " ("; for (i=6 ; i<NF ; i++) { printf $i " " } print $NF ")"}'`
fi
/usr/bin/echo "MSHW;$STATUS;$ERRORCOUNT;$LASTERROR"
exit


EmbeddedFile(3).End
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(4) = shell script that gives the
///    the errorcount and status information of the controller
///
/////////////////////////////////////////////////////////
EmbeddedFile(4):
#!/bin/sh
LANG=C
export LANG
TODAY=`/usr/bin/date +%m%d0000%y`
ERRORCOUNT=`/usr/bin/errpt -d H -s $TODAY -N $1|/usr/bin/tail -n +2|/usr/bin/wc -l|/usr/bin/awk '{print $1}'`
if /usr/bin/test $ERRORCOUNT -gt 0 ; then
	LASTERROR=`/usr/bin/errpt -d H -s $TODAY -N $1|/usr/bin/head -n 2|/usr/bin/tail -n 1|/usr/bin/awk '{printf $1 " ("; for (i=6 ; i<NF ; i++) { printf $i " " } print $NF ")"}'`
fi
/usr/bin/echo "MSHW;$ERRORCOUNT;$LASTERROR"
exit
EmbeddedFile(4).End
////////////////////////////////////////////////////////////////////
