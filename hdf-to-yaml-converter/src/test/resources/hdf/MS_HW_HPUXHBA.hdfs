//
//
//                 C O N N E C T O R
//
//                       f o r
//
//                 Hardware Sentry
//
//                 by Sentry Software (c)
//
//                  MS_HW_HPUXHBA.hdf
//
//

//
// HEADER
//

hdf.DisplayName="HP-UX - HBA"
hdf.TypicalPlatform="HP 9000,HP Integrity,HP SuperDome"
hdf.ReliesOn="HP UX system commands (ioscan, fcmsutil)"
hdf.Comments="Provides hardware status information for the fiber channel HBA cards on HP UX systems."
hdf.Version="1.0"
hdf.RemoteSupport="true"
hdf.AppliesToOS="HP"
hdf.Supersedes="MS_HW_CpqHBA.hdf,MS_HW_SMISHBA.hdf"

//
// SUDO-able commands
//
Sudo(1).Command="/usr/sbin/ioscan"
Sudo(2).Command="/opt/fcms/bin/fcmsutil"



//
// DETECTION
//

// Test the hbacmd command for ports
Detection.Criteria(1).Type="OSCommand"
Detection.Criteria(1).CommandLine= "%{SUDO:/usr/sbin/ioscan} /usr/sbin/ioscan -fnC fc"
Detection.Criteria(1).ExpectedResult="/dev/"
Detection.Criteria(1).Timeout=60


//
// Discovery

// Get the outputs of ioscan and fcmsutil for all ports using EmbeddedFile 1
//
NetworkCard.Discovery.Source(1).Type="OsCommand"
NetworkCard.Discovery.Source(1).CommandLine="/bin/sh %EmbeddedFile(1)%"
NetworkCard.Discovery.Source(1).Timeout=90

// AWK the output to get the instance table
// portID;device;description;path;speed;portWWN;remoteWWN;
NetworkCard.Discovery.Source(1).Compute(1).Type="Awk"
NetworkCard.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(2)
NetworkCard.Discovery.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
NetworkCard.Discovery.Source(1).Compute(1).Separators=";"
NetworkCard.Discovery.Source(1).Compute(1).SelectColumns="2,3,4,5,6,7,8"

// The Instance Table
// portID;device;description;path;speed;portWWN;remoteWWN;
NetworkCard.Discovery.InstanceTable=%NetworkCard.Discovery.Source(1)%
NetworkCard.Discovery.Instance.DeviceID=InstanceTable.Column(1)
NetworkCard.Discovery.Instance.Model=InstanceTable.Column(3)
NetworkCard.Discovery.Instance.PhysicalAddress=InstanceTable.Column(6)
NetworkCard.Discovery.Instance.PhysicalAddressType="WWN"
NetworkCard.Discovery.Instance.Bandwidth=InstanceTable.Column(5)
NetworkCard.Discovery.Instance.RemotePhysicalAddress=InstanceTable.Column(7)
NetworkCard.Discovery.Instance.RemotePhysicalAddressType="WWN"


//
// Collect

// Collect type is multi-instance
NetworkCard.Collect.Type="MonoInstance"

// Source(1) = output of fcmsutil %hbaID%
NetworkCard.Collect.Source(1).Type="OsCommand"
NetworkCard.Collect.Source(1).CommandLine="%{SUDO:/opt/fcms/bin/fcmsutil} /opt/fcms/bin/fcmsutil /dev/%NetworkCard.Collect.DeviceID%"

// AWK the output to get the speed and status table
// speed;status;
NetworkCard.Collect.Source(1).Compute(1).Type="Awk"
NetworkCard.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(3)
NetworkCard.Collect.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
NetworkCard.Collect.Source(1).Compute(1).Separators=";"
NetworkCard.Collect.Source(1).Compute(1).SelectColumns="2,3"

// Duplicate Staus Column
// Speed;Status;Status;Status;
NetworkCard.Collect.Source(1).Compute(2).Type="DuplicateColumn"
NetworkCard.Collect.Source(1).Compute(2).Column=2
NetworkCard.Collect.Source(1).Compute(3).Type="DuplicateColumn"
NetworkCard.Collect.Source(1).Compute(3).Column=2

// Translate Network Status
// Speed;PatrolStatus;Status;Status;
NetworkCard.Collect.Source(1).Compute(4).Type="Translate"
NetworkCard.Collect.Source(1).Compute(4).Column=2
NetworkCard.Collect.Source(1).Compute(4).TranslationTable="NetworkStatusTranslationTable"

// The NetworkStatusTranslationTable
NetworkStatusTranslationTable("LOOPBACK_STATE")="ALARM"
NetworkStatusTranslationTable("OFFLINE")="ALARM"
NetworkStatusTranslationTable("DISABLED")="ALARM"
NetworkStatusTranslationTable("READY")="OK"
NetworkStatusTranslationTable("ONLINE")="OK"
NetworkStatusTranslationTable("RESETTING")="WARN"
NetworkStatusTranslationTable("SUSPENDED")="WARN"
NetworkStatusTranslationTable("AWAITING_LINK_UP")="OK"
NetworkStatusTranslationTable(Default)="UNKNOWN"

// Translate Network Status Information
// Speed;PatrolStatus;StatusInformation;Status;WWN;
NetworkCard.Collect.Source(1).Compute(5).Type="Translate"
NetworkCard.Collect.Source(1).Compute(5).Column=3
NetworkCard.Collect.Source(1).Compute(5).TranslationTable="NetworkStatusInfoTranslationTable"

// The NetworkStatusInfoTranslationTable
NetworkStatusInfoTranslationTable("LOOPBACK_STATE")="The host bus adapter is in the loop back test phase."
NetworkStatusInfoTranslationTable("OFFLINE")="Offline - The host bus adapter is not participating on the loop"
NetworkStatusInfoTranslationTable("DISABLED")="Disabled - The host bus adapter is not participating on the loop"
NetworkStatusInfoTranslationTable("READY")=""
NetworkStatusInfoTranslationTable("ONLINE")=""
NetworkStatusInfoTranslationTable("RESETTING")="The host bus adapter is being reset."
NetworkStatusInfoTranslationTable("SUSPENDED")="The driver has been suspended by the user."
NetworkStatusInfoTranslationTable("AWAITING_LINK_UP")="Waiting for the Fibre Channel link to come up."
NetworkStatusInfoTranslationTable(Default)="Unknown Status"


// Translate Network Status Information
// Speed;PatrolStatus;StatusInformation;LinkStatus;
NetworkCard.Collect.Source(1).Compute(6).Type="Translate"
NetworkCard.Collect.Source(1).Compute(6).Column=4
NetworkCard.Collect.Source(1).Compute(6).TranslationTable="NetworkLinkStatusTranslationTable"

// The NetworkLinkStatusTranslationTable
// NetworkLinkStatusTranslationTable("LOOPBACK_STATE")=""
// NetworkLinkStatusTranslationTable("OFFLINE")=""
// NetworkLinkStatusTranslationTable("DISABLED")=""
NetworkLinkStatusTranslationTable("READY")="OK"
NetworkLinkStatusTranslationTable("ONLINE")="OK"
// NetworkLinkStatusTranslationTable("RESETTING")=""
// NetworkLinkStatusTranslationTable("SUSPENDED")=""
NetworkLinkStatusTranslationTable("AWAITING_LINK_UP")="WARN"
NetworkLinkStatusTranslationTable(Default)="UNKNOWN"


// Value table = Source(1)
// Speed;PatrolStatus;StatusInformation;LinkStatus;
NetworkCard.Collect.ValueTable=%NetworkCard.Collect.Source(1)%
NetworkCard.Collect.LinkStatus=ValueTable.Column(4)
NetworkCard.Collect.LinkSpeed=ValueTable.Column(1)
NetworkCard.Collect.Status=ValueTable.Column(2)
NetworkCard.Collect.StatusInformation=ValueTable.Column(3)


////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(1) = shell script that lists the HBA
///    with all of their characteristics
///
/////////////////////////////////////////////////////////
EmbeddedFile(1):
print -n  "MS_HW_START ioscan " ; date
ioscanOutput=`%{SUDO:/usr/sbin/ioscan} /usr/sbin/ioscan -fnC fc`
echo "$ioscanOutput"
print -n  "MS_HW_END ioscan " ; date

devicelist=`(echo "$ioscanOutput" ) | awk '$1 ~ "/dev/fcd[0-9]" {print $1}'`
for device in $devicelist
    do
    print -n  "MS_HW_START fcmsutil $device " ; date
    %{SUDO:/opt/fcms/bin/fcmsutil} /opt/fcms/bin/fcmsutil $device
    print -n  "MS_HW_END fcmsutil $device " ; date
    done
EmbeddedFile(1).End
////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(2) = AWK Script that takes the output of Embedded File 1's shell and outputs the instance table.
///
/////////////////////////////////////////////////////////
EmbeddedFile(2):
BEGIN {ioscanSection=0; ioscanFcmsutil = 0  }
$1 ~ /MS_HW_START/ && $2 ~ /ioscan/ {ioscanSection=1}

$1 == "fc" && ioscanSection==1 {path=$3
	                              description=$0; gsub (/^.*INTERFACE */,"",description) ; gsub (/ ?\(.*\)/,"",description)
	                              getline
	                              device=$1
	                              descriptionArray[device] = description
	                              pathArray[device] = path
	                             }

$1 ~ /MS_HW_END/ && $2 ~ /ioscan/ {ioscanSection=0}

$1 ~ /MS_HW_START/ && $2 ~ /fcmsutil/ {fcmsutilSection=1
	                                     device=$3 ;
	                                     portID=$3 ; gsub ("/dev/","",portID)
	                                    }
$1 ~ /N_Port/ && $0 ~ /Port World Wide Name =/ && $NF ~ /0x/ && fcmsutilSection==1 { portWWN = $NF ; gsub (/^0x/,"",portWWN)}
$1 ~ /(Switch)|(Target)/ && $0 ~ /Port World Wide Name =/ && $NF ~ /0x/ && fcmsutilSection==1 { remoteWWN = $NF ; gsub (/^0x/,"",remoteWWN)}
$0 ~ /Link Speed =/ && $NF ~ /[MmGg][Bb]/ && fcmsutilSection==1 {speed = $NF ; gsub (/ ?[Gg][Bb]/,"000",speed) ; gsub (/ ?[Mm][Bb]/,"",speed) }


$1 ~ /MS_HW_END/ && $2 ~ /fcmsutil/ && fcmsutilSection==1 && device != "" {
	                                   fcmsutilSection=0
		                                 print ( "MSHW;" portID ";" device ";" descriptionArray[device] ";" pathArray[device] ";" speed ";" portWWN ";" remoteWWN ";" )
		                                 device="" ;
		                                }
EmbeddedFile(2).End
////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(2) = AWK Script that takes the output of fsmsutil File 1's shell and outputs the speed and status of the port
///
/////////////////////////////////////////////////////////
EmbeddedFile(3):
$0 ~ /Link Speed =/ && $NF ~ /[MmGg][Bb]/ {speed = $NF ; gsub (/ ?[Gg][Bb]/,"000",speed) ; gsub (/ ?[Mm][Bb]/,"",speed) }

$0 ~ /Driver state = / {status = $NF}

END { if (speed != "") {print ( "MSHW;" speed ";" status ";" )}}
EmbeddedFile(3).End
////////////////////////////////////////////////////////////////////