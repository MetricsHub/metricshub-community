//
//
//                 C O N N E C T O R
//
//                       f o r
//
//                 Hardware Sentry
//
//                 by Sentry Software (c)
//
//                MS_HW_AdptStorManUnix.hdf
//
//      Supports: Linux/Solaris machines
//		Monitors: Physical and logical disks behind an Adaptec controller with enabled volumes
//      Connects to: Arcconf under Linux/Solaris
//
//

//
// HEADER
//

hdf.DisplayName="Adaptec - StorMan - RAID"
hdf.TypicalPlatform="Any system with Adaptec"
hdf.ReliesOn="arcconf"
hdf.Comments="Gives information about physical disks and volumes of Adaptec SAS RAID controllers through the arcconf utility."
hdf.Version="1.0"
hdf.RemoteSupport="true"
hdf.AppliesToOS="Solaris,Linux"

// SUDO-ABLE COMMANDS

Sudo(1).Command="/[opt|usr]/StorMan/arcconf"


//
// DETECTION
//

Detection.Criteria(1).Type="OS"
Detection.Criteria(1).KeepOnly="Solaris,SunOS,Linux"

// We should find disks attached to one controller
Detection.Criteria(2).Type="OSCommand"
Detection.Criteria(2).CommandLine="/bin/sh %EmbeddedFile(1)%"
Detection.Criteria(2).ExpectedResult="Hard drive"
Detection.Criteria(2).ErrorMessage="No Adaptec Controller with Physical Disks attached or not enough rights to execute arcconf."

//
// DISK CONTROLLER
//

//
// Discovery

DiskController.Discovery.Source(1).Type="OsCommand"
DiskController.Discovery.Source(1).CommandLine="/bin/sh %EmbeddedFile(3)%"

// Reformat Source(1) output via EmbeddedFile(4)
// MSHW;controllerID;status;model;serial;slot;memory;firmware;driver;batteryStatus;
DiskController.Discovery.Source(1).Compute(1).Type="Awk"
DiskController.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(4)
DiskController.Discovery.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
DiskController.Discovery.Source(1).Compute(1).Separators=";"
DiskController.Discovery.Source(1).Compute(1).SelectColumns="2,4,5,6,7,8,9,10"

// The InstanceTable
// controllerID;model;serial;slot;memory;firmware;driver;batteryStatus;
DiskController.Discovery.InstanceTable=%DiskController.Discovery.Source(1)%
DiskController.Discovery.Instance.DeviceID=InstanceTable.Column(1)
DiskController.Discovery.Instance.ControllerNumber=InstanceTable.Column(1)
DiskController.Discovery.Instance.Model=InstanceTable.Column(2)
DiskController.Discovery.Instance.SerialNumber=InstanceTable.Column(3)
DiskController.Discovery.Instance.AdditionalInformation1=InstanceTable.Column(4)
DiskController.Discovery.Instance.AdditionalInformation2=InstanceTable.Column(5)
DiskController.Discovery.Instance.FirmwareVersion=InstanceTable.Column(6)
DiskController.Discovery.Instance.DriverVersion=InstanceTable.Column(7)
DiskController.Discovery.Instance.ParameterActivation.BatteryStatus=InstanceTable.Column(8)

//
// Collect

// Collect type is "all instances in one shot"
DiskController.Collect.Type="MultiInstance"

// Source(1) = EF4
DiskController.Collect.Source(1).Type="OsCommand"
DiskController.Collect.Source(1).CommandLine="/bin/sh %EmbeddedFile(3)%"

// Reformat Source(1) output via EmbeddedFile(4)
// MSHW;controllerID;status;model;serial;slot;memory;firmware;driver;batteryStatus;
DiskController.Collect.Source(1).Compute(1).Type="Awk"
DiskController.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(4)
DiskController.Collect.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
DiskController.Collect.Source(1).Compute(1).Separators=";"
DiskController.Collect.Source(1).Compute(1).SelectColumns="2,3,10"

// Translate the Status into a PATROL status
// controllerID;Patrolstatus;batteryStatus;
DiskController.Collect.Source(1).Compute(2).Type="Translate"
DiskController.Collect.Source(1).Compute(2).Column=2
DiskController.Collect.Source(1).Compute(2).TranslationTable="DiskControllerStatusTranslationTable"

// The DiskControllerStatusTranslationTable
DiskControllerStatusTranslationTable("optimal")="OK"
DiskControllerStatusTranslationTable("ok")="OK"
DiskControllerStatusTranslationTable("degraded")="WARN"
DiskControllerStatusTranslationTable("failed")="ALARM"
DiskControllerStatusTranslationTable("warning")="WARN"
DiskControllerStatusTranslationTable(Default)="UNKNOWN"

// Translate the Status into a PATROL status
// controllerID;Patrolstatus;PatrolBatteryStatus;
DiskController.Collect.Source(1).Compute(3).Type="Translate"
DiskController.Collect.Source(1).Compute(3).Column=3
DiskController.Collect.Source(1).Compute(3).TranslationTable="ControllerBatteryStatusTranslationTable"

// The DiskControllerStatusTranslationTable
ControllerBatteryStatusTranslationTable("optimal")="OK"
ControllerBatteryStatusTranslationTable("ok")="OK"
ControllerBatteryStatusTranslationTable("charging")="OK"
ControllerBatteryStatusTranslationTable("discharging")="OK"
ControllerBatteryStatusTranslationTable("maintenance mode")="WARN"
ControllerBatteryStatusTranslationTable("charging disabled")="OK"
ControllerBatteryStatusTranslationTable("over temperature")="ALARM"
ControllerBatteryStatusTranslationTable("degraded")="WARN"
ControllerBatteryStatusTranslationTable("failed")="ALARM"
ControllerBatteryStatusTranslationTable(Default)="UNKNOWN"

// ValueTable = Source(1)
// controllerID;Patrolstatus;status;PatrolBatteryStatus;batteryStatus;
DiskController.Collect.ValueTable=%DiskController.Collect.Source(1)%
DiskController.Collect.DeviceID=ValueTable.Column(1)
DiskController.Collect.ControllerStatus=ValueTable.Column(2)
DiskController.Collect.BatteryStatus=ValueTable.Column(3)

//
// PHYSICAL DISKS
//

//
// Discovery

PhysicalDisk.Discovery.Source(1).Type="OsCommand"
PhysicalDisk.Discovery.Source(1).CommandLine="/bin/sh %EmbeddedFile(1)%"

// Reformat Source(1) output via EmbeddedFile(2)
// MSHW;controllerID;hardDriveID;status;location;vendor;model;firmware;serialNumber;sizeGB;channel;
PhysicalDisk.Discovery.Source(1).Compute(1).Type="Awk"
PhysicalDisk.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(2)
PhysicalDisk.Discovery.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
PhysicalDisk.Discovery.Source(1).Compute(1).Separators=";"
PhysicalDisk.Discovery.Source(1).Compute(1).SelectColumns="2,3,5,6,7,8,9,10,11"

// Multiply to get Bytes
// controllerID;hardDriveID;location;vendor;model;firmware;serialNumber;sizeB;channel;
PhysicalDisk.Discovery.Source(1).Compute(2).Type="Multiply"
PhysicalDisk.Discovery.Source(1).Compute(2).Column=8
PhysicalDisk.Discovery.Source(1).Compute(2).MultiplyBy=1073741824

// The InstanceTable
// controllerID;hardDriveID;location;vendor;model;firmware;serialNumber;sizeB;channel;
PhysicalDisk.Discovery.InstanceTable=%PhysicalDisk.Discovery.Source(1)%
PhysicalDisk.Discovery.Instance.DeviceID=InstanceTable.Column(2)
PhysicalDisk.Discovery.Instance.Size=InstanceTable.Column(8)
PhysicalDisk.Discovery.Instance.ControllerNumber=InstanceTable.Column(1)
PhysicalDisk.Discovery.Instance.AdditionalInformation1=InstanceTable.Column(3)
PhysicalDisk.Discovery.Instance.Vendor=InstanceTable.Column(4)
PhysicalDisk.Discovery.Instance.Model=InstanceTable.Column(5)
PhysicalDisk.Discovery.Instance.AdditionalInformation2=InstanceTable.Column(9)
PhysicalDisk.Discovery.Instance.SerialNumber=InstanceTable.Column(7)

//
// Collect

// Collect type is "all instances in one shot"
PhysicalDisk.Collect.Type="MultiInstance"

// Source(1) = EF1
PhysicalDisk.Collect.Source(1).Type="OsCommand"
PhysicalDisk.Collect.Source(1).CommandLine="/bin/sh %EmbeddedFile(1)%"

// Reformat Source(1) output via EmbeddedFile(2)
// MSHW;controllerID;hardDriveID;status;location;vendor;model;firmware;serialNumber;sizeGB;Channel;
PhysicalDisk.Collect.Source(1).Compute(1).Type="Awk"
PhysicalDisk.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(2)
PhysicalDisk.Collect.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
PhysicalDisk.Collect.Source(1).Compute(1).Separators=";"
PhysicalDisk.Collect.Source(1).Compute(1).SelectColumns="3,4"

// Duplicate the Status column
// hardDriveID;Status;Status
PhysicalDisk.Collect.Source(1).Compute(2).Type="DuplicateColumn"
PhysicalDisk.Collect.Source(1).Compute(2).Column=2

// Remove spaces in the Statys column
// hardDriveID;Status;Status
PhysicalDisk.Collect.Source(1).Compute(3).Type="Replace"
PhysicalDisk.Collect.Source(1).Compute(3).Column=2
PhysicalDisk.Collect.Source(1).Compute(3).Replace=" "
PhysicalDisk.Collect.Source(1).Compute(3).ReplaceBy=""

// Translate the Status into a PATROL status
// hardDriveID;PATROLStatus;Status
PhysicalDisk.Collect.Source(1).Compute(4).Type="Translate"
PhysicalDisk.Collect.Source(1).Compute(4).Column=2
PhysicalDisk.Collect.Source(1).Compute(4).TranslationTable="DiskStatusTranslationTable"

// The PhysicalDiskStatusTranslationTable
DiskStatusTranslationTable("okay")="OK"
DiskStatusTranslationTable("raw")="OK"
DiskStatusTranslationTable("online")="OK"
DiskStatusTranslationTable("ready")="OK"
DiskStatusTranslationTable("spare")="OK"
DiskStatusTranslationTable("failed")="ALARM"
DiskStatusTranslationTable("rebuilding")="WARN"
DiskStatusTranslationTable("unsupported")="ALARM"
DiskStatusTranslationTable("offline")="ALARM"
DiskStatusTranslationTable("device-error")="ALARM"
DiskStatusTranslationTable("removed")="ALARM"
DiskStatusTranslationTable("inaccessible")="ALARM"
DiskStatusTranslationTable("down")="ALARM"
DiskStatusTranslationTable(Default)="UNKNOWN"

// ValueTable = Source(1)
PhysicalDisk.Collect.ValueTable=%PhysicalDisk.Collect.Source(1)%
PhysicalDisk.Collect.DeviceID=ValueTable.Column(1)
PhysicalDisk.Collect.Status=ValueTable.Column(2)
PhysicalDisk.Collect.StatusInformation=ValueTable.Column(3)

//
// LOGICAL DISKS
//

//
// Discovery

LogicalDisk.Discovery.Source(1).Type="OsCommand"
LogicalDisk.Discovery.Source(1).CommandLine="/bin/sh %EmbeddedFile(5)%"

// Reformat Source(1) output via EmbeddedFile(6)
// MSHW;controllerID;logicaldriveID;logicaldriveName;status;size;raidLevel;statusInfo;
LogicalDisk.Discovery.Source(1).Compute(1).Type="Awk"
LogicalDisk.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(6)
LogicalDisk.Discovery.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
LogicalDisk.Discovery.Source(1).Compute(1).Separators=";"
LogicalDisk.Discovery.Source(1).Compute(1).SelectColumns="2,3,4,6,7"

// Multiply to get Bytes
// controllerID;logicaldriveID;logicaldriveName;size;raidLevel;
LogicalDisk.Discovery.Source(1).Compute(2).Type="Multiply"
LogicalDisk.Discovery.Source(1).Compute(2).Column=4
LogicalDisk.Discovery.Source(1).Compute(2).MultiplyBy=1073741824

// The InstanceTable
// controllerID;logicaldriveID;logicaldriveName;size;raidLevel;
LogicalDisk.Discovery.InstanceTable=%LogicalDisk.Discovery.Source(1)%
LogicalDisk.Discovery.Instance.DeviceID=InstanceTable.Column(2)
LogicalDisk.Discovery.Instance.Size=InstanceTable.Column(4)
LogicalDisk.Discovery.Instance.RaidLevel=InstanceTable.Column(5)
LogicalDisk.Discovery.Instance.ControllerNumber=InstanceTable.Column(1)
LogicalDisk.Discovery.Instance.DisplayID=InstanceTable.Column(3)

//
// Collect

// Collect type is "all instances in one shot"
LogicalDisk.Collect.Type="MultiInstance"

// Source(1) = EF5
LogicalDisk.Collect.Source(1).Type="OsCommand"
LogicalDisk.Collect.Source(1).CommandLine="/bin/sh %EmbeddedFile(5)%"

// Reformat Source(1) output via EmbeddedFile(6)
// MSHW;controllerID;logicaldriveID;logicaldriveName;status;size;raidLevel;statusInfo;
LogicalDisk.Collect.Source(1).Compute(1).Type="Awk"
LogicalDisk.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(6)
LogicalDisk.Collect.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
LogicalDisk.Collect.Source(1).Compute(1).Separators=";"
LogicalDisk.Collect.Source(1).Compute(1).SelectColumns="3,5,8"

// Translate the Status into a PATROL status
// logicaldriveID;Patrolstatus;statusInfo;
LogicalDisk.Collect.Source(1).Compute(2).Type="Translate"
LogicalDisk.Collect.Source(1).Compute(2).Column=2
LogicalDisk.Collect.Source(1).Compute(2).TranslationTable="LogicalDiskStatusTranslationTable"

// The LogicalDiskStatusTranslationTable
LogicalDiskStatusTranslationTable("okay")="OK"
LogicalDiskStatusTranslationTable("optimal")="OK"
LogicalDiskStatusTranslationTable("uninitialized")="OK"
LogicalDiskStatusTranslationTable("logical")="WARN"
LogicalDiskStatusTranslationTable("suboptimal")="WARN"
LogicalDiskStatusTranslationTable("degraded")="WARN"
LogicalDiskStatusTranslationTable("failed")="ALARM"
LogicalDiskStatusTranslationTable("inaccessible")="ALARM"
LogicalDiskStatusTranslationTable("impacted")="WARN"
LogicalDiskStatusTranslationTable("ready")="OK"
LogicalDiskStatusTranslationTable("online")="OK"
LogicalDiskStatusTranslationTable("standby")="OK"
LogicalDiskStatusTranslationTable("hot")="OK"
LogicalDiskStatusTranslationTable("rebuilding")="WARN"
LogicalDiskStatusTranslationTable("partitioned")="OK"
LogicalDiskStatusTranslationTable(Default)="UNKNOWN"

// ValueTable = Source(1)
// logicaldriveID;Patrolstatus;status;
LogicalDisk.Collect.ValueTable=%LogicalDisk.Collect.Source(1)%
LogicalDisk.Collect.DeviceID=ValueTable.Column(1)
LogicalDisk.Collect.Status=ValueTable.Column(2)
LogicalDisk.Collect.StatusInformation=ValueTable.Column(3)


////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(1) = Physical Disks Command
///    Gets a list of controllers from arcconf getversion
///		 Then runs an arcconf getconfig PD for each controller.
///
/////////////////////////////////////////////////////////
EmbeddedFile(1):
# Awk (or nawk)
if [ -f /usr/xpg4/bin/awk ]; then
	AWK="/usr/xpg4/bin/awk";
elif [ -f /usr/bin/nawk ]; then
	AWK="/usr/bin/nawk";
else
	AWK="awk";
fi
if [ -f /opt/StorMan/arcconf ]; then
       STORMAN="/opt/StorMan";
elif [ -f /usr/StorMan/arcconf ]; then
       STORMAN="/usr/StorMan";
else
	echo No Storman Installed; exit;
fi
DEVICES=`%{SUDO:/[opt|usr]/StorMan/arcconf} $STORMAN/arcconf getversion | $AWK '($1 ~ /Controller/ && $2 ~ /#[0-9]/) {controller=$2;gsub(/#/,"",controller);print(controller)}'`
for CTRL in $DEVICES
                do
                echo MSHWController $CTRL
                %{SUDO:/[opt|usr]/StorMan/arcconf} $STORMAN/arcconf getconfig $CTRL PD
                done
EmbeddedFile(1).End

////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(2) = Physical Disks AWK
///    takes output of EF1 and returns
///		 MSHW;controllerID;hardDriveID;status;location;vendor;model;firmware;serialNumber;size;
///
/////////////////////////////////////////////////////////
EmbeddedFile(2):
BEGIN {controllerID="";deviceID="";hardDriveID="";status="";location="";vendor="";model="";firmware="";serialNumber="";size="";channel="";}
 $1 ~ /MSHWController/ {controllerID=$2};

$1 ~/[Dd]evice/ && $2 ~ /#[0-9]/ {deviceID=(controllerID"-"$2);gsub(/#/,"",deviceID);
	                                getline;
	                                if ( $(NF-1) ~ /[Hh]ard/ && $NF ~ /[Dd]rive/ ) {hardDriveID = deviceID};
	                               }

$1 ~ /[Ss]tate/ && hardDriveID != "" {status=tolower($3)}

$1 ~ /[Ss]upported/ && hardDriveID != "" && $NF ~ /[Nn]o/ {status="Unsupported"}

$1 ~ /[Rr]eported/ && $2 ~ /[Ll]ocation/ {colonIndex = index($0, ":") ;
	                                        location = ("Controller: "controllerID","substr($0, colonIndex + 1)) ;
	                                       }

$1 ~ /[Rr]eported/ && $2 ~ /[Ee]nclosure/ {colonIndex = index($0, ":") ;
	                                         enclosureSlot = substr($0, colonIndex + 2) ;
	                                         commaIndex = index(enclosureSlot, ",") ;
	                                         enclosure = substr(enclosureSlot,1,commaIndex-1) ;
	                                         slot = substr(enclosureSlot,commaIndex + 1) ;
	                                         location = ("Enclosure: " enclosure " - Location: " slot) ;
	                                        }

$1 ~ /[Rr]eported/ && $2 ~ /[Cc]hannel/ {  fullLine=$0 ;
                                           gsub("\(T:L\)","",fullLine);
                                            colonIndex = index(fullLine, ":") ;
	                                        channelDevice = substr(fullLine, colonIndex + 2) ;
	                                        commaIndex = index(channelDevice, ",") ;
	                                        channel = substr(channelDevice,1,commaIndex-1) ;
	                                        device = substr(channelDevice,commaIndex + 1) ;
	                                        channel = ("Channel: " channel " - Device: " device) ;
	                                       }

$1 ~ /[Vv]endor/ {colonIndex = index($0, ":") ;
	                vendor = substr($0, colonIndex + 2) ;
	               }

$1 ~ /[Mm]odel/  {colonIndex = index($0, ":") ;
	                model = substr($0, colonIndex + 2) ;
	               }

$1 ~ /[Ff]irmware/  {colonIndex = index($0, ":") ;
	                   firmware = substr($0, colonIndex + 2) ;
	                  }

$1 ~ /[Ss]erial/ && $2 ~ /[Nn]umber/ {colonIndex = index($0, ":") ;
	                                    serialNumber = substr($0, colonIndex + 2) ;
	                                   }

($1 ~ /^[Ss]ize/ || $1 ~ /^Total/) && $NF ~ /[TtGgMm][Bb]/ && hardDriveID != "" {size=$(NF-1);
	if ($NF ~ /[Mm][Bb]/) {size = size / 1024};
  if ($NF ~ /[Tt][Bb]/) {size = size * 1024};
	print("MSHW;"controllerID";"hardDriveID";"status";"location";"vendor";"model";"firmware";"serialNumber";"size";"channel";");
	deviceID="";hardDriveID="";status="";location="";vendor="";model="";firmware="";serialNumber="";size="";channel="";
	                                                           }
EmbeddedFile(2).End


////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(3) = Disks ControllerCommand
///    Gets a list of controllers from arcconf getversion
///		 Then runs an arcconf getconfig AD  for each controller.
///
/////////////////////////////////////////////////////////
EmbeddedFile(3):
# Awk (or nawk)
if [ -f /usr/xpg4/bin/awk ]; then
	AWK="/usr/xpg4/bin/awk";
elif [ -f /usr/bin/nawk ]; then
	AWK="/usr/bin/nawk";
else
	AWK="awk";
fi
if [ -f /opt/StorMan/arcconf ]; then
       STORMAN="/opt/StorMan";
elif [ -f /usr/StorMan/arcconf ]; then
       STORMAN="/usr/StorMan";
else
	echo No Storman Installed; exit;
fi
DEVICES=`%{SUDO:/[opt|usr]/StorMan/arcconf} $STORMAN/arcconf getversion | $AWK '($1 ~ /Controller/ && $2 ~ /#[0-9]/) {controller=$2;gsub(/#/,"",controller);print(controller)}'`
for CTRL in $DEVICES
                do
                echo MSHWController $CTRL
                %{SUDO:/[opt|usr]/StorMan/arcconf} $STORMAN/arcconf getconfig $CTRL AD
                done
EmbeddedFile(3).End


////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(4) = Disks ControllerCommand
///    takes output of EF3 and returns
///		 MSHW;controllerID;status;model;serial;slot;memory;firmware;driver;batteryStatus;
///
/////////////////////////////////////////////////////////
EmbeddedFile(4):
BEGIN {controllerID="";status="";model="";serial="";memory="";firmware="";driver="";batteryStatus="";}
$1 ~ /MSHWController/ {if (controllerID != "") {print ("MSHW;"controllerID";"status";"model";"serial";"slot";"memory";"firmware";"driver";"batteryStatus";");
	                                              controllerID="";status="";model="";serial="";memory="";firmware="";driver="";batteryStatus="";
	                                             }
	                     controllerID=$2};

$1 ~ /[Cc]ontroller/ && $2 ~ /[Ss]tatus/ {status=tolower($4);if (NF > 4) {status=status " " tolower($5) }}

$1 ~ /[Cc]ontroller/ && $2 ~ /[Mm]odel/  {colonIndex = index($0, ":") ;
	                                        model = substr($0, colonIndex + 2) ;
	                                       }

$1 ~ /[Cc]ontroller/ && $2 ~ /[Ss]erial/ {colonIndex = index($0, ":") ;
	                                        serial = substr($0, colonIndex + 2) ;
	                                       }

$1 ~ /[Pp]hysical/ && $2 ~ /[Ss]lot/     {slot = "Location: " $NF}

$1 ~ /[Ii]nstalled/ && $2 ~ /[Mm]emory/  {colonIndex = index($0, ":") ;
	                                        memory = "Memory: " substr($0, colonIndex + 2) ;
	                                       }

$1 ~ /[Ff]irmware/ {colonIndex = index($0, ":") ;
	                  firmware = substr($0, colonIndex + 2) ;
	                 }

$1 ~ /[Dd]river/   {colonIndex = index($0, ":") ;
	                  driver = substr($0, colonIndex + 2) ;
	                 }

$1 ~ /[Ss]tatus/   {batteryStatus=tolower($3);
	                  if (NF > 3) {batteryStatus=batteryStatus " " tolower($4) };
	                  if (batteryStatus ~ /not installed/) {batteryStatus=""};
	                  getline;
	                  if ($1 ~ /[Oo]ver/ && $2 ~ /[Tt]emperature/ && $NF ~ /[Yy]es/ && batteryStatus!="") {batteryStatus="over temperature";}
	                 }

END {print ("MSHW;"controllerID";"status";"model";"serial";"slot";"memory";"firmware";"driver";"batteryStatus";");}
EmbeddedFile(4).End

////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(5) = Disks ControllerCommand
///    Gets a list of controllers from arcconf getversion
///		 Then runs an arcconf getconfig LD  for each controller.
///
/////////////////////////////////////////////////////////
EmbeddedFile(5):
# Awk (or nawk)
if [ -f /usr/xpg4/bin/awk ]; then
	AWK="/usr/xpg4/bin/awk";
elif [ -f /usr/bin/nawk ]; then
	AWK="/usr/bin/nawk";
else
	AWK="awk";
fi
if [ -f /opt/StorMan/arcconf ]; then
       STORMAN="/opt/StorMan";
elif [ -f /usr/StorMan/arcconf ]; then
       STORMAN="/usr/StorMan";
else
	echo No Storman Installed; exit;
fi
DEVICES=`%{SUDO:/[opt|usr]/StorMan/arcconf} $STORMAN/arcconf getversion | $AWK '($1 ~ /Controller/ && $2 ~ /#[0-9]/) {controller=$2;gsub(/#/,"",controller);print(controller)}'`
for CTRL in $DEVICES
                do
                echo MSHWController $CTRL
                %{SUDO:/[opt|usr]/StorMan/arcconf} $STORMAN/arcconf getconfig $CTRL LD
                done
EmbeddedFile(5).End

////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(6) = Disks ControllerCommand
///    Takes output of EF5 and returns a list of Logical Disks
///		 MSHW;controllerID;logicaldriveID;logicaldriveName;status;size;raidLevel;
///
/////////////////////////////////////////////////////////
EmbeddedFile(6):
BEGIN {controllerID="";logicaldriveID="";logicaldriveName="";status="";size="";raidLevel="";statusInfo="";
	    }
$1 ~ /MSHWController/ {controllerID=$2};

$1 ~ /[Ll]ogical/ && $2 ~ /([Dd]evice)|([Dd]rive)/ && $3 ~ /[Nn]umber/ {logicaldriveID=controllerID "-" $NF}

$1 ~ /[Ll]ogical/ && $2 ~ /[Dd]evice|([Dd]rive)/ && $3 ~ /[Nn]ame/   {logicaldriveName=$NF}

tolower($1) ~ /raid/ && $2 ~ /[Ll]evel/ {raidLevel=$NF}

$1 ~/[Ss]tatus/ && $3 ~ /[Ll]ogical/ && $4 ~ /[Dd]evice|([Dd]rive)/ {status=tolower($6); gsub(/,/,"",status);
	                                                                   colonIndex = index($0, ":") ;
	                                                                   statusInfo = substr($0, colonIndex + 2) ;
	                                                                  }

$1 ~ /[Ss]ize/ && $NF ~ /[TtGgMm][Bb]/ {size=$(NF-1);
	                                      if ($NF ~ /[Mm][Bb]/) {size = size / 1024};
                                        if ($NF ~ /[Tt][Bb]/) {size = size * 1024};
                                        print ("MSHW;"controllerID";"logicaldriveID";"logicaldriveName";"status";"size";"raidLevel";"statusInfo";");
                                        logicaldriveID="";logicaldriveName="";status="";size="";raidLevel="";statusInfo="";
                                       }
EmbeddedFile(6).End
