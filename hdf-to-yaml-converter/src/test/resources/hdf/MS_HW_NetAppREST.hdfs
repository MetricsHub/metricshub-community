////////////////////////////////////////////////////////////////
//
//    H a r d w a r e   D e f i n i t i o n   F i l e
//
//                       f o r
//
//                 Hardware Sentry
//
//               by Sentry Software (c)
//
//
//      Supports: NetApp Filer
//                Connects to NetApp's REST API
//

//
// Header
//

hdf.DisplayName="NetApp Filer (REST)"
hdf.TypicalPlatform="NetApp"
hdf.ReliesOn="NetApp REST API"
hdf.Version="1.0"
hdf.Comments="This connector discovers the enclosure and the disks of NetApp disk arrays (filer) as well as the various environment sensors (temperatures, fans, power supplies, etc.). It relies on the REST API protocol."
hdf.RemoteSupport="true"
hdf.LocalSupport="false"
hdf.AppliesToOS="Storage"

//
// Detection
//

// Check that system-get-vendor-info at least contains "NetApp"
Detection.Criteria(1).Type="HTTP"
Detection.Criteria(1).Method="POST"
Detection.Criteria(1).URL="/servlets/netapp.servlets.admin.XMLrequest_filer"
Detection.Criteria(1).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><system-node-get-iter/></netapp>"
Detection.Criteria(1).ExpectedResult="<product-version>NetApp"
Detection.Criteria(1).ErrorMessage="Credentials Incorrect / Not a NetApp Filer system"

//
// Enclosure
//

// Discovery

// Source(1) = Nodes
// Get XML from REST API Call <system-node-get-iter/>
Enclosure.Discovery.Source(1).Type="HTTP"
Enclosure.Discovery.Source(1).Method="POST"
Enclosure.Discovery.Source(1).URL="/servlets/netapp.servlets.admin.XMLrequest_filer"
Enclosure.Discovery.Source(1).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><system-node-get-iter/></netapp>"

// Convert xml output to multiLine
Enclosure.Discovery.Source(1).Compute(1).Type="Awk"
Enclosure.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(18)

// Source(2) = Multi-line XML for Nodes
// Preserve Enclosure Discovery Source 1 for use elsewhere
Enclosure.Discovery.Source(2)=%Enclosure.Discovery.Source(1)%

// Convert xml output to CSV
// MSHW;node;node-model;node-serial;product-version;cup-firmware-version;is-node-healthy
Enclosure.Discovery.Source(2).Compute(1).Type="Awk"
Enclosure.Discovery.Source(2).Compute(1).AwkScript=EmbeddedFile(1)

// Add Node column to act as type
Enclosure.Discovery.Source(2).Compute(2).Type="RightConcat"
Enclosure.Discovery.Source(2).Compute(2).Column=1
Enclosure.Discovery.Source(2).Compute(2).String=";Node"

// Source(3) = Storage Shelves
// Get XML from REST API Call <storage-shelf-info-get-iter/>
Enclosure.Discovery.Source(3).Type="HTTP"
Enclosure.Discovery.Source(3).Method="POST"
Enclosure.Discovery.Source(3).URL="/servlets/netapp.servlets.admin.XMLrequest_filer"
Enclosure.Discovery.Source(3).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><storage-shelf-info-get-iter/></netapp>"

// Convert xml output to multiLine
Enclosure.Discovery.Source(3).Compute(1).Type="Awk"
Enclosure.Discovery.Source(3).Compute(1).AwkScript=EmbeddedFile(18)

// Source(4) = Multi-line XML for Shelves
// Preserve Enclosure Discovery Source 3 for use elsewhere
Enclosure.Discovery.Source(4)=%Enclosure.Discovery.Source(3)%

// Convert xml output to CSV
// MSHW;shelf;shelf-model;serial-number;;;op-status
Enclosure.Discovery.Source(4).Compute(1).Type="Awk"
Enclosure.Discovery.Source(4).Compute(1).AwkScript=EmbeddedFile(2)

// Concat ";Shelf" to Column for type
// MSHW;type;shelf;shelf-model;serial-number;;;op-status
Enclosure.Discovery.Source(4).Compute(2).Type="RightConcat"
Enclosure.Discovery.Source(4).Compute(2).Column=1
Enclosure.Discovery.Source(4).Compute(2).String=";Shelf"

// Source(5) = All enclosures (Nodes + Shelves)
// Union the Nodes and Shelves tables
// Table 1 // MSHW;type;node; node-model; node-serial;  product-version;cpu-firmware-version;is-node-healthy
// Table 2 // MSHW;type;shelf;shelf-model;serial-number;						   ;									  ;op-status
// index   //    1;   2;    3;          4;            5;              6;                   7;		   				8
Enclosure.Discovery.Source(5).Type="TableUnion"
Enclosure.Discovery.Source(5).Table1=%Enclosure.Discovery.Source(2)%
Enclosure.Discovery.Source(5).Table2=%Enclosure.Discovery.Source(4)%

Enclosure.Discovery.Source(5).Compute(1).Type="LeftConcat"
Enclosure.Discovery.Source(5).Compute(1).Column=6
Enclosure.Discovery.Source(5).Compute(1).String="Firmware Version: "

// Enclosure Instance Table
// MSHW;type;node;model;serial;product-version;firmware;status
Enclosure.Discovery.InstanceTable=%Enclosure.Discovery.Source(5)%
Enclosure.Discovery.Instance.Type=InstanceTable.Column(2)
Enclosure.Discovery.Instance.DeviceID=InstanceTable.Column(3)
Enclosure.Discovery.Instance.DisplayID=InstanceTable.Column(3)
Enclosure.Discovery.Instance.Vendor="NetApp"
Enclosure.Discovery.Instance.Model=InstanceTable.Column(4)
Enclosure.Discovery.Instance.SerialNumber=InstanceTable.Column(5)
Enclosure.Discovery.Instance.AdditionalInformation1=InstanceTable.Column(6)


// Collection

// Collection Type (Multi-instance)
Enclosure.Collect.Type="MultiInstance"

// Source(1) = Nodes
// Get XML from REST API Call <system-node-get-iter/>
Enclosure.Collect.Source(1).Type="HTTP"
Enclosure.Collect.Source(1).Method="POST"
Enclosure.Collect.Source(1).Url="/servlets/netapp.servlets.admin.XMLrequest_filer"
Enclosure.Collect.Source(1).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><system-node-get-iter/></netapp>"

// Convert xml output to multiLine
Enclosure.Collect.Source(1).Compute(1).Type="Awk"
Enclosure.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(18)

// Source(2) = Multi-line XML for Nodes
// Preserve Enclosure Discovery Source 1 for use elsewhere
Enclosure.Collect.Source(2)=%Enclosure.Collect.Source(1)%

// Convert xml output to CSV
// MSHW;node;node-model;node-serial;product-version;cup-firmware-version;is-node-healthy
Enclosure.Collect.Source(2).Compute(1).Type="Awk"
Enclosure.Collect.Source(2).Compute(1).AwkScript=EmbeddedFile(1)

// Source(3) = Shelves
// Get XML from REST API Call <storage-shelf-info-get-iter/>
Enclosure.Collect.Source(3).Type="HTTP"
Enclosure.Collect.Source(3).Method="POST"
Enclosure.Collect.Source(3).URL="/servlets/netapp.servlets.admin.XMLrequest_filer"
Enclosure.Collect.Source(3).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><storage-shelf-info-get-iter/></netapp>"

// Convert xml output to multiLine
Enclosure.Collect.Source(3).Compute(1).Type="Awk"
Enclosure.Collect.Source(3).Compute(1).AwkScript=EmbeddedFile(18)

// Source(4) = Multi-line XML for Nodes
// Preserve Enclosure Discovery Source 3 for use elsewhere
Enclosure.Collect.Source(4)=%Enclosure.Collect.Source(3)%

// Convert xml output to CSV
// MSHW;shelf;shelf-model;serial-number;;;op-status
Enclosure.Collect.Source(4).Compute(1).Type="Awk"
Enclosure.Collect.Source(4).Compute(1).AwkScript=EmbeddedFile(2)

// Union the Nodes and Shelves tables
// Source(5) = All enclosures (Nodes + Shelves)
// Table 1 // MSHW; node; node-model; node-serial;  product-version;cpu-firmware-version;is-node-healthy
// Table 2 // MSHW;shelf;shelf-model;serial-number;						    ;									   ;op-status
// index   //    1;   2;    3;          4;            5;              6;                   7;
Enclosure.Collect.Source(5).Type="TableUnion"
Enclosure.Collect.Source(5).Table1=%Enclosure.Collect.Source(2)%
Enclosure.Collect.Source(5).Table2=%Enclosure.Collect.Source(4)%

Enclosure.Collect.Source(5).Compute(1).Type="DuplicateColumn"
Enclosure.Collect.Source(5).Compute(1).Column=7

// Translate is-node-healthy to PatrolStatus
// MSHW;node;node-model;node-serial;product-version;cup-firmware-version;is-node-healthy
Enclosure.Collect.Source(5).Compute(2).Type="Translate"
Enclosure.Collect.Source(5).Compute(2).Column=7
Enclosure.Collect.Source(5).Compute(2).TranslationTable="EnclosureHealthTranslationTable"

EnclosureHealthTranslationTable("normal")="OK"
EnclosureHealthTranslationTable("true")="OK"
EnclosureHealthTranslationTable(Default)="ALARM"

Enclosure.Collect.Source(5).Compute(3).Type="Translate"
Enclosure.Collect.Source(5).Compute(3).Column=8
Enclosure.Collect.Source(5).Compute(3).TranslationTable="EnclosureStatusInformationTable"

EnclosureStatusInformationTable("false")="Node is not healthy."
EnclosureStatusInformationTable("true")="Node is healthy."
EnclosureStatusInformationTable("normal")=""
EnclosureStatusInformationTable(Default)=""

// Enclosure Value Table
// MSHW;node;node-model;node-serial;product-version;cup-firmware-version;is-node-healthy
Enclosure.Collect.ValueTable=%Enclosure.Collect.Source(5)%
Enclosure.Collect.DeviceID=ValueTable.Column(2)
Enclosure.Collect.Status=ValueTable.Column(7)

//
// PowerSupply
//

//
// Discovery

// Source(1) = Nodes
PowerSupply.Discovery.Source(1)=%Enclosure.Discovery.Source(1)%

// Xml2Cvs using AWK
// MSHW;node;env-failed-power-supply-count;env-failed-power-supply-message;
PowerSupply.Discovery.Source(1).Compute(1).Type="Awk"
PowerSupply.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(3)

// Add "Global" as name
// MSHW;node;Name;env-failed-power-supply-count;env-failed-power-supply-message;
PowerSupply.Discovery.Source(1).Compute(2).Type="RightConcat"
PowerSupply.Discovery.Source(1).Compute(2).Column=2
PowerSupply.Discovery.Source(1).Compute(2).String=";Global"

// Duplicate node to align with second source table and provide unique ID.
// MSHW;node;node;Name;env-failed-power-supply-count;env-failed-power-supply-message;
PowerSupply.Discovery.Source(1).Compute(3).Type="DuplicateColumn"
PowerSupply.Discovery.Source(1).Compute(3).Column=2

// Source(3) = Storage Shelves
// Use XML from AWK after it's been multi-lined
PowerSupply.Discovery.Source(2)=%Enclosure.Discovery.Source(3)%

// Xml2Cvs using AWK
// MSHW;shelf;psu-id;op-status;
PowerSupply.Discovery.Source(2).Compute(1).Type="Awk"
PowerSupply.Discovery.Source(2).Compute(1).AwkScript=EmbeddedFile(4)

// Duplicate psu-id for use in uniqueId and DisplayID
PowerSupply.Discovery.Source(2).Compute(2).Type="DuplicateColumn"
PowerSupply.Discovery.Source(2).Compute(2).Column=3

// Create unique-id by concating shelf and psu-id (computes 3-4)
PowerSupply.Discovery.Source(2).Compute(3).Type="LeftConcat"
PowerSupply.Discovery.Source(2).Compute(3).Column=3
PowerSupply.Discovery.Source(2).Compute(3).String="."

// MSHW;shelf;psu-id;psu-id;op-status;
PowerSupply.Discovery.Source(2).Compute(4).Type="LeftConcat"
PowerSupply.Discovery.Source(2).Compute(4).Column=3
PowerSupply.Discovery.Source(2).Compute(4).String=Column(2)

// Append "PSU - " to ID to create displayID
PowerSupply.Discovery.Source(2).Compute(5).Type="LeftConcat"
PowerSupply.Discovery.Source(2).Compute(5).Column=4
PowerSupply.Discovery.Source(2).Compute(5).String="PSU - "

// Source(3) = All PSUs
//
// Union Node and Shelf PSUs
// Combine both node and shelve power supplies.
// If the nodes report on the status of the shelf power supplies. We will get duplicate events.
//
// table 1 // MSHW; node;     node;       name;env-failed-power-supply-count;env-failed-power-supply-message;
// table 2 // MSHW;shelf;unique-id;displayname;op-status;
// index   //    1    2          3           4
PowerSupply.Discovery.Source(3).Type="TableUnion"
PowerSupply.Discovery.Source(3).Table1=%PowerSupply.Discovery.Source(1)%
PowerSupply.Discovery.Source(3).Table2=%PowerSupply.Discovery.Source(2)%

// Powersupply Instance Table
PowerSupply.Discovery.InstanceTable=%PowerSupply.Discovery.Source(3)%
PowerSupply.Discovery.Instance.DeviceID=InstanceTable.Column(3)
PowerSupply.Discovery.Instance.DisplayID=InstanceTable.Column(4)

PowerSupply.Discovery.Instance.AttachedToDeviceID=InstanceTable.Column(2)

//
// Collection

// Collection Type (Multi-instance)
PowerSupply.Collect.Type="MultiInstance"

// Source(1) = Nodes
PowerSupply.Collect.Source(1)=%Enclosure.Collect.Source(1)%

// Convert XML to CSV
// MSHW;node;env-failed-power-supply-count;env-failed-power-supply-message;
PowerSupply.Collect.Source(1).Compute(1).Type="Awk"
PowerSupply.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(3)

// Source(2) = Shelves
PowerSupply.Collect.Source(2)=%Enclosure.Collect.Source(3)%

// Convert XML to CSV
// MSHW;shelf;psu-id;op-status;
PowerSupply.Collect.Source(2).Compute(1).Type="Awk"
PowerSupply.Collect.Source(2).Compute(1).AwkScript=EmbeddedFile(4)

// Create unique-id (computes 2-3)
// MSHW;shelf;unique-id;op-status;
PowerSupply.Collect.Source(2).Compute(2).Type="LeftConcat"
PowerSupply.Collect.Source(2).Compute(2).Column=3
PowerSupply.Collect.Source(2).Compute(2).String="."

PowerSupply.Collect.Source(2).Compute(3).Type="LeftConcat"
PowerSupply.Collect.Source(2).Compute(3).Column=3
PowerSupply.Collect.Source(2).Compute(3).String=Column(2)

// Drop columns to align with Nodes
// MSHW;unique-id;op-status;
PowerSupply.Collect.Source(2).Compute(4).Type="KeepColumns"
PowerSupply.Collect.Source(2).Compute(4).ColumnNumbers="1,3,4"

// Duplicate status to be used as StatusInformation
// MSHW;unique-id;op-status;op-status
PowerSupply.Collect.Source(2).Compute(5).Type="DuplicateColumn"
PowerSupply.Collect.Source(2).Compute(5).Column=3

// Source(3) = All PSUs
//
// Union Nodes and Shelves
// Combine both node and shelve power supplies.
// If the nodes report on the status of the shelf power supplies. We will get duplicate events.
//
// table 1 // MSHW;node;     PatrolStatus;env-failed-power-supply-message;
// table 2 // MSHW;unique-id;PatrolStatus;op-status
PowerSupply.Collect.Source(3).Type="TableUnion"
PowerSupply.Collect.Source(3).Table1=%PowerSupply.Collect.Source(1)%
PowerSupply.Collect.Source(3).Table2=%PowerSupply.Collect.Source(2)%

// Translate status to PatrolStatus
// MSHW;unique-id;PatrolStatus;StatusInformation
PowerSupply.Collect.Source(3).Compute(1).Type="Translate"
PowerSupply.Collect.Source(3).Compute(1).Column=3
PowerSupply.Collect.Source(3).Compute(1).TranslationTable="PowerSupplyStatusTranslationTable"

PowerSupplyStatusTranslationTable(0)="OK"
PowerSupplyStatusTranslationTable("normal")="OK"
PowerSupplyStatusTranslationTable(Default)="ALARM"

// PowerSupply Value Table
// MSHW;unique-id;PatrolStatus;StatusInformation
PowerSupply.Collect.ValueTable=%PowerSupply.Collect.Source(3)%
PowerSupply.Collect.DeviceID=ValueTable.Column(2)
PowerSupply.Collect.Status=ValueTable.Column(3)
PowerSupply.Collect.StatusInformation=ValueTable.Column(4)


//
// Fans
//

//
// Discovery

// Source(1) = Nodes
Fan.Discovery.Source(1)=%Enclosure.Discovery.Source(1)%

// Xml2Cvs using AWK
// MSHW;node;env-failed-fan-count;env-failed-fan-message;
Fan.Discovery.Source(1).Compute(1).Type="Awk"
Fan.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(5)

// Add "Global" as name
// MSHW;node;name;env-failed-fan-count;env-failed-fan-message;
Fan.Discovery.Source(1).Compute(2).Type="RightConcat"
Fan.Discovery.Source(1).Compute(2).Column=2
Fan.Discovery.Source(1).Compute(2).String=";Global"

// Duplicate column 2 to use as uniqueID
// MSHW;node;node;name;env-failed-fan-count;env-failed-fan-message;
Fan.Discovery.Source(1).Compute(3).Type="DuplicateColumn"
Fan.Discovery.Source(1).Compute(3).Column=2

// Source(2) = Storage Shelves
Fan.Discovery.Source(2)=%Enclosure.Discovery.Source(3)%

// Xml2Cvs using AWK
// MSHW;shelf;fan-id;op-status;
Fan.Discovery.Source(2).Compute(1).Type="Awk"
Fan.Discovery.Source(2).Compute(1).AwkScript=EmbeddedFile(6)

// Duplicate fan-id since we need it for uniqueId and displayID
// MSHW;shelf;fan-id;fan-id;op-status;
Fan.Discovery.Source(2).Compute(2).Type="DuplicateColumn"
Fan.Discovery.Source(2).Compute(2).Column=3

// Combine shelf and fan-id to create uniqueID (Computes 3-4)
Fan.Discovery.Source(2).Compute(3).Type="LeftConcat"
Fan.Discovery.Source(2).Compute(3).Column=3
Fan.Discovery.Source(2).Compute(3).String="."

// MSHW;shelf;unique-id;fan-id;op-status;
Fan.Discovery.Source(2).Compute(4).Type="LeftConcat"
Fan.Discovery.Source(2).Compute(4).Column=3
Fan.Discovery.Source(2).Compute(4).String=Column(2)

// Add "Fan - " to ID for display name
// MSHW;shelf;unique-id;name;op-status;
Fan.Discovery.Source(2).Compute(5).Type="LeftConcat"
Fan.Discovery.Source(2).Compute(5).Column=4
Fan.Discovery.Source(2).Compute(5).String="Fan - "

// Source(3) = All Fans
// Union Node and Shelf PSUs
// Table 1 // MSHW;node; node;     name;env-failed-fan-count;env-failed-fan-message;
// Table 2 // MSHW;shelf;unique-id;name;op-status;
Fan.Discovery.Source(3).Type="TableUnion"
Fan.Discovery.Source(3).Table1=%Fan.Discovery.Source(1)%
Fan.Discovery.Source(3).Table2=%Fan.Discovery.Source(2)%

// Fan Instance Table
// MSHW;node;uniqueId;name;env-failed-fan-count;env-failed-fan-message;
Fan.Discovery.InstanceTable=%Fan.Discovery.Source(3)%
Fan.Discovery.Instance.DeviceID=InstanceTable.Column(3)
Fan.Discovery.Instance.DisplayID=InstanceTable.Column(4)

Fan.Discovery.Instance.AttachedToDeviceID=InstanceTable.Column(2)

//
// Collection

// Collection Type (Multi-instance)
Fan.Collect.Type="MultiInstance"

// Source(1) = Nodes
Fan.Collect.Source(1)=%Enclosure.Collect.Source(1)%

// Xml2Cvs using AWK
// MSHW;node;env-failed-fan-count;env-failed-fan-message;
Fan.Collect.Source(1).Compute(1).Type="Awk"
Fan.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(5)

// Source(2) = Shelves
Fan.Collect.Source(2)=%Enclosure.Collect.Source(3)%

// Xml2Cvs using AWK
// MSHW;shelf;psu-id;op-status;
Fan.Collect.Source(2).Compute(1).Type="Awk"
Fan.Collect.Source(2).Compute(1).AwkScript=EmbeddedFile(6)

// Concat Shelf and fan-id to create uniqueID (computes 2-3)
// MSHW;shelf;psu-id;op-status;
Fan.Collect.Source(2).Compute(2).Type="LeftConcat"
Fan.Collect.Source(2).Compute(2).Column=3
Fan.Collect.Source(2).Compute(2).String="."

// MSHW;shelf;unique-id;op-status;
Fan.Collect.Source(2).Compute(3).Type="LeftConcat"
Fan.Collect.Source(2).Compute(3).Column=3
Fan.Collect.Source(2).Compute(3).String=Column(2)

// drop "shelf" (Column(2)) to align with node table
// MSHW;unique-id;op-status;
Fan.Collect.Source(2).Compute(4).Type="KeepColumns"
Fan.Collect.Source(2).Compute(4).ColumnNumbers="1,3,4"

// Duplicate Column 3 for StatusInformation
// MSHW;unique-id;op-status;op-status
Fan.Collect.Source(2).Compute(5).Type="DuplicateColumn"
Fan.Collect.Source(2).Compute(5).Column=3

// Source(3) = All Fans
// Table Union
// Table 1 // MSHW;node;     env-failed-fans-count;env-failed-power-supply-message;
// Table 2 // MSHW;unique-id;op-status;            op-status
Fan.Collect.Source(3).Type="TableUnion"
Fan.Collect.Source(3).Table1=%Fan.Collect.Source(1)%
Fan.Collect.Source(3).Table2=%Fan.Collect.Source(2)%

// Translate Fan status into PatrolStatus
// MSHW;unique-id;PatrolStatus;StatusInformation
Fan.Collect.Source(3).Compute(1).Type="Translate"
Fan.Collect.Source(3).Compute(1).Column=3
Fan.Collect.Source(3).Compute(1).TranslationTable="FanStatusTranslationTable"

FanStatusTranslationTable(0)="OK"
FanStatusTranslationTable("normal")="OK"
FanStatusTranslationTable(Default)="ALARM"

// Fan Value Table
// MSHW;unique-id;PatrolStatus;StatusInformation
Fan.Collect.ValueTable=%Fan.Collect.Source(3)%
Fan.Collect.DeviceID=ValueTable.Column(2)
Fan.Collect.Status=ValueTable.Column(3)
Fan.Collect.StatusInformation=ValueTable.Column(4)

//
// Battery
//

//
// Discovery

// Source(1) = Nodes
Battery.Discovery.Source(1)=%Enclosure.Discovery.Source(1)%

// Xml2Cvs using AWK
// MSHW;node;nvram-battery-status
Battery.Discovery.Source(1).Compute(1).Type="Awk"
Battery.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(7)

// Add "NV RAM" as battery name (Column 2)
// MSHW;node;name;nvram-battery-status
Battery.Discovery.Source(1).Compute(2).Type="RightConcat"
Battery.Discovery.Source(1).Compute(2).Column=2
Battery.Discovery.Source(1).Compute(2).String=";NV RAM"

// Battery Instance Table
Battery.Discovery.InstanceTable=%Battery.Discovery.Source(1)%
Battery.Discovery.Instance.DeviceID=InstanceTable.Column(2)
Battery.Discovery.Instance.DisplayID=InstanceTable.Column(3)

Battery.Discovery.Instance.AttachedToDeviceID=InstanceTable.Column(2)

//
// Collect

// Source(1) = Nodes
Battery.Collect.Source(1)=%Enclosure.Collect.Source(1)%

// Xml2Cvs using AWK
// MSHW;node;nvram-battery-status
Battery.Collect.Source(1).Compute(1).Type="Awk"
Battery.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(7)

// Duplicate status column for StatusInformation
// MSHW;node;nvram-battery-status;battery-status
Battery.Collect.Source(1).Compute(2).Type="DuplicateColumn"
Battery.Collect.Source(1).Compute(2).Column=3

// Translate nvram-battery-status to PatrolStatus
// MSHW;node;PatrolStatus;battery-status
Battery.Collect.Source(1).Compute(3).Type="Translate"
Battery.Collect.Source(1).Compute(3).Column=3
Battery.Collect.Source(1).Compute(3).TranslationTable="BatteryStatusTranslationTable"

BatteryStatusTranslationTable("battery_ok")="OK"
BatteryStatusTranslationTable(Default)="ALARM"

// Translate battery-status into StatusInformation
// MSHW;node;PatrolStatus;StatusInformation
Battery.Collect.Source(1).Compute(4).Type="Translate"
Battery.Collect.Source(1).Compute(4).Column=4
Battery.Collect.Source(1).Compute(4).TranslationTable="BatteryStatusInformationTranslationTable"

BatteryStatusInformationTranslationTable("battery_ok")="Battery OK"
BatteryStatusInformationTranslationTable(Default)=""

// Battery Value Table
// MSHW;node;PatrolStatus;StatusInformation
Battery.Collect.ValueTable=%Battery.Collect.Source(1)%
Battery.Collect.DeviceID=ValueTable.Column(2)
Battery.Collect.Status=ValueTable.Column(3)
Battery.Collect.StatusInformation=ValueTable.Column(4)

///
// Temperature
//

//
// Discovery

// Source(1) = Nodes
Temperature.Discovery.Source(1)=%Enclosure.Discovery.Source(1)%

// Xml2Cvs using AWK
// MSHW;node;env-over-temperature
Temperature.Discovery.Source(1).Compute(1).Type="Awk"
Temperature.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(8)

// Add "Global" as bettery name (Column 2)
// MSHW;node;name;env-over-temperature
Temperature.Discovery.Source(1).Compute(2).Type="RightConcat"
Temperature.Discovery.Source(1).Compute(2).Column=2
Temperature.Discovery.Source(1).Compute(2).String=";Global"

// Duplicate node as uniqueID
// MSHW;node;node;name;env-over-temperature
Temperature.Discovery.Source(1).Compute(3).Type="DuplicateColumn"
Temperature.Discovery.Source(1).Compute(3).Column=2

// Source(3) = Shelves
Temperature.Discovery.Source(2)=%Enclosure.Discovery.Source(3)%

// Xml2Cvs using AWK
// MSHW;shelf;Temperature-id;op-status;
Temperature.Discovery.Source(2).Compute(1).Type="Awk"
Temperature.Discovery.Source(2).Compute(1).AwkScript=EmbeddedFile(9)

// Duplicate temperature-id for use in uniqueID and name
// MSHW;shelf;Temperature-id;Temperature-id;op-status;
Temperature.Discovery.Source(2).Compute(2).Type="DuplicateColumn"
Temperature.Discovery.Source(2).Compute(2).Column=3

// Create uniqueID (computes 3-4)
Temperature.Discovery.Source(2).Compute(3).Type="LeftConcat"
Temperature.Discovery.Source(2).Compute(3).Column=3
Temperature.Discovery.Source(2).Compute(3).String="."

// MSHW;shelf;unique-id;Temperature-id;op-status;
Temperature.Discovery.Source(2).Compute(4).Type="LeftConcat"
Temperature.Discovery.Source(2).Compute(4).Column=3
Temperature.Discovery.Source(2).Compute(4).String=Column(2)

// MSHW;shelf;unique-id;name;op-status;
Temperature.Discovery.Source(2).Compute(5).Type="LeftConcat"
Temperature.Discovery.Source(2).Compute(5).Column=4
Temperature.Discovery.Source(2).Compute(5).String="Temperature - "

// Source(3) = All Temperatures
// Union Node and Shelf Temperatures
// Table 1 // MSHW;node;name;env-over-temperature
// Table 2 // MSHW;shelf;unique-id;name;status;
Temperature.Discovery.Source(3).Type="TableUnion"
Temperature.Discovery.Source(3).Table1=%Temperature.Discovery.Source(1)%
Temperature.Discovery.Source(3).Table2=%Temperature.Discovery.Source(2)%

// Temperature Instance Table
// MSHW;node;uniqueID;name;env-over-temperature
Temperature.Discovery.InstanceTable=%Temperature.Discovery.Source(3)%
Temperature.Discovery.Instance.DeviceID=InstanceTable.Column(3)
Temperature.Discovery.Instance.DisplayID=InstanceTable.Column(4)

Temperature.Discovery.Instance.AttachedToDeviceID=InstanceTable.Column(2)

//
// Collection

// Collection Type (Multi-instance)
Temperature.Collect.Type="MultiInstance"

// Source(1) = Nodes
Temperature.Collect.Source(1)=%Enclosure.Collect.Source(1)%

// Xml2Cvs using AWK
// MSHW;node;env-over-temperature
Temperature.Collect.Source(1).Compute(1).Type="Awk"
Temperature.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(8)

// Source(2) = Shelves
Temperature.Collect.Source(2)=%Enclosure.Collect.Source(3)%

// Xml2Cvs using AWK
// MSHW;shelf;temp-sensor-id;temp-sens-op-status
Temperature.Collect.Source(2).Compute(1).Type="Awk"
Temperature.Collect.Source(2).Compute(1).AwkScript=EmbeddedFile(9)

// Create unique ID
Temperature.Collect.Source(2).Compute(2).Type="LeftConcat"
Temperature.Collect.Source(2).Compute(2).Column=3
Temperature.Collect.Source(2).Compute(2).String="."

// MSHW;shelf;uniqueID;temp-sensor-id;temp-sens-op-status
Temperature.Collect.Source(2).Compute(3).Type="LeftConcat"
Temperature.Collect.Source(2).Compute(3).Column=3
Temperature.Collect.Source(2).Compute(3).String=Column(2)

// Drop "shelf" (Column(2)) to align tables
// MSHW;unique-id;op-status;
Temperature.Collect.Source(2).Compute(4).Type="KeepColumns"
Temperature.Collect.Source(2).Compute(4).ColumnNumbers="1,3,4"

// Duplicate op-status for StatusInformation
// MSHW;unique-id;op-status;op-status
Temperature.Collect.Source(2).Compute(5).Type="DuplicateColumn"
Temperature.Collect.Source(2).Compute(5).Column=3

// Source(3) = All Temperatures
// Table Union
// MSHW;node;env-over-temperature
// MSHW;unique-id;PatrolStatus;op-status
Temperature.Collect.Source(3).Type="TableUnion"
Temperature.Collect.Source(3).Table1=%Temperature.Collect.Source(1)%
Temperature.Collect.Source(3).Table2=%Temperature.Collect.Source(2)%

// Translate status information into PatrolStatus
Temperature.Collect.Source(3).Compute(1).Type="Translate"
Temperature.Collect.Source(3).Compute(1).Column=3
Temperature.Collect.Source(3).Compute(1).TranslationTable="TemperatureStatusTranslationTable"

TemperatureStatusTranslationTable("normal")="OK"
TemperatureStatusTranslationTable("false")="OK"
TemperatureStatusTranslationTable(Default)="ALARM"

// Temperature Value Table
// MSHW;unique-id;PatrolStatus;StatusInformation
Temperature.Collect.ValueTable=%Temperature.Collect.Source(3)%
Temperature.Collect.DeviceID=ValueTable.Column(2)
Temperature.Collect.Status=ValueTable.Column(3)
Temperature.Collect.StatusInformation=ValueTable.Column(4)

//
// Voltages
//

//
// Discovery

// Source(1) = Shelves
Voltage.Discovery.Source(1)=%Enclosure.Discovery.Source(3)%

// Xml2Cvs using AWK
// MSHW;shelf;Voltage-id;voltage-op-status;
Voltage.Discovery.Source(1).Compute(1).Type="Awk"
Voltage.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(10)

// Duplicate voltage-id for use in uniqueID and name
// MSHW;shelf;voltage-sensor-id;voltage-sensor-id;voltage-op-status
Voltage.Discovery.Source(1).Compute(2).Type="DuplicateColumn"
Voltage.Discovery.Source(1).Compute(2).Column=3

// Create uniqueID (computes 3-4)
Voltage.Discovery.Source(1).Compute(3).Type="LeftConcat"
Voltage.Discovery.Source(1).Compute(3).Column=3
Voltage.Discovery.Source(1).Compute(3).String="."

// MSHW;shelf;unique-id;Voltage-id;op-status;
Voltage.Discovery.Source(1).Compute(4).Type="LeftConcat"
Voltage.Discovery.Source(1).Compute(4).Column=3
Voltage.Discovery.Source(1).Compute(4).String=Column(2)

// Append Voltage to id to create name
// MSHW;shelf;unique-id;Voltage-name;op-status;
Voltage.Discovery.Source(1).Compute(5).Type="LeftConcat"
Voltage.Discovery.Source(1).Compute(5).Column=4
Voltage.Discovery.Source(1).Compute(5).String="Voltage - "

// Voltage Instance Table
// MSHW;shelf;uniqueID;name;env-over-Voltage
Voltage.Discovery.InstanceTable=%Voltage.Discovery.Source(1)%
Voltage.Discovery.Instance.DeviceID=InstanceTable.Column(3)
Voltage.Discovery.Instance.DisplayID=InstanceTable.Column(4)
Voltage.Discovery.Instance.AttachedToDeviceID=InstanceTable.Column(2)

//
// Collection

// Collection Type (Multi-Instance)
Voltage.Collect.Type="MultiInstance"

// Source(1) = Shelves
Voltage.Collect.Source(1)=%Enclosure.Collect.Source(3)%

// Xml2Cvs using AWK
// MSHW;shelf;Voltage-id;voltage-op-status;
Voltage.Collect.Source(1).Compute(1).Type="Awk"
Voltage.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(10)

// create uniqueID
Voltage.Collect.Source(1).Compute(2).Type="LeftConcat"
Voltage.Collect.Source(1).Compute(2).Column=3
Voltage.Collect.Source(1).Compute(2).String="."

// MSHW;shelf;unique-id;voltage-op-status;
Voltage.Collect.Source(1).Compute(3).Type="LeftConcat"
Voltage.Collect.Source(1).Compute(3).Column=3
Voltage.Collect.Source(1).Compute(3).String=Column(2)

// MSHW;shelf;unique-id;voltage-id;op-status;
Voltage.Collect.Source(1).Compute(4).Type="DuplicateColumn"
Voltage.Collect.Source(1).Compute(4).Column=4

// MSHW;shelf;unique-id;voltage-id;op-status;
Voltage.Collect.Source(1).Compute(5).Type="Translate"
Voltage.Collect.Source(1).Compute(5).Column=4
Voltage.Collect.Source(1).Compute(5).TranslationTable="VoltageStatusTranslationTable"

VoltageStatusTranslationTable("normal")="OK"
VoltageStatusTranslationTable(Default)="ALARM"

// Voltage value Table
// MSHW;shelf;unique-id;voltage-id;op-status;
Voltage.Collect.ValueTable=%Voltage.Collect.Source(1)%
Voltage.Collect.DeviceID=ValueTable.Column(3)
Voltage.Collect.Status=ValueTable.Column(4)
Voltage.Collect.StatusInformation=ValueTable.Column(5)


//
// PhysicalDisk
//

//
// Discovery

// Source(1) = Storage Shelf Info
// Get XML from REST API Call <storage-shelf-info-get-iter/>
PhysicalDisk.Discovery.Source(1).Type="HTTP"
PhysicalDisk.Discovery.Source(1).Method="POST"
PhysicalDisk.Discovery.Source(1).Url="/servlets/netapp.servlets.admin.XMLrequest_filer"
PhysicalDisk.Discovery.Source(1).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><storage-shelf-info-get-iter/></netapp>"

// Convert xml output to multiLine
PhysicalDisk.Discovery.Source(1).Compute(1).Type="Awk"
PhysicalDisk.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(18)

// Source(2) = Storage Shelf Info
PhysicalDisk.Discovery.Source(2)=%PhysicalDisk.Discovery.Source(1)%

// Xml2Cvs using AWK
// MSHW;shelf;bay-id;bay-has-disk;bay-type;bay-op-status;
PhysicalDisk.Discovery.Source(2).Compute(1).Type="Awk"
PhysicalDisk.Discovery.Source(2).Compute(1).AwkScript=EmbeddedFile(11)

// create uniqueID (Computes 2-3)
PhysicalDisk.Discovery.Source(2).Compute(2).Type="LeftConcat"
PhysicalDisk.Discovery.Source(2).Compute(2).Column=3
PhysicalDisk.Discovery.Source(2).Compute(2).String="."

// MSHW;shelf;unique-id;bay-has-disk;bay-type;bay-op-status;
PhysicalDisk.Discovery.Source(2).Compute(3).Type="LeftConcat"
PhysicalDisk.Discovery.Source(2).Compute(3).Column=3
PhysicalDisk.Discovery.Source(2).Compute(3).String=Column(2)

// Exclude bays that report no drive
PhysicalDisk.Discovery.Source(2).Compute(4).Type="ExcludeMatchingLines"
PhysicalDisk.Discovery.Source(2).Compute(4).Column=4
PhysicalDisk.Discovery.Source(2).Compute(4).RegExp="false"

// Source(3) = Disks
// Get XML from REST API Call <storage-disk-get-iter/>
PhysicalDisk.Discovery.Source(3).Type="HTTP"
PhysicalDisk.Discovery.Source(3).Method="POST"
PhysicalDisk.Discovery.Source(3).Url="/servlets/netapp.servlets.admin.XMLrequest_filer"
PhysicalDisk.Discovery.Source(3).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><storage-disk-get-iter/></netapp>"

// Convert xml to multi-line
PhysicalDisk.Discovery.Source(3).Compute(1).Type="Awk"
PhysicalDisk.Discovery.Source(3).Compute(1).AwkScript=EmbeddedFile(18)

// Source(4) = Disks
PhysicalDisk.Discovery.Source(4)=%PhysicalDisk.Discovery.Source(3)%

// Xml2Cvs using AWK
// MSHW;disk-cluster-name;shelf-bay;model;serial-number;bytes-per-sector;capacity-sector;rpm;disk-type
PhysicalDisk.Discovery.Source(4).Compute(1).Type="Awk"
PhysicalDisk.Discovery.Source(4).Compute(1).AwkScript=EmbeddedFile(12)

// multiply bytes-per-sector (column 6) by capacity-sector (column 7) for size
// MSHW;uniqueID;shelf-bay;model;serial-number;size;capacity-sector;rpm;disk-type
PhysicalDisk.Discovery.Source(4).Compute(2).Type="Multiply"
PhysicalDisk.Discovery.Source(4).Compute(2).Column=6
PhysicalDisk.Discovery.Source(4).Compute(2).MultiplyBy=Column(7)

// MSHW;uniqueID;shelf-bay;model;serial-number;size;capacity-sector;rpm;disk-type
PhysicalDisk.Discovery.Source(4).Compute(3).Type="LeftConcat"
PhysicalDisk.Discovery.Source(4).Compute(3).Column=8
PhysicalDisk.Discovery.Source(4).Compute(3).String="RPM: "

// Source(5) = Table joint of Source(2) and Source(4)
// Left  // MSHW;shelf;unique-id;bay-has-disk;bay-type;bay-op-status;
// right // MSHW;uniqueID;shelf-bay;model;serial-number;size;capacity-sector;rpm;disk-type
// results;
// MSHW;shelf;uniqueID;bay-has-disk;bay-type;bay-op-status;MSHW;uniqueID;shelf-bay;model;serial-number;size;capacity-sector;rpm;disk-type
//  1      2        3      4             5       6           7     8         9      10    11            12      13           14      15
PhysicalDisk.Discovery.Source(5).Type="TableJoint"
PhysicalDisk.Discovery.Source(5).LeftTable=%PhysicalDisk.Discovery.Source(2)%
PhysicalDisk.Discovery.Source(5).RightTable=%PhysicalDisk.Discovery.Source(4)%
PhysicalDisk.Discovery.Source(5).LeftKeyColumn=3
PhysicalDisk.Discovery.Source(5).RightKeyColumn=2
PhysicalDisk.Discovery.Source(5).DefaultRightLine=";;;;;;;;;;;"

PhysicalDisk.Discovery.Source(5).Compute(1).Type="LeftConcat"
PhysicalDisk.Discovery.Source(5).Compute(1).Column=4
PhysicalDisk.Discovery.Source(5).Compute(1).String="Type: "

// PhysicalDisk Instancce
// MSHW;shelf-id;bay-id;bay-has-disk;bay-type;bay-op-status;MSHW;shelf-bay;model;serial-number;size;capacity-sector;rpm;disk-type
PhysicalDisk.Discovery.InstanceTable=%PhysicalDisk.Discovery.Source(5)%
PhysicalDisk.Discovery.Instance.DeviceID=InstanceTable.Column(3)
PhysicalDisk.Discovery.Instance.DisplayID=InstanceTable.Column(3)
PhysicalDisk.Discovery.Instance.Model=InstanceTable.Column(10)
PhysicalDisk.Discovery.Instance.SerialNumber=InstanceTable.Column(11)
PhysicalDisk.Discovery.Instance.Size=InstanceTable.Column(12)
PhysicalDisk.Discovery.Instance.AdditionalInformation1=InstanceTable.Column(14)
PhysicalDisk.Discovery.Instance.AdditionalInformation2=InstanceTable.Column(15)

PhysicalDisk.Discovery.Instance.AttachedToDeviceID=InstanceTable.Column(2)

// Collect
// Collect type: MultiInstance
PhysicalDisk.Collect.Type="MultiInstance"

// Source(1) = PhysicalDisks
// Get XML from REST API Call
PhysicalDisk.Collect.Source(1).Type="HTTP"
PhysicalDisk.Collect.Source(1).Method="POST"
PhysicalDisk.Collect.Source(1).Url="/servlets/netapp.servlets.admin.XMLrequest_filer"
PhysicalDisk.Collect.Source(1).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><storage-shelf-info-get-iter/></netapp>"

PhysicalDisk.Collect.Source(1).Compute(1).Type="Awk"
PhysicalDisk.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(18)

// Source(2) = PhysicalDisks
PhysicalDisk.Collect.Source(2)=%PhysicalDisk.Collect.Source(1)%

// Xml2Cvs with Awk
// MSHW;shelf-id;bay-id;bay-has-disk;bay-type;bay-op-status;
PhysicalDisk.Collect.Source(2).Compute(1).Type="Awk"
PhysicalDisk.Collect.Source(2).Compute(1).AwkScript=EmbeddedFile(11)

// Translate bay-op-status into PatrolStatus
// MSHW;shelf-id;bay-id;bay-has-disk;bay-type;PatrolStatus;
PhysicalDisk.Collect.Source(2).Compute(2).Type="Translate"
PhysicalDisk.Collect.Source(2).Compute(2).Column=6
PhysicalDisk.Collect.Source(2).Compute(2).TranslationTable="PhysicalDiskTranslationTable"

PhysicalDiskTranslationTable("normal")="OK"
PhysicalDiskTranslationTable(Default)="ALARM"

// create uniqueID (Computes 3-4)
PhysicalDisk.Collect.Source(2).Compute(3).Type="LeftConcat"
PhysicalDisk.Collect.Source(2).Compute(3).Column=3
PhysicalDisk.Collect.Source(2).Compute(3).String="."

// MSHW;shelf;unique-id;bay-has-disk;bay-type;PatrolStatus;
PhysicalDisk.Collect.Source(2).Compute(4).Type="LeftConcat"
PhysicalDisk.Collect.Source(2).Compute(4).Column=3
PhysicalDisk.Collect.Source(2).Compute(4).String=Column(2)

// PhysicalDisk Value Table
// MSHW;shelf;unique-id;bay-has-disk;bay-type;PatrolStatus;
PhysicalDisk.Collect.ValueTable=%PhysicalDisk.Collect.Source(2)%
PhysicalDisk.Collect.DeviceID=ValueTable.Column(3)
PhysicalDisk.Collect.Status=ValueTable.Column(6)

//
// NetworkCard
//

// Discovery

// Source(1) = NetworkCards
// Get XML from REST API Call
NetworkCard.Discovery.Source(1).Type="HTTP"
NetworkCard.Discovery.Source(1).Method="POST"
NetworkCard.Discovery.Source(1).Url="/servlets/netapp.servlets.admin.XMLrequest_filer"
NetworkCard.Discovery.Source(1).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><net-port-get-iter/></netapp>"

// multi-line the xml response
NetworkCard.Discovery.Source(1).Compute(1).Type="Awk"
NetworkCard.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(18)

// Source(2) = NetworkCards
NetworkCard.Discovery.Source(2)=%NetworkCard.Discovery.Source(1)%

// Xml2Cvs with Awk
// MSHW;node;port;link-status;health-status;mac-address;operational-speed
NetworkCard.Discovery.Source(2).Compute(1).Type="Awk"
NetworkCard.Discovery.Source(2).Compute(1).AwkScript=EmbeddedFile(13)

// Add port identifying information for this source (always MAC and "Ethernet Port")
// MSHW;node;port;link-status;health-status;mac-address;operational-speed;physical-address-type;device-type
NetworkCard.Discovery.Source(2).Compute(2).Type="RightConcat"
NetworkCard.Discovery.Source(2).Compute(2).Column=7
NetworkCard.Discovery.Source(2).Compute(2).String=";MAC;Ethernet Port"

// Fiber ports
NetworkCard.Discovery.Source(3).Type="HTTP"
NetworkCard.Discovery.Source(3).Method="POST"
NetworkCard.Discovery.Source(3).Url="/servlets/netapp.servlets.admin.XMLrequest_filer"
NetworkCard.Discovery.Source(3).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><fcp-adapter-get-iter/></netapp>"

// multi-line the xml response
NetworkCard.Discovery.Source(3).Compute(1).Type="Awk"
NetworkCard.Discovery.Source(3).Compute(1).AwkScript=EmbeddedFile(18)

// Source(4) = Fiber Channels
NetworkCard.Discovery.Source(4)=%NetworkCard.Discovery.Source(3)%

// Xml2Cvs with Awk
// MSHW;node;adapter;link-status;status-description;mac;max-speed
NetworkCard.Discovery.Source(4).Compute(1).Type="Awk"
NetworkCard.Discovery.Source(4).Compute(1).AwkScript=EmbeddedFile(17)

// Multiply column 8 to convert gbit/s to mbit/s
NetworkCard.Discovery.Source(4).Compute(2).Type="Multiply"
NetworkCard.Discovery.Source(4).Compute(2).Column=7
NetworkCard.Discovery.Source(4).Compute(2).MultiplyBy="1000"

// Add port identifying information for this source (always WWN and "FC Port")
// MSHW;node;adapter;link-status;status-description;mac;max-speed;physical-address-type;device-type
NetworkCard.Discovery.Source(4).Compute(3).Type="RightConcat"
NetworkCard.Discovery.Source(4).Compute(3).Column=7
NetworkCard.Discovery.Source(4).Compute(3).String=";WWN;FC Port"

//Replace "0" with "" (computes 4-6)
NetworkCard.Discovery.Source(4).Compute(4).Type="LeftConcat"
NetworkCard.Discovery.Source(4).Compute(4).Column=7
NetworkCard.Discovery.Source(4).Compute(4).String="MSHW"

NetworkCard.Discovery.Source(4).Compute(5).Type="Replace"
NetworkCard.Discovery.Source(4).Compute(5).Column=7
NetworkCard.Discovery.Source(4).Compute(5).Replace="MSHW0"
NetworkCard.Discovery.Source(4).Compute(5).ReplaceBy=""

NetworkCard.Discovery.Source(4).Compute(6).Type="Replace"
NetworkCard.Discovery.Source(4).Compute(6).Column=7
NetworkCard.Discovery.Source(4).Compute(6).Replace="MSHW"
NetworkCard.Discovery.Source(4).Compute(6).ReplaceBy=""

// Source(5) Union of all Network Cards (Ethernet + FCs)
// Table1   // MSHW;node;port;link-status;health-status;mac-address;operational-speed;physical-address-type;device-type
// Table2   // MSHW;node;adapter;link-status;status-description;mac;max-speed;physical-address-type;device-type
NetworkCard.Discovery.Source(5).Type="TableUnion"
NetworkCard.Discovery.Source(5).Table1=%NetworkCard.Discovery.Source(2)%
NetworkCard.Discovery.Source(5).Table2=%NetworkCard.Discovery.Source(4)%

// Create uniqueID (computes 2-4)
// MSHW;node;port;port;link-status;health-status;mac-address;speed;physical-address-type;device-type
NetworkCard.Discovery.Source(5).Compute(1).Type="DuplicateColumn"
NetworkCard.Discovery.Source(5).Compute(1).Column=3

NetworkCard.Discovery.Source(5).Compute(2).Type="LeftConcat"
NetworkCard.Discovery.Source(5).Compute(2).Column=3
NetworkCard.Discovery.Source(5).Compute(2).String="."

// MSHW;node;uniqueId;port;link-status;health-status;mac-address;speed;physical-address-type;device-type
NetworkCard.Discovery.Source(5).Compute(3).Type="LeftConcat"
NetworkCard.Discovery.Source(5).Compute(3).Column=3
NetworkCard.Discovery.Source(5).Compute(3).String=Column(2)

// NetworkCard Instance Table
// MSHW;node;uniqueId;port;link-status;health-status;mac-address;link-speed;physical-address-type;device-type
NetworkCard.Discovery.InstanceTable=%NetworkCard.Discovery.Source(5)%
NetworkCard.Discovery.Instance.DeviceID=InstanceTable.Column(3)
NetworkCard.Discovery.Instance.DisplayID=InstanceTable.Column(4)
NetworkCard.Discovery.Instance.PhysicalAddress=InstanceTable.Column(7)
NetworkCard.Discovery.Instance.ParameterActivation.LinkSpeed=InstanceTable.Column(8)
NetworkCard.Discovery.Instance.PhysicalAddressType=InstanceTable.Column(9)
NetworkCard.Discovery.Instance.DeviceType=InstanceTable.Column(10)

NetworkCard.Discovery.Instance.AttachedToDeviceID=InstanceTable.Column(2)

//
// Collect

// Collection type (Multi-instance)
NetworkCard.Collect.Type="MultiInstance"

// Source(1) = NetworkCards
// Get XML from REST API Call
NetworkCard.Collect.Source(1).Type="HTTP"
NetworkCard.Collect.Source(1).Method="POST"
NetworkCard.Collect.Source(1).Url="/servlets/netapp.servlets.admin.XMLrequest_filer"
NetworkCard.Collect.Source(1).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><net-port-get-iter/></netapp>"

// xml to multi-line
NetworkCard.Collect.Source(1).Compute(1).Type="Awk"
NetworkCard.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(18)

// Source(2) = NetworkCards
NetworkCard.Collect.Source(2)=%NetworkCard.Collect.Source(1)%

// Xml2Cvs using AWK
// MSHW;node;port;link-status;health-status;mac-address;operational-speed
NetworkCard.Collect.Source(2).Compute(1).Type="Awk"
NetworkCard.Collect.Source(2).Compute(1).AwkScript=EmbeddedFile(13)

//Fiber Channels

// Source(1) = NetworkCards
// Get XML from REST API Call
NetworkCard.Collect.Source(3).Type="HTTP"
NetworkCard.Collect.Source(3).Method="POST"
NetworkCard.Collect.Source(3).Url="/servlets/netapp.servlets.admin.XMLrequest_filer"
NetworkCard.Collect.Source(3).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><fcp-adapter-get-iter/></netapp>"

// xml to multi-line
NetworkCard.Collect.Source(3).Compute(1).Type="Awk"
NetworkCard.Collect.Source(3).Compute(1).AwkScript=EmbeddedFile(18)

// Source(4) = Fiber Channels
NetworkCard.Collect.Source(4)=%NetworkCard.Collect.Source(3)%

// Xml2Cvs using AWK
// MSHW;node;adapter;link-status;status-description;mac;max-speed
NetworkCard.Collect.Source(4).Compute(1).Type="Awk"
NetworkCard.Collect.Source(4).Compute(1).AwkScript=EmbeddedFile(17)

NetworkCard.Collect.Source(4).Compute(2).Type="Multiply"
NetworkCard.Collect.Source(4).Compute(2).Column=7
NetworkCard.Collect.Source(4).Compute(2).MultiplyBy=1000

// Source(5) Union of all Network Cards (Ethernet + FCs)
// Table1   // MSHW;node;uniqueId;port;   link-status;health-status;     mac;speed
// Table2   // MSHW;node;uniqueID;adapter;link-status;status-description;mac;speed
NetworkCard.Collect.Source(5).Type="TableUnion"
NetworkCard.Collect.Source(5).Table1=%NetworkCard.Collect.Source(2)%
NetworkCard.Collect.Source(5).Table2=%NetworkCard.Collect.Source(4)%

// Duplicate status column (link status)
// MSHW;node;port;link-status;link-status;health-status;mac-address;operational-speed
NetworkCard.Collect.Source(5).Compute(1).Type="DuplicateColumn"
NetworkCard.Collect.Source(5).Compute(1).Column=4

// Duplicate status column (status information)
// MSHW;node;port;link-status;link-status;link-status;health-status;mac-address;operational-speed
NetworkCard.Collect.Source(5).Compute(2).Type="DuplicateColumn"
NetworkCard.Collect.Source(5).Compute(2).Column=4

// Translate NetworkCardStatus into PatrolStatus
// MSHW;node;port;PatrolStatus;link-status;link-status;health-status;mac-address;operational-speed
NetworkCard.Collect.Source(5).Compute(3).Type="Translate"
NetworkCard.Collect.Source(5).Compute(3).Column=4
NetworkCard.Collect.Source(5).Compute(3).TranslationTable="NetworkCardStatusTranslationTable"

NetworkCardStatusTranslationTable("inactive")="OK"
NetworkCardStatusTranslationTable("up")="OK"
NetworkCardStatusTranslationTable("no carrier")="OK"
NetworkCardStatusTranslationTable("online")="OK"
NetworkCardStatusTranslationTable("link not connected")="OK"
NetworkCardStatusTranslationTable(Default)="ALARM"

// Translate link-status status into LinkStatus
// MSHW;node;port;PatrolStatus;link-status;link-status;health-status;mac-address;operational-speed
NetworkCard.Collect.Source(5).Compute(4).Type="Translate"
NetworkCard.Collect.Source(5).Compute(4).Column=5
NetworkCard.Collect.Source(5).Compute(4).TranslationTable="LinkStatusTranslationTable"

// The NetworkCardStatusTranslationTable
LinkStatusTranslationTable("inactive")="WARN"
LinkStatusTranslationTable("up")="OK"
LinkStatusTranslationTable("no carrier")="WARN"
LinkStatusTranslationTable("online")="OK"
LinkStatusTranslationTable("link not connected")="WARN"
LinkStatusTranslationTable(Default)="WARN"

// Create uniqueID (computes 5-6)
// MSHW;node;unique-id;PatrolStatus;link-status;health-status;mac-address;operational-speed
NetworkCard.Collect.Source(5).Compute(5).Type="LeftConcat"
NetworkCard.Collect.Source(5).Compute(5).Column=3
NetworkCard.Collect.Source(5).Compute(5).String="."

NetworkCard.Collect.Source(5).Compute(6).Type="LeftConcat"
NetworkCard.Collect.Source(5).Compute(6).Column=3
NetworkCard.Collect.Source(5).Compute(6).String=Column(2)

// NetworkCard Value Table
// MSHW;node;unique-id;PatrolStatus;link-status;health-status;mac-address;operational-speed
NetworkCard.Collect.ValueTable=%NetworkCard.Collect.Source(5)%
NetworkCard.Collect.DeviceID=ValueTable.Column(3)
NetworkCard.Collect.Status=ValueTable.Column(4)
NetworkCard.Collect.LinkStatus=ValueTable.Column(5)
NetworkCard.Collect.StatusInformation=ValueTable.Column(6)
NetworkCard.Collect.LinkSpeed=ValueTable.Column(9)

//
// LogicalDisk
//

// Discovery

// Source(1) = Aggregate (raid) information
// Get XML from REST API Call
LogicalDisk.Discovery.Source(1).Type="HTTP"
LogicalDisk.Discovery.Source(1).Method="POST"
LogicalDisk.Discovery.Source(1).Url="/servlets/netapp.servlets.admin.XMLrequest_filer"
LogicalDisk.Discovery.Source(1).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><aggr-get-iter/></netapp>"

// XML to multi-line xml
LogicalDisk.Discovery.Source(1).Compute(1).Type="Awk"
LogicalDisk.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(18)

// Source(2) = Aggregate (raid) inforamtion
LogicalDisk.Discovery.Source(2)=%LogicalDisk.Discovery.Source(1)%

// Xml2Cvs using Awk
// MSHW;;aggregate-uuid;aggregate-name;raid-type;raid-status;
LogicalDisk.Discovery.Source(2).Compute(1).Type="Awk"
LogicalDisk.Discovery.Source(2).Compute(1).AwkScript=EmbeddedFile(14)

// Source(3) = Aggregate (raid) information (node)
LogicalDisk.Discovery.Source(3)=%LogicalDisk.Discovery.Source(1)%

// Xml2Cvs using Awk
// MSHW;node-name;aggregate-uuid;
LogicalDisk.Discovery.Source(3).Compute(1).Type="Awk"
LogicalDisk.Discovery.Source(3).Compute(1).AwkScript=EmbeddedFile(15)

// Source (4) Join Raid and Node information
// table1 // MSHW;         ;aggregate-uuid;aggregate-name;raid-type;raid-status;
// table2 // MSHW;node-name;aggregate-uuid;
LogicalDisk.Discovery.Source(4).Type="TableJoint"
LogicalDisk.Discovery.Source(4).LeftTable=%LogicalDisk.Discovery.Source(2)%
LogicalDisk.Discovery.Source(4).RightTable=%LogicalDisk.Discovery.Source(3)%
LogicalDisk.Discovery.Source(4).LeftKeyColumn=3
LogicalDisk.Discovery.Source(4).RightKeyColumn=3
LogicalDisk.Discovery.Source(4).DefaultRightLine=";;;;;;;"

// Move AttachedToDeviceID to column 2
LogicalDisk.Discovery.Source(4).Compute(1).Type="Replace"
LogicalDisk.Discovery.Source(4).Compute(1).Column=2
LogicalDisk.Discovery.Source(4).Compute(1).Replace=Column(2)
LogicalDisk.Discovery.Source(4).Compute(1).ReplaceBy=Column(8)

// LogicalDisk Instance Table
// MSHW;node-name;aggregate-uuid;aggregate-name;raid-type;raid-status;
LogicalDisk.Discovery.InstanceTable=%LogicalDisk.Discovery.Source(4)%
LogicalDisk.Discovery.Instance.DeviceID=InstanceTable.Column(3)
LogicalDisk.Discovery.Instance.DisplayID=InstanceTable.Column(4)
LogicalDisk.Discovery.Instance.RaidLevel=InstanceTable.Column(5)

LogicalDisk.Discovery.Instance.AttachedToDeviceID=InstanceTable.Column(2)

//
// Collection

// CollectionType (Multi-instance)
LogicalDisk.Collect.Type="MultiInstance"

// Source(1) = Aggregate (raid) information
// Get XML from REST API Call
LogicalDisk.Collect.Source(1).Type="HTTP"
LogicalDisk.Collect.Source(1).Method="POST"
LogicalDisk.Collect.Source(1).Url="/servlets/netapp.servlets.admin.XMLrequest_filer"
LogicalDisk.Collect.Source(1).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><aggr-get-iter/></netapp>"

// XML to multi-line XML
LogicalDisk.Collect.Source(1).Compute(1).Type="Awk"
LogicalDisk.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(18)

// Source(2) = Aggregate (raid) information
LogicalDisk.Collect.Source(2)=%LogicalDisk.Collect.Source(1)%

// Xml2Cvs using Awk
// MSHW;;aggregate-uuid;aggregate-name;raid-type;raid-status;
LogicalDisk.Collect.Source(2).Compute(1).Type="Awk"
LogicalDisk.Collect.Source(2).Compute(1).AwkScript=EmbeddedFile(14)

// Duplicate Raid Status for StatusInformation
// MSHW;node-name;aggregate-uuid;aggregate-name;raid-type;raid-status;StatusInformation;
LogicalDisk.Collect.Source(2).Compute(2).Type="DuplicateColumn"
LogicalDisk.Collect.Source(2).Compute(2).Column=6

//Array Translate Column(7) for raid-status1
//Replace "," with "|"
LogicalDisk.Collect.Source(2).Compute(3).Type="Replace"
LogicalDisk.Collect.Source(2).Compute(3).Column=6
LogicalDisk.Collect.Source(2).Compute(3).Replace=","
LogicalDisk.Collect.Source(2).Compute(3).ReplaceBy="|"

LogicalDisk.Collect.Source(2).Compute(4).Type="Replace"
LogicalDisk.Collect.Source(2).Compute(4).Column=6
LogicalDisk.Collect.Source(2).Compute(4).Replace=" "
LogicalDisk.Collect.Source(2).Compute(4).ReplaceBy=""

// To see what I'm inputting into array translate.
LogicalDisk.Collect.Source(3)=%LogicalDisk.Collect.Source(2)%

LogicalDisk.Collect.Source(3).Compute(1).Type="ArrayTranslate"
LogicalDisk.Collect.Source(3).Compute(1).Column=6
LogicalDisk.Collect.Source(3).Compute(1).TranslationTable="RaidStatusTranslationTable"

RaidStatusTranslationTable("normal")="OK"
RaidStatusTranslationTable("raid_dp")="UNKNOWN"
RaidStatusTranslationTable("mixed_raid_type")="UNKNOWN"
RaidStatusTranslationTable("hybrid")="UNKNOWN"
RaidStatusTranslationTable(Default)="ALARM"

// Convert PATROLStatusArray to a simple (unique) PATROLStatus
LogicalDisk.Collect.Source(3).Compute(2).Type="Convert"
LogicalDisk.Collect.Source(3).Compute(2).Column=6
LogicalDisk.Collect.Source(3).Compute(2).ConversionType="Array2SimpleStatus"

// Remove temporary work Column (and unneeded)
// MSHW;aggregate-uuid;raid-status;StatusInformation
LogicalDisk.Collect.Source(3).Compute(3).Type="KeepColumns"
LogicalDisk.Collect.Source(3).Compute(3).ColumnNumbers="1,3,6,7"

// LogicalDisk Value Table
// MSHW;aggregate-uuid;PatrolStatus;StatusInformation;
LogicalDisk.Collect.ValueTable=%LogicalDisk.Collect.Source(3)%
LogicalDisk.Collect.DeviceID=ValueTable.Column(2)
LogicalDisk.Collect.Status=ValueTable.Column(3)
LogicalDisk.Collect.StatusInformation=ValueTable.Column(4)

//
// DiskController
//

// Source(1) = Environment Sensors
// Get XML from REST API Call
DiskController.Discovery.Source(1).Type="HTTP"
DiskController.Discovery.Source(1).Method="POST"
DiskController.Discovery.Source(1).Url="/servlets/netapp.servlets.admin.XMLrequest_filer"
DiskController.Discovery.Source(1).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><environment-sensors-get-iter/></netapp>"

// xml to multi-line xml
DiskController.Discovery.Source(1).Compute(1).Type="Awk"
DiskController.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(18)

// Source(2) = Environment Sensors
DiskController.Discovery.Source(2)=%DiskController.Discovery.Source(1)%

// Xml2Cvs using awk
// MSHW;node-name;sensor-name;discrete-sensor-state;discrete-sensor-value;
DiskController.Discovery.Source(2).Compute(1).Type="Awk"
DiskController.Discovery.Source(2).Compute(1).AwkScript=EmbeddedFile(16)

// Keep only "SP Status" sensor-names (DiskController)
DiskController.Discovery.Source(2).Compute(2).Type="KeepOnlyMatchingLines"
DiskController.Discovery.Source(2).Compute(2).Column=3
DiskController.Discovery.Source(2).Compute(2).RegExp="SP Status"

// Create uniqueID (computes 3-5)
// MSHW;node-name;sensor-name;sensor-name;discrete-sensor-state;discrete-sensor-value;
DiskController.Discovery.Source(2).Compute(3).Type="DuplicateColumn"
DiskController.Discovery.Source(2).Compute(3).Column=3

DiskController.Discovery.Source(2).Compute(4).Type="LeftConcat"
DiskController.Discovery.Source(2).Compute(4).Column=3
DiskController.Discovery.Source(2).Compute(4).String="."

// MSHW;node-name;unique-id;sensor-name;discrete-sensor-state;discrete-sensor-value;
DiskController.Discovery.Source(2).Compute(5).Type="LeftConcat"
DiskController.Discovery.Source(2).Compute(5).Column=3
DiskController.Discovery.Source(2).Compute(5).String=Column(2)

// DiskController Instance Table
// MSHW;node-name;unique-id;sensor-name;discrete-sensor-state;discrete-sensor-value;
DiskController.Discovery.InstanceTable=%DiskController.Discovery.Source(2)%
DiskController.Discovery.Instance.DeviceID=InstanceTable.Column(3)
DiskController.Discovery.Instance.DisplayID=InstanceTable.Column(4)
DiskController.Discovery.Instance.AttachedToDeviceID=InstanceTable.Column(2)

//
// Collect

//Collection Type (Multi-instance)
DiskController.Collect.Type="MultiInstance"

//Source(1) = Environment Sensors
DiskController.Collect.Source(1).Type="HTTP"
DiskController.Collect.Source(1).Method="POST"
DiskController.Collect.Source(1).Url="/servlets/netapp.servlets.admin.XMLrequest_filer"
DiskController.Collect.Source(1).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><environment-sensors-get-iter/></netapp>"

//XML to multi-line XML
DiskController.Collect.Source(1).Compute(1).Type="Awk"
DiskController.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(18)

// Source(2) = Environment sensors
DiskController.Collect.Source(2)=%DiskController.Collect.Source(1)%

// Xml2Cvs using awk
// MSHW;node-name;sensor-name;discrete-sensor-state;discrete-sensor-value;
DiskController.Collect.Source(2).Compute(1).Type="Awk"
DiskController.Collect.Source(2).Compute(1).AwkScript=EmbeddedFile(16)

// Translate discrete-sensor-state to PatrolStatus
// MSHW;node-name;sensor-name;PatrolStatus;discrete-sensor-value;
DiskController.Collect.Source(2).Compute(2).Type="Translate"
DiskController.Collect.Source(2).Compute(2).Column=4
DiskController.Collect.Source(2).Compute(2).TranslationTable="DiskControllerStatusTranslationTable"

DiskControllerStatusTranslationTable("normal")="OK"
DiskControllerStatusTranslationTable(Default)="ALARM"

// Create uniqueID (computes 3-4)
DiskController.Collect.Source(2).Compute(3).Type="LeftConcat"
DiskController.Collect.Source(2).Compute(3).Column=3
DiskController.Collect.Source(2).Compute(3).String="."

// MSHW;node-name;unique-id;discrete-sensor-state;discrete-sensor-value;
DiskController.Collect.Source(2).Compute(4).Type="LeftConcat"
DiskController.Collect.Source(2).Compute(4).Column=3
DiskController.Collect.Source(2).Compute(4).String=Column(2)

// DiskController Value Table
DiskController.Collect.ValueTable=%DiskController.Collect.Source(2)%
DiskController.Collect.DeviceID=ValueTable.Column(3)
DiskController.Collect.ControllerStatus=ValueTable.Column(4)
DiskController.Collect.StatusInformation=ValueTable.Column(5)

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(1) = system-node-get-iter API call (XML2CSV awk script)
///
///    NB:
///    Returns:   MSHW;node;node-model;node-serial;product-version;cup-firmware-version;is-node-healthy
///
/////////////////////////////////////////////////////////
EmbeddedFile(1):
BEGIN{
  # Set the name for each object level
	InstanceLevel = "node-details-info"
	ParentLevel = ""
	GrandParentLevel = ""

  # Set the Properties to Extract
  # The number indicates which column that property will be put in
  # If you specify property[1] and property[3], you will end up with:
  # MSHW;propertyvalue1;;propertyvalue3;
	property[1] = "node"
	property[2] = "node-model"
	property[3] = "node-serial-number"
	property[4] = "product-version"
	property[5] = "cpu-firmware-version"
	property[6] = "is-node-healthy"

  # The rest of this script is standardized
  # and does not need to be edited
  #
  #
  # System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(1).End

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(2) = storage-shelf-info-get-iter API call (XML2CSV awk script)
///
///    NB:        Extra columns to match return from EmbeddedFile(1)
///    Returns:   MSHW;shelf;shelf-model;serial-number;;;op-status
///
/////////////////////////////////////////////////////////
EmbeddedFile(2):
BEGIN{
# Set the name for each object level

  	InstanceLevel = "storage-shelf-info"
		ParentLevel = ""
		GrandParentLevel = ""

# Set the Properties to Extract
# The number indicates which column that property will be put in
# If you specify property[1] and property[3], you will end up with:
# MSHW;propertyvalue1;;propertyvalue3;

	#storage-shelf-info
	property[1] = "shelf"
	property[2] = "shelf-model"
	property[3] = "serial-number"
	property[6] = "op-status"

# The rest of this script is standardized
# and does not need to be edited
#
#
# System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(2).End

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(3) = system-node-get-iter API call (XML2CSV awk script)
///
///    NB:        Node PSUs
///    Returns:   MSHW;node;env-failed-power-supply-count;env-failed-power-supply-message;
///
/////////////////////////////////////////////////////////
EmbeddedFile(3):
BEGIN{
  # Set the name for each object level
	InstanceLevel = "node-details-info"
	ParentLevel = ""
	GrandParentLevel = ""

  # Set the Properties to Extract
  # The number indicates which column that property will be put in
  # If you specify property[1] and property[3], you will end up with:
  # MSHW;propertyvalue1;;propertyvalue3;

  property[1] = "node"
	property[2] = "env-failed-power-supply-count"
	property[3] = "env-failed-power-supply-message"

  # The rest of this script is standardized
  # and does not need to be edited
  #
  #
  # System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(3).End

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(4) = storage-shelf-info-get-iter API call (XML2CSV awk script)
///
///    NB:        Shelf PSUs
///    Returns:   MSHW;shelf;psu-id;op-status;
///
/////////////////////////////////////////////////////////
EmbeddedFile(4):
BEGIN{
	# Set the name for each object level
  InstanceLevel = "storage-shelf-power-supply-unit-info"
	ParentLevel = "power-supply-units"
	GrandParentLevel = "storage-shelf-info"

  # Set the Properties to Extract
  # The number indicates which column that property will be put in
  # If you specify property[1] and property[3], you will end up with:
  # MSHW;propertyvalue1;;propertyvalue3;
	property[1] = "../../shelf"
	property[2] = "psu-id"
	property[3] = "psu-op-status"

  # The rest of this script is standardized
  # and does not need to be edited
  #
  #
  # System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(4).End

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(5) = system-node-get-iter API call (XML2CSV awk script)
///
///    NB:        Node Fans
///    Returns:   MSHW;node;env-failed-fan-count;env-failed-fan-message
///
/////////////////////////////////////////////////////////
EmbeddedFile(5):
BEGIN{
  # Set the name for each object level
  InstanceLevel = "node-details-info"
	ParentLevel = ""
	GrandParentLevel = ""

  # Set the Properties to Extract
  # The number indicates which column that property will be put in
  # If you specify property[1] and property[3], you will end up with:
  # MSHW;propertyvalue1;;propertyvalue3;
	property[1] = "node"
	property[2] = "env-failed-fan-count"
	property[3] = "env-failed-fan-message"

  # The rest of this script is standardized
  # and does not need to be edited
  #
  #
  # System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(5).End

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(6) = storage-shelf-info-get-iter API call (XML2CSV awk script)
///
///    NB:        Shelf Fans
///    Returns:   MSHW;shelf;fan-id;fan-op-status
///
/////////////////////////////////////////////////////////
EmbeddedFile(6):
BEGIN{
	# Set the name for each object level
  InstanceLevel = "storage-shelf-cooling-fan-info"
	ParentLevel = "cooling-fans"
	GrandParentLevel = "storage-shelf-info"

  # Set the Properties to Extract
  # The number indicates which column that property will be put in
  # If you specify property[1] and property[3], you will end up with:
  # MSHW;propertyvalue1;;propertyvalue3;
	property[1] = "../../shelf"
	property[2] = "fan-id"
	property[3] = "fan-op-status"

  # The rest of this script is standardized
  # and does not need to be edited
  #
  #
  # System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(6).End

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(7) = system-node-get-iter API call (XML2CSV awk script)
///
///    NB:        Node Batteries
///    Returns:   MSHW;node;nvram-battery-status
///
/////////////////////////////////////////////////////////
EmbeddedFile(7):
BEGIN{
  # Set the name for each object level
	InstanceLevel = "node-details-info"
	ParentLevel = ""
	GrandParentLevel = ""

  # Set the Properties to Extract
  # The number indicates which column that property will be put in
  # If you specify property[1] and property[3], you will end up with:
  # MSHW;propertyvalue1;;propertyvalue3;
	property[1] = "node"
	property[2] = "nvram-battery-status"

  # The rest of this script is standardized
  # and does not need to be edited
  #
  #
  # System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(7).End

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(8) = system-node-get-iter API call (XML2CSV awk script)
///
///    NB:        Node Temperature
///    Returns:   MSHW;node;env-over-temperature
///
/////////////////////////////////////////////////////////
EmbeddedFile(8):
BEGIN{
  # Set the name for each object level
	InstanceLevel = "node-details-info"
	ParentLevel = ""
	GrandParentLevel = ""

  # Set the Properties to Extract
  # The number indicates which column that property will be put in
  # If you specify property[1] and property[3], you will end up with:
  # MSHW;propertyvalue1;;propertyvalue3;
	property[1] = "node"
	property[2] = "env-over-temperature"

  # The rest of this script is standardized
  # and does not need to be edited
  #
  #
  # System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(8).End

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(9) = storage-shelf-info-get-iter API call (XML2CSV awk script)
///
///    NB:        Storage Shelf Temperatures
///    Returns:   MSHW;shelf;temp-sensor-id;temp-sens-op-status
///
/////////////////////////////////////////////////////////
EmbeddedFile(9):
BEGIN{
	# Set the name for each object level
  InstanceLevel = "storage-shelf-temperature-sensor-info"
	ParentLevel = "temperature-sensors"
	GrandParentLevel = "storage-shelf-info"

  # Set the Properties to Extract
  # The number indicates which column that property will be put in
  # If you specify property[1] and property[3], you will end up with:
  # MSHW;propertyvalue1;;propertyvalue3;
	property[1] = "../../shelf"
	property[2] = "temp-sensor-id"
	property[3] = "temp-sens-op-status"

  # The rest of this script is standardized
  # and does not need to be edited
  #
  #
  # System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(9).End

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(10) = storage-shelf-info-get-iter API call (XML2CSV awk script)
///
///    NB:        Storage Shelf Voltages
///    Returns:   MSHW;shelf;voltage-sensor-id;voltage-op-status
///
/////////////////////////////////////////////////////////
EmbeddedFile(10):
BEGIN{
	# Set the name for each object level
  InstanceLevel = "storage-shelf-voltage-sensor-info"
	ParentLevel = "voltage-sensors"
	GrandParentLevel = "storage-shelf-info"

  # Set the Properties to Extract
  # The number indicates which column that property will be put in
  # If you specify property[1] and property[3], you will end up with:
  # MSHW;propertyvalue1;;propertyvalue3;
	property[1] = "../../shelf"
	property[2] = "voltage-sensor-id"
	property[3] = "voltage-op-status"

  # The rest of this script is standardized
  # and does not need to be edited
  #
  #
  # System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(10).End

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(11) = storage-shelf-info-get-iter API call (XML2CSV awk script)
///
///    NB:        Storage Shelf Drive Bays
///    Returns:   MSHW;shelf;bay-id;bay-has-disk;bay-type;bay-op-status
///
/////////////////////////////////////////////////////////
EmbeddedFile(11):
BEGIN{
	# Set the name for each object level
  InstanceLevel = "storage-shelf-bay-info"
	ParentLevel = "shelf-bays"
	GrandParentLevel = "storage-shelf-info"

  # Set the Properties to Extract
  # The number indicates which column that property will be put in
  # If you specify property[1] and property[3], you will end up with:
  # MSHW;propertyvalue1;;propertyvalue3;
	property[1] = "../../shelf"
	property[2] = "bay-id"
	property[3] = "bay-has-disk"
	property[4] = "bay-type"
	property[5] = "bay-op-status"

  # The rest of this script is standardized
  # and does not need to be edited
  #
  #
  # System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(11).End

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(12) = storage-shelf-info-get-iter API call (XML2CSV awk script)
///
///    NB:        Storage Shelf Disks
///    Returns:   MSHW;disk-cluster-name;shelf-bay;model;serial-number;bytes-per-sector;capacity-sector;rpm;disk-type
///
/////////////////////////////////////////////////////////
EmbeddedFile(12):
BEGIN{
	# Set the name for each object level
  InstanceLevel = "disk-inventory-info"
	ParentLevel = "storage-disk-info"
	GrandParentLevel = "storage-shelf-info"

  # Set the Properties to Extract
  # The number indicates which column that property will be put in
  # If you specify property[1] and property[3], you will end up with:
  # MSHW;propertyvalue1;;propertyvalue3;
	property[1] = "disk-cluster-name"
	property[2] = "shelf-bay"
	property[3] = "model"
	property[4] = "serial-number"
	property[5] = "bytes-per-sector"
	property[6] = "capacity-sectors"
  property[7] = "rpm"
  property[8] = "disk-type"

  # The rest of this script is standardized
  # and does not need to be edited
  #
  #
  # System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(12).End

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(13) = <net-port-get-iter/> API call (XML2CSV awk script)
///
///    NB:        NetworkCard
///    Returns:   MSHW;node;port;link-status;health-status;mac-address;operational-speed
///
/////////////////////////////////////////////////////////
EmbeddedFile(13):
BEGIN{
	# Set the name for each object level
  InstanceLevel = "net-port-info"
	ParentLevel = ""
	GrandParentLevel = ""

  # Set the Properties to Extract
  # The number indicates which column that property will be put in
  # If you specify property[1] and property[3], you will end up with:
  # MSHW;propertyvalue1;;propertyvalue3;
	property[1] = "node"
	property[2] = "port"
	property[3] = "link-status"
	property[4] = "health-status"
	property[5] = "mac-address"
	property[6] = "operational-speed"

  # The rest of this script is standardized
  # and does not need to be edited
  #
  #
  # System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(13).End

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(14) = <aggr-get-iter/> API call (XML2CSV awk script)
///
///    NB:        Logical Disk
///    Returns:   MSHW;;aggregate-uuid;aggregate-name;raid-type;raid-status;
///
/////////////////////////////////////////////////////////
EmbeddedFile(14):
BEGIN{
	# Set the name for each object level
  InstanceLevel = "aggr-raid-attributes"
	ParentLevel = "aggr-attributes"
	GrandParentLevel = ""

  # Set the Properties to Extract
  # The number indicates which column that property will be put in
  # If you specify property[1] and property[3], you will end up with:
  # MSHW;propertyvalue1;;propertyvalue3;
	property[2] = "../aggregate-uuid"
	property[3] = "../aggregate-name"
	property[4] = "raid-type"
	property[5] = "raid-status"

  # The rest of this script is standardized
  # and does not need to be edited
  #
  #
  # System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(14).End

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(15) = <aggr-get-iter/> API call (XML2CSV awk script)
///
///    NB:        Logical Disk part 2
///    Returns:   MSHW;node-name;aggregate-uuid;
///
/////////////////////////////////////////////////////////
EmbeddedFile(15):
BEGIN{
	# Set the name for each object level
  InstanceLevel = "nodes"
	ParentLevel = "aggr-attributes"
	GrandParentLevel = ""

  # Set the Properties to Extract
  # The number indicates which column that property will be put in
  # If you specify property[1] and property[3], you will end up with:
  # MSHW;propertyvalue1;;propertyvalue3;
	property[1] = "node-name"
	property[2] = "../aggregate-uuid"

  # The rest of this script is standardized
  # and does not need to be edited
  #
  #
  # System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(15).End

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(16) = <environment-sensors-get-iter/> API call (XML2CSV awk script)
///
///    NB:        Environment Sensors
///    Returns:   MSHW;node-name;sensor-name;discrete-sensor-name;discrete-sensor-status;discrete-sensor-value
///
/////////////////////////////////////////////////////////
EmbeddedFile(16):
BEGIN{
	# Set the name for each object level
  InstanceLevel = "environment-sensors-info"
	ParentLevel = ""
	GrandParentLevel = ""

  # Set the Properties to Extract
  # The number indicates which column that property will be put in
  # If you specify property[1] and property[3], you will end up with:
  # MSHW;propertyvalue1;;propertyvalue3;
	property[1] = "node-name"
	property[2] = "sensor-name"
	property[3] = "discrete-sensor-state"
	property[4] = "discrete-sensor-value"

  # The rest of this script is standardized
  # and does not need to be edited
  #
  #
  # System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(16).End

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(17) = <fcp-adapter-get-iter/> API call (XML2CSV awk script)
///
///    NB:        Fiber Ports
///    Returns:   MSHW;node;adapter;link-status;status-description;mac;max-speed
///     ---
///    eth ref:   MSHW;node;port;link-status;health-status;mac-address;operational-speed
///
/////////////////////////////////////////////////////////
EmbeddedFile(17):
BEGIN{
	# Set the name for each object level
  InstanceLevel = "fcp-config-adapter-info"
	ParentLevel = ""
	GrandParentLevel = ""

  # Set the Properties to Extract
  # The number indicates which column that property will be put in
  # If you specify property[1] and property[3], you will end up with:
  # MSHW;propertyvalue1;;propertyvalue3;
	property[1] = "node"
	property[2] = "adapter"
	property[3] = "state"
	property[4] = "status-extended"
  property[5] = "port-name"
  property[6] = "data-link-rate"

  # The rest of this script is standardized
  # and does not need to be edited
  #
  #
  # System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(17).End


/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(18) = Converts XML into multi-line for other AWK Script to understand.
///
///    NB:
///    Returns:   Multiple Lines
///
/////////////////////////////////////////////////////////
EmbeddedFile(18):
{
	# the line contains multiple objects
	if ($0 ~ />.*>.*>.*>/) {
    line = $0
    xmlArraySize = split(line,xmlArray,">")
    for ( objectNumber = 1; objectNumber <= xmlArraySize ; objectNumber++ ) {
      name = xmlArray[objectNumber]
      gsub(/.*</,"",name)
      nextobjectNumber = objectNumber + 1
      nextname = xmlArray[nextobjectNumber]
      gsub(/.*</,"",nextname)
      # if the object is blank, or its the second part of an array ( data</objectname ), then skip
      if ( name != "" || xmlArray[objectNumber] ~ /^</ ) {
        # if the next object contains the same object name (basically it's the </object>) , then print both objects
        if ( nextname ~ name && xmlArray[objectNumber] ) {
          print xmlArray[objectNumber] ">" xmlArray[nextobjectNumber] ">" }
        # else just print the current object
        else { print xmlArray[objectNumber] ">" }
        }
      }
    }
  # else if it's in the header, just print the line
  else { print $0 }
}
EmbeddedFile(18).End
