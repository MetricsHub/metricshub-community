////////////////////////////////////////////////////////////////
//
//    H a r d w a r e   D e f i n i t i o n   F i l e
//
//                       f o r
//
//                  Hardware Sentry
//
//                 by Sentry Software (c)
//
//
//      Supports: KVM, QEMU, Xen, Hypervisors
//                Uses virsh commands to gather information
//
//


//
// Header
//

hdf.DisplayName="KVM, QEMU, Xen and Hypervisors (virsh)"
hdf.TypicalPlatform="KVM, QEMU, Xen, Hypervisors"
hdf.ReliesOn="libvirt API"
hdf.Version="1.0"
hdf.Comments="This connector provides VM monitoring through the virsh command. The host requires the libvirt API installed."
hdf.RemoteSupport="true"
hdf.AppliesToOS="Linux"

//
// DETECTION

// Verifying that the KMVersion is 11.3.00 or above, as the VM class did not exist prior to that version

Detection.Criteria(1).Type="KMVersion"
Detection.Criteria(1).Version="11.3.00"

// Launches a command to see if this device has an outpout for virsh list

Detection.Criteria(2).Type="OSCommand"
Detection.Criteria(2).CommandLine="virsh list"
Detection.Criteria(2).ExpectedResult="Name"

//
// VM
//

// Source(1)

VM.Discovery.Source(1).Type="OsCommand"
VM.Discovery.Source(1).CommandLine="virsh list | awk '{print $1}' | grep -oIE "[0-9]*" | while read word; do virsh dominfo ${word} ; done"

// Process the output through an Awk script
// vmName; powerState; powerShare; UUID

VM.Discovery.Source(1).Compute(1).Type="Awk"
VM.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(1)

// InstanceTable = source(1)
// vmName; powerState; powerShare; UUID

VM.Discovery.InstanceTable=%VM.Discovery.Source(1)%
VM.Discovery.Instance.DeviceID=InstanceTable.Column(1)
VM.Discovery.Instance.DisplayID=InstanceTable.Column(1)
VM.Discovery.Instance.Hostname=InstanceTable.Column(1)
VM.Discovery.Instance.AdditionalInformation1=InstanceTable.Column(4)
VM.Discovery.Instance.ParameterActivation.PowerConsumption=0

// Collect

VM.Collect.Type="MultiInstance"

// Source(1)

VM.Collect.Source(1).Type="OsCommand"
VM.Collect.Source(1).CommandLine="virsh list | awk '{print $1}' | grep -oIE "[0-9]*" | while read word; do virsh dominfo ${word} ; done"

// Process the output through an Awk script
// vmName; powerState; powerShare; UUID

VM.Collect.Source(1).Compute(1).Type="Awk"
VM.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(1)

// Translate state to recognized values

VM.Collect.Source(1).Compute(2).Type="Translate"
VM.Collect.Source(1).Compute(2).Column=2
VM.Collect.Source(1).Compute(2).TranslationTable="stateTranslationTable"

// ValueTable = source (1)
// vmName; powerState; powerShare; UUID

VM.Collect.ValueTable=%VM.Collect.Source(1)%
VM.Collect.DeviceID=ValueTable.Column(1)
VM.Collect.PowerState=ValueTable.Column(2)
VM.Collect.PowerShare=ValueTable.Column(3)

// Translation Table

stateTranslationTable("running")="ON"
stateTranslationTable("suspended")="OFF"
stateTranslationTable("paused")="SUSPENDED"
stateTranslationTable(default)="OFF"

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(1) = awk script that parses the output our virsh command
///
/////////////////////////////////////////////////////////
EmbeddedFile(1):

BEGIN { FS = ": "; vmName = ""; UUID = ""; powerState = ""; powerShare = ""}

/Name/ {vmName = $2; gsub(/ /,"",vmName)}
/UUID/ {uuid = $2; gsub(/ /,"",uuid)}
/State/ {powerState = $2; gsub(/ /,"",powerState)}
/CPU\(s\)/ {
  powerShare = $2; gsub(/ /,"",powerShare);
  print vmName ";" powerState ";" powerShare ";UUID: " uuid;
  vmName = ""; powerState = ""; powerShare = ""; uuid = "";
}

EmbeddedFile(1).End
