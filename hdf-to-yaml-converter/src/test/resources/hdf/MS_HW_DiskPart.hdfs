//
//
//                 C O N N E C T O R
//
//                       f o r
//
//                 Hardware Sentry
//
//              by Sentry Software (c)
//
//                MS_HW_DiskPart.hdf
//
//      Supports: Windows systems
//		Monitors: Logical disks (RAID sets)
//      Connects to: DISKPART.EXE
//
//

//
// HEADER
//

hdf.DisplayName="Windows - DiskPart"
hdf.TypicalPlatform="Any system"
hdf.ReliesOn="The DISKPART.EXE command-line utility"
hdf.Comments="Discovers and monitors the logical disks in a Microsoft Windows system through the DISKPART.EXE utility, notably the software RAID volumes."
hdf.Version="1.0"
hdf.RemoteSupport="false"
hdf.AppliesToOS="NT"

//
// DETECTION
//

// OS should be Windows
Detection.Criteria(1).Type="OS"
Detection.Criteria(1).KeepOnly="NT"

// Diskpart must be int he path and return something meaningful. Please note that we're using CHCP 437 to make sure the locale is English.
Detection.Criteria(2).Type="OSCommand"
Detection.Criteria(2).CommandLine="CHCP 437&&DISKPART.EXE /S %EmbeddedFile(3)%"
Detection.Criteria(2).ExpectedResult="Leaving DiskPart"
Detection.Criteria(2).Timeout=120

//
// NO COMPUTER
//

//
// LOGICAL DISKS
//

//
// Discovery

// Source(1) = DISKPART.EXE running "list volume" and "exit"
LogicalDisk.Discovery.Source(1).Type="OsCommand"
LogicalDisk.Discovery.Source(1).CommandLine="CHCP 437&&DISKPART.EXE /S %EmbeddedFile(1)%"
LogicalDisk.Discovery.Source(1).Timeout=120

// Run Source(1) through an AWK script
// ID;Label;Letter;VolumeType;FileSystem;Size;Status;MoreInformation
LogicalDisk.Discovery.Source(1).Compute(1).Type="Awk"
LogicalDisk.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(2)
LogicalDisk.Discovery.Source(1).Compute(1).Separators=";"
LogicalDisk.Discovery.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
LogicalDisk.Discovery.Source(1).Compute(1).SelectColumns="2,3,4,5,6,7,8,9"

// Exclude DVDs and stupid stuff
// ID;Label;Letter;VolumeType;FileSystem;Size;Status;MoreInformation
LogicalDisk.Discovery.Source(1).Compute(2).Type="ExcludeMatchingLines"
LogicalDisk.Discovery.Source(1).Compute(2).Column=4
LogicalDisk.Discovery.Source(1).Compute(2).ValueList="CD-ROM,DVD-ROM,Removable"

LogicalDisk.Discovery.Source(1).Compute(3).Type="LeftConcat"
LogicalDisk.Discovery.Source(1).Compute(3).Column=5
LogicalDisk.Discovery.Source(1).Compute(3).String="File System: "

LogicalDisk.Discovery.Source(1).Compute(4).Type="LeftConcat"
LogicalDisk.Discovery.Source(1).Compute(4).Column=8
LogicalDisk.Discovery.Source(1).Compute(4).String="Volume Information: "

// The InstanceTable
LogicalDisk.Discovery.InstanceTable=%LogicalDisk.Discovery.Source(1)%
LogicalDisk.Discovery.Instance.DeviceID=InstanceTable.Column(1)
LogicalDisk.Discovery.Instance.DisplayID=InstanceTable.Column(2)
LogicalDisk.Discovery.Instance.RAIDLevel=InstanceTable.Column(4)
LogicalDisk.Discovery.Instance.Size=InstanceTable.Column(6)
LogicalDisk.Discovery.Instance.AdditionalInformation1=InstanceTable.Column(5)
LogicalDisk.Discovery.Instance.AdditionalInformation2=InstanceTable.Column(8)

//
// Collect

// Collection is multi-instance
LogicalDisk.Collect.Type="MultiInstance"

// Source(1) = DISKPART.EXE running "list volume" and "exit"
LogicalDisk.Collect.Source(1).Type="OsCommand"
LogicalDisk.Collect.Source(1).CommandLine="CHCP 437&&DISKPART.EXE /S %EmbeddedFile(1)%"
LogicalDisk.Collect.Source(1).Timeout=120

// Run Source(1) through an AWK script
// ID;Status;
LogicalDisk.Collect.Source(1).Compute(1).Type="Awk"
LogicalDisk.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(2)
LogicalDisk.Collect.Source(1).Compute(1).Separators=";"
LogicalDisk.Collect.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
LogicalDisk.Collect.Source(1).Compute(1).SelectColumns="2,8"

// Duplicate the status column
// ID;Status;Status
LogicalDisk.Collect.Source(1).Compute(2).Type="DuplicateColumn"
LogicalDisk.Collect.Source(1).Compute(2).Column=2

// Now translate Status to Patrol Status
// status
LogicalDisk.Collect.Source(1).Compute(3).Type="Translate"
LogicalDisk.Collect.Source(1).Compute(3).Column=2
LogicalDisk.Collect.Source(1).Compute(3).TranslationTable="LogicalDiskTranslationTable"

// The LogicalDiskTranslationTable
LogicalDiskTranslationTable("Healthy")="OK"
LogicalDiskTranslationTable("Failed")="ALARM"
LogicalDiskTranslationTable("Failed Redundancy")="WARN"
LogicalDiskTranslationTable("Failed Rd")="WARN"
LogicalDiskTranslationTable("Formatting")="OK"
LogicalDiskTranslationTable("Regenerating")="WARN"
LogicalDiskTranslationTable("Rebuild")="WARN"
LogicalDiskTranslationTable("Resynching")="WARN"
LogicalDiskTranslationTable("Unknown")="ALARM"
LogicalDiskTranslationTable(Default)="UNKNOWN"

// ValueTable = Source(1)
LogicalDisk.Collect.ValueTable=%LogicalDisk.Collect.Source(1)%
LogicalDisk.Collect.DeviceID=ValueTable.Column(1)
LogicalDisk.Collect.Status=ValueTable.Column(2)
LogicalDisk.Collect.StatusInformation=ValueTable.Column(3)


////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(1) = very small DISKPART script to run "list volume" and then exit
///
/////////////////////////////////////////////////////////
EmbeddedFile(1):
list volume
exit
EmbeddedFile(1).End
/////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(2) = Awk script that takes the output of DISKPART's list volume
///                      and returns a properly formatted list of volumes
///
/////////////////////////////////////////////////////////
EmbeddedFile(2):
BEGIN {
	foundHeader = 0;
}
($1 == "Volume" && $2 == "###" && $3 == "Ltr" && $4 == "Label" && $5 == "Fs" && $6 == "Type" && $7 == "Size" && $8 == "Status" && $9 == "Info") {
	ltrIndex = index($0, "Ltr")
	labelIndex = index($0, "Label")
	fsIndex = index($0, "Fs")
	typeIndex = index($0, "Type")
	sizeIndex = index($0, "Size")
	statusIndex = index($0, "Status")
	infoIndex = index($0, "Info")
	foundHeader = 1;
}
($1 == "Volume" && $2 ~ /^[0-9]+$/ && foundHeader == 1) {

	# Get the fields
	volumeID = $2;
	letter = substr($0, ltrIndex, 3);
	label = substr($0, labelIndex, fsIndex - labelIndex);
	fs = substr($0, fsIndex, typeIndex - fsIndex);
	type = substr($0, typeIndex, sizeIndex - typeIndex);
	sizeT = substr($0, sizeIndex, statusIndex - sizeIndex);
	status = substr($0, statusIndex, infoIndex - statusIndex);
	info = substr($0, infoIndex, length($0) - infoIndex + 1);

	# Do some processing, remove unnecessary white spaces
	gsub(" ", "", letter);
	sub("^ +", "", label); sub(" +$", "", label);
	sub("^ +", "", fs); sub(" +$", "", fs);
	sub("^ +", "", type); sub(" +$", "", type);
	gsub(" ", "", sizeT);
	sub("^ +", "", status); sub(" +$", "", status);
	sub("^ +", "", info); sub(" +$", "", info);

	# Convert size to bytes
	size = "";
	if (substr(sizeT, length(sizeT), 1) == "B")
	{
		size = substr(sizeT, 1, length(sizeT) - 1);

		# Handle unit multipliers
		if (substr(size, length(size), 1) == "K")
		{
			size = substr(size, 1, length(size) - 1) * 1024;
		}
		else if (substr(size, length(size), 1) == "M")
		{
			size = substr(size, 1, length(size) - 1) * 1024 * 1024;
		}
		else if (substr(size, length(size), 1) == "G")
		{
			size = substr(size, 1, length(size) - 1) * 1024 * 1024 * 1024;
		}
		else if (substr(size, length(size), 1) == "T")
		{
			size = substr(size, 1, length(size) - 1) * 1024 * 1024 * 1024 * 1024;
		}

		# Make sure we got a number
		if (size !~ /^[0-9]+$/)
		{
			size = "";
		}
	}

	# Add a colon to the drive letter, if any
	if (letter ~ /^[A-Z]$/)
	{
		letter = letter ":"
	}

	# Build the displayID from label and letter
	if (letter != "" && label != "")
	{
		displayID = letter " - " label;
	}
	else if (letter != "" && label == "")
	{
		displayID = letter;
	}
	else if (letter == "" && label != "")
	{
		displayID = label;
	}
	else
	{
		displayID = "";
	}

	# Replace "Partition" type with nothing
	if (type == "Partition")
	{
		type = "";
	}

	print "MSHW;" volumeID ";" displayID ";" letter ";" type ";" fs ";" size ";" status ";" info ";"
}
EmbeddedFile(2).End
/////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(3) = even smaller DISKPART script that does nothing but exit
///
/////////////////////////////////////////////////////////
EmbeddedFile(3):
exit
EmbeddedFile(3).End
/////////////////////////////////////////////////////////////////////
