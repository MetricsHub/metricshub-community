//
//
//                 C O N N E C T O R
//
//                       f o r
//
//                 Hardware Sentry
//
//                 by Sentry Software (c)
//
//                   MS_HW_IBMVIOS.hdf
//
//      Supports: IBM AIX machines
//		Monitors: network interfaces, processors
//      Connects to: different AIX standard tools
//
//
// NOTES:  Environmental information will needed to be collected from an LPAR
//  Any network cards exclusively allocated to an LPAR will also need to be monitored from that LPAR
// ioscli is the restricted shell command

// Include MS_HW_IBMAIXModels.hhdf, which contains the translation table for the AIX model codes
#include MS_HW_IBMAIXModels.hhdf

//
// HEADER
//

hdf.DisplayName="IBM VIO Server"
hdf.TypicalPlatform="IBM POWER"
hdf.ReliesOn="IBM AIX system commands through the IOS interface (lsdev, entstat, etc.)"
hdf.Comments="Provides hardware status information (processors, memory modules, network interfaces, HBAs, physical disks) on IBM VIO systems."
hdf.Version="1.3"
hdf.RemoteSupport="true"
hdf.AppliesToOS="RS6000"
hdf.Supersedes="MS_HW_IBMAIX.hdf,MS_HW_IBMAIXChrpMachstat.hdf,MS_HW_IBMAIXDisk.hdf,MS_HW_IBMAIXHBA.hdf,MS_HW_IBMAIXUeSensor.hdf"

//
// DETECTION
//

// OS should be AIX (whatever version)
Detection.Criteria(1).Type="OS"
Detection.Criteria(1).KeepOnly="RS6000"

// uname should return vioserver
Detection.Criteria(2).Type="OSCommand"
Detection.Criteria(2).CommandLine="ioscli uname -a"
Detection.Criteria(2).ExpectedResult="AIX"



//
// Discovery

// Source(1) = the output of uname -M
// MachineIDNumber;ModelCode;SystemID;LPARSystemID;
Enclosure.Discovery.Source(1).Type="OsCommand"
Enclosure.Discovery.Source(1).CommandLine="ioscli uname -mMfF"
Enclosure.Discovery.Source(1).KeepOnlyRegExp=" IBM,"
Enclosure.Discovery.Source(1).Separators=" "
Enclosure.Discovery.Source(1).SelectColumns="1,2,3,4"

// Duplicate the MachineIDNumber
// MachineIDNumber;MachineIDNumber;ModelCode;LPARSystemID;SystemID;
Enclosure.Discovery.Source(1).Compute(1).Type="DuplicateColumn"
Enclosure.Discovery.Source(1).Compute(1).Column=1

// Remove the IBM,  (We, unfortunately, already know it's an IBM)
// MachineIDNumber;MachineIDNumber;ModelCode;LPARSystemID;SystemID;
Enclosure.Discovery.Source(1).Compute(2).Type="Replace"
Enclosure.Discovery.Source(1).Compute(2).Column=3
Enclosure.Discovery.Source(1).Compute(2).Replace="IBM,"
Enclosure.Discovery.Source(1).Compute(2).ReplaceBy=""

// Add descriptive prefixes to the different IDs
// MachineIDNumber;MachineIDNumber;ModelCode;LPARSystemID;SystemID;
Enclosure.Discovery.Source(1).Compute(3).Type="LeftConcat"
Enclosure.Discovery.Source(1).Compute(3).Column=2
Enclosure.Discovery.Source(1).Compute(3).String="Machine ID: "

Enclosure.Discovery.Source(1).Compute(4).Type="LeftConcat"
Enclosure.Discovery.Source(1).Compute(4).Column=4
Enclosure.Discovery.Source(1).Compute(4).String="LPAR System ID: "

Enclosure.Discovery.Source(1).Compute(5).Type="LeftConcat"
Enclosure.Discovery.Source(1).Compute(5).Column=5
Enclosure.Discovery.Source(1).Compute(5).String="System ID: "

// Duplicate the ModelCode
// MachineIDNumber;MachineIDNumber;ModelCode;ModelCode;LPARSystemID;SystemID;
Enclosure.Discovery.Source(1).Compute(6).Type="DuplicateColumn"
Enclosure.Discovery.Source(1).Compute(6).Column=3

// Translate the 2nd Model Code into a Model Name
// The translation table will need to be regularly updated
// MachineIDNumber;MachineIDNumber;ModelCode;ModelName;LPARSystemID;SystemID;
Enclosure.Discovery.Source(1).Compute(7).Type="Translate"
Enclosure.Discovery.Source(1).Compute(7).Column=4
Enclosure.Discovery.Source(1).Compute(7).TranslationTable="ModelTranslationTable"

// The discovery table
// MachineIDNumber;MachineIDNumber;ModelCode;ModelName;LPARSystemID;SystemID;
Enclosure.Discovery.InstanceTable=%Enclosure.Discovery.Source(1)%
Enclosure.Discovery.Instance.DeviceID=InstanceTable.Column(3)
Enclosure.Discovery.Instance.DisplayID=InstanceTable.Column(3)
Enclosure.Discovery.Instance.Vendor="IBM"
Enclosure.Discovery.Instance.Model=InstanceTable.Column(4)
Enclosure.Discovery.Instance.Type="Computer"
Enclosure.Discovery.Instance.SerialNumber=InstanceTable.Column(1)
Enclosure.Discovery.Instance.AdditionalInformation1=InstanceTable.Column(2)
Enclosure.Discovery.Instance.AdditionalInformation2=InstanceTable.Column(6)
Enclosure.Discovery.Instance.AdditionalInformation3=InstanceTable.Column(5)


//
// CPUS
//

//
// Discovery

// Source(1) = lsdev
// cpuID;
cpu.Discovery.Source(1).Type="OsCommand"
cpu.Discovery.Source(1).CommandLine="ioscli lsdev -field name"
cpu.Discovery.Source(1).Separators=","
cpu.Discovery.Source(1).KeepOnlyRegExp="^proc"


// Instance table = source(1)
cpu.Discovery.InstanceTable=%cpu.Discovery.Source(1)%
cpu.Discovery.Instance.DeviceID=InstanceTable.Column(1)
//cpu.Discovery.Instance.AttachedToDeviceID="AIX"
//cpu.Discovery.Instance.AttachedToDeviceType="Computer"


//
// Collect

// Collect type is multi-instance
cpu.Collect.Type="MultiInstance"

cpu.Collect.Source(1).Type="OsCommand"
cpu.Collect.Source(1).CommandLine="ioscli lsdev -fmt : -field name status"
cpu.Collect.Source(1).KeepOnlyRegExp="^proc"
cpu.Collect.Source(1).Separators=":"
cpu.Collect.Source(1).SelectColumns="1,2"

// Duplicate the status column
// cpuID;cpuStatus;cpuStatus
cpu.Collect.Source(1).Compute(1).Type="DuplicateColumn"
cpu.Collect.Source(1).Compute(1).Column="2"

// Translate the first status column into a PATROL status
// cpuID;PATROLStatus;cpuStatus
cpu.Collect.Source(1).Compute(2).Type="Translate"
cpu.Collect.Source(1).Compute(2).Column="2"
cpu.Collect.Source(1).Compute(2).TranslationTable="cpuStatusTranslationTable"

// Translate the second status column into a more readable string
// cpuID;PATROLStatus;statusInformation
cpu.Collect.Source(1).Compute(3).Type="Translate"
cpu.Collect.Source(1).Compute(3).Column="3"
cpu.Collect.Source(1).Compute(3).TranslationTable="cpuStatusInformationTranslationTable"


//  "ValueTable = source(1)
cpu.Collect.ValueTable=%cpu.Collect.Source(1)%
cpu.Collect.DeviceID=ValueTable.Column(1)
cpu.Collect.Status=ValueTable.Column(2)
cpu.Collect.StatusInformation=ValueTable.Column(3)

// The cpuStatusTranslationTable
cpuStatusTranslationTable("Available")="OK"
cpuStatusTranslationTable("Defined")="OK"
cpuStatusTranslationTable("Stopped")="WARN"
cpuStatusTranslationTable(Default)="UNKNOWN"

// The cpuStatusInformationTranslationTable
cpuStatusInformationTranslationTable("Available")="Available"
cpuStatusInformationTranslationTable("Defined")="Defined"
cpuStatusInformationTranslationTable("Stopped")="Stopped"
cpuStatusInformationTranslationTable(Default)="Unknown Status"

//
// Memory Modules
//

//
// Discovery

// Source(1) = output of ioscli lsdev -vpd
Memory.Discovery.Source(1).Type="OsCommand"
Memory.Discovery.Source(1).CommandLine="ioscli lsdev -vpd"

// Reformat lscfg's output through awk (see EmbeddedFile(6))
// DeviceID;Size;SerialNumber
Memory.Discovery.Source(1).Compute(1).Type="Awk"
Memory.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(6)
Memory.Discovery.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
Memory.Discovery.Source(1).Compute(1).Separators=";"
Memory.Discovery.Source(1).Compute(1).SelectColumns="2,3,4"

// Add ";1;" to the DeviceID that will correspond to the Status and ErrorCount ParameterActivation values
// DeviceID;StatusActivation;ErrorCountActivation;Size;SerialNumber
Memory.Discovery.Source(1).Compute(2).Type="RightConcat"
Memory.Discovery.Source(1).Compute(2).Column=1
Memory.Discovery.Source(1).Compute(2).String=";1;"

// Source(2) = Static table to represent the global memory stuff
Memory.Discovery.Source(2)="Memory Controller;;1;;;"

// Source(3) = Union of Source(1) and Source(2)
// DeviceID;StatusActivation;ErrorCountActivation;Size;SerialNumber
Memory.Discovery.Source(3).Type="TableUnion"
Memory.Discovery.Source(3).Table1=%Memory.Discovery.Source(1)%
Memory.Discovery.Source(3).Table2=%Memory.Discovery.Source(2)%

// Source (4) = Date + Complete Errorlog
// Not used in Discovery, it is used in the collect.  But as it can be a large file and we don't want to collect it
// too often, "true" memory collects will only be done once per hour.
Memory.Discovery.Source(4).Type="OsCommand"
Memory.Discovery.Source(4).CommandLine="ioscli errlog -ls | grep -c -E ""CORRECTED_SCRUB||MEM[0-9]||RECOV_ECC_ERR||CORRECTED_SCRUB"""

// Add the Memory Controller Identifier
// DeviceID;Status;StatusInformation;ErrorCount
Memory.Discovery.Source(4).Compute(1).Type="LeftConcat"
Memory.Discovery.Source(4).Compute(1).Column=1
Memory.Discovery.Source(4).Compute(1).String="Memory Controller;;;"

// InstanceTable = Source(1)
Memory.Discovery.InstanceTable=%Memory.Discovery.Source(3)%
Memory.Discovery.Instance.DeviceID=InstanceTable.Column(1)
Memory.Discovery.Instance.Size=InstanceTable.Column(4)
Memory.Discovery.Instance.SerialNumber=InstanceTable.Column(5)
Memory.Discovery.Instance.ParameterActivation.Status=InstanceTable.Column(2)
Memory.Discovery.Instance.ParameterActivation.ErrorCount=InstanceTable.Column(3)
//Memory.Discovery.Instance.AttachedToDeviceID="AIX"
//Memory.Discovery.Instance.AttachedToDeviceType="Computer"



//
// Collect

// Collect type is multi-instance
Memory.Collect.Type="MultiInstance"

// Source(1) = output of ioscli lsdev -vpd
Memory.Collect.Source(1).Type="OsCommand"
Memory.Collect.Source(1).CommandLine="ioscli lsdev -vpd"

// Reformat lsdev's output through awk (see EmbeddedFile(6))
// DeviceID;Status;StatusInformation;
Memory.Collect.Source(1).Compute(1).Type="Awk"
Memory.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(6)
Memory.Collect.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
Memory.Collect.Source(1).Compute(1).Separators=";"
Memory.Collect.Source(1).Compute(1).SelectColumns="2,5,6"


// Add ";" to the right, as an empty ErrorCount column
// DeviceID;Status;StatusInformation;ErrorCount
Memory.Collect.Source(1).Compute(2).Type="RightConcat"
Memory.Collect.Source(1).Compute(2).Column=3
Memory.Collect.Source(1).Compute(2).String=";"

// Source(4) = Number of events reported by errlog of type "memory"
// this is done in discovery
// DeviceID;Status;StatusInformation;ErrorCount
Memory.Collect.Source(2)=%Memory.Discovery.Source(4)%

// Source(3) = Union of Source(1) and Source(2)
Memory.Collect.Source(3).Type="TableUnion"
Memory.Collect.Source(3).Table1=%Memory.Collect.Source(1)%
Memory.Collect.Source(3).Table2=%Memory.Collect.Source(2)%

// Value table = Source(1)
Memory.Collect.ValueTable=%Memory.Collect.Source(3)%
Memory.Collect.DeviceID=ValueTable.Column(1)
Memory.Collect.Status=ValueTable.Column(2)
Memory.Collect.StatusInformation=ValueTable.Column(3)
Memory.Collect.ErrorCount=ValueTable.Column(4)

//
// DISK CONTROLLERS
//

//
// Discovery

// Source(1) = output of lsdev - list of disk "parents"
// diskDevicePath
DiskController.Discovery.Source(1).Type="OsCommand"
DiskController.Discovery.Source(1).CommandLine="ioscli lsdev -field physloc -type disk"

// Retrieve the controller device path from the disk device path
// controllerDevicePath; (may be several identical instances)
DiskController.Discovery.Source(1).Compute(1).Type="SubString"
DiskController.Discovery.Source(1).Compute(1).Column="1"
DiskController.Discovery.Source(1).Compute(1).Start="1"
DiskController.Discovery.Source(1).Compute(1).Length="5"

// Source(2) = output of lsdev -field name physloc description -fmt : -type adapter
// adapterDevicePath;DeviceID;displayName;
DiskController.Discovery.Source(2).Type="OsCommand"
DiskController.Discovery.Source(2).CommandLine="ioscli lsdev -field physloc name description -fmt : -type adapter"
DiskController.Discovery.Source(2).Separators=":"
DiskController.Discovery.Source(2).SelectColumns="1,2,3"

// Keep only scsi[0-9]* disk controllers (not RAID or SSA)
// adapterDevicePath;DeviceID;displayName
DiskController.Discovery.Source(2).Compute(1).Type="KeepOnlyMatchingLines"
DiskController.Discovery.Source(2).Compute(1).Column="2"
DiskController.Discovery.Source(2).Compute(1).RegExp="\(^sisscsi[A-Za-z0-9]+$\)\|\(^scsi[A-Za-z0-9]+$\)\|\(^sisio[A-Za-z0-9]+$\)\|\(^sissas[A-Za-z0-9]+$\)"

// Retrieve the controller device path from the disk device path
// adapterDevicePath;DeviceID;displayName
DiskController.Discovery.Source(2).Compute(2).Type="SubString"
DiskController.Discovery.Source(2).Compute(2).Column="1"
DiskController.Discovery.Source(2).Compute(2).Start="1"
DiskController.Discovery.Source(2).Compute(2).Length="5"

// Source(3) = Table joint of Source(1) and Source(2)
// This jointure will make MSHW keep only adapters that are disk controllers
// with disks attached to them
// adapterDevicePath;DeviceID;displayName;controllerDevicePath
DiskController.Discovery.Source(3).Type="TableJoint"
DiskController.Discovery.Source(3).LeftTable=%DiskController.Discovery.Source(2)%
DiskController.Discovery.Source(3).RightTable=%DiskController.Discovery.Source(1)%
DiskController.Discovery.Source(3).LeftKeyColumn="1"
DiskController.Discovery.Source(3).RightKeyColumn="1"

// InstanceTable = Source(5)
DiskController.Discovery.InstanceTable=%DiskController.Discovery.Source(3)%
DiskController.Discovery.Instance.DeviceID=InstanceTable.Column(2)
DiskController.Discovery.Instance.ControllerNumber=InstanceTable.Column(4)
DiskController.Discovery.Instance.Model=InstanceTable.Column(3)

// Source (4) = Complete Errorlog
// Not used in Discovery, it is used in the collect.  But as it can be a large file and we don't want to collect it
// too often, "true" Disk Controller / PhysicalDisk errocount will only be done once per hour.
DiskController.Discovery.Source(4).Type="OsCommand"
DiskController.Discovery.Source(4).CommandLine="date +MSHW_DATE%%m%%d0000%%y;datestring=`date +%%m%%d`;ioscli errlog | grep $datestring"

// Parsing this through an awk script
// DeviceID;ErrorCount;
DiskController.Discovery.Source(4).Compute(1).Type="Awk"
DiskController.Discovery.Source(4).Compute(1).AwkScript=EmbeddedFile(7)
DiskController.Discovery.Source(4).Compute(1).KeepOnlyRegExp="^MSHW;"
DiskController.Discovery.Source(4).Compute(1).Separators=";"
DiskController.Discovery.Source(4).Compute(1).SelectColumns="2,3"


//
// Collect

// Collect type = multi-instance
DiskController.Collect.Type="MultiInstance"

// Table Join Discovery Source (3) - Instance Table, with Discovery Table (4) - Errorcounts
// adapterDevicePath;DeviceID;displayName;controllerDevicePath;DeviceID;ErrorCount;
DiskController.Collect.Source(1).Type="TableJoint"
DiskController.Collect.Source(1).LeftTable=%DiskController.Discovery.Source(3)%
DiskController.Collect.Source(1).RightTable=%DiskController.Discovery.Source(4)%
DiskController.Collect.Source(1).LeftKeyColumn="2"
DiskController.Collect.Source(1).RightKeyColumn="1"
DiskController.Collect.Source(1).DefaultRightLine=";0;"

// Duplicate the ErrorCount Column
// adapterDevicePath;DeviceID;displayName;controllerDevicePath;DeviceID;ErrorCount;ErrorCount;
DiskController.Collect.Source(1).Compute(1).Type="DuplicateColumn"
DiskController.Collect.Source(1).Compute(1).Column="6"

// Translate the errorcount into a status (as errorcount does not exist for Disk Controllers)
// adapterDevicePath;DeviceID;displayName;controllerDevicePath;DeviceID;PatrolStatus;ErrorCount;
DiskController.Collect.Source(1).Compute(2).Type="Translate"
DiskController.Collect.Source(1).Compute(2).Column=6
DiskController.Collect.Source(1).Compute(2).TranslationTable="ErrorcounttoStatusTranslationTable"

// The PhysicalDiskStatusTranslationTable
ErrorcounttoStatusTranslationTable(0)="OK"
ErrorcounttoStatusTranslationTable(Default)="ALARM"

// Translate the errorcount into a status (as errorcount does not exist for Disk Controllers)
// adapterDevicePath;DeviceID;displayName;controllerDevicePath;DeviceID;PatrolStatus;PatrolStatusInfo;
DiskController.Collect.Source(1).Compute(3).Type="Translate"
DiskController.Collect.Source(1).Compute(3).Column=7
DiskController.Collect.Source(1).Compute(3).TranslationTable="ErrorcounttoStatusInformationTranslationTable"

// The ErrorcounttoStatusInformationTranslationTable
ErrorcounttoStatusInformationTranslationTable(0)="No Disk Controller Events found today (Parameter only collects every hour)"
ErrorcounttoStatusInformationTranslationTable(Default)="Disk Controller Events found today - Run errlog for more details"


// ValueTable = Source(1)
// adapterDevicePath;DeviceID;displayName;controllerDevicePath;DeviceID;PatrolStatus;PatrolStatusInfo;
DiskController.Collect.ValueTable=%DiskController.Collect.Source(1)%
DiskController.Collect.ControllerStatus=ValueTable.Column(6)
DiskController.Collect.StatusInformation=ValueTable.Column(7)
DiskController.Collect.DeviceID=ValueTable.Column(2)


//
// PHYSICAL DISKS
//

//
// Discovery

// Source(1) = output of ioscli lsdev -field physloc -type disk
// diskName;diskPath
PhysicalDisk.Discovery.Source(1).Type="OsCommand"
PhysicalDisk.Discovery.Source(1).CommandLine="ioscli lsdev -fmt : -field name physloc -type disk"
PhysicalDisk.Discovery.Source(1).KeepOnlyRegExp="^hdisk"
PhysicalDisk.Discovery.Source(1).Separators=":"
PhysicalDisk.Discovery.Source(1).SelectColumns="1,2"

// Keep only the first 5 chars of the diskPath to obtain the diskControllerID
// DeviceID;controllerID
PhysicalDisk.Discovery.Source(1).Compute(1).Type="Substring"
PhysicalDisk.Discovery.Source(1).Compute(1).Column="2"
PhysicalDisk.Discovery.Source(1).Compute(1).Start="1"
PhysicalDisk.Discovery.Source(1).Compute(1).Length="5"

// Source(1) = output of ioscli lsdev -vpd
PhysicalDisk.Discovery.Source(2).Type="OsCommand"
PhysicalDisk.Discovery.Source(2).CommandLine="ioscli lsdev -vpd"

// Reformat lsdev's output through awk (see EmbeddedFile(3))
// DeviceID;size;make-model-FRU;Serial;
PhysicalDisk.Discovery.Source(2).Compute(1).Type="Awk"
PhysicalDisk.Discovery.Source(2).Compute(1).AwkScript=EmbeddedFile(3)
PhysicalDisk.Discovery.Source(2).Compute(1).KeepOnlyRegExp="^MSHW;"
PhysicalDisk.Discovery.Source(2).Compute(1).Separators=";"
PhysicalDisk.Discovery.Source(2).Compute(1).SelectColumns="2,3,4,5"

// Source(3) = Table joint of Source(1) and Source(2)
// DeviceID;controllerID;DeviceID;size;make-model-FRU;Serial;
PhysicalDisk.Discovery.Source(3).Type="TableJoint"
PhysicalDisk.Discovery.Source(3).LeftTable=%PhysicalDisk.Discovery.Source(1)%
PhysicalDisk.Discovery.Source(3).RightTable=%PhysicalDisk.Discovery.Source(2)%
PhysicalDisk.Discovery.Source(3).LeftKeyColumn=1
PhysicalDisk.Discovery.Source(3).RightKeyColumn=1

// Translate size into bytes
// DeviceID;controllerID;DeviceID;size;make-model-FRU;Serial;
PhysicalDisk.Discovery.Source(3).Compute(1).Type="Multiply"
PhysicalDisk.Discovery.Source(3).Compute(1).Column=4
PhysicalDisk.Discovery.Source(3).Compute(1).MultiplyBy="1073741824"

// Now we are ready to go
// InstanceTable = Source(4)
// DeviceID;controllerID;DeviceID;size;make-model-FRU;Serial;
PhysicalDisk.Discovery.InstanceTable=%PhysicalDisk.Discovery.Source(3)%
PhysicalDisk.Discovery.Instance.DeviceID=InstanceTable.Column(1)
PhysicalDisk.Discovery.Instance.ControllerNumber=InstanceTable.Column(2)
PhysicalDisk.Discovery.Instance.Size=InstanceTable.Column(4)
PhysicalDisk.Discovery.Instance.Vendor=InstanceTable.Column(5)
PhysicalDisk.Discovery.Instance.SerialNumber=InstanceTable.Column(6)


//
// Collect

// Collect type is multi-instance
PhysicalDisk.Collect.Type="MultiInstance"

PhysicalDisk.Collect.Source(1).Type="OsCommand"
PhysicalDisk.Collect.Source(1).CommandLine="ioscli lsdev -fmt : -field name status"
PhysicalDisk.Collect.Source(1).KeepOnlyRegExp="^hdisk"
PhysicalDisk.Collect.Source(1).Separators=":"
PhysicalDisk.Collect.Source(1).SelectColumns="1,2"

// Duplicate the status column
// PhysicalDiskID;PhysicalDiskStatus;PhysicalDiskStatus
PhysicalDisk.Collect.Source(1).Compute(1).Type="DuplicateColumn"
PhysicalDisk.Collect.Source(1).Compute(1).Column="2"

// Translate the first status column into a PATROL status
// PhysicalDiskID;PATROLStatus;PhysicalDiskStatus
PhysicalDisk.Collect.Source(1).Compute(2).Type="Translate"
PhysicalDisk.Collect.Source(1).Compute(2).Column="2"
PhysicalDisk.Collect.Source(1).Compute(2).TranslationTable="PhysicalDiskStatusTranslationTable"

// Translate the second status column into a more readable string
// PhysicalDiskID;PATROLStatus;statusInformation
PhysicalDisk.Collect.Source(1).Compute(3).Type="Translate"
PhysicalDisk.Collect.Source(1).Compute(3).Column="3"
PhysicalDisk.Collect.Source(1).Compute(3).TranslationTable="PhysicalDiskStatusInformationTranslationTable"

// Table Join Discovery Source (3) - Instance Table, with Discovery Table (4) - Errorcounts
// PhysicalDiskID;PATROLStatus;statusInformation;DeviceID;ErrorCount;
PhysicalDisk.Collect.Source(2).Type="TableJoint"
PhysicalDisk.Collect.Source(2).LeftTable=%PhysicalDisk.Collect.Source(1)%
PhysicalDisk.Collect.Source(2).RightTable=%DiskController.Discovery.Source(4)%
PhysicalDisk.Collect.Source(2).LeftKeyColumn="1"
PhysicalDisk.Collect.Source(2).RightKeyColumn="1"
PhysicalDisk.Collect.Source(2).DefaultRightLine=";0;"

//  "ValueTable = source(1)
// PhysicalDiskID;PATROLStatus;statusInformation;DeviceID;ErrorCount;
PhysicalDisk.Collect.ValueTable=%PhysicalDisk.Collect.Source(2)%
PhysicalDisk.Collect.DeviceID=ValueTable.Column(1)
// PhysicalDisk.Collect.Status=ValueTable.Column(2)
PhysicalDisk.Collect.StatusInformation=ValueTable.Column(3)
PhysicalDisk.Collect.Errorcount=ValueTable.Column(5)

// The PhysicalDiskStatusTranslationTable
PhysicalDiskStatusTranslationTable("Available")="OK"
PhysicalDiskStatusTranslationTable("Defined")="OK"
PhysicalDiskStatusTranslationTable("Stopped")="WARN"
PhysicalDiskStatusTranslationTable(Default)="UNKNOWN"

// The PhysicalDiskStatusInformationTranslationTable
PhysicalDiskStatusInformationTranslationTable("Available")="Available"
PhysicalDiskStatusInformationTranslationTable("Defined")="Defined"
PhysicalDiskStatusInformationTranslationTable("Stopped")="Stopped"
PhysicalDiskStatusInformationTranslationTable(Default)="Unknown Status"


//
// Network cards
//

//
// Discovery

// Source(1) = output of fcstat (Fiber Cards)
NetworkCard.Discovery.Source(1).Type="OsCommand"
//NetworkCard.Discovery.Source(1).CommandLine="for NIC in `for a in $(for i in $(ioscli lsdev -type disk -field name -state Available |grep ^hdisk); do ioscli lsdev -dev $i -parent ; done |grep ^fs|sort -n |uniq); do ioscli lsdev -dev $a -parent; done |grep ^fc`;do ioscli fcstat $NIC;done"
NetworkCard.Discovery.Source(1).CommandLine="for FCSTAT in $(for NIC in `for a in $(for i in $(ioscli lsdev -type  disk -field name -state Available && ioscli lsdev -type tape -field name |grep "^hdisk|^rmt"); do ioscli lsdev -dev $i -parent  ; done |grep ^fs|sort -n |uniq); do ioscli lsdev -dev $a -parent; done |grep ^fc ; ioscli lsmap -all -npiv |awk '{FS=":"} /name:fcs/ && /loc/  {print $2}' |awk '{print $1}' |uniq `; do echo $NIC ; done |uniq); do  fcstat $FCSTAT ; done"


// AWK it
// MSHW;portID;;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;WWPN;AddressType;SerialNumber;
NetworkCard.Discovery.Source(1).Compute(1).Type="Awk"
NetworkCard.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(4)
NetworkCard.Discovery.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
NetworkCard.Discovery.Source(1).Compute(1).Separators=";"
// NetworkCard.Discovery.Source(1).Compute(1).SelectColumns="2,3,5,6,7,8,9,10,11,12,13,14"

// Source(2) = output of netstat (Ethernet Cards)
NetworkCard.Discovery.Source(2).Type="OsCommand"
//NetworkCard.Discovery.Source(2).CommandLine="ioscli netstat -cdlistats"
NetworkCard.Discovery.Source(2).CommandLine="STR0=$(ioscli lsdev -type adapter -state Available -field name|egrep '^ent'); STR1=$(ioscli lsmap -all -npiv |awk '/FC name:/ {print $2}' |sort |uniq |cut -c '6-10'); STR2=$(ioscli viostat -adapter |awk '/fcs/ {print $1}') ;for i in $(for i in $(echo $STR0 $STR1 $STR2); do echo $i; done |sort |uniq) ; do ioscli netstat -cdlistats $i; done"

// AWK it
// MSHW;portID;Status;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;WWPN;
NetworkCard.Discovery.Source(2).Compute(1).Type="Awk"
NetworkCard.Discovery.Source(2).Compute(1).AwkScript=EmbeddedFile(5)
NetworkCard.Discovery.Source(2).Compute(1).KeepOnlyRegExp="^MSHW;"
NetworkCard.Discovery.Source(2).Compute(1).Separators=";"
// NetworkCard.Discovery.Source(2).Compute(1).SelectColumns="2,13,6,7,8,9,5,12,10,11"

// Add MAC and blank serial number - This is done so that Embedded File 5 matched the one in IBM AIX Embedded file 3
// MSHW;portID;Status;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;MAC;AddressType;SerialNumber;
NetworkCard.Discovery.Source(2).Compute(2).Type="RightConcat"
NetworkCard.Discovery.Source(2).Compute(2).Column=13
NetworkCard.Discovery.Source(2).Compute(2).String=";MAC;"

// Source(3) = Union of Source(1) and Source(2)
// MSHW;portID;;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;MAC;AddressType;SerialNumber;
NetworkCard.Discovery.Source(3).Type="TableUnion"
NetworkCard.Discovery.Source(3).Table1=%NetworkCard.Discovery.Source(1)%
NetworkCard.Discovery.Source(3).Table2=%NetworkCard.Discovery.Source(2)%

// InstanceTable = Source(1)
// 1     2     3          4             5             6       7          8      9       10   11    12      13    14         15
// MSHW;portID;Status;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;MAC;AddressType;SerialNumber;
NetworkCard.Discovery.InstanceTable=%NetworkCard.Discovery.Source(3)%
NetworkCard.Discovery.Instance.DeviceID=InstanceTable.Column(2)
NetworkCard.Discovery.Instance.PhysicalAddress=InstanceTable.Column(13)
NetworkCard.Discovery.Instance.PhysicalAddressType=InstanceTable.Column(14)
NetworkCard.Discovery.Instance.DeviceType=InstanceTable.Column(12)
NetworkCard.Discovery.Instance.Bandwidth=InstanceTable.Column(10)
NetworkCard.Discovery.Instance.SerialNumber=InstanceTable.Column(15)
NetworkCard.Discovery.Instance.ParameterActivation.Status=InstanceTable.Column(3)
NetworkCard.Discovery.Instance.ParameterActivation.LinkStatus=InstanceTable.Column(4)
NetworkCard.Discovery.Instance.ParameterActivation.LinkSpeed=InstanceTable.Column(10)
NetworkCard.Discovery.Instance.ParameterActivation.ReceivedPackets=InstanceTable.Column(7)
NetworkCard.Discovery.Instance.ParameterActivation.TransmittedPackets=InstanceTable.Column(6)
NetworkCard.Discovery.Instance.ParameterActivation.ErrorCount=InstanceTable.Column(5)
NetworkCard.Discovery.Instance.ParameterActivation.ReceivedBytes=InstanceTable.Column(9)
NetworkCard.Discovery.Instance.ParameterActivation.TransmittedBytes=InstanceTable.Column(8)
NetworkCard.Discovery.Instance.ParameterActivation.DuplexMode=InstanceTable.Column(11)

//
// Collect

// The NetworkCard collect is a "MultiInstance" collect
NetworkCard.Collect.Type="MultiInstance"

// Source(1) = output of fcstat (Fiber Cards)
NetworkCard.Collect.Source(1).Type="OsCommand"
//NetworkCard.Collect.Source(1).CommandLine="for NIC in `for a in $(for i in $(ioscli lsdev -type disk -field name -state Available |grep ^hdisk); do ioscli lsdev -dev $i -parent ; done |grep ^fs|sort -n |uniq); do ioscli lsdev -dev $a -parent; done |grep ^fc`;do ioscli fcstat $NIC;done"
NetworkCard.Collect.Source(1).CommandLine="for FCSTAT in $(for NIC in `for a in $(for i in $(ioscli lsdev -type  disk -field name -state Available && ioscli lsdev -type tape -field name |grep "^hdisk|^rmt"); do ioscli lsdev -dev $i -parent  ; done |grep ^fs|sort -n |uniq); do ioscli lsdev -dev $a -parent; done |grep ^fc ; ioscli lsmap -all -npiv |awk '{FS=":"} /name:fcs/ && /loc/  {print $2}' |awk '{print $1}' |uniq `; do echo $NIC ; done |uniq); do  fcstat $FCSTAT ; done"

// AWK it
// MSHW;portID;;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;WWPN;AddressType;SerialNumber;
NetworkCard.Collect.Source(1).Compute(1).Type="Awk"
NetworkCard.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(4)
NetworkCard.Collect.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
NetworkCard.Collect.Source(1).Compute(1).Separators=";"
//NetworkCard.Collect.Source(1).Compute(1).SelectColumns="2,4,5,6,7,8,9,11,12"

// Source(2) = output of netstat (Ethernat Cards)
NetworkCard.Collect.Source(2).Type="OsCommand"
//NetworkCard.Collect.Source(2).CommandLine="ioscli netstat -cdlistats"
NetworkCard.Collect.Source(2).CommandLine="STR0=$(ioscli lsdev -type adapter -state Available -field name|egrep '^ent'); STR1=$(ioscli lsmap -all -npiv |awk '/FC name:/ {print $2}' |sort |uniq |cut -c '6-10'); STR2=$(ioscli viostat -adapter |awk '/fcs/ {print $1}') ;for i in $(for i in $(echo $STR0 $STR1 $STR2); do echo $i; done |sort |uniq) ; do ioscli netstat -cdlistats $i; done"

// AWK it
// MSHW;portID;;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;WWPN;
NetworkCard.Collect.Source(2).Compute(1).Type="Awk"
NetworkCard.Collect.Source(2).Compute(1).AwkScript=EmbeddedFile(5)
NetworkCard.Collect.Source(2).Compute(1).KeepOnlyRegExp="^MSHW;"
NetworkCard.Collect.Source(2).Compute(1).Separators=";"
// NetworkCard.Collect.Source(2).Compute(1).SelectColumns="2,4,6,7,8,9,5,10,11"



// Source(3) = Union of Source(1) and Source(2)
// MSHW;portID;;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;WWPN;AddressType;SerialNumber;
NetworkCard.Collect.Source(3).Type="TableUnion"
NetworkCard.Collect.Source(3).Table1=%NetworkCard.Collect.Source(1)%
NetworkCard.Collect.Source(3).Table2=%NetworkCard.Collect.Source(2)%

// ValueTable = Source(1)
// MSHW;portID;;linkStatus;ErrorCountFrames;TxPackets;RxPackets;TxBytes;RxBytes;speed;Full;PortType;WWPN;AddressType;SerialNumber;
NetworkCard.Collect.ValueTable=%NetworkCard.Collect.Source(3)%
NetworkCard.Collect.DeviceID=ValueTable.Column(2)
NetworkCard.Collect.LinkSpeed=ValueTable.Column(10)
NetworkCard.Collect.LinkStatus=ValueTable.Column(4)
NetworkCard.Collect.ReceivedPackets=ValueTable.Column(7)
NetworkCard.Collect.TransmittedPackets=ValueTable.Column(6)
NetworkCard.Collect.ErrorCount=ValueTable.Column(5)
NetworkCard.Collect.ReceivedBytes=ValueTable.Column(9)
NetworkCard.Collect.TransmittedBytes=ValueTable.Column(8)
NetworkCard.Collect.DuplexMode=ValueTable.Column(11)
// NetworkCard.Collect.Status=ValueTable.Column(2)

//
// LUNs
//

//
// Discovery

// Get the list of Ports from lspath
//
LUN.Discovery.Source(1).Type="OsCommand"
LUN.Discovery.Source(1).CommandLine="ioscli lspath"

// AWK it
// LunName;LunInfo;LunStatus;
LUN.Discovery.Source(1).Compute(1).Type="Awk"
LUN.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(1)
LUN.Discovery.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
LUN.Discovery.Source(1).Compute(1).Separators=";"
LUN.Discovery.Source(1).Compute(1).SelectColumns="2"

// InstanceTable = Source(1)
// LunName;LunInfo;LunStatus;
LUN.Discovery.InstanceTable=%LUN.Discovery.Source(1)%
LUN.Discovery.Instance.DeviceID=InstanceTable.Column(1)


// Collect type is multi-instance
LUN.Collect.Type="MultiInstance"

// Get the list of Ports from multipath -l
//
LUN.Collect.Source(1).Type="OsCommand"
LUN.Collect.Source(1).CommandLine="ioscli lspath"

// AWK it
// LunName;NumberPaths;
LUN.Collect.Source(1).Compute(1).Type="Awk"
LUN.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(1)
LUN.Collect.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
LUN.Collect.Source(1).Compute(1).Separators=";"
LUN.Collect.Source(1).Compute(1).SelectColumns="2,3"

// ValueTable = Source(1)
// LunName;NumberPaths;LunStatus;LunStatusInfo;AvailablePathInformation;
LUN.Collect.ValueTable=%LUN.Collect.Source(1)%
LUN.Collect.DeviceID=ValueTable.Column(1)
LUN.Collect.AvailablePathCount=ValueTable.Column(2)

/////////////////////////////////////////////////////////////
///
///    Embedded File 1
///
///    AWK script that takes the wonderful array of objects and returns them in column form
///	   MSHW;LunName;NumberPaths;
///
/////////////////////////////////////////////////////////////
EmbeddedFile(1):
$2 ~ /hdisk[0-9]+/ && $3 ~ /fscsi/ {if ($2 in LUN == 0) {LUN[$2] = 0}
	                                  if ($1 ~ /[Ee]nabled/) {LUN[$2] = LUN[$2] + 1}
	                                 }
END {for (id in LUN) {print "MSHW;" id ";" LUN[id] ";"} }
EmbeddedFile(1).End
///////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(2) = shell script that gives the link speed
///    of each network card that is configured as UP
///
/////////////////////////////////////////////////////////
EmbeddedFile(2):
BEGIN {
	nicUp = 0;
	nicSpeed = "";
}
/^Driver Flags:.*Up/ {
	nicUp = 1;
}

/^Media Speed Running: +[0-9]+ / {
	nicSpeed = $4;
}

/^Hardware Address:/ {
	address = $3;
}

END {
	if (nicUp == 1)
	{
		print "MSHW;" nicId ";" nicSpeed ";" address ";"
	}
}
EmbeddedFile(2).End
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(3) = shell script that gives hard disk descriptors from lsdev -vpd
///
/////////////////////////////////////////////////////////
EmbeddedFile(3):
($1 ~ /hdisk[0-9]/) {
	ID=$1;
	size = $(NF-1);
	gsub("[^0-9.]", "", size);
	if ($NF ~ /MB/) { size = size / 1024; }
	if ($NF ~ /TB/) { size = size * 1024; }
}

(ID != "" && $1 ~ /Manufacturer/) { make = $1; gsub (".+\\.", "", make); }

(ID != "" && $1 ~ /Machine/ && $2 ~ /Type/) { model = $NF; gsub(".+\\.", "", model); }

(ID != "" && $1 ~ /FRU/ && $2 ~ /Number/) { FRU = $NF; gsub(".+\\.", "", FRU); }

(ID != "" && $1 ~ /Serial/ && $2 ~ /Number/) {
	Serial = $NF;
	gsub(".+\\.", "", Serial);
	if (FRU != "")
	{
		print ("MSHW;" ID ";" size ";" make "-" model " FRU: " FRU ";" Serial ";");
	}
	ID=""; size=""; make=""; model=""; FRU=""; Serial="";
}
EmbeddedFile(3).End
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(4) = AWK that parses FCSTAT
///    MSHW;portID;WWPN;linkStatus;TxPackets;RxPackets;TxBytes;RxBytes;ErrorCountFrames;PortType;Speed;Duplex;
///
/////////////////////////////////////////////////////////
EmbeddedFile(4):
BEGIN { portID = ""; WWPN = ""; linkStatus = "WARN"; TxPackets = ""; RxPackets = ""; TxBytes = ""; RxBytes = ""; ErrorCountFrames = ""; PortType = ""; speed = ""; SerialNumber = ""; }

($1 == "FIBRE" && $2 == "CHANNEL" && $3 == "STATISTICS") {

	# If portID != "", it means we're starting the section for a new port, so report the one that we've just processed
  	if (portID != "") { print("MSHW;" portID ";"  ";" linkStatus ";" ErrorCountFrames ";" TxPackets ";" RxPackets ";" TxBytes ";" RxBytes ";" speed ";Full;" PortType ";" WWPN ";WWN;"  SerialNumber ";" ); }
    portID = ""; WWPN = ""; linkStatus = "WARN"; TxPackets = ""; RxPackets = ""; TxBytes = ""; RxBytes = ""; ErrorCountFrames = ""; PortType = ""; speed = ""; SerialNumber = "";

	portID = $NF;
}

($1 == "World" && $2 == "Wide" && $3 == "Port") { WWPN = $NF; gsub(/^0x/, "" , WWPN); }
($1 == "Port" && $2 == "WWN") { WWPN=$NF; gsub(/^0x/, "" , WWPN); }

$0 ~ /[Aa]ttention.*[Tt]ype.*[Ll]ink.*[Uu]p/ {linkStatus = "OK"}
$0 ~ /[Aa]ttention.*[Tt]ype.*[Ll]ink.*[Dd]own/ {linkStatus = "WARN"}
($1 == "Port" && $2 == "Speed" && $3 ~ /running/) { speed = $(NF-1); speed = speed * 1000; linkStatus = "OK"; }

($1 == "Port" && $2 == "Type:") { PortType = "HBA FC Port (" $3 ")"; }

($1 == "Serial" && $2 == "Number:") { SerialNumber = $NF; }

($1 ~ /^Frames/ && $2 ~ /^[0-9]+$/ && $3 ~ /^[0-9]+$/) { TxPackets = $2; RxPackets = $3; }
($1 ~ /^Frames/ && $2 ~ /^[0-9]+$/ && $3 ~ /^Frames/ && $4 ~ /^[0-9]+$/) { TxPackets = $2; RxPackets = $4; }

($1 ~ /Error/ && $2 ~ /Frames/ && $3 ~ /^[0-9]+$/) { if (ErrorCountFrames == "") { ErrorCountFrames = $3; } else { ErrorCountFrames = ErrorCountFrames + $3;} }

($1 ~ /Dumped/ && $2 ~ /Frames/ && $3 ~ /^[0-9]+$/) { if (ErrorCountFrames == "") { ErrorCountFrames = $3; } else { ErrorCountFrames = ErrorCountFrames + $3;} }

($1 ~ /Input/ && $2 ~ /Bytes/ && $3 ~ /^[0-9]+$/) { if (RxBytes == "") { RxBytes = $3; } else { RxBytes = RxBytes + $3;} }

($1 ~ /Output/ && $2 ~ /Bytes/ && $3 ~ /^[0-9]+$/) { if (TxBytes == "") { TxBytes = $3; } else { TxBytes = TxBytes + $3;} }

END {
	if (portID != "") { print("MSHW;" portID ";"  ";" linkStatus ";" ErrorCountFrames ";" TxPackets ";" RxPackets ";" TxBytes ";" RxBytes ";" speed ";Full;" PortType ";" WWPN ";WWN;"  SerialNumber ";" ); }
}
EmbeddedFile(4).End
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(5) = AWK that parses netstat
///    MSHW;nicdevices;nicStatus;linkStatus;totalErrors;transmitPackets;receivePackets;transmitBytes;receiveBytes;linkSpeed;duplexMode;Type;PhysicalAddressType;
///
/////////////////////////////////////////////////////////
EmbeddedFile(5):
/^ETHERNET STATISTICS/ { nicdevice = $3; gsub (/[\050\051]/,"",nicdevice); nicdevices[nicdevice]=nicdevice }

/^Device Type:/ {
                 if ( ($3 ~ /EtherChannel/ || $3 ~ /Virtual/) || ($0 ~ /Shared Ethernet Adapter/) || ($0 ~ /Link Aggregation/) || ($0 ~ /VLAN/)) { EtherT[nicdevice] = "Logical"; lastLogical = nicdevice }
                    else { EtherT[nicdevice] = "Physical" }
                }

/^Driver Flags:/ {
                  if ($0 ~ /Running/) { nicStatus[nicdevice] = "OK";}
                  else {
                        nicStatus[nicdevice] = "ALARM";
                        getline
                        if ($0 ~ /Running/) { nicStatus[nicdevice] = "OK";}
                       }
                 }

$1 == "Hardware" && $2 == "Address:" { mac[nicdevice] = $3 ; gsub (/:/,"",mac[nicdevice])}

# Link
/Physical Port Link Stat/ {
                           if ($NF == "up" || $NF == "Up" || $NF == "UP") {
                                                                           linkStatus[nicdevice] = "OK";
                                                                           if ( linkStatus[lastLogical] == "WARN" ) { linkStatus[lastLogical] = "OK" ; nicStatus[lastLogical] = "WARN" ; }
                                                                          }
                              else {
                                    linkStatus[nicdevice] = "WARN"; nicStatus[nicdevice] = "OK";
                                    if (linkStatus[lastLogical] == "OK") { nicStatus[lastLogical] = "WARN" }
                                    if (linkStatus[lastLogical] == "") { linkStatus[lastLogical] = "WARN" ; nicStatus[lastLogical] = "ALARM" }
                                   }
                          }

$1 == "Link" && $2 == "Status" { if ($4 == "up" || $4 == "Up" || $4 == "UP") { linkStatus[nicdevice] = "OK"; }
                                      else {linkStatus[nicdevice] = "WARN"; nicStatus[nicdevice] = "OK";}
                                 }

$1 == "Link" && $2 == "Status:" { if ($3 == "up" || $3 == "Up" || $3 == "UP") { linkStatus[nicdevice] = "OK";}
                                       else { linkStatus[nicdevice] = "WARN"; nicStatus[nicdevice] = "OK"; }
                                  }

# Speed
$0 ~ /Media Speed Running:/ || $0 ~ /Physical Port Speed:/ {
																	if ($4 ~ /^[0-9]+$/) {linkSpeed[nicdevice] = $4 $5; gsub(/Gbps/,"000",linkSpeed[nicdevice]);gsub(/Mbps/,"",linkSpeed[nicdevice]);}
																		else {linkSpeed[nicdevice] = $4; gsub(/Gbps/,"000",linkSpeed[nicdevice]);gsub(/Mbps/,"",linkSpeed[nicdevice]);}
																 if ($0 ~ /[Hh]alf [Dd]uplex/) { duplexMode[nicdevice] = "half"; }
                                    else { duplexMode[nicdevice] = "full"; }
                                 }

# Statistics
$1 == "Packets:" && $3 == "Packets:" { transmitPackets[nicdevice] = $2; receivePackets[nicdevice] = $4; }

$1 == "Bytes:" && $3 == "Bytes:" {transmitBytes[nicdevice] = $2;receiveBytes[nicdevice] = $4; }

$1 == "Transmit" && $2 == "Errors:" && $4 == "Receive" && $5 == "Errors:" { transmitErrors[nicdevice] = $3; receiveErrors[nicdevice] = $6; totalErrors[nicdevice] = transmitErrors[nicdevice] + receiveErrors[nicdevice] ; }

END { for (nic in nicdevices) {
          if (EtherT[nic] == "Logical") {
             printf("MSHW;%s;%s;%s;%.0f;%.0f;%.0f;%.0f;%.0f;;;%s;;\n", nicdevices[nic],nicStatus[nic],linkStatus[nic],totalErrors[nic],transmitPackets[nic],receivePackets[nic],transmitBytes[nic],receiveBytes[nic],"Logical");
             }
             else {printf("MSHW;%s;%s;%s;%.0f;%.0f;%.0f;%.0f;%.0f;%s;%s;%s;%s;\n",nicdevices[nic],nicStatus[nic],linkStatus[nic],totalErrors[nic],transmitPackets[nic],receivePackets[nic],transmitBytes[nic],receiveBytes[nic],linkSpeed[nic],duplexMode[nic],"Physical", mac[nic]);
                  }

          }
    }
EmbeddedFile(5).End
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(6) = awk script
///    in order to list memory modules
///
///
/////////////////////////////////////////////////////////
EmbeddedFile(6):
BEGIN {
	MemoryObject = 0;
	DeviceID = "";
	Size = "";
	SerialNumber = "";
	PartNumber = "";
}
/Memory [DS]IMM:/ {
	MemoryObject = 1;
}

/Size\.+/ {
	Size = $0;
	gsub(" +Size\\.+", "", Size);
}
/Serial Number\.+/ {
	SerialNumber = $0;
	gsub(" +Serial Number\\.+", "", SerialNumber);
}
/Part Number\.+/ {
	PartNumber = $0;
	gsub(" +Part Number\\.+", "", PartNumber);
}
/Physical Location:/ {
	if (MemoryObject == 1)
	{
		DeviceID = $3;

		if (Size == 0)
		{
			Status = "ALARM";
			StatusInformation = "Failed";
		}
		else
		{
			Status = "OK";
			StatusInformation = "";
		}
		print "MSHW;" DeviceID ";" Size ";" SerialNumber " - FRU: " PartNumber ";" Status ";" StatusInformation ";"
	}
	DeviceID = "";
	MemoryObject = 0;
	SerialNumber = "";
	PartNumber = "";
}
EmbeddedFile(6).End
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(7) = awk script
///    to parse errlog and extract hard disk errors from today.
///
///
/////////////////////////////////////////////////////////
EmbeddedFile(7):
$1 ~ /MSHW_DATE[0-9]+/ {mmdd = substr($1,10,4) ; yy = substr ($1,18,2)}
# Match the date
substr($2,1,4) == mmdd &&  substr($2,9,2) == yy { if ($5 in DeviceErrorCount == 0) {DeviceErrorCount[$5] = 1}
	                                                else {DeviceErrorCount[$5] = DeviceErrorCount[$5] + 1 }
	                                               }
END {for (id in DeviceErrorCount) {print "MSHW;" id ";" DeviceErrorCount[id] ";"} }
EmbeddedFile(7).End
////////////////////////////////////////////////////////////////////
