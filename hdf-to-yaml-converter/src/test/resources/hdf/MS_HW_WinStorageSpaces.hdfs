//
//
//    H a r d w a r e   D e f i n i t i o n   F i l e
//
//                       f o r
//
//                 Hardware Sentry
//
//                 by Sentry Software (c)
//
//                MS_HW_WinStorageSpaces.hdf
//
//      Supports: HDDs, SDDs and NVMe disks on Windows, through
//                Windows Storage Spaces (WMI)
//
//

//
// HEADER
//
hdf.DisplayName="Windows Storage Spaces (WMI)"
hdf.TypicalPlatform="Any system"
hdf.ReliesOn="Windows Storage Spaces"
hdf.Comments="This connector provides monitoring physical disks through Windows Storage Management's WMI provider. It supports all disk types, including disks on NVMe bus and NVDIMM. When available, temperature sensors are also discovered and monitored."
hdf.RemoteSupport="true"
hdf.AppliesToOS="NT"
hdf.Supersedes="MS_HW_WBEMGenDiskNT.hdf,MS_HW_DiskPart.hdf"


//
// DETECTION
//

// Must be Windows
Detection.Criteria(1).Type="OS"
Detection.Criteria(1).KeepOnly="NT"

// Must be Hardware Sentry KM 11.3 at least
Detection.Criteria(2).Type="KMVersion"
Detection.Criteria(2).Version="11.3.00"

// Having something in MSFT_Volume is enough to consider that the WMI provider
// for Windows Storage Spaces is working
Detection.Criteria(3).Type="WMI"
Detection.Criteria(3).WbemNameSpace="root\Microsoft\Windows\Storage"
Detection.Criteria(3).WbemQuery="SELECT ObjectId FROM MSFT_Volume"


//
// DISK CONTROLLERS
//

//
// Discovery

// Source(1) = MSFT_PhysicalDisk
// __PATH;BusType;DeviceId;FirmwareVersion;MediaType;Model;SerialNumber;Size;SpindleSpeed;
DiskController.Discovery.Source(1).Type="WMI"
DiskController.Discovery.Source(1).WbemNameSpace="root\Microsoft\Windows\Storage"
DiskController.Discovery.Source(1).WbemQuery="SELECT __PATH,BusType,DeviceId,FirmwareVersion,MediaType,Model,SerialNumber,Size,SpindleSpeed FROM MSFT_PhysicalDisk"

// Filter on MediaType: Keep only actual disks (HDD, SDD and SCM)
// __PATH;BusType;DeviceId;FirmwareVersion;MediaType;Model;SerialNumber;Size;SpindleSpeed;
DiskController.Discovery.Source(1).Compute(1).Type="KeepOnlyMatchingLines"
DiskController.Discovery.Source(1).Compute(1).Column=5
DiskController.Discovery.Source(1).Compute(1).ValueList="3,4,5"

// Filter on BusType: Keep only disks on bus that are on an actual physical disk bus (SCSI, ATA, SSA, SAS, SATA, NVMe)
// Note: We exclude 6 (FC) because modern systems no longer use FC to attach disks, and that allows us to easily
// exclude LUNs over HBAs.
// __PATH;BusType;DeviceId;FirmwareVersion;MediaType;Model;SerialNumber;Size;SpindleSpeed;
DiskController.Discovery.Source(1).Compute(2).Type="KeepOnlyMatchingLines"
DiskController.Discovery.Source(1).Compute(2).Column=2
DiskController.Discovery.Source(1).Compute(2).ValueList="1,3,5,10,11,17"

// Translate BusType
// __PATH;BusType;DeviceId;FirmwareVersion;MediaType;Model;SerialNumber;Size;SpindleSpeed;
DiskController.Discovery.Source(1).Compute(3).Type="Translate"
DiskController.Discovery.Source(1).Compute(3).Column=2
DiskController.Discovery.Source(1).Compute(3).TranslationTable="BustypeTranslationTable"

// The BustypeTranslationTable
BustypeTranslationTable(0)="Unknown"
BustypeTranslationTable(1)="SCSI"
BustypeTranslationTable(2)="ATAPI"
BustypeTranslationTable(3)="ATA"
BustypeTranslationTable(4)="IEEE 1394"
BustypeTranslationTable(5)="SSA"
BustypeTranslationTable(6)="Fibre Channel"
BustypeTranslationTable(7)="USB"
BustypeTranslationTable(8)="RAID"
BustypeTranslationTable(9)="iSCSI"
BustypeTranslationTable(10)="SAS"
BustypeTranslationTable(11)="SATA"
BustypeTranslationTable(12)="Secure Digital"
BustypeTranslationTable(13)="MMC - Multimedia Card"
BustypeTranslationTable(14)="Other"
BustypeTranslationTable(15)="File-Backed Virtual"
BustypeTranslationTable(16)="Storage Spaces"
BustypeTranslationTable(17)="NVMe"
BustypeTranslationTable(18)="Other"

// Merge all info into a proper label for the "Model" field
// __PATH;DeviceID;Model;FirmwareVersion;SerialNumber;Size
DiskController.Discovery.Source(1).Compute(4).Type="Awk"
DiskController.Discovery.Source(1).Compute(4).AwkScript=EmbeddedFile(1)
DiskController.Discovery.Source(1).Compute(4).KeepOnlyRegExp="^MSHW;"
DiskController.Discovery.Source(1).Compute(4).Separators=";"
DiskController.Discovery.Source(1).Compute(4).SelectColumns="2,3,4,5,6,7"

// Source(2) = Win32_DiskDrive
// SerialNumber;PnPDeviceID;
DiskController.Discovery.Source(2).Type="WMI"
DiskController.Discovery.Source(2).WbemQuery="SELECT __PATH,SerialNumber,PnPDeviceID FROM Win32_DiskDrive"
DiskController.Discovery.Source(2).WbemNameSpace="root\cimv2"

// Remove extraneous spaces
// __PATH;SerialNumber;PnPDeviceID;
DiskController.Discovery.Source(2).Compute(1).Type="Replace"
DiskController.Discovery.Source(2).Compute(1).Column=2
DiskController.Discovery.Source(2).Compute(1).Replace=" "
DiskController.Discovery.Source(2).Compute(1).ReplaceBy=""

// Source(3) = jointure of source(1) and source(2) on SerialNumber in order to
// have the PnPDeviceID of the disk instances from MSFT_PhysicalDisk
// __PATH_MSFT_DiskDrive;DeviceID;Model;FirmwareVersion;SerialNumber;Size;__PATH_Win32_DiskDrive;SerialNumber;PnPDeviceID;
DiskController.Discovery.Source(3).Type="TableJoint"
DiskController.Discovery.Source(3).LeftTable=%DiskController.Discovery.Source(1)%
DiskController.Discovery.Source(3).RightTable=%DiskController.Discovery.Source(2)%
DiskController.Discovery.Source(3).LeftKeyColumn=5
DiskController.Discovery.Source(3).RightKeyColumn=2

// Source(4) = Win32_PnpDevice
// __PATH_Device;__PATH_PnP;
DiskController.Discovery.Source(4).Type="WMI"
DiskController.Discovery.Source(4).WbemQuery="SELECT SameElement,SystemElement FROM Win32_PnpDevice"
DiskController.Discovery.Source(4).WbemNameSpace="root\cimv2"

// Source(5) = Join Source(3) and Source(4)
// __PATH_MSFT_DiskDrive;DeviceID;Model;FirmwareVersion;SerialNumber;Size;__PATH_Win32_DiskDrive;SerialNumber;PnPDeviceID;__PATH_Win32_DiskDrive;__PATH_PnP;
DiskController.Discovery.Source(5).Type="TableJoint"
DiskController.Discovery.Source(5).LeftTable=%DiskController.Discovery.Source(3)%
DiskController.Discovery.Source(5).RightTable=%DiskController.Discovery.Source(4)%
DiskController.Discovery.Source(5).LeftKeyColumn=7
DiskController.Discovery.Source(5).RightKeyColumn=1
DiskController.Discovery.Source(5).KeyType="Wbem"

// Source(6) = Table that links the PnP Devices (who controls who)
// __PATH_ControllerPnPDeviceID;__PATH_DiskPnPDeviceID;
DiskController.Discovery.Source(6).Type="WMI"
DiskController.Discovery.Source(6).WbemQuery="SELECT Antecedent,Dependent FROM CIM_ControlledBy"
DiskController.Discovery.Source(6).WbemNameSpace="root\cimv2"

// Source(7) = jointure of PnPDeviceID  source(3) with Dependant source(4)
// __PATH_MSFT_DiskDrive;DeviceID;Model;FirmwareVersion;SerialNumber;Size;__PATH_Win32_DiskDrive;SerialNumber;PnPDeviceID;__PATH_Win32_DiskDrive;__PATH_PnP;__PATH_Controller;__PATH_DiskPnPDeviceID;
DiskController.Discovery.Source(7).Type="TableJoint"
DiskController.Discovery.Source(7).LeftTable=%DiskController.Discovery.Source(5)%
DiskController.Discovery.Source(7).RightTable=%DiskController.Discovery.Source(6)%
DiskController.Discovery.Source(7).LeftKeyColumn=11
DiskController.Discovery.Source(7).RightKeyColumn=2
DiskController.Discovery.Source(7).KeyType="Wbem"

// Keep only relevant columns (remove temporary garbage)
// __PATH_MSFT_DiskDrive;DeviceID;Model;FirmwareVersion;SerialNumber;Size;PnPDeviceID;__PATH_Controller;
DiskController.Discovery.Source(7).Compute(1).Type="KeepColumns"
DiskController.Discovery.Source(7).Compute(1).ColumnNumbers="1,2,3,4,5,6,9,12"

// Source(8) = CIM_Controller
// __PATH;Name;
DiskController.Discovery.Source(8).Type="WMI"
DiskController.Discovery.Source(8).WbemQuery="SELECT __PATH,Name FROM CIM_Controller"
DiskController.Discovery.Source(8).WbemNameSpace="root\cimv2"

// Source(9) = jointure of source(8) and source(7)
// This filters out controllers that don't have disks attached to them)
// __PATH_Controller;ControllerName;__PATH_MSFT_DiskDrive;DeviceID;Model;FirmwareVersion;SerialNumber;Size;PnPDeviceID;__PATH_Controller;
DiskController.Discovery.Source(9).Type="TableJoint"
DiskController.Discovery.Source(9).LeftTable=%DiskController.Discovery.Source(8)%
DiskController.Discovery.Source(9).RightTable=%DiskController.Discovery.Source(7)%
DiskController.Discovery.Source(9).LeftKeyColumn=1
DiskController.Discovery.Source(9).RightKeyColumn=8
DiskController.Discovery.Source(9).KeyType="Wbem"

// Source(10) = ASSOCIATORS of each MSFT_PhysicalDisk, from the MSFT_StorageReliabilityCounter table
// DeviceId;ReadErrors;Wear;WriteErrors;Temperature;TemperatureMax;
DiskController.Discovery.Source(10).Type="WMI"
DiskController.Discovery.Source(10).ExecuteForEachEntryOf=%DiskController.Discovery.Source(7)%
DiskController.Discovery.Source(10).WbemNameSpace="root\Microsoft\Windows\Storage"
DiskController.Discovery.Source(10).WbemQuery="SELECT DeviceId,ReadErrorsTotal,Wear,WriteErrorsTotal,Temperature,TemperatureMax FROM ASSOCIATORS OF {%Entry.Column(1)%} WHERE ResultClass = MSFT_StorageReliabilityCounter"
DiskController.Discovery.Source(10).EntryConcatMethod="List"

// InstanceTable: Source(9) (not Source(10)!)
// __PATH_Controller;ControllerName;__PATH_MSFT_DiskDrive;DeviceID;Model;FirmwareVersion;SerialNumber;Size;PnPDeviceID;__PATH_Controller;
DiskController.Discovery.InstanceTable=%DiskController.Discovery.Source(9)%
DiskController.Discovery.Instance.DeviceID=InstanceTable.Column(1)
DiskController.Discovery.Instance.Model=InstanceTable.Column(2)

//
// PhysicalDisk
//

//
// Discovery

// Source(1) = jointure of DiskController.Discovery.Source(7) and DiskController.Discovery.Source(8)
// __PATH_MSFT_DiskDrive;DeviceID;Model;FirmwareVersion;SerialNumber;Size;PnPDeviceID;__PATH_Controller;__PATH_Controller;ControllerName;
PhysicalDisk.Discovery.Source(1).Type="TableJoint"
PhysicalDisk.Discovery.Source(1).LeftTable=%DiskController.Discovery.Source(7)%
PhysicalDisk.Discovery.Source(1).RightTable=%DiskController.Discovery.Source(8)%
PhysicalDisk.Discovery.Source(1).LeftKeyColumn=8
PhysicalDisk.Discovery.Source(1).RightKeyColumn=1
PhysicalDisk.Discovery.Source(1).KeyType="Wbem"

// Keep only the necessary columns
// __PATH_MSFT_DiskDrive;DeviceID;Model;FirmwareVersion;SerialNumber;Size;__PATH_Controller;
PhysicalDisk.Discovery.Source(1).Compute(1).Type="KeepColumns"
PhysicalDisk.Discovery.Source(1).Compute(1).ColumnNumbers="1,2,3,4,5,6,8"

// Source(2) = Table joint of Source(1) with DiskController.Discovery.Source(10)
// __PATH_MSFT_DiskDrive;DeviceID;Model;FirmwareVersion;SerialNumber;Size;__PATH_Controller;DeviceId;ReadErrors;Wear;WriteErrors;Temperature;TemperatureMax;
PhysicalDisk.Discovery.Source(2).Type="TableJoint"
PhysicalDisk.Discovery.Source(2).LeftTable=%PhysicalDisk.Discovery.Source(1)%
PhysicalDisk.Discovery.Source(2).RightTable=%DiskController.Discovery.Source(10)%
PhysicalDisk.Discovery.Source(2).LeftKeyColumn=2
PhysicalDisk.Discovery.Source(2).RightKeyColumn=1
PhysicalDisk.Discovery.Source(2).DefaultRightLine=";;;;;;"

// The instance table = Source(2)
// __PATH_MSFT_DiskDrive;DeviceID;Model;FirmwareVersion;SerialNumber;Size;__PATH_Controller;DeviceId;ReadErrors;Wear;WriteErrors;Temperature;TemperatureMax;
PhysicalDisk.Discovery.InstanceTable=%PhysicalDisk.Discovery.Source(2)%
PhysicalDisk.Discovery.Instance.DeviceID=InstanceTable.Column(2)
PhysicalDisk.Discovery.Instance.Vendor=InstanceTable.Column(3)
PhysicalDisk.Discovery.Instance.FirmwareVersion=InstanceTable.Column(4)
PhysicalDisk.Discovery.Instance.SerialNumber=InstanceTable.Column(5)
PhysicalDisk.Discovery.Instance.Size=InstanceTable.Column(6)
PhysicalDisk.Discovery.Instance.AttachedToDeviceType="DiskController"
PhysicalDisk.Discovery.Instance.AttachedToDeviceID=InstanceTable.Column(7)
PhysicalDisk.Discovery.Instance.ParameterActivation.ErrorCount=InstanceTable.Column(9)
PhysicalDisk.Discovery.Instance.ParameterActivation.EnduranceRemaining=InstanceTable.Column(10)

//
// Collect
PhysicalDisk.Collect.Type="MultiInstance"

// Source(1) = the MSFT_PhysicalDisk table
// __PATH;DeviceId;OperationalStatus
PhysicalDisk.Collect.Source(1).Type="WMI"
PhysicalDisk.Collect.Source(1).WbemNameSpace="root\Microsoft\Windows\Storage"
PhysicalDisk.Collect.Source(1).WbemQuery="SELECT __PATH,DeviceId,OperationalStatus FROM MSFT_PhysicalDisk"

// Duplicate the OperationalStatus column, twice
// __PATH;DeviceId;OperationalStatus;OperationalStatus;OperationalStatus
PhysicalDisk.Collect.Source(1).Compute(1).Type="DuplicateColumn"
PhysicalDisk.Collect.Source(1).Compute(1).Column=3
PhysicalDisk.Collect.Source(1).Compute(2).Type="DuplicateColumn"
PhysicalDisk.Collect.Source(1).Compute(2).Column=3

// Translate the OperationalStatus field into an array of statuses
// __PATH;DeviceId;StatusArray;OperationalStatus;OperationalStatus
PhysicalDisk.Collect.Source(1).Compute(3).Type="ArrayTranslate"
PhysicalDisk.Collect.Source(1).Compute(3).Column=3
PhysicalDisk.Collect.Source(1).Compute(3).TranslationTable="OperationalStatusTranslationTable"

// Convert the array of status to a simple status (keep the worse one)
PhysicalDisk.Collect.Source(1).Compute(4).Type="Convert"
PhysicalDisk.Collect.Source(1).Compute(4).Column=3
PhysicalDisk.Collect.Source(1).Compute(4).ConversionType="Array2SimpleStatus"

// Translate the 2nd OperationalStatus field into a more readable string
// __PATH;DeviceId;Status;StatusInformation;OperationalStatus
PhysicalDisk.Collect.Source(1).Compute(5).Type="ArrayTranslate"
PhysicalDisk.Collect.Source(1).Compute(5).Column=4
PhysicalDisk.Collect.Source(1).Compute(5).TranslationTable="OperationalStatusInformationTranslationTable"
PhysicalDisk.Collect.Source(1).Compute(5).ResultSeparator=" - "

// Translate the 3rd OperationalStatus field into the PredictiveFailure parameter
// __PATH;DeviceId;Status;StatusInformation;PredictedFailure
PhysicalDisk.Collect.Source(1).Compute(6).Type="Translate"
PhysicalDisk.Collect.Source(1).Compute(6).Column=5
PhysicalDisk.Collect.Source(1).Compute(6).TranslationTable="PredictedFailureTranslationTable"

// The OperationalStatusTranslationTable
OperationalStatusTranslationTable(2)="OK"
OperationalStatusTranslationTable(3)="WARN"
OperationalStatusTranslationTable(4)="WARN"
OperationalStatusTranslationTable(5)="OK"
OperationalStatusTranslationTable(6)="ALARM"
OperationalStatusTranslationTable(7)="ALARM"
OperationalStatusTranslationTable(8)="OK"
OperationalStatusTranslationTable(9)="OK"
OperationalStatusTranslationTable(10)="OK"
OperationalStatusTranslationTable(11)="WARN"
OperationalStatusTranslationTable(12)="ALARM"
OperationalStatusTranslationTable(13)="ALARM"
OperationalStatusTranslationTable(14)="ALARM"
OperationalStatusTranslationTable(15)="OK"
OperationalStatusTranslationTable(16)="ALARM"
OperationalStatusTranslationTable(17)="OK"
OperationalStatusTranslationTable(18)="OK"
OperationalStatusTranslationTable(19)="OK"
OperationalStatusTranslationTable(53252)="ALARM"
OperationalStatusTranslationTable(53253)="WARN"
OperationalStatusTranslationTable(53254)="WARN"
OperationalStatusTranslationTable(53255)="ALARM"
OperationalStatusTranslationTable(53256)="WARN"
OperationalStatusTranslationTable(53261)="OK"
OperationalStatusTranslationTable(53262)="OK"
OperationalStatusTranslationTable(53263)="WARN"
OperationalStatusTranslationTable(53269)="OK"
OperationalStatusTranslationTable(53270)="WARN"
OperationalStatusTranslationTable(53271)="WARN"
OperationalStatusTranslationTable(53272)="ALARM"
OperationalStatusTranslationTable(53273)="ALARM"
OperationalStatusTranslationTable(53274)="ALARM"
OperationalStatusTranslationTable(53276)="WARN"
OperationalStatusTranslationTable(53277)="WARN"
OperationalStatusTranslationTable(53285)="WARN"
OperationalStatusTranslationTable(53286)="WARN"

// The OperationalStatusInformationTranslationTable
OperationalStatusInformationTranslationTable(1)="Other"
OperationalStatusInformationTranslationTable(2)=""
OperationalStatusInformationTranslationTable(3)="Degraded"
OperationalStatusInformationTranslationTable(4)="Stressed"
OperationalStatusInformationTranslationTable(5)="Predictive Failure"
OperationalStatusInformationTranslationTable(6)="Error"
OperationalStatusInformationTranslationTable(7)="Non-Recoverable Error"
OperationalStatusInformationTranslationTable(8)="Starting"
OperationalStatusInformationTranslationTable(9)="Stopping"
OperationalStatusInformationTranslationTable(10)="Stopped"
OperationalStatusInformationTranslationTable(11)="In Service"
OperationalStatusInformationTranslationTable(12)="No Contact"
OperationalStatusInformationTranslationTable(13)="Lost Communication"
OperationalStatusInformationTranslationTable(14)="Aborted"
OperationalStatusInformationTranslationTable(15)="Dormant"
OperationalStatusInformationTranslationTable(16)="Supporting Entity in Error"
OperationalStatusInformationTranslationTable(17)="Completed"
OperationalStatusInformationTranslationTable(18)="Power Mode"
OperationalStatusInformationTranslationTable(19)="Relocating"
OperationalStatusInformationTranslationTable(53252)="Failed Media"
OperationalStatusInformationTranslationTable(53253)="Split"
OperationalStatusInformationTranslationTable(53254)="Stale Metadata"
OperationalStatusInformationTranslationTable(53255)="IO Error"
OperationalStatusInformationTranslationTable(53256)="Unrecognized Metadata"
OperationalStatusInformationTranslationTable(53261)="Scan Needed"
OperationalStatusInformationTranslationTable(53262)="Spot Fix Needed"
OperationalStatusInformationTranslationTable(53263)="Full Repair Needed"
OperationalStatusInformationTranslationTable(53269)="Removing From Pool"
OperationalStatusInformationTranslationTable(53270)="In Maintenance Mode"
OperationalStatusInformationTranslationTable(53271)="Updating Firmware"
OperationalStatusInformationTranslationTable(53272)="Device Hardware Error"
OperationalStatusInformationTranslationTable(53273)="Not Usable"
OperationalStatusInformationTranslationTable(53274)="Transient Error"
OperationalStatusInformationTranslationTable(53276)="Starting Maintenance Mode"
OperationalStatusInformationTranslationTable(53277)="Stopping Maintenance Mode"
OperationalStatusInformationTranslationTable(53285)="Threshold Exceeded"
OperationalStatusInformationTranslationTable(53286)="Abnormal Latency"

// The PredictedFailureTranslationTable
PredictedFailureTranslationTable(5)="True"
PredictedFailureTranslationTable(53285)="True"
PredictedFailureTranslationTable(Default)="False"

// Source(2) = ASSOCIATORS of each MSFT_PhysicalDisk, from the MSFT_StorageReliabilityCounter table
// Use DiskController.Discovery.Source(7) for the list of instances instead of PhysicalDisk.Collect.Source(1)
// because non real physical disks have been filtered out from it, thus preventing unnecessary WMI queries
// DeviceId;ReadErrors;Wear;WriteErrors;
PhysicalDisk.Collect.Source(2).Type="WMI"
PhysicalDisk.Collect.Source(2).ExecuteForEachEntryOf=%DiskController.Discovery.Source(7)%
PhysicalDisk.Collect.Source(2).WbemNameSpace="root\Microsoft\Windows\Storage"
PhysicalDisk.Collect.Source(2).WbemQuery="SELECT DeviceId,ReadErrorsTotal,Wear,WriteErrorsTotal FROM ASSOCIATORS OF {%Entry.Column(1)%} WHERE ResultClass = MSFT_StorageReliabilityCounter"
PhysicalDisk.Collect.Source(2).EntryConcatMethod="List"

// TotalErrors = Read + Write
// DeviceId;TotalErrors;Wear;WriteErrors;
PhysicalDisk.Collect.Source(2).Compute(1).Type="Add"
PhysicalDisk.Collect.Source(2).Compute(1).Column=2
PhysicalDisk.Collect.Source(2).Compute(1).Add=Column(4)

// Convert Wear into EnduranceRemaing (Endurance Remaining = 100 - Wear)
// DeviceId;TotalErrors;EnduranceRemaing;WriteErrors;
PhysicalDisk.Collect.Source(2).Compute(2).Type="Multiply"
PhysicalDisk.Collect.Source(2).Compute(2).Column=3
PhysicalDisk.Collect.Source(2).Compute(2).MultiplyBy=-1
PhysicalDisk.Collect.Source(2).Compute(3).Type="Add"
PhysicalDisk.Collect.Source(2).Compute(3).Column=3
PhysicalDisk.Collect.Source(2).Compute(3).Add=100

// Source(3) = Table join of Source(1) and Source(2)
// __PATH;DeviceId;Status;StatusInformation;OperationalStatus;DeviceId;TotalErrors;EnduranceRemaing;WriteErrors;
PhysicalDisk.Collect.Source(3).Type="TableJoint"
PhysicalDisk.Collect.Source(3).LeftTable=%PhysicalDisk.Collect.Source(1)%
PhysicalDisk.Collect.Source(3).RightTable=%PhysicalDisk.Collect.Source(2)%
PhysicalDisk.Collect.Source(3).LeftKeyColumn=2
PhysicalDisk.Collect.Source(3).RightKeyColumn=1
PhysicalDisk.Collect.Source(3).DefaultRightLine=";;;;"

// ValueTable = Source(3)
// __PATH;DeviceId;Status;StatusInformation;OperationalStatus;DeviceId;TotalErrors;EnduranceRemaing;WriteErrors;
PhysicalDisk.Collect.ValueTable=%PhysicalDisk.Collect.Source(3)%
PhysicalDisk.Collect.DeviceID=ValueTable.Column(2)
PhysicalDisk.Collect.Status=ValueTable.Column(3)
PhysicalDisk.Collect.StatusInformation=ValueTable.Column(4)
PhysicalDisk.Collect.PredictedFailure=ValueTable.Column(5)
PhysicalDisk.Collect.ErrorCount=ValueTable.Column(7)
PhysicalDisk.Collect.EnduranceRemaining=ValueTable.Column(8)


//
// LOGICAL DISKS
//

//
// Discovery

// Source(1) = MSFT_Volume
// ObjectId;DriveLetterNumber;DriveType;FileSystem;Name;Size;
LogicalDisk.Discovery.Source(1).Type="WMI"
LogicalDisk.Discovery.Source(1).WbemQuery="SELECT ObjectId,DriveLetter,DriveType,FileSystem,FileSystemLabel,Size FROM MSFT_Volume"
LogicalDisk.Discovery.Source(1).WbemNamespace="root\Microsoft\Windows\Storage"

// Keep only drive type 3 ("Fixed Drive")
// ObjectId;DriveLetterNumber;DriveType;FileSystem;Name;Size;
LogicalDisk.Discovery.Source(1).Compute(1).Type="KeepOnlyMatchingLines"
LogicalDisk.Discovery.Source(1).Compute(1).Column=3
LogicalDisk.Discovery.Source(1).Compute(1).ValueList="3"

// Transform DriveLetterNumber into a letter, and change ObjectId for DriveLetter is possible
// DeviceID;Label;Filesystem;Size;
LogicalDisk.Discovery.Source(1).Compute(2).Type="Awk"
LogicalDisk.Discovery.Source(1).Compute(2).AwkScript=EmbeddedFile(2)
LogicalDisk.Discovery.Source(1).Compute(2).KeepOnlyRegExp="^MSHW;"
LogicalDisk.Discovery.Source(1).Compute(2).Separators=";"
LogicalDisk.Discovery.Source(1).Compute(2).SelectColumns="2,3,4,5"

// InstanceTable = Source(1)
LogicalDisk.Discovery.InstanceTable=%LogicalDisk.Discovery.Source(1)%
LogicalDisk.Discovery.Instance.DeviceID=InstanceTable.Column(1)
LogicalDisk.Discovery.Instance.DisplayID=InstanceTable.Column(2)
LogicalDisk.Discovery.Instance.AdditionalInformation1=InstanceTable.Column(3)
LogicalDisk.Discovery.Instance.Size=InstanceTable.Column(4)
LogicalDisk.Discovery.Instance.LogicalDiskType="Volume"

//
// Collect
LogicalDisk.Collect.Type="MultiInstance"

// Source(1) = MSFT_Volume
// ObjectId;DriveLetter;HealthStatus;OperationalStatus;SizeRemaning;
LogicalDisk.Collect.Source(1).Type="WMI"
LogicalDisk.Collect.Source(1).WbemQuery="SELECT ObjectId,DriveLetter,HealthStatus,SizeRemaining FROM MSFT_Volume"
LogicalDisk.Collect.Source(1).WbemNamespace="root\Microsoft\Windows\Storage"

// Duplicate the HealthStatus column
// ObjectId;DriveLetter;HealthStatus;HealthStatus;SizeRemaning;
LogicalDisk.Collect.Source(1).Compute(1).Type="DuplicateColumn"
LogicalDisk.Collect.Source(1).Compute(1).Column=3

// Translate the first HealthStatus field into a simple status
// ObjectId;DriveLetter;Status;OperationalStatus;SizeRemaning;
LogicalDisk.Collect.Source(1).Compute(2).Type="Translate"
LogicalDisk.Collect.Source(1).Compute(2).Column=3
LogicalDisk.Collect.Source(1).Compute(2).TranslationTable="LogicalDiskHealthStatusTranslationTable"

// The LogicalDiskHealthStateTranslationTable
LogicalDiskHealthStatusTranslationTable(0)="OK"
LogicalDiskHealthStatusTranslationTable(1)="WARN"
LogicalDiskHealthStatusTranslationTable(2)="WARN"
LogicalDiskHealthStatusTranslationTable(3)="ALARM"
LogicalDiskHealthStatusTranslationTable(Default)="UNKNOWN"

// Translate the OperationalStatus field into detailed status information
// ObjectId;DriveLetter;Status;StatusInformation;SizeRemaning;
LogicalDisk.Collect.Source(1).Compute(3).Type="Translate"
LogicalDisk.Collect.Source(1).Compute(3).Column=4
LogicalDisk.Collect.Source(1).Compute(3).TranslationTable="LogicalDiskHealthStatusInformationTranslationTable"

// The LogicalDiskHealthStatusInformationTranslationTable
LogicalDiskHealthStatusInformationTranslationTable(0)=""
LogicalDiskHealthStatusInformationTranslationTable(1)="Scan Needed"
LogicalDiskHealthStatusInformationTranslationTable(2)="Spot Fix Needed"
LogicalDiskHealthStatusInformationTranslationTable(3)="Full Repair Needed"
LogicalDiskHealthStatusInformationTranslationTable(Default)="Unknown"

// Convert ObjectId and DriveLetterNumber into a DeviceId
// DeviceID;Status;StatusInformation;SizeRemaning;
LogicalDisk.Collect.Source(1).Compute(4).Type="Awk"
LogicalDisk.Collect.Source(1).Compute(4).AwkScript=EmbeddedFile(3)
LogicalDisk.Collect.Source(1).Compute(4).KeepOnlyRegExp="^MSHW;"
LogicalDisk.Collect.Source(1).Compute(4).Separators=";"
LogicalDisk.Collect.Source(1).Compute(4).SelectColumns="2,3,4,5"

// ValueTable = Source(1)
LogicalDisk.Collect.ValueTable=%LogicalDisk.Collect.Source(1)%
LogicalDisk.Collect.DeviceID=ValueTable.Column(1)
LogicalDisk.Collect.Status=ValueTable.Column(2)
LogicalDisk.Collect.StatusInformation=ValueTable.Column(3)
LogicalDisk.Collect.UnallocatedSpace=ValueTable.Column(4)


//
// Temperatures
//

//
// Discovery

// Source(1) = ASSOCIATORS of each MSFT_PhysicalDisk, from the MSFT_StorageReliabilityCounter table
// DeviceId;ReadErrors;Wear;WriteErrors;Temperature;TemperatureMax;
Temperature.Discovery.Source(1)=%DiskController.Discovery.Source(10)%

// Remove lines where temperature = 0
// DeviceId;ReadErrors;Wear;WriteErrors;Temperature;TemperatureMax;
Temperature.Discovery.Source(1).Compute(1).Type="ExcludeMatchingLines"
Temperature.Discovery.Source(1).Compute(1).Column=5
Temperature.Discovery.Source(1).Compute(1).ValueList="0"

// Source(2) = Table join of Source(1) with PhysicalDisk.Discovery.Source(1)
// DeviceId;ReadErrors;Wear;WriteErrors;Temperature;TemperatureMax;__PATH_MSFT_DiskDrive;DeviceID;Model;FirmwareVersion;SerialNumber;Size;PnPDeviceID;__PATH_Controller;__PATH_Controller;ControllerName;
Temperature.Discovery.Source(2).Type="TableJoint"
Temperature.Discovery.Source(2).LeftTable=%Temperature.Discovery.Source(1)%
Temperature.Discovery.Source(2).RightTable=%PhysicalDisk.Discovery.Source(1)%
Temperature.Discovery.Source(2).LeftKeyColumn=1
Temperature.Discovery.Source(2).RightKeyColumn=2

// Keep only the necessary columns
// DeviceId;TemperatureMax;Model;
Temperature.Discovery.Source(2).Compute(1).Type="KeepColumns"
Temperature.Discovery.Source(2).Compute(1).ColumnNumbers="1,6,9"

// Assess Warning and Alarm thresholds, based on TemperatureMax
// (which is often 0, in which case we set thresholds based on the type of the disk)
// DeviceId;TemperatureType;WarningThreshold;AlarmThreshold;
Temperature.Discovery.Source(2).Compute(2).Type="Awk"
Temperature.Discovery.Source(2).Compute(2).AwkScript=EmbeddedFile(4)
Temperature.Discovery.Source(2).Compute(2).KeepOnlyRegExp="^MSHW;"
Temperature.Discovery.Source(2).Compute(2).Separators=";"
Temperature.Discovery.Source(2).Compute(2).SelectColumns="2,3,4,5"

// InstanceTable = Source(2)
Temperature.Discovery.InstanceTable=%Temperature.Discovery.Source(2)%
Temperature.Discovery.Instance.DeviceID=InstanceTable.Column(1)
Temperature.Discovery.Instance.TemperatureType=InstanceTable.Column(2)
Temperature.Discovery.Instance.WarningThreshold=InstanceTable.Column(3)
Temperature.Discovery.Instance.AlarmThreshold=InstanceTable.Column(4)

//
// Collect
Temperature.Collect.Type="MultiInstance"

// Source(1) = ASSOCIATORS of each MSFT_PhysicalDisk, from the MSFT_StorageReliabilityCounter table
// DeviceId;ReadErrors;Wear;WriteErrors;Temperature;TemperatureMax;
Temperature.Collect.Source(1).Type="WMI"
Temperature.Collect.Source(1).ExecuteForEachEntryOf=%PhysicalDisk.Discovery.Source(1)%
Temperature.Collect.Source(1).WbemNameSpace="root\Microsoft\Windows\Storage"
Temperature.Collect.Source(1).WbemQuery="SELECT DeviceId,Temperature FROM ASSOCIATORS OF {%Entry.Column(1)%} WHERE ResultClass = MSFT_StorageReliabilityCounter"
Temperature.Collect.Source(1).EntryConcatMethod="List"

// ValueTable = Source(1)
Temperature.Collect.ValueTable=%Temperature.Collect.Source(1)%
Temperature.Collect.DeviceID=ValueTable.Column(1)
Temperature.Collect.Temperature=ValueTable.Column(2)


//////////////////////////////////////////////////////////////////////////
//
// EmbeddedFile(1)
//
// AWK script that combines MSFT_PhysicalDisk info into a label
//
// Input:
// __PATH;BusType;DeviceId;FirmwareVersion;MediaType;Model;SerialNumber;Size;SpindleSpeed;
//
// Output:
// MSHW;__PATH;DisplayID;Model;FirmwareVersion;SerialNumber;Size
//
//////////////////////////////////////////////////////////////////////////
EmbeddedFile(1):
BEGIN { FS = ";" }
{
	__Path = $1;
	busType = $2;
	deviceId = $3;
	firmwareVersion = $4;
	mediaType = $5;
	model = $6
	serialNumber = $7
	size = $8
	speed = $9

	# Media Type
	if (mediaType == 3) {
		# HDD
		if (speed == 15000) {
			model = model " - 15K"
		} else if (speed == 10000) {
			model = model " - 10K"
		} else if (speed > 1000 && speed < 100000) {
			model =  model " - " speed
		}
	} else if (mediaType == 4) {
		# SDD
		model = model " - SSD"
	} else if (mediaType == 5) {
		# SCM (fancy NVDIMM-N)
		model = model " - NVDIMM"
	}

	# Bus Type
	model = model " - " busType

	# Output
	print "MSHW;" __Path ";" deviceId ";" model ";" firmwareVersion ";" serialNumber ";" size
}
EmbeddedFile(1).End


//////////////////////////////////////////////////////////////////////////
//
// EmbeddedFile(2)
//
// AWK script that enhances logical disk information
//
// Input:
// {1}\\BERTRAND4\root/Mic[...]941-11e5-aa56-0090f5e97b36}\";68;3;NTFS;System;34095409406
//
// Output:
// MSHW;C:;C: System;NTFS;34095409406
//
//////////////////////////////////////////////////////////////////////////
EmbeddedFile(2):
BEGIN {
	FS = ";";
	alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
}
{
	if ($2 > 64 && $2 < 91) {
		deviceId = substr(alphabet, int($2) - 64, 1) ":";
		label = deviceId
	} else {
		deviceId = $1;
		label = ""
	}
	if ($5 != "") {
		if (label != "") {
			label = label " ";
		}
		label = label $5;
	}
	filesystem = $4;
	size = $6;
	print "MSHW;" deviceId ";" label ";File System: " filesystem ";" size;
}
EmbeddedFile(2).End


//////////////////////////////////////////////////////////////////////////
//
// EmbeddedFile(3)
//
// AWK script that converts ObjectId and DriveLetterNumber into a DeviceId
//
// Input:
// {1}\\BERTRAND4\root/Mic[...]941-11e5-aa56-0090f5e97b36}\";68;OK;Scan Needed;34095409406
//
// Output:
// MSHW;C:;OK;Scan Needed;34095409406
//
//////////////////////////////////////////////////////////////////////////
EmbeddedFile(3):
BEGIN {
	FS = ";";
	alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
}
{
	if ($2 > 64 && $2 < 91) {
		deviceId = substr(alphabet, int($2) - 64, 1) ":";
	} else {
		deviceId = $1;
	}
	print "MSHW;" deviceId ";" $3 ";" $4 ";" $5;
}
EmbeddedFile(3).End

//////////////////////////////////////////////////////////////////////////
//
// EmbeddedFile(4)
//
// AWK script that returns the alarm thresholds for temperatures
//
// Input:
// DeviceId;TemperatureMax;Model;
// 0;75;SAMSUNG SSD870 3043594530;
//
// Output:
// DeviceId;TemperatureType;WarningThreshold;AlarmThreshold;
// MSHW;0;SAMSUNG SSD870 3043594530;;75
//
//////////////////////////////////////////////////////////////////////////
EmbeddedFile(4):
BEGIN { FS = ";" }
{
	warningThreshold = "";
	alarmThreshold = $2;
	model = $3;
	if (alarmThreshold == "" || alarmThreshold == 0) {
		if (tolower(model) ~ /ssd|nvm/) {
			warningThreshold = 65;
			alarmThreshold = 70;
		} else {
			warningThreshold = 41;
			alarmThreshold = 50;
		}
	}
	print "MSHW;" $1 ";" model ";" warningThreshold ";" alarmThreshold
}
EmbeddedFile(4).End
