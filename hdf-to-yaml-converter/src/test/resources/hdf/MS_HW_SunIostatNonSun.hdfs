//
//
//                 C O N N E C T O R
//
//                       f o r
//
//                 Hardware Sentry
//
//                 by Sentry Software (c)
//
//               MS_HW_SunIostatNonSun.hdf
//
//      Supports: Sun machines
//		Monitors: disks (physical disks, but only NON-'Sun' stamped disks)
//      Connects to: iostat under Solaris
//
//

//
// HEADER
//

hdf.DisplayName="Oracle/Sun Solaris - Non-Sun Disks"
hdf.TypicalPlatform="Oracle/Sun"
hdf.ReliesOn="Sun Solaris system commands (iostat, dd)"
hdf.Comments="Gives physical disk information (status and error count) on Sun Solaris systems through the iostat -En utility. Supports only non-Sun official disks."
hdf.Version="1.7"
hdf.RemoteSupport="true"
hdf.AppliesToOS="Solaris"

//
// SUDO-able commands
//
Sudo(1).Command="/usr/bin/dd"


//
// DETECTION
//

// Solaris only
Detection.Criteria(1).Type="OS"
Detection.Criteria(1).KeepOnly="SunOS,Solaris"

// iostat must return something
Detection.Criteria(2).Type="OSCommand"
Detection.Criteria(2).CommandLine="/usr/bin/iostat -En"
Detection.Criteria(2).ExpectedResult="Soft [Ee]rrors.*Hard [Ee]rrors.*Transport [Ee]rrors"
Detection.Criteria(2).ErrorMessage="iostat seems to not work as expected. Please check the output of 'iostat -En'"

// Logically, this connector is superseded by the MS_HW_SunIostat.hdf connector (for official Sun disks)
// which means that this connector gets "detected" if and only if there are no Sun disks.
// Then, you can still pre-select it, if needed.

//
// DISK CONTROLLER
//

//
// Discovery

// Source(1) = output of iostat reformatted by the awk (see EmbeddedFile(1))
// DeviceID
DiskController.Discovery.Source(1).Type="OsCommand"
DiskController.Discovery.Source(1).CommandLine="/usr/bin/iostat -En|/usr/bin/awk -f %EmbeddedFile(1)%|/usr/bin/uniq"
DiskController.Discovery.Source(1).KeepOnlyRegExp="^MSHW;"
DiskController.Discovery.Source(1).Separators=";"
DiskController.Discovery.Source(1).SelectColumns="2"

// Source(2) = output of iostat
DiskController.Discovery.Source(2).Type="OsCommand"
DiskController.Discovery.Source(2).CommandLine="iostat -En"

// Reformat iostat's output through awk (see EmbeddedFile(2))
// DeviceID;ControllerNumber;Size;VendorModel;SerialNumber
DiskController.Discovery.Source(2).Compute(1).Type="Awk"
DiskController.Discovery.Source(2).Compute(1).AwkScript=EmbeddedFile(2)
DiskController.Discovery.Source(2).Compute(1).KeepOnlyRegExp="^MSHW;"
DiskController.Discovery.Source(2).Compute(1).Separators=";"
DiskController.Discovery.Source(2).Compute(1).SelectColumns="2,3,4,5,6"


// Source(3) = Table Joint of source(1) and source(2)
// this is to remove disk controllers which don't have physical disks attached to
// DeviceID;DiskDeviceID;ControllerNumber;Size;VendorModel;SerialNumber
DiskController.Discovery.Source(3).Type="TableJoint"
DiskController.Discovery.Source(3).LeftTable=%DiskController.Discovery.Source(1)%
DiskController.Discovery.Source(3).RightTable=%DiskController.Discovery.Source(2)%
DiskController.Discovery.Source(3).LeftKeyColumn=1
DiskController.Discovery.Source(3).RightKeyColumn=2


// InstanceTable = Source(3)
DiskController.Discovery.InstanceTable=%DiskController.Discovery.Source(3)%
DiskController.Discovery.Instance.DeviceID=InstanceTable.Column(1)
DiskController.Discovery.Instance.DisplayID=InstanceTable.Column(1)
DiskController.Discovery.Instance.ControllerNumber=InstanceTable.Column(1)
DiskController.Discovery.Instance.Model=""


//
// PHYSICAL DISKS
//

//
// Discovery

// Source(1) = copy of DiskController.Discovery.Source(2)
PhysicalDisk.Discovery.Source(1)=%DiskController.Discovery.Source(2)%

// InstanceTable = Source(1)
PhysicalDisk.Discovery.InstanceTable=%PhysicalDisk.Discovery.Source(1)%
PhysicalDisk.Discovery.Instance.DeviceID=InstanceTable.Column(1)
PhysicalDisk.Discovery.Instance.DisplayID=InstanceTable.Column(1)
PhysicalDisk.Discovery.Instance.ControllerNumber=InstanceTable.Column(2)
PhysicalDisk.Discovery.Instance.Size=InstanceTable.Column(3)
PhysicalDisk.Discovery.Instance.Vendor=InstanceTable.Column(4)
PhysicalDisk.Discovery.Instance.SerialNumber=InstanceTable.Column(5)

//
// Collect

// Collect type is "all instances in one shot"
PhysicalDisk.Collect.Type="MultiInstance"

// Source(1) = output of iostat
PhysicalDisk.Collect.Source(1).Type="OsCommand"
PhysicalDisk.Collect.Source(1).CommandLine="/usr/bin/iostat -En"

// Source(1) = output of iostat reformatted by awk (see EmbeddedFile(3))
// DeviceID;ErrorCount;HardErrorCount;MediaErrorCount;DeviceNotReadyErrorCount;NoDeviceErrorCount;TransportErrorCount;RecoverableErrorCount;IllegalRequestErrorCount;PredictedFailure
PhysicalDisk.Collect.Source(1).Compute(1).Type="Awk"
PhysicalDisk.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(3)
PhysicalDisk.Collect.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
PhysicalDisk.Collect.Source(1).Compute(1).Separators=";"
PhysicalDisk.Collect.Source(1).Compute(1).SelectColumns="2,3,4,5,6,7,8,9,10,11"

// Source(2) = output of the shell script based on the format command
// DeviceID;Status;StatusInformation
PhysicalDisk.Collect.Source(2).Type="OsCommand"
PhysicalDisk.Collect.Source(2).CommandLine="/usr/bin/sh %EmbeddedFile(4)%"
PhysicalDisk.Collect.Source(2).KeepOnlyRegExp="^MSHW;"
PhysicalDisk.Collect.Source(2).Separators=";"
PhysicalDisk.Collect.Source(2).SelectColumns="2,3,4"

// Source(3) = Table joint of Source(1) and Source(2)
// DeviceID;ErrorCount;HardErrorCount;MediaErrorCount;DeviceNotReadyErrorCount;NoDeviceErrorCount;TransportErrorCount;RecoverableErrorCount;IllegalRequestErrorCount;PredictedFailure;DeviceID;Status;StatusInformation
PhysicalDisk.Collect.Source(3).Type="TableJoint"
PhysicalDisk.Collect.Source(3).LeftTable=%PhysicalDisk.Collect.Source(1)%
PhysicalDisk.Collect.Source(3).RightTable=%PhysicalDisk.Collect.Source(2)%
PhysicalDisk.Collect.Source(3).LeftKeyColumn=1
PhysicalDisk.Collect.Source(3).RightKeyColumn=1

// ValueTable = Source(3)
PhysicalDisk.Collect.ValueTable=%PhysicalDisk.Collect.Source(3)%
PhysicalDisk.Collect.DeviceID=ValueTable.Column(1)
PhysicalDisk.Collect.ErrorCount=ValueTable.Column(2)
PhysicalDisk.Collect.HardErrorCount=ValueTable.Column(3)
PhysicalDisk.Collect.MediaErrorCount=ValueTable.Column(4)
PhysicalDisk.Collect.DeviceNotReadyErrorCount=ValueTable.Column(5)
PhysicalDisk.Collect.NoDeviceErrorCount=ValueTable.Column(6)
PhysicalDisk.Collect.TransportErrorCount=ValueTable.Column(7)
PhysicalDisk.Collect.RecoverableErrorCount=ValueTable.Column(8)
PhysicalDisk.Collect.IllegalRequestErrorCount=ValueTable.Column(9)
PhysicalDisk.Collect.PredictedFailure=ValueTable.Column(10)
PhysicalDisk.Collect.Status=ValueTable.Column(12)
PhysicalDisk.Collect.StatusInformation=ValueTable.Column(13)


/////////////////////////////////////////////////////////////
///
///    Embedded File 1
///
///    AWK script that takes iostat -En as stdin
///    and returns a table with all the disk controllers
///
/////////////////////////////////////////////////////////////

EmbeddedFile(1):
{
	if ($0 ~ /^c[0-9]+t[0-9A-Z]+d[0-9]+/ || $0 ~ /^s+d[0-9]+/)
	{
		if ($1 ~ /^c[0-9]+t[0-9A-Z]+d[0-9]+/)
		{
			targetIndex = index($1, "t")
			controller = substr($1, 1, targetIndex - 1)
		}
		else
		{
			controller = "Other"
		}
	}

	if ($0 ~/Illegal Request:/)
	{
		print "MSHW;" controller
	}
}
EmbeddedFile(1).End
///////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////
///
///    Embedded File 2
///
///    AWK script that takes iostat -En as stdin
///    and returns a table with all the physical disks of
///    the computer
///
///////////////////////////////////////////////////////////////

EmbeddedFile(2):
{
	if ($0 ~ /^c[0-9]+t[0-9A-Z]+d[0-9]+/ || $0 ~ /^s+d[0-9]+/)
	{
		disk = $1
		size = "0"
		vendor = ""
		product = ""
		model = ""
		productmodel = ""
		serial = ""
		if (disk ~ /^c[0-9]+t[0-9A-Z]+d[0-9]+/)
		{
			targetIndex = index(disk, "t")
			controller = substr(disk, 1, targetIndex - 1)
		}
		else
		{
			controller = "Other"
		}
	}

	if ($0 ~ /Size: /)
	{
		index1 = index($0, "<") + 1
		index2 = index($0, " bytes>")
		size = substr($0, index1, index2-index1)
	}

	if ($0 ~ /Vendor: /)
	{
		index1 = index($0, "Vendor: " ) + length("Vendor: ")
		vendor = substr($0, index1, length-index1)
		index1 = index(vendor, ":")
		if (index1 > 0)
		{
			vendor = substr(vendor, 1, index1-1)
			n = split(vendor, a, " ")
			vendor = ""
			for (i=1 ; i<n ; i++)
			{
				vendor = vendor a[i]
				if (i < n-1)
					vendor = vendor " "
			}
		}
	}

	if ($0 ~ /Model: /)
	{
		index1 = index($0, "Model: " ) + length("Model: ")
		model = substr($0, index1, length-index1)
		index1 = index(model, ":")
		if (index1 > 0)
		{
			model = substr(model, 1, index1-1)
			n = split(model, a, " ")
			model = ""
			for (i=1 ; i<n ; i++)
			{
				model = model a[i]
				if (i < n-1)
					model = model " "
			}
		}
	}

	if ($0 ~ /Product: /)
	{
		index1 = index($0, "Product: " ) + length("Product: ")
		product = substr($0, index1, length-index1)
		index1 = index(product, ":")
		if (index1 > 0)
		{
			product = substr(product, 1, index1-1)
			n = split(product, a, " ")
			product = ""
			for (i=1 ; i<n ; i++)
			{
				product = product a[i]
				if (i < n-1)
					product = product " "
			}
		}
	}

	if ($0 ~ /Serial No: /)
	{
		index1 = index($0, "Serial No: " ) + length("Serial No: ")
		serial = substr($0, index1, length-index1)
		index1 = index(serial, ":")
		if (index1 > 0)
		{
			serial = substr(serial, 1, index1-1)
			n = split(serial, a, " ")
			serial = ""
			for (i=1 ; i<n ; i++)
			{
				serial = serial a[i]
				if (i < n-1)
					serial = serial " "
			}
		}

	}

	if ($0 ~/Illegal Request:/)
	{
		if (product != "" && model != "")
		{
			productmodel = product " " model
		}
		else
		{
			productmodel = product model
		}

# THE FOLLOWING LINE EXISTS 3 TIMES IN THIS CONNECTOR.  ALL 3 SHOULD BE IDENTICAL
if (disk != "" && product !~ /SUN[0-9\.]+[GT]/ && vendor != "EMC" && vendor != "LSILOGIC" && vendor != "DGC" && vendor != "StoreAge" && vendor != "SUN" && product != "StorEdge" && product != "StorEDGE" && product !~ /^HSV[0-9]/ && vendor != "EUROLOGC"  && vendor !~ /HP HSV[0-9]/ && product !~ /OPEN-V/ && product !~ /INF-01-00/ && product !~ /DF600F/ && size > 10 && vendor !="NETAPP" && product != "LUN" && vendor !="3PARdata" && (!(vendor == ("IBM") && product == ("2145"))))
		{
			print "MSHW;" disk ";" controller ";" size ";" vendor " " productmodel ";" serial
		}

		disk = ""
		size = "0"
		vendor = ""
		product = ""
		model = ""
		productmodel = ""
		serial = ""

	}

}
EmbeddedFile(2).End
//////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////
///
///    Embedded File 3
///
///    AWK script that takes iostat -En as stdin
///    and returns a table with the status of each physical disks of
///    the computer
///
///////////////////////////////////////////////////////////////

EmbeddedFile(3):
{
	if ($0 ~ /^c[0-9]+t[0-9A-Z]+d[0-9]+/ || $0 ~ /^s+d[0-9]+/)
	{
		disk = $1
		product = ""
		transporterror = 0
		hardwareerror = 0
		mediaerror = 0
		devicenotready = 0
		nodevice = 0
		recoverable = 0
		illegalrequests = 0
		predictivefailureanalysis = 0
		statusinformation = ""
		totalerror = 0
		vendor = ""
		size = 0
	}

	if ($0 ~ /Product: /)
	{
		index1 = index($0, "Product: " ) + length("Product: ")
		product = substr($0, index1, length-index1)
		index1 = index(product, ":")
		if (index1 > 0)
		{
			product = substr(product, 1, index1-1)
			n = split(product, a, " ")
			product = ""
			for (i=1 ; i<n ; i++)
			{
				product = product a[i]
				if (i < n-1)
					product = product " "
			}
		}
	}

	if ($0 ~ /Vendor: /)
	{
		index1 = index($0, "Vendor: " ) + length("Vendor: ")
		vendor = substr($0, index1, length-index1)
		index1 = index(vendor, ":")
		if (index1 > 0)
		{
			vendor = substr(vendor, 1, index1-1)
			n = split(vendor, a, " ")
			vendor = ""
			for (i=1 ; i<n ; i++)
			{
				vendor = vendor a[i]
				if (i < n-1)
					vendor = vendor " "
			}
		}
	}

	if ($0 ~ /Size: /)
	{
		index1 = index($0, "<") + 1
		index2 = index($0, " bytes>")
		size = substr($0, index1, index2-index1)
	}

	if ($8 == "Transport" && ($9 == "Errors:" || $9 == "errors:"))
	{
		transporterror = $10
	}

	if ($5 == "Hard" && ($6 == "Errors:" || $6 == "errors:"))
	{
		hardwareerror = $7
	}

	if ($1 == "Media" && ($2 == "Error:" || $2 == "error:"))
	{
		mediaerror = $3
	}

	if ($4 == "Device" && $5 == "Not" && $6 == "Ready:")
	{
		devicenotready = $7
	}

	if ($8 == "No" && $9 == "Device:")
	{
		nodevice = $10
	}

	if ($11 == "Recoverable:")
	{
		recoverable = $12
	}

	if ($1 == "Illegal" && $2 == "Request:")
	{
		illegalrequests = $3
	}

	if ($4 == "Predictive" && $5 == "Failure" && $6 == "Analysis:")
	{
		predictivefailureanalysis = $7
	}

	if ($0 ~/Illegal Request:/)
	{
		hardwareerror = hardwareerror - mediaerror - devicenotready - nodevice
		if (hardwareerror < 0)
		{
			hardwareerror = 0
		}

		if (predictivefailureanalysis > 0)
		{
			predictivefailureanalysis = "TRUE"
		}
		else
		{
			predictivefailureanalysis = "FALSE"
		}

		totalerror = recoverable + transporterror + mediaerror + devicenotready + nodevice + hardwareerror

# THE FOLLOWING LINE EXISTS 3 TIMES IN THIS CONNECTOR.  ALL 3 SHOULD BE IDENTICAL
if (disk != "" && product !~ /SUN[0-9\.]+[GT]/ && vendor != "EMC" && vendor != "LSILOGIC" && vendor != "DGC" && vendor != "StoreAge" && vendor != "SUN" && product != "StorEdge" && product != "StorEDGE" && product !~ /^HSV[0-9]/ && vendor != "EUROLOGC"  && vendor !~ /HP HSV[0-9]/ && product !~ /OPEN-V/ && product !~ /INF-01-00/ && product !~ /DF600F/ && size > 10 && vendor !="NETAPP" && product != "LUN" && vendor !="3PARdata" && (!(vendor == ("IBM") && product == ("2145"))))
		{
			print "MSHW;" disk ";" totalerror ";" hardwareerror ";" mediaerror ";" devicenotready ";" nodevice ";" transporterror ";" recoverable ";" illegalrequests ";" predictivefailureanalysis
		}

		product = ""
		transporterror = 0
		hardwareerror = 0
		mediaerror = 0
		devicenotready = 0
		nodevice = 0
		recoverable = 0
		illegalrequests = 0
		predictivefailureanalysis = 0
		statusinformation = ""
		totalerror = 0
		vendor = ""
		size = 0

	}

}
EmbeddedFile(3).End
///////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////
///
///    Embedded File 4
///
///    Shell script that polls the status of each
///    physical disk as returned by the format utility
///
///    Requires root privileges for the format command
///
///////////////////////////////////////////////////////////////
EmbeddedFile(4):
DISKLIST=`/usr/bin/iostat -En|/usr/bin/awk '{
	if ($0 ~ /^c[0-9]+t[0-9A-Z]+d[0-9]+/ || $0 ~ /^s+d[0-9]+/)
	{
		disk = $1
		product = ""
		vendor = ""
		size = 0
	}

	if ($0 ~ /Product: /)
	{
		index1 = index($0, "Product: " ) + length("Product: ")
		product = substr($0, index1, length-index1)
		index1 = index(product, ":")
		if (index1 > 0)
		{
			product = substr(product, 1, index1-1)
			n = split(product, a, " ")
			product = ""
			for (i=1 ; i<n ; i++)
			{
				product = product a[i]
				if (i < n-1)
					product = product " "
			}
		}
	}

	if ($0 ~ /Vendor: /)
	{
		index1 = index($0, "Vendor: " ) + length("Vendor: ")
		vendor = substr($0, index1, length-index1)
		index1 = index(vendor, ":")
		if (index1 > 0)
		{
			vendor = substr(vendor, 1, index1-1)
			n = split(vendor, a, " ")
			vendor = ""
			for (i=1 ; i<n ; i++)
			{
				vendor = vendor a[i]
				if (i < n-1)
					vendor = vendor " "
			}
		}
	}

	if ($0 ~ /Size: /)
	{
		index1 = index($0, "<") + 1
		index2 = index($0, " bytes>")
		size = substr($0, index1, index2-index1)
	}

	if ($0 ~/Illegal Request:/)
	{
# THE FOLLOWING LINE EXISTS 3 TIMES IN THIS CONNECTOR.  ALL 3 SHOULD BE IDENTICAL
if (disk != "" && product !~ /SUN[0-9\.]+[GT]/ && vendor != "EMC" && vendor != "LSILOGIC" && vendor != "DGC" && vendor != "StoreAge" && vendor != "SUN" && product != "StorEdge" && product != "StorEDGE" && product !~ /^HSV[0-9]/ && vendor != "EUROLOGC"  && vendor !~ /HP HSV[0-9]/ && product !~ /OPEN-V/ && product !~ /INF-01-00/ && product !~ /DF600F/ && size > 10 && vendor !="NETAPP" && product != "LUN" && vendor !="3PARdata" && (!(vendor == ("IBM") && product == ("2145"))))
		{
			print disk
		}

		disk = ""
		product = ""
	}
}'|/usr/bin/head -30`

LANG=C
export LANG

for DISK in $DISKLIST
do

	if /usr/bin/echo $DISK|/usr/bin/grep "^c[0-9][0-9]*t[0-9A-Z][0-9A-Z]*d[0-9][0-9]*" 2>/dev/null >/dev/null; then
		CTDSLIST=`/usr/bin/ls /dev/rdsk/$DISK"s"* 2>/dev/null`
	else
		DRIVERNAME=`/usr/bin/echo $DISK|/usr/bin/tr -d [:digit:]`
		INSTANCENUMBER=`/usr/bin/echo $DISK|/usr/bin/tr -d [:alpha:]`
		DEVICEPATH=`/usr/xpg4/bin/awk -v instanceNumber=$INSTANCENUMBER -v driverName=$DRIVERNAME '($(NF-1) == instanceNumber) && ($NF == "\""driverName"\"") { print $1 }' /etc/path_to_inst|/usr/bin/tr -d \"`
		CTDSLIST=`/usr/bin/ls -l /dev/rdsk/c*|/usr/xpg4/bin/awk -v devicePath="$DEVICEPATH" '($NF ~ devicePath && devicePath != "") { print $(NF-2); }'`
	fi

	if /usr/bin/test -z "$CTDSLIST" ; then
		/usr/bin/echo "MSHW;$DISK;UNKNOWN;Couldn't find corresponding block device";
	else
		FOUNDWORKINGCTDS=0
		for CTDS in $CTDSLIST
		do
			ERRORMESSAGE=`%{SUDO:/usr/bin/dd}/usr/bin/dd if=$CTDS of=/dev/null count=20 2>&1`
			if /usr/bin/test "$?" = "0" ; then
				/usr/bin/echo "MSHW;$DISK;OK;Working"
				FOUNDWORKINGCTDS=1
				break
			fi
		done
		if /usr/bin/test "$FOUNDWORKINGCTDS" == "0" ; then
			ERRORMESSAGE=`/usr/bin/echo $ERRORMESSAGE|/usr/bin/awk -F: '($4 !~ /denied/ && $4 !~ /[Nn]o such file/) {print $4}'`
			if /usr/bin/test -z "$ERRORMESSAGE" ; then
				/usr/bin/echo "MSHW;$DISK;UNKNOWN;Unknown Status";
			else
				/usr/bin/echo "MSHW;$DISK;ALARM;$ERRORMESSAGE";
			fi
		fi
	fi
done
EmbeddedFile(4).End
///////////////////////////////////////////////////////////////////
