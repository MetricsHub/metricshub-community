//
// SUDO-able commands
//
Sudo(1).Command="/usr/bin/isi"
Sudo(2).Command="/usr/bin/isi_for_array"

//
// DETECTION
//

// Check that /usr/bin/isi exists
Detection.Criteria(1).Type="OSCommand"
Detection.Criteria(1).CommandLine="if [ -f /usr/bin/isi ] ; then echo ms_hw_isi_found ; fi"
Detection.Criteria(1).ErrorMessage="/usr/bin/isi not found"
Detection.Criteria(1).ExpectedResult="ms_hw_isi_found"

// ENCLOSURE

// Source(1) = Run isi_hw_check
Enclosure.Discovery.Source(1).Type="OsCommand"
Enclosure.Discovery.Source(1).CommandLine="/bin/zsh -c ""%{SUDO:/usr/bin/isi_for_array} /usr/bin/isi_for_array /usr/bin/isi_hwtools/isi_hw_check -l /tmp/MS_HW_isi_hw_check"" "
Enclosure.Discovery.Source(1).TimeOut="1200"

// Process the command through an AWK script
// Sorts Parallel to Sequential
Enclosure.Discovery.Source(1).Compute(1).Type="Awk"
Enclosure.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(7)

// Process the command through an AWK script
// MSHW_CLASS;  ....
Enclosure.Discovery.Source(1).Compute(2).Type="Awk"
Enclosure.Discovery.Source(1).Compute(2).AwkScript=EmbeddedFile(1)
Enclosure.Discovery.Source(1).Compute(2).KeepOnlyRegExp="^MSHW"
Enclosure.Discovery.Source(1).Compute(2).Separators=";"

// Source(2) = Run isi status -v
// NOTE:  _IsiStatusCommand is a constant (from individual connector)
Enclosure.Discovery.Source(2).Type="OsCommand"
Enclosure.Discovery.Source(2).CommandLine="/bin/zsh -c ""%{SUDO:/usr/bin/isi} _IsiStatusCommand "" "
Enclosure.Discovery.Source(2).TimeOut="60"

// Process the command through an AWK script
// MSHW_ENCLOSURE;Class;nodeNumber;Status;Status;IPAddress;
Enclosure.Discovery.Source(2).Compute(1).Type="Awk"
Enclosure.Discovery.Source(2).Compute(1).AwkScript=EmbeddedFile(4)
Enclosure.Discovery.Source(2).Compute(1).KeepOnlyRegExp="^MSHW"
Enclosure.Discovery.Source(2).Compute(1).Separators=";"

// Source(3) = Run isi devices
Enclosure.Discovery.Source(3).Type="OsCommand"
Enclosure.Discovery.Source(3).CommandLine="/bin/zsh -c ""%{SUDO:/usr/bin/isi_for_array} /usr/bin/isi_for_array _IsiDevicesCommand "" "
Enclosure.Discovery.Source(3).TimeOut="60"

// Process the command through an AWK script
// Sorts Parallel to Sequential
Enclosure.Discovery.Source(3).Compute(1).Type="Awk"
Enclosure.Discovery.Source(3).Compute(1).AwkScript=EmbeddedFile(7)

// Process the command through an AWK script
// MSHW_Node;nodeName;nodeNumber;
// MSHW_PhysicalDisk;Location;Lnum;SerialNumber;Status;Status;
Enclosure.Discovery.Source(3).Compute(2).Type="Awk"
Enclosure.Discovery.Source(3).Compute(2).AwkScript=EmbeddedFile(5)
Enclosure.Discovery.Source(3).Compute(2).KeepOnlyRegExp="^MSHW"
Enclosure.Discovery.Source(3).Compute(2).Separators=";"

// Join the Enclosure Instance list (source 2) with the nodename to nodeid table from isi devices
// MSHW_ENCLOSURE;Class;nodeNumber;Status;Status;IPAddress;MSHW_Node;nodeName;nodeNumber;
Enclosure.Discovery.Source(4).Type="TableJoint"
Enclosure.Discovery.Source(4).LeftTable=%Enclosure.Discovery.Source(2)%
Enclosure.Discovery.Source(4).RightTable=%Enclosure.Discovery.Source(3)%
Enclosure.Discovery.Source(4).LeftKeyColumn=3
Enclosure.Discovery.Source(4).RightKeyColumn=3
Enclosure.Discovery.Source(4).DefaultRightLine="MSHW_Cluster;Cluster;Cluster;"

// Get FRU information
// Source(5) = Run auparts
Enclosure.Discovery.Source(5).Type="OsCommand"
Enclosure.Discovery.Source(5).CommandLine="/bin/zsh -c ""%{SUDO:/usr/bin/isi_for_array} /usr/bin/isi_for_array /usr/bin/isi_hwtools/isi_hw_status"" "
Enclosure.Discovery.Source(5).TimeOut="60"

// Process through awk to get model, serial, etc.
// MSHW;nodeName;systemSerialNumber;systemProductModel;systemRAM;
Enclosure.Discovery.Source(5).Compute(1).Type="Awk"
Enclosure.Discovery.Source(5).Compute(1).AwkScript=EmbeddedFile(10)
Enclosure.Discovery.Source(5).Compute(1).KeepOnlyRegExp="^MSHW"
Enclosure.Discovery.Source(5).Compute(1).Separators=";"

// Join the Main discovery with the FRU info
// MSHW_ENCLOSURE;Class;nodeNumber;Status;Status;IPAddress;MSHW_Node;nodeName;nodeNumber;MSHW;nodeName;systemSerialNumber;systemProductModel;systemRAM;
Enclosure.Discovery.Source(6).Type="TableJoint"
Enclosure.Discovery.Source(6).LeftTable=%Enclosure.Discovery.Source(4)%
Enclosure.Discovery.Source(6).RightTable=%Enclosure.Discovery.Source(5)%
Enclosure.Discovery.Source(6).LeftKeyColumn=8
Enclosure.Discovery.Source(6).RightKeyColumn=2
Enclosure.Discovery.Source(6).DefaultRightLine=";;;;;"

Enclosure.Discovery.Source(6).Compute(1).Type="LeftConcat"
Enclosure.Discovery.Source(6).Compute(1).Column=14
Enclosure.Discovery.Source(6).Compute(1).String="Memory: "

// Instance Table
// MSHW_ENCLOSURE;Class;nodeNumber;Status;Status;IPAddress;MSHW_Node;nodeName;nodeNumber;MSHW;nodeName;systemSerialNumber;systemProductModel;systemRAM;
//       1          2       3        4        5      6          7       8          9       10    11       12                    13             14
Enclosure.Discovery.InstanceTable=%Enclosure.Discovery.Source(6)%
Enclosure.Discovery.Instance.DeviceID=InstanceTable.Column(8)
Enclosure.Discovery.Instance.DisplayID=InstanceTable.Column(8)
Enclosure.Discovery.Instance.Vendor="EMC"
Enclosure.Discovery.Instance.Model=InstanceTable.Column(13)
Enclosure.Discovery.Instance.SerialNumber=InstanceTable.Column(12)
Enclosure.Discovery.Instance.AdditionalInformation1=InstanceTable.Column(14)
Enclosure.Discovery.Instance.Type=InstanceTable.Column(2)


// Collect

// Collect type: MultiInstance
Enclosure.Collect.Type="MultiInstance"

// Source(1) = Run isi status -w
Enclosure.Collect.Source(1).Type="OsCommand"
Enclosure.Collect.Source(1).CommandLine="/bin/zsh -c ""%{SUDO:/usr/bin/isi} _IsiStatusCommand"" "
Enclosure.Collect.Source(1).TimeOut="60"

// Process the command through an AWK script
// MSHW_ENCLOSURE;Class;nodeNumber;Status;Status;IPAddress;
Enclosure.Collect.Source(1).Compute(1).Type="Awk"
Enclosure.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(4)
Enclosure.Collect.Source(1).Compute(1).KeepOnlyRegExp="^MSHW"
Enclosure.Collect.Source(1).Compute(1).Separators=";"

// Take a copy of the Enclosure Collect
// MSHW_ENCLOSURE;Class;nodeNumber;Status;Status;IPAddress;
Enclosure.Collect.Source(2)=%Enclosure.Collect.Source(1)%

// Keep only Cluster
// MSHW_ENCLOSURE;Class;nodeNumber;Status;Status;IPAddress;
Enclosure.Collect.Source(2).Compute(1).Type="KeepOnlyMatchingLines"
Enclosure.Collect.Source(2).Compute(1).Column=2
Enclosure.Collect.Source(2).Compute(1).ValueList="Cluster"

// Translate the Status to Patrol Status
// MSHW_ENCLOSURE;Class;nodeNumber;PatrolStatus;Status;IPAddress;
Enclosure.Collect.Source(2).Compute(2).Type="Translate"
Enclosure.Collect.Source(2).Compute(2).Column=4
Enclosure.Collect.Source(2).Compute(2).TranslationTable="ClusterStatusTranslationTable"

// The ClusterStatusTranslationTable
ClusterStatusTranslationTable("OK")="OK"
ClusterStatusTranslationTable(Default)="ALARM"

// Replace the Cluster's name (nodeNumber) with "Cluster"
// MSHW_ENCLOSURE;Class;nodeName;PatrolStatus;Status;IPAddress;
Enclosure.Collect.Source(2).Compute(3).Type="Replace"
Enclosure.Collect.Source(2).Compute(3).Column=3
Enclosure.Collect.Source(2).Compute(3).Replace=Column(3)
Enclosure.Collect.Source(2).Compute(3).ReplaceBy="Cluster"

// Join the Source 1 collect with discovery source 3 so that we can get node names
// MSHW_ENCLOSURE;Class;nodeNumber;Status;Status;IPAddress;MSHW_Node;nodeName;nodeNumber;
Enclosure.Collect.Source(3).Type="TableJoint"
Enclosure.Collect.Source(3).LeftTable=%Enclosure.Collect.Source(1)%
Enclosure.Collect.Source(3).RightTable=%Enclosure.Discovery.Source(3)%
Enclosure.Collect.Source(3).LeftKeyColumn=3
Enclosure.Collect.Source(3).RightKeyColumn=3

// Replace the Node Number with the Node Name
// MSHW_ENCLOSURE;Class;nodeName;Status;Status;IPAddress;MSHW_Node;nodeName;nodeNumber;
Enclosure.Collect.Source(3).Compute(1).Type="Replace"
Enclosure.Collect.Source(3).Compute(1).Column=3
Enclosure.Collect.Source(3).Compute(1).Replace=Column(3)
Enclosure.Collect.Source(3).Compute(1).ReplaceBy=Column(8)

// Translate the Patrol Status
// MSHW_ENCLOSURE;Class;nodeName;PatrolStatus;Status;IPAddress;MSHW_Node;nodeName;nodeNumber;
Enclosure.Collect.Source(3).Compute(2).Type="Translate"
Enclosure.Collect.Source(3).Compute(2).Column=4
Enclosure.Collect.Source(3).Compute(2).TranslationTable="NodeStatusTranslationTable"

// The BatteryStatusTranslationTable
NodeStatusTranslationTable("----")="OK"
NodeStatusTranslationTable("---R")="WARN"
NodeStatusTranslationTable("--S-")="WARN"
NodeStatusTranslationTable("--SR")="WARN"
NodeStatusTranslationTable("-A--")="WARN"
NodeStatusTranslationTable("-A-R")="WARN"
NodeStatusTranslationTable("-AS-")="WARN"
NodeStatusTranslationTable("-ASR")="WARN"
NodeStatusTranslationTable("D---")="ALARM"
NodeStatusTranslationTable("D--R")="ALARM"
NodeStatusTranslationTable("D-S-")="ALARM"
NodeStatusTranslationTable("D-SR")="ALARM"
NodeStatusTranslationTable("DA--")="ALARM"
NodeStatusTranslationTable("DA-R")="ALARM"
NodeStatusTranslationTable("DAS-")="ALARM"
NodeStatusTranslationTable("DASR")="ALARM"
NodeStatusTranslationTable("OK")="OK"
NodeStatusTranslationTable(Default)="UNKNOWN"

// Translate the Status Information
// MSHW_ENCLOSURE;Class;nodeName;PatrolStatus;StatusInformation;IPAddress;MSHW_Node;nodeName;nodeNumber;
Enclosure.Collect.Source(3).Compute(3).Type="Translate"
Enclosure.Collect.Source(3).Compute(3).Column=5
Enclosure.Collect.Source(3).Compute(3).TranslationTable="NodeStatusInformationTranslationTable"

// The BatteryStatusTranslationTable
NodeStatusInformationTranslationTable("----")=""
NodeStatusInformationTranslationTable("---R")="Read-Only"
NodeStatusInformationTranslationTable("--S-")="Smartfailed"
NodeStatusInformationTranslationTable("--SR")="Smartfailed Read-Only"
NodeStatusInformationTranslationTable("-A--")="Attention"
NodeStatusInformationTranslationTable("-A-R")="Attention Read-Only"
NodeStatusInformationTranslationTable("-AS-")="Attention Smartfailed"
NodeStatusInformationTranslationTable("-ASR")="Attention Smartfailed Read-Only"
NodeStatusInformationTranslationTable("D---")="Down"
NodeStatusInformationTranslationTable("D--R")="Down Read-Only"
NodeStatusInformationTranslationTable("D-S-")="Down Smartfailed"
NodeStatusInformationTranslationTable("D-SR")="Down Smartfailed Read-Only"
NodeStatusInformationTranslationTable("DA--")="Down Attention"
NodeStatusInformationTranslationTable("DA-R")="Down Attention Read-Only"
NodeStatusInformationTranslationTable("DAS-")="Down Attention Smartfailed"
NodeStatusInformationTranslationTable("DASR")="Down Attention Smartfailed Read-Only"
NodeStatusInformationTranslationTable("OK")=""
NodeStatusInformationTranslationTable(Default)="UNKNOWN"

// Get rid of the unwanted columns
// MSHW_ENCLOSURE;Class;nodeName;PatrolStatus;StatusInformation;IPAddress;
Enclosure.Collect.Source(3).Compute(4).Type="KeepColumns"
Enclosure.Collect.Source(3).Compute(4).ColumnNumbers="1,2,3,4,5,6"

// Union Clusters and Nodes
// MSHW_ENCLOSURE;Class;nodeName;PatrolStatus;StatusInformation;IPAddress;
Enclosure.Collect.Source(4).Type="TableUnion"
Enclosure.Collect.Source(4).Table1=%Enclosure.Collect.Source(2)%
Enclosure.Collect.Source(4).Table2=%Enclosure.Collect.Source(3)%

// The value table
// MSHW_ENCLOSURE;Class;nodeName;PatrolStatus;StatusInformation;IPAddress;
Enclosure.Collect.ValueTable=%Enclosure.Collect.Source(4)%
Enclosure.Collect.DeviceID=ValueTable.Column(3)
Enclosure.Collect.Status=ValueTable.Column(4)
Enclosure.Collect.StatusInformation=ValueTable.Column(5)

// Now discover information for other collects
// Source(5) = Run auparts
Enclosure.Collect.Source(5).Type="OsCommand"
Enclosure.Collect.Source(5).CommandLine="/bin/zsh -c ""%{SUDO:/usr/bin/isi_for_array} /usr/bin/isi_for_array /usr/bin/isi_hwtools/isi_hw_status"" "
Enclosure.Collect.Source(5).TimeOut="60"

// Process the command through an AWK script
// Sorts Parallel to Sequential
Enclosure.Collect.Source(5).Compute(1).Type="Awk"
Enclosure.Collect.Source(5).Compute(1).AwkScript=EmbeddedFile(7)

// Process the command through an AWK script
// MSHW_Class;systemName;DeviceID;DisplayID;Status;Status;
Enclosure.Collect.Source(5).Compute(2).Type="Awk"
Enclosure.Collect.Source(5).Compute(2).AwkScript=EmbeddedFile(2)
Enclosure.Collect.Source(5).Compute(2).KeepOnlyRegExp="^MSHW"
Enclosure.Collect.Source(5).Compute(2).Separators=";"

//
// Fan
//

// Discovery

// Source(1) = Enclosure Discovery 1
Fan.Discovery.Source(1)=%Enclosure.Discovery.Source(1)%

// Keep only Fans
// MSHW_FAN;ChassisID;DeviceID;DisplayID;LowerThresholds;UpperThreshold;
Fan.Discovery.Source(1).Compute(1).Type="KeepOnlyMatchingLines"
Fan.Discovery.Source(1).Compute(1).Column=1
Fan.Discovery.Source(1).Compute(1).RegExp="^MSHW_FAN$"

// The discovery table
// MSHW_FAN;ChassisID;DeviceID;DisplayID;LowerThresholds;UpperThreshold;
Fan.Discovery.InstanceTable=%Fan.Discovery.Source(1)%
Fan.Discovery.Instance.DeviceID=InstanceTable.Column(3)
Fan.Discovery.Instance.DisplayID=InstanceTable.Column(4)
Fan.Discovery.Instance.AlarmThreshold=InstanceTable.Column(5)
Fan.Discovery.Instance.AttachedToDeviceID=InstanceTable.Column(2)

// Collect
// Collect type: MultiInstance
Fan.Collect.Type="MultiInstance"

// Source(1) = Enclosure Collect 1
//
Fan.Collect.Source(1)=%Enclosure.Collect.Source(5)%

// Keep only MSHW
// MSHW;ID;Value;
Fan.Collect.Source(1).Compute(1).Type="KeepOnlyMatchingLines"
Fan.Collect.Source(1).Compute(1).Column=1
Fan.Collect.Source(1).Compute(1).RegExp="^MSHW$"

// The value table
// MSHW;ID;Value;
Fan.Collect.ValueTable=%Fan.Collect.Source(1)%
Fan.Collect.DeviceID=ValueTable.Column(2)
Fan.Collect.Speed=ValueTable.Column(3)

//
// Voltage
//

// Discovery

// Source(1) = Enclosure Discovery 1
Voltage.Discovery.Source(1)=%Enclosure.Discovery.Source(1)%

// Keep only Voltages
// MSHW_VOLTAGE;ChassisID;DeviceID;DisplayID;LowerThresholds;UpperThreshold;
Voltage.Discovery.Source(1).Compute(1).Type="KeepOnlyMatchingLines"
Voltage.Discovery.Source(1).Compute(1).Column=1
Voltage.Discovery.Source(1).Compute(1).RegExp="^MSHW_VOLTAGE$"

// Multiply the thresholds by 1000 to get mV
// MSHW_VOLTAGE;ChassisID;DeviceID;DisplayID;LowerThresholds;UpperThreshold;
Voltage.Discovery.Source(1).Compute(2).Type="Multiply"
Voltage.Discovery.Source(1).Compute(2).Column=5
Voltage.Discovery.Source(1).Compute(2).MultiplyBy=1000

Voltage.Discovery.Source(1).Compute(3).Type="Multiply"
Voltage.Discovery.Source(1).Compute(3).Column=6
Voltage.Discovery.Source(1).Compute(3).MultiplyBy=1000

// The discovery table
// MSHW_VOLTAGE;ChassisID;DeviceID;DisplayID;LowerThresholds;UpperThreshold;
Voltage.Discovery.InstanceTable=%Voltage.Discovery.Source(1)%
Voltage.Discovery.Instance.DeviceID=InstanceTable.Column(3)
Voltage.Discovery.Instance.DisplayID=InstanceTable.Column(4)
Voltage.Discovery.Instance.UpperThreshold=InstanceTable.Column(6)
Voltage.Discovery.Instance.LowerThreshold=InstanceTable.Column(5)
Voltage.Discovery.Instance.AttachedToDeviceID=InstanceTable.Column(2)

// Collect
// Collect type: MultiInstance
Voltage.Collect.Type="MultiInstance"

// Source(1) = Enclosure Collect 1
//
Voltage.Collect.Source(1)=%Enclosure.Collect.Source(5)%

// Keep only MSHW
// MSHW;ID;Value;
Voltage.Collect.Source(1).Compute(1).Type="KeepOnlyMatchingLines"
Voltage.Collect.Source(1).Compute(1).Column=1
Voltage.Collect.Source(1).Compute(1).RegExp="^MSHW$"

// Multiply the voltage by 1000 to get mV
// MSHW;ID;Value;
Voltage.Collect.Source(1).Compute(2).Type="Multiply"
Voltage.Collect.Source(1).Compute(2).Column=3
Voltage.Collect.Source(1).Compute(2).MultiplyBy=1000


// The value table
// MSHW;ID;Value;
Voltage.Collect.ValueTable=%Voltage.Collect.Source(1)%
Voltage.Collect.DeviceID=ValueTable.Column(2)
Voltage.Collect.Voltage=ValueTable.Column(3)

//
// Temperature
//

// Discovery

// Source(1) = Enclosure Discovery 1
Temperature.Discovery.Source(1)=%Enclosure.Discovery.Source(1)%

// Keep only Temperatures
// MSHW_TEMPERATURE;ChassisID;DeviceID;DisplayID;LowerThresholds;UpperThreshold;
Temperature.Discovery.Source(1).Compute(1).Type="KeepOnlyMatchingLines"
Temperature.Discovery.Source(1).Compute(1).Column=1
Temperature.Discovery.Source(1).Compute(1).RegExp="^MSHW_TEMPERATURE$"

// The discovery table
// MSHW_TEMPERATURE;ChassisID;DeviceID;DisplayID;LowerThresholds;UpperThreshold;
Temperature.Discovery.InstanceTable=%Temperature.Discovery.Source(1)%
Temperature.Discovery.Instance.DeviceID=InstanceTable.Column(3)
Temperature.Discovery.Instance.DisplayID=InstanceTable.Column(4)
Temperature.Discovery.Instance.AlarmThreshold=InstanceTable.Column(6)
Temperature.Discovery.Instance.AttachedToDeviceID=InstanceTable.Column(2)

// Collect
// Collect type: MultiInstance
Temperature.Collect.Type="MultiInstance"

// Source(1) = Enclosure Collect 1
//
Temperature.Collect.Source(1)=%Enclosure.Collect.Source(5)%

// Keep only MSHW
// MSHW;ID;Value;
Temperature.Collect.Source(1).Compute(1).Type="KeepOnlyMatchingLines"
Temperature.Collect.Source(1).Compute(1).Column=1
Temperature.Collect.Source(1).Compute(1).RegExp="^MSHW$"

// The value table
// MSHW;ID;Value;
Temperature.Collect.ValueTable=%Temperature.Collect.Source(1)%
Temperature.Collect.DeviceID=ValueTable.Column(2)
Temperature.Collect.Temperature=ValueTable.Column(3)

//
// PowerSupply
//

// Discovery

// Source(1) = Enclosure Discovery 1
PowerSupply.Discovery.Source(1)=%Enclosure.Discovery.Source(1)%

// Keep only PowerSupplys
// MSHW_POWERSUPPLY;nodeName;nodeName-Global;Global;
PowerSupply.Discovery.Source(1).Compute(1).Type="KeepOnlyMatchingLines"
PowerSupply.Discovery.Source(1).Compute(1).Column=1
PowerSupply.Discovery.Source(1).Compute(1).RegExp="^MSHW_POWERSUPPLY$"

// The discovery table
// MSHW_PowerSupply;ChassisID;DeviceID;DisplayID;LowerThresholds;UpperThreshold;
PowerSupply.Discovery.InstanceTable=%PowerSupply.Discovery.Source(1)%
PowerSupply.Discovery.Instance.DeviceID=InstanceTable.Column(3)
PowerSupply.Discovery.Instance.DisplayID=InstanceTable.Column(4)
PowerSupply.Discovery.Instance.AttachedToDeviceID=InstanceTable.Column(2)

// Collect
// Collect type: MultiInstance
PowerSupply.Collect.Type="MultiInstance"

// Source(1) = Enclosure Collect 1
//
PowerSupply.Collect.Source(1)=%Enclosure.Collect.Source(5)%

// Keep only MSHW
// MSHW_POWERSUPPLY;nodeName-Global;status;
PowerSupply.Collect.Source(1).Compute(1).Type="KeepOnlyMatchingLines"
PowerSupply.Collect.Source(1).Compute(1).Column=1
PowerSupply.Collect.Source(1).Compute(1).RegExp="^MSHW_POWERSUPPLY$"

// Duplicate the Status Column
// MSHW_POWERSUPPLY;nodeName-Global;status;status;
PowerSupply.Collect.Source(1).Compute(2).Type="DuplicateColumn"
PowerSupply.Collect.Source(1).Compute(2).Column=3

// Translate first Status into a PATROL status
// MSHW_POWERSUPPLY;nodeName-Global;Patrolstatus;status;
PowerSupply.Collect.Source(1).Compute(3).Type="Translate"
PowerSupply.Collect.Source(1).Compute(3).Column=3
PowerSupply.Collect.Source(1).Compute(3).TranslationTable="PowerSupplyStatusTranslationTable"

// The BatteryStatusTranslationTable
PowerSupplyStatusTranslationTable("OK")="OK"
PowerSupplyStatusTranslationTable(Default)="ALARM"

// The value table
// MSHW;ID;Value;
PowerSupply.Collect.ValueTable=%PowerSupply.Collect.Source(1)%
PowerSupply.Collect.DeviceID=ValueTable.Column(2)
PowerSupply.Collect.Status=ValueTable.Column(3)
PowerSupply.Collect.StatusInformation=ValueTable.Column(4)

//
// CPU
//

// Discovery

// Source(1) = Enclosure Discovery 1
CPU.Discovery.Source(1)=%Enclosure.Discovery.Source(1)%

// Keep only CPUs
// MSHW_CPU;nodeName;nodeName-Global;Global;
CPU.Discovery.Source(1).Compute(1).Type="KeepOnlyMatchingLines"
CPU.Discovery.Source(1).Compute(1).Column=1
CPU.Discovery.Source(1).Compute(1).RegExp="^MSHW_CPU$"

// The discovery table
// MSHW_CPU;ChassisID;DeviceID;DisplayID;LowerThresholds;UpperThreshold;
CPU.Discovery.InstanceTable=%CPU.Discovery.Source(1)%
CPU.Discovery.Instance.DeviceID=InstanceTable.Column(3)
CPU.Discovery.Instance.DisplayID=InstanceTable.Column(4)
CPU.Discovery.Instance.AttachedToDeviceID=InstanceTable.Column(2)

// Collect
// Collect type: MultiInstance
CPU.Collect.Type="MultiInstance"

// Source(1) = Enclosure Collect 1
//
CPU.Collect.Source(1)=%Enclosure.Collect.Source(5)%

// Keep only MSHW
// MSHW_CPU;nodeName-Global;status;
CPU.Collect.Source(1).Compute(1).Type="KeepOnlyMatchingLines"
CPU.Collect.Source(1).Compute(1).Column=1
CPU.Collect.Source(1).Compute(1).RegExp="^MSHW_CPU$"

// Duplicate the Status Column
// MSHW_CPU;nodeName-Global;status;status;
CPU.Collect.Source(1).Compute(2).Type="DuplicateColumn"
CPU.Collect.Source(1).Compute(2).Column=3

// Translate first Status into a PATROL status
// MSHW_CPU;nodeName-Global;Patrolstatus;status;
CPU.Collect.Source(1).Compute(3).Type="Translate"
CPU.Collect.Source(1).Compute(3).Column=3
CPU.Collect.Source(1).Compute(3).TranslationTable="CPUStatusTranslationTable"

// The BatteryStatusTranslationTable
CPUStatusTranslationTable("Normal")="OK"
CPUStatusTranslationTable(Default)="ALARM"

// The value table
// MSHW;ID;Value;
CPU.Collect.ValueTable=%CPU.Collect.Source(1)%
CPU.Collect.DeviceID=ValueTable.Column(2)
CPU.Collect.Status=ValueTable.Column(3)
CPU.Collect.StatusInformation=ValueTable.Column(4)



// Battery

// Source(1) = Run isi batterystatus
Battery.Discovery.Source(1).Type="OsCommand"
Battery.Discovery.Source(1).CommandLine="/bin/zsh -c ""%{SUDO:/usr/bin/isi_for_array} /usr/bin/isi_for_array _IsiBatteryCommand "" "
Battery.Discovery.Source(1).TimeOut="60"

// Process the command through an AWK script
// Sorts Parallel to Sequential
Battery.Discovery.Source(1).Compute(1).Type="Awk"
Battery.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(7)

// Process the command through an AWK script
// MSHW_BATTERY;ChassisID;DeviceID;DisplayID;status;status;
Battery.Discovery.Source(1).Compute(2).Type="Awk"
Battery.Discovery.Source(1).Compute(2).AwkScript=EmbeddedFile(3)
Battery.Discovery.Source(1).Compute(2).KeepOnlyRegExp="^MSHW"
Battery.Discovery.Source(1).Compute(2).Separators=";"

// The discovery table
// MSHW_BATTERY;ChassisID;DeviceID;DisplayID;status;status;
Battery.Discovery.InstanceTable=%Battery.Discovery.Source(1)%
Battery.Discovery.Instance.DeviceID=InstanceTable.Column(3)
Battery.Discovery.Instance.DisplayID=InstanceTable.Column(4)
Battery.Discovery.Instance.AttachedToDeviceID=InstanceTable.Column(2)

// Collect type is MultiInstance
Battery.Collect.Type="MultiInstance"

// Source(1) = Run isi batterystatus
Battery.Collect.Source(1).Type="OsCommand"
Battery.Collect.Source(1).CommandLine="/bin/zsh -c ""%{SUDO:/usr/bin/isi_for_array} /usr/bin/isi_for_array _IsiBatteryCommand "" "
Battery.Collect.Source(1).TimeOut="60"

// Process the command through an AWK script
// Sorts Parallel to Sequential
Battery.Collect.Source(1).Compute(1).Type="Awk"
Battery.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(7)

// Process the command through an AWK script
// MSHW_BATTERY;ChassisID;DeviceID;DisplayID;status;status;
Battery.Collect.Source(1).Compute(2).Type="Awk"
Battery.Collect.Source(1).Compute(2).AwkScript=EmbeddedFile(3)
Battery.Collect.Source(1).Compute(2).KeepOnlyRegExp="^MSHW"
Battery.Collect.Source(1).Compute(2).Separators=";"

// Translate first Status into a PATROL status
// MSHW_BATTERY;ChassisID;DeviceID;DisplayID;Patrolstatus;status;
Battery.Collect.Source(1).Compute(3).Type="Translate"
Battery.Collect.Source(1).Compute(3).Column=5
Battery.Collect.Source(1).Compute(3).TranslationTable="BatteryStatusTranslationTable"

// The BatteryStatusTranslationTable
BatteryStatusTranslationTable("Good-Good")="OK"
BatteryStatusTranslationTable("Good")="OK"
BatteryStatusTranslationTable("Ready-enabled")="OK"
BatteryStatusTranslationTable("Ready-enabled-fully charged")="OK"
BatteryStatusTranslationTable("Good-Testing")="OK"
BatteryStatusTranslationTable("Testing-Good")="OK"
BatteryStatusTranslationTable("Good-Test")="OK"
BatteryStatusTranslationTable(Default)="ALARM"

// The ValueTable = Source(1)
// MSHW_BATTERY;ChassisID;DeviceID;DisplayID;Patrolstatus;status;
Battery.Collect.ValueTable=%Battery.Collect.Source(1)%
Battery.Collect.DeviceID=ValueTable.Column(3)
Battery.Collect.Status=ValueTable.Column(5)
Battery.Collect.StatusInformation=ValueTable.Column(6)

//
// PhysicalDisk
//

// Discovery

// Source(1) = Enclosure Discovery 3
PhysicalDisk.Discovery.Source(1)=%Enclosure.Discovery.Source(3)%

// Keep only PhysicalDisk
// MSHW_PhysicalDisk;ChassisID;DeviceID;DisplayID;Lnum;SerialNumber;Status;Status;
PhysicalDisk.Discovery.Source(1).Compute(1).Type="KeepOnlyMatchingLines"
PhysicalDisk.Discovery.Source(1).Compute(1).Column=1
PhysicalDisk.Discovery.Source(1).Compute(1).RegExp="^MSHW_PhysicalDisk$"

// Source(2) = Enclosure Discovery 1
PhysicalDisk.Discovery.Source(2)=%Enclosure.Discovery.Source(1)%

// Keep only PhysicalDisk
// MSHW_PhysicalDisk;DeviceID;Manufacturer;Model;Firmware;SizeGB;SerialNumber;
PhysicalDisk.Discovery.Source(2).Compute(1).Type="KeepOnlyMatchingLines"
PhysicalDisk.Discovery.Source(2).Compute(1).Column=1
PhysicalDisk.Discovery.Source(2).Compute(1).RegExp="^MSHW_PhysicalDisk$"

// Convert GB to bytes
// MSHW_PhysicalDisk;DeviceID;Manufacturer;Model;Firmware;SizeB;SerialNumber;
PhysicalDisk.Discovery.Source(2).Compute(2).Type="Multiply"
PhysicalDisk.Discovery.Source(2).Compute(2).Column=6
PhysicalDisk.Discovery.Source(2).Compute(2).MultiplyBy=1000000000

// Join the Status table (1) with the FRU table (2)
// MSHW_PhysicalDisk;ChassisID;DeviceID;DisplayID;Lnum;SerialNumber;Status;Status;MSHW_PhysicalDisk;DeviceID;Manufacturer;Model;Firmware;SizeB;SerialNumber;
PhysicalDisk.Discovery.Source(3).Type="TableJoint"
PhysicalDisk.Discovery.Source(3).LeftTable=%PhysicalDisk.Discovery.Source(1)%
PhysicalDisk.Discovery.Source(3).RightTable=%PhysicalDisk.Discovery.Source(2)%
PhysicalDisk.Discovery.Source(3).LeftKeyColumn=3
PhysicalDisk.Discovery.Source(3).RightKeyColumn=2
PhysicalDisk.Discovery.Source(3).DefaultRightLine=";;;;;;;"

// The discovery table
//      1                2         3        4       5     6            7      8        9               10        11         12      13     14    15
// MSHW_PhysicalDisk;ChassisID;DeviceID;DisplayID;Lnum;SerialNumber;Status;Status;MSHW_PhysicalDisk;DeviceID;Manufacturer;Model;Firmware;SizeB;SerialNumber;
PhysicalDisk.Discovery.InstanceTable=%PhysicalDisk.Discovery.Source(3)%
PhysicalDisk.Discovery.Instance.DeviceID=InstanceTable.Column(3)
PhysicalDisk.Discovery.Instance.DisplayID=InstanceTable.Column(4)
PhysicalDisk.Discovery.Instance.AttachedToDeviceID=InstanceTable.Column(2)
PhysicalDisk.Discovery.Instance.Size=InstanceTable.Column(14)
PhysicalDisk.Discovery.Instance.Model=InstanceTable.Column(12)
PhysicalDisk.Discovery.Instance.Vendor=InstanceTable.Column(11)
PhysicalDisk.Discovery.Instance.FirmwareVersion=InstanceTable.Column(13)
PhysicalDisk.Discovery.Instance.SerialNumber=InstanceTable.Column(6)

// Collect type is MultiInstance
PhysicalDisk.Collect.Type="MultiInstance"

// Source(1) = Run isi devices
PhysicalDisk.Collect.Source(1).Type="OsCommand"
PhysicalDisk.Collect.Source(1).CommandLine="/bin/zsh -c ""%{SUDO:/usr/bin/isi_for_array} /usr/bin/isi_for_array _IsiDrivesCommand "" "
PhysicalDisk.Collect.Source(1).TimeOut="60"

// Process the command through an AWK script
// Sorts Parallel to Sequential
PhysicalDisk.Collect.Source(1).Compute(1).Type="Awk"
PhysicalDisk.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(7)

// Process the command through an AWK script
// MSHW_PhysicalDisk;Location;Lnum;SerialNumber;Status;Status;
PhysicalDisk.Collect.Source(1).Compute(2).Type="Awk"
PhysicalDisk.Collect.Source(1).Compute(2).AwkScript=EmbeddedFile(5)
PhysicalDisk.Collect.Source(1).Compute(2).KeepOnlyRegExp="^MSHW"
PhysicalDisk.Collect.Source(1).Compute(2).Separators=";"

// Keep only PhysicalDisk
// MSHW_PhysicalDisk;ChassisID;DeviceID;DisplayID;Lnum;SerialNumber;Status;Status;
PhysicalDisk.Collect.Source(1).Compute(3).Type="KeepOnlyMatchingLines"
PhysicalDisk.Collect.Source(1).Compute(3).Column=1
PhysicalDisk.Collect.Source(1).Compute(3).RegExp="^MSHW_PhysicalDisk$"

// Translate first Status into a PATROL status
// MSHW_PhysicalDisk;ChassisID;DeviceID;DisplayID;Lnum;SerialNumber;PatrolStatus;Status;
PhysicalDisk.Collect.Source(1).Compute(4).Type="Translate"
PhysicalDisk.Collect.Source(1).Compute(4).Column=7
PhysicalDisk.Collect.Source(1).Compute(4).TranslationTable="PhysicalDiskStatusTranslationTable"

// The BatteryStatusTranslationTable
PhysicalDiskStatusTranslationTable("HEALTHY")="OK"
PhysicalDiskStatusTranslationTable("L3")="OK"
PhysicalDiskStatusTranslationTable("JOURNAL")="OK"
PhysicalDiskStatusTranslationTable("STALLED")="OK"
PhysicalDiskStatusTranslationTable("BOOT_DRIVE")="OK"
PhysicalDiskStatusTranslationTable("SMARTFAIL")="WARN"
PhysicalDiskStatusTranslationTable("RESTRIPE")="WARN"
PhysicalDiskStatusTranslationTable("SUSPENDED")="WARN"
PhysicalDiskStatusTranslationTable("NEW")="WARN"
PhysicalDiskStatusTranslationTable("PREPARING")="WARN"
PhysicalDiskStatusTranslationTable("USED")="WARN"
PhysicalDiskStatusTranslationTable("WRONG_TYPE")="WARN"
PhysicalDiskStatusTranslationTable("REPLACE")="ALARM"
PhysicalDiskStatusTranslationTable("ERASE")="WARN"
PhysicalDiskStatusTranslationTable("NOT")="ALARM"
PhysicalDiskStatusTranslationTable("INSECURE")="ALARM"
PhysicalDiskStatusTranslationTable("UNENCRYPTED")="ALARM"
PhysicalDiskStatusTranslationTable("SED_ERROR")="ALARM"
PhysicalDiskStatusTranslationTable(Default)="ALARM"

// The ValueTable = Source(1)
// MSHW_PhysicalDisk;ChassisID;DeviceID;DisplayID;Lnum;SerialNumber;Status;Status;
PhysicalDisk.Collect.ValueTable=%PhysicalDisk.Collect.Source(1)%
PhysicalDisk.Collect.DeviceID=ValueTable.Column(3)
PhysicalDisk.Collect.Status=ValueTable.Column(7)
PhysicalDisk.Collect.StatusInformation=ValueTable.Column(8)

// NetworkCard

// Source(1) = Run isi networks list interfaces --verbose --wide --show-inactive
NetworkCard.Discovery.Source(1).Type="OsCommand"
NetworkCard.Discovery.Source(1).CommandLine="/bin/zsh -c ""%{SUDO:/usr/bin/isi} _IsiNetworkCommand "" "
NetworkCard.Discovery.Source(1).TimeOut="60"

// Process the command through an AWK script
// MSHW;NodeNumber;NICName;NICName;Interface;IPAddress;Status;
NetworkCard.Discovery.Source(1).Compute(1).Type="Awk"
NetworkCard.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(6)
NetworkCard.Discovery.Source(1).Compute(1).KeepOnlyRegExp="^MSHW"
NetworkCard.Discovery.Source(1).Compute(1).Separators=";"

// Join the Enclosure Instance list (source 2) with the nodename to nodeid table from isi devices
// MSHW;NodeNumber;NICName;NICName;Interface;IPAddress;Status;MSHW_Node;nodeName;nodeNumber;
NetworkCard.Discovery.Source(2).Type="TableJoint"
NetworkCard.Discovery.Source(2).LeftTable=%NetworkCard.Discovery.Source(1)%
NetworkCard.Discovery.Source(2).RightTable=%Enclosure.Discovery.Source(3)%
NetworkCard.Discovery.Source(2).LeftKeyColumn=2
NetworkCard.Discovery.Source(2).RightKeyColumn=3

// Add a - and the NodeName to the NICName to make the DeviceID
// MSHW;NodeNumber;DeviceID;DisplayID;Interface;IPAddress;Status;MSHW_Node;nodeName;nodeNumber;
NetworkCard.Discovery.Source(2).Compute(1).Type="LeftConcat"
NetworkCard.Discovery.Source(2).Compute(1).Column=3
NetworkCard.Discovery.Source(2).Compute(1).String="-"

NetworkCard.Discovery.Source(2).Compute(2).Type="LeftConcat"
NetworkCard.Discovery.Source(2).Compute(2).Column=3
NetworkCard.Discovery.Source(2).Compute(2).String=Column(9)

// The discovery table
// MSHW;NodeNumber;DeviceID;DisplayID;Interface;IPAddress;Status;MSHW_Node;nodeName;nodeNumber;
NetworkCard.Discovery.InstanceTable=%NetworkCard.Discovery.Source(2)%
NetworkCard.Discovery.Instance.DeviceID=InstanceTable.Column(3)
NetworkCard.Discovery.Instance.DisplayID=InstanceTable.Column(4)
NetworkCard.Discovery.Instance.AttachedToDeviceID=InstanceTable.Column(9)

// Collect type is MultiInstance
NetworkCard.Collect.Type="MultiInstance"

// Source(1) = Run isi networks list interfaces --verbose --wide --show-inactive
NetworkCard.Collect.Source(1).Type="OsCommand"
NetworkCard.Collect.Source(1).CommandLine="/bin/zsh -c ""%{SUDO:/usr/bin/isi} _IsiNetworkCommand "" "
NetworkCard.Collect.Source(1).TimeOut="60"

// Process the command through an AWK script
// MSHW;NodeNumber;NICName;NICName;Interface;IPAddress;Status;
NetworkCard.Collect.Source(1).Compute(1).Type="Awk"
NetworkCard.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(6)
NetworkCard.Collect.Source(1).Compute(1).KeepOnlyRegExp="^MSHW"
NetworkCard.Collect.Source(1).Compute(1).Separators=";"

// Join the Enclosure Instance list (source 2) with the nodename to nodeid table from isi devices
// MSHW;NodeNumber;NICName;NICName;Interface;IPAddress;Status;MSHW_Node;nodeName;nodeNumber;
NetworkCard.Collect.Source(2).Type="TableJoint"
NetworkCard.Collect.Source(2).LeftTable=%NetworkCard.Discovery.Source(1)%
NetworkCard.Collect.Source(2).RightTable=%Enclosure.Discovery.Source(3)%
NetworkCard.Collect.Source(2).LeftKeyColumn=2
NetworkCard.Collect.Source(2).RightKeyColumn=3

// Add a - and the NodeName to the NICName to make the DeviceID
// MSHW;NodeNumber;DeviceID;DisplayID;Interface;IPAddress;Status;MSHW_Node;nodeName;nodeNumber;
NetworkCard.Collect.Source(2).Compute(1).Type="LeftConcat"
NetworkCard.Collect.Source(2).Compute(1).Column=3
NetworkCard.Collect.Source(2).Compute(1).String="-"

NetworkCard.Collect.Source(2).Compute(2).Type="LeftConcat"
NetworkCard.Collect.Source(2).Compute(2).Column=3
NetworkCard.Collect.Source(2).Compute(2).String=Column(9)

// Get rid of the unwanted columns
// MSHW;DeviceID;Status;
NetworkCard.Collect.Source(2).Compute(3).Type="KeepColumns"
NetworkCard.Collect.Source(2).Compute(3).ColumnNumbers="1,3,7"

// Duplicate the Status (twice)
// MSHW;DeviceID;Status;Status;Status;
NetworkCard.Collect.Source(2).Compute(4).Type="DuplicateColumn"
NetworkCard.Collect.Source(2).Compute(4).Column=3

NetworkCard.Collect.Source(2).Compute(5).Type="DuplicateColumn"
NetworkCard.Collect.Source(2).Compute(5).Column=3

// Translate first Status into a PATROL status
// MSHW;DeviceID;PatrolStatus;Status;Status;
NetworkCard.Collect.Source(2).Compute(6).Type="Translate"
NetworkCard.Collect.Source(2).Compute(6).Column=3
NetworkCard.Collect.Source(2).Compute(6).TranslationTable="NetworkCardStatusTranslationTable"

// The NetworkCardStatusTranslationTable
NetworkCardStatusTranslationTable("inactive")="OK"
NetworkCardStatusTranslationTable("up")="OK"
NetworkCardStatusTranslationTable("no carrier")="OK"
NetworkCardStatusTranslationTable(Default)="ALARM"

// Translate third Status into a Link status
// MSHW;DeviceID;PatrolStatus;Status;LinkStatus;
NetworkCard.Collect.Source(2).Compute(7).Type="Translate"
NetworkCard.Collect.Source(2).Compute(7).Column=5
NetworkCard.Collect.Source(2).Compute(7).TranslationTable="LinkStatusTranslationTable"

// The NetworkCardStatusTranslationTable
LinkStatusTranslationTable("inactive")="WARN"
LinkStatusTranslationTable("up")="OK"
LinkStatusTranslationTable("no carrier")="WARN"
LinkStatusTranslationTable(Default)="WARN"

// The ValueTable = Source(1)
// MSHW;DeviceID;PatrolStatus;Status;LinkStatus;
NetworkCard.Collect.ValueTable=%NetworkCard.Collect.Source(2)%
NetworkCard.Collect.DeviceID=ValueTable.Column(2)
NetworkCard.Collect.Status=ValueTable.Column(3)
NetworkCard.Collect.StatusInformation=ValueTable.Column(4)
NetworkCard.Collect.LinkStatus=ValueTable.Column(5)

//
// LogicalDisk
//

// Discovery

// Source(1) = Run isi storagepool health --verbose
LogicalDisk.Discovery.Source(1).Type="OsCommand"
LogicalDisk.Discovery.Source(1).CommandLine="/bin/zsh -c ""%{SUDO:/usr/bin/isi} /usr/bin/isi storagepool health --verbose"" "
LogicalDisk.Discovery.Source(1).TimeOut="60"

// Process the command through an AWK script
// MSHW;ID;Status;AdditionalInformation;StatusInformation;
LogicalDisk.Discovery.Source(1).Compute(1).Type="Awk"
LogicalDisk.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(8)
LogicalDisk.Discovery.Source(1).Compute(1).Separators=";"

// Keep only LogicalDisk
// MSHW;ID;Status;AdditionalInformation;StatusInformation;
LogicalDisk.Discovery.Source(1).Compute(2).Type="KeepOnlyMatchingLines"
LogicalDisk.Discovery.Source(1).Compute(2).Column=1
LogicalDisk.Discovery.Source(1).Compute(2).RegExp="^MSHW"

// Source(2) = isi storagepool list --verbose --no-header --format csv
// ID;Nodes;Requested Protection;Type;Children;HDD Used;HDD Total;HDD % Used;SSD Used;SSD Total;SSD % Used;
LogicalDisk.Discovery.Source(2).Type="OsCommand"
LogicalDisk.Discovery.Source(2).CommandLine="/bin/zsh -c ""%{SUDO:/usr/bin/isi} /usr/bin/isi storagepool list --verbose --no-header --format csv"" "
LogicalDisk.Discovery.Source(2).TimeOut="60"

// Process the command through an AWK script
// ID;TotalSize;
LogicalDisk.Discovery.Source(2).Compute(1).Type="Awk"
LogicalDisk.Discovery.Source(2).Compute(1).AwkScript=EmbeddedFile(9)
LogicalDisk.Discovery.Source(2).Compute(1).Separators=";"

// Keep Columns
// ID;HDD Total;
LogicalDisk.Discovery.Source(2).Compute(2).Type="KeepColumns"
LogicalDisk.Discovery.Source(2).Compute(2).ColumnNumbers="2,3"

// Convert to Bytes
// ID;TotalSize;
LogicalDisk.Discovery.Source(2).Compute(3).Type="Multiply"
LogicalDisk.Discovery.Source(2).Compute(3).Column=2
LogicalDisk.Discovery.Source(2).Compute(3).MultiplyBy="1073741824"

// Join the Logical Disk information with the Size Information
// MSHW;ID;Status;AdditionalInformation;StatusInformation;ID;TotalSize;
LogicalDisk.Discovery.Source(3).Type="TableJoint"
LogicalDisk.Discovery.Source(3).LeftTable=%LogicalDisk.Discovery.Source(1)%
LogicalDisk.Discovery.Source(3).RightTable=%LogicalDisk.Discovery.Source(2)%
LogicalDisk.Discovery.Source(3).LeftKeyColumn=2
LogicalDisk.Discovery.Source(3).RightKeyColumn=1
LogicalDisk.Discovery.Source(3).DefaultRightLine=";;"

LogicalDisk.Discovery.Source(3).Compute(1).Type="LeftConcat"
LogicalDisk.Discovery.Source(3).Compute(1).Column=4
LogicalDisk.Discovery.Source(3).Compute(1).String="Protection Policy: "

// The discovery table
// MSHW;ID;Status;AdditionalInformation;StatusInformation;ID;TotalSize;
LogicalDisk.Discovery.InstanceTable=%LogicalDisk.Discovery.Source(3)%
LogicalDisk.Discovery.Instance.DeviceID=InstanceTable.Column(2)
LogicalDisk.Discovery.Instance.DisplayID=InstanceTable.Column(2)
LogicalDisk.Discovery.Instance.Size=InstanceTable.Column(7)
LogicalDisk.Discovery.Instance.AttachedToDeviceID="Cluster"
LogicalDisk.Discovery.Instance.AdditionalInformation1=InstanceTable.Column(4)

// Collect type is MultiInstance
LogicalDisk.Collect.Type="MultiInstance"

// Source(1) = Run isi devices
LogicalDisk.Collect.Source(1).Type="OsCommand"
LogicalDisk.Collect.Source(1).CommandLine="/bin/zsh -c ""%{SUDO:/usr/bin/isi} /usr/bin/isi storagepool health --verbose"" "
LogicalDisk.Collect.Source(1).TimeOut="60"

// Process the command through an AWK script
// MSHW;ID;Status;AdditionalInformation;StatusInformation;
LogicalDisk.Collect.Source(1).Compute(1).Type="Awk"
LogicalDisk.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(8)
LogicalDisk.Collect.Source(1).Compute(1).Separators=";"

// Keep only LogicalDisk
// MSHW;ID;Status;AdditionalInformation;StatusInformation;
LogicalDisk.Collect.Source(1).Compute(2).Type="KeepOnlyMatchingLines"
LogicalDisk.Collect.Source(1).Compute(2).Column=1
LogicalDisk.Collect.Source(1).Compute(2).RegExp="^MSHW"

// Translate first Status into a PATROL status
// MSHW;ID;Status;AdditionalInformation;StatusInformation;
LogicalDisk.Collect.Source(1).Compute(3).Type="ArrayTranslate"
LogicalDisk.Collect.Source(1).Compute(3).Column=3
LogicalDisk.Collect.Source(1).Compute(3).TranslationTable="LogicalDiskStatusTranslationTable"

// Convert PATROLStatusArray to a simple (unique) PATROLStatus
// MSHW;ID;Status;AdditionalInformation;StatusInformation;
LogicalDisk.Collect.Source(1).Compute(4).Type="Convert"
LogicalDisk.Collect.Source(1).Compute(4).Column=3
LogicalDisk.Collect.Source(1).Compute(4).ConversionType="Array2SimpleStatus"

// The BatteryStatusTranslationTable
LogicalDiskStatusTranslationTable("OK")="OK"
LogicalDiskStatusTranslationTable("TooFewNodes")="ALARM"
LogicalDiskStatusTranslationTable("MissingDrives")="ALARM"
LogicalDiskStatusTranslationTable("Down")="WARN"
LogicalDiskStatusTranslationTable("SmartFailed")="WARN"
LogicalDiskStatusTranslationTable("Repair")="ALARM"
LogicalDiskStatusTranslationTable(Default)="ALARM"

// The ValueTable = Source(1)
// MSHW;ID;Status;AdditionalInformation;StatusInformation;
LogicalDisk.Collect.ValueTable=%LogicalDisk.Collect.Source(1)%
LogicalDisk.Collect.DeviceID=ValueTable.Column(2)
LogicalDisk.Collect.Status=ValueTable.Column(3)
LogicalDisk.Collect.StatusInformation=ValueTable.Column(5)

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(1) = The isi_hw_check awk script
///
///
/////////////////////////////////////////////////////////
EmbeddedFile(1):
BEGIN {SensorSection = 0 ; DriveSection = 0}

$2 ~ /\[safe.id.*\]/ { SensorSection = 0
	if ($2 ~ "[safe.id.sensors]") { SensorSection = 1 }
	if ($2 ~ "[safe.id.drives]") { DriveSection = 1 }
    }

SensorSection == 1 && NF > 5 {
	nodeName = $1 ; gsub (/:/,"",nodeName);
	if (tolower($3) ~ /chassis/ && $4 ~ /=/) {nodeModelNumber = $5 ;
                                            nodeModel = $6 $7 $8 $9;
                                            gsub(/^[(]/,"",nodeModel);gsub(/[)]$/,"",nodeModel)
                                            print "MSHW_ENCLOSURE;Node;" nodeName ";" nodeModelNumber ";" nodeModel ";"
                                           }
	if (tolower($3) ~ /power/ && $4 ~ /=/) {print "MSHW_POWERSUPPLY;" nodeName ";" nodeName "-Global;Global;"}

	if (tolower($3) ~ /cpu/ && tolower($4) ~ /operation/ && $5 ~ /=/) {print "MSHW_CPU;" nodeName ";" nodeName "-Global;Global;"}

	if ($(NF-5) ~ /\[/ && $(NF-3)~ /\]/ && $(NF-2) ~ /=/) {lowerThreshold = $(NF-5) ; gsub (/\[/,"",lowerThreshold)
                                                                upperThreshold = $(NF-3) ; gsub (/\]/,"",upperThreshold )
                                                                ID = $0 ; gsub (/^.*: +: +/,"",ID);gsub (/ *\[.*$/,"",ID);
                                                                if (tolower($NF) ~ /rpm/) {print "MSHW_FAN;" nodeName ";" nodeName"-"ID ";" ID ";" lowerThreshold ";" upperThreshold ";"}
                                                                if ($NF ~ /C/) {print "MSHW_TEMPERATURE;" nodeName ";" nodeName"-"ID ";" ID ";" lowerThreshold ";" upperThreshold ";"}
                                                                if ($NF ~ /V/) {print "MSHW_VOLTAGE;" nodeName ";" nodeName"-"ID ";" ID ";" lowerThreshold ";" upperThreshold ";"}
                                                               }
	}

DriveSection == 1 && $3 ~ /Bay/ && $4 ~ /^[0-9]+$/ {
	nodeName = $1 ; gsub (/:/,"",nodeName);
	Location = $4 ; Location = "Bay-" Location ;
	Manufacturer = $6 ; Model = $7 ; Firmware = $(NF-3) ;
	Size = $(NF-2) ; gsub (/[(]/,"",Size) ; Size = Size * 512 ; SizeGB = Size / 1000000000 ;
	SerialNumber = $NF ; gsub (/sn:/,"",SerialNumber)
	print "MSHW_PhysicalDisk;" nodeName "-" Location ";" Manufacturer ";" Model ";" Firmware ";" SizeGB ";" SerialNumber ";"
	}
EmbeddedFile(1).End
/////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(2) = The isi_hw_status awk script
///
///
/////////////////////////////////////////////////////////
EmbeddedFile(2):
{nodeName = $1 ; gsub (/:/,"",nodeName);}
tolower($2) ~ /power/ && tolower($3) ~ /supplies/ {print "MSHW_POWERSUPPLY;"nodeName"-Global;" $4 ";"}

tolower($2) ~ /cpu/ && tolower($3) ~ /operation/ {print "MSHW_CPU;" nodeName "-Global;" $NF ";"}

NF > 3 && $NF ~ /^[0-9.-]+$/ {
	if ($(NF-1) ~ /=/) {ID = $0 ; gsub (/^.*: */,"",ID);gsub (/ *=.*$/,"",ID);
                           value = $NF
                           print "MSHW;" nodeName "-" ID ";" value ";"
                          }
	}
EmbeddedFile(2).End
/////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(4) = The /usr/bin/isi status -w awk script
///
///
/////////////////////////////////////////////////////////
EmbeddedFile(4):
BEGIN { FS="[|]" }
$1 ~ /Cluster Name:/   {ClusterName = $0 ; gsub (/^.*: +/,"",ClusterName) }
$1 ~ /Cluster Health:/ {ClusterStatus = $0 ; gsub (/^.*\[ */,"",ClusterStatus) ; gsub (/ *\] *$/,"",ClusterStatus)
	                      print "MSHW_ENCLOSURE;Cluster;" ClusterName ";" ClusterStatus ";" ClusterStatus ";;"
	                     }
$1 ~ /^[0-9 ]+$/ && NF == 8 {NodeStatus = $3 ; gsub (/ /,"",NodeStatus);
	                           NodeID = $1 ; gsub (/ /,"",NodeID);
	                           NodeIP = $2 ; gsub (/ /,"",NodeIP);
	                           print "MSHW_ENCLOSURE;Node;" NodeID ";" NodeStatus ";"  NodeStatus ";" NodeIP ";"
	                          }
EmbeddedFile(4).End
/////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(7) = an awk script that sorts commands that are run in parallel and returns them in sequential
///
///
/////////////////////////////////////////////////////////
EmbeddedFile(7):
$1 ~ /:/ { node = $1
	         SORT[node] = SORT[node] "\n" $0
	       }

END { for (nodeList in SORT)
          print SORT[nodeList]
    }
EmbeddedFile(7).End
/////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(8) = The /usr/bin/isi storagepool health --verbose
///
///
/////////////////////////////////////////////////////////
EmbeddedFile(8):
BEGIN { activate = 0 ; poolEnum = 0; id = 0}
$1 ~ /^OK$/ && $2 ~ /=/ && $3 ~ /Ok/ {exit}
NF > 1 && NF != 3 && activate == 1 && $2 !~ /Drives:/ { poolEnum = poolEnum + 1
  ID[poolEnum] = $1
  Health[poolEnum] = $2
  AdditionalInformation[poolEnum] = $3 $4 $5
  # make sure that the pool name is not divided into two lines
  if($1 ~ /-$/) {key=$1; getline; $id = key $1;} else $id=$1;
  ID[poolEnum] = $id
  }

$1 ~ /^[-]+$/ && $2 ~ /^[-]+$/ && $3 ~ /^[-]+$/ && $4 ~ /^[-]+$/ && $5 ~ /^[-]+$/ && $6 ~ /^[-]+$/ && $7 ~ /^[-]+$/ { activate = 1}

END {
  for (pool in ID) {
# Translate the status in the script as it's a mess
    status = ""
    statusInformation = ""
    if ( Health[pool]~ /OK/ ) { status = status "OK|" ; statusInformation = statusInformation ""}
    if ( Health[pool]~ /U/ ) { status = status "TooFewNodes|" ; statusInformation = statusInformation "Too Few Nodes for this Pool"}
    if ( Health[pool]~ /M/ ) { status = status "MissingDrives|" ; statusInformation = statusInformation "This Pool is Missing Drives"}
    if ( Health[pool]~ /D/ ) { status = status "Down|" ; statusInformation = statusInformation "Some Nodes or Drives for this Pool are Down"}
    if ( Health[pool]~ /S/ ) { status = status "SmartFailed|" ; statusInformation = statusInformation "Some Nodes or Drives for this Pool are SmartFailed"}
    if ( Health[pool]~ /R/ ) { status = status "Repair|" ; statusInformation = statusInformation "Some Nodes or Drives for this Pool need Repair"}
    # It can be difficult to differentiate a two column top level line from a line with leftovers from the previous line.
    # We with thus check that some form of status was collected and that no numbers are in the status (items that flow over are likely to contain numbers)
    if ( status != "" && Health[pool] !~ /[0-9]/ ) { print "MSHW;" ID[pool] ";" status  ";" AdditionalInformation[pool] ";" statusInformation ";"}
    }
  }
EmbeddedFile(8).End
/////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(10) = The isi_hw_status awk script
///    Gets Serial Product and RAM for nodes
///
/////////////////////////////////////////////////////////
EmbeddedFile(10):
{nodeName = $1 ; gsub (/:/,"",nodeName);}
$2 ~ /SerNo/ { systemSerialNumber = $NF }
$2 ~ /Product/ { systemProductModel = $0 ; gsub(/.*: /,"",systemProductModel) }
$2 ~ /^RAM.$/ { systemRAM = $3 ; print "MSHW;" nodeName ";" systemSerialNumber ";" systemProductModel ";System RAM: " systemRAM ";" }
EmbeddedFile(10).End
/////////////////////////////////////////////////////////////////////
