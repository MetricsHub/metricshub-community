//
//
//                 C O N N E C T O R
//
//                       f o r
//
//                 Hardware Sentry
//
//                 by Sentry Software (c)
//
//                  MS_HW_SmartMonLinux.hdf
//
//      Supports: Linux machines
//		Monitors: disks (S.M.A.R.T. information from physical disks only)
//      Connects to: smartd/smartctl (SmartMon Tools) under Linux
//
//

//
// HEADER
//

hdf.DisplayName="SmartMon Tools"
hdf.TypicalPlatform="Any system with SmartMon"
hdf.ReliesOn="SmartMon Tools"
hdf.Comments="Gives S.M.A.R.T.-enabled physical disk information through the smartd/smartctl utility under Linux."
hdf.Version="1.1"
hdf.RemoteSupport="true"
hdf.AppliesToOS="Linux"

// SUDO-ABLE COMMANDS

Sudo(1).Command="/usr/sbin/smartctl"
Sudo(2).Command="/bin/dd"

//
// DETECTION
//

Detection.Criteria(1).Type="OS"
Detection.Criteria(1).KeepOnly="Linux"

Detection.Criteria(2).Type="OSCommand"
Detection.Criteria(2).CommandLine="/bin/ls /usr/sbin/smartd"
Detection.Criteria(2).ExpectedResult="^/usr/sbin/smartd$"
Detection.Criteria(2).ErrorMessage="Unable to find the smartd program in /usr/sbin"

Detection.Criteria(3).Type="OSCommand"
Detection.Criteria(3).CommandLine="/bin/ls /usr/sbin/smartctl"
Detection.Criteria(3).ExpectedResult="^/usr/sbin/smartctl$"
Detection.Criteria(3).ErrorMessage="Unable to find the smartctl program in /usr/sbin"

Detection.Criteria(4).Type="OSCommand"
Detection.Criteria(4).CommandLine="%{SUDO:/usr/sbin/smartctl}/usr/sbin/smartd -c;%{SUDO:/usr/sbin/smartctl}/usr/sbin/smartd -q onecheck"
Detection.Criteria(4).ExpectedResult="Device: .* opened"
Detection.Criteria(4).ErrorMessage="Unable to run the smartd/smartctl utility (not enough privilege?)"

Detection.Criteria(5).Type="OSCommand"
Detection.Criteria(5).CommandLine="%{SUDO:/usr/sbin/smartctl}/usr/sbin/smartd -c;%{SUDO:/usr/sbin/smartctl}/usr/sbin/smartd -q onecheck"
Detection.Criteria(5).ExpectedResult="Device: .* is SMART capable"
Detection.Criteria(5).ErrorMessage="No S.M.A.R.T-capable disk found."


//
// DISK CONTROLLER
//

// No disk controller... could you believe that?
// Well, actually the problem is that, under Linux, it's hard to figure out
// which device is attached to which controller.
// Yes, I know, that's weird.
// If I give you "/dev/sda", you won't have a clue where it is attached to.
// Long life to Linux, I'm telling you...

//
// PHYSICAL DISKS
//

//
// Discovery

// Source(1) = output of smartd -c + smartctl reformatted by awk (see EmbeddedFile(1))
// DeviceID;Vendor;SerialNumber
PhysicalDisk.Discovery.Source(1).Type="OsCommand"
PhysicalDisk.Discovery.Source(1).CommandLine="sh %EmbeddedFile(1)% ""%{SUDO:/usr/sbin/smartctl}/usr/sbin/smartd"" ""%{SUDO:/usr/sbin/smartctl}/usr/sbin/smartctl"""
PhysicalDisk.Discovery.Source(1).KeepOnlyRegExp="^MSHW;"
PhysicalDisk.Discovery.Source(1).Separators=";"
PhysicalDisk.Discovery.Source(1).SelectColumns="2,3,4"

// Convert size from GB to bytes
// DeviceID;Vendor;Size
//PhysicalDisk.Discovery.Source(1).Compute(1).Type="Multiply"
//PhysicalDisk.Discovery.Source(1).Compute(1).Column="3"
//PhysicalDisk.Discovery.Source(1).Compute(1).MultiplyBy="1000000000"

// Exclude Disks Whose vendor is listed as "Virtual"
// This was added because IBM's drivers are badly written.
// DeviceID;Vendor;Size
PhysicalDisk.Discovery.Source(1).Compute(1).Type="ExcludeMatchingLines"
PhysicalDisk.Discovery.Source(1).Compute(1).Column=2
PhysicalDisk.Discovery.Source(1).Compute(1).RegExp="[Vv]irtual"


// InstanceTable = Source(1)
PhysicalDisk.Discovery.InstanceTable=%PhysicalDisk.Discovery.Source(1)%
PhysicalDisk.Discovery.Instance.DeviceID=InstanceTable.Column(1)
PhysicalDisk.Discovery.Instance.SerialNumber=InstanceTable.Column(3)
PhysicalDisk.Discovery.Instance.Vendor=InstanceTable.Column(2)

//
// Collect

// Collect type is "one instance per instance"
PhysicalDisk.Collect.Type="MonoInstance"

// Source(1) = output of smartctl
PhysicalDisk.Collect.Source(1).Type="OsCommand"
PhysicalDisk.Collect.Source(1).CommandLine="%{SUDO:/usr/sbin/smartctl}/usr/sbin/smartctl -H %PhysicalDisk.Collect.DeviceID%"

// Process smartctl's output through awk EmbeddedFile(4)
// SMARTstatus
PhysicalDisk.Collect.Source(1).Compute(1).Type="Awk"
PhysicalDisk.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(4)
PhysicalDisk.Collect.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
PhysicalDisk.Collect.Source(1).Compute(1).Separators=";"
PhysicalDisk.Collect.Source(1).Compute(1).SelectColumns="2"

// Translate the SMARTstatus into a PredictedFailure value
// 1;PredictedFailure
PhysicalDisk.Collect.Source(1).Compute(2).Type="Translate"
PhysicalDisk.Collect.Source(1).Compute(2).Column="1"
PhysicalDisk.Collect.Source(1).Compute(2).TranslationTable="PhysicalDiskPredictedFailureTranslationTable"

// The PhysicalDiskPredictedFailureTranslationTable
PhysicalDiskPredictedFailureTranslationTable("Ok!")="1;false"
PhysicalDiskPredictedFailureTranslationTable("OK")="1;false"
PhysicalDiskPredictedFailureTranslationTable("PASSED")="1;false"
PhysicalDiskPredictedFailureTranslationTable(Default)="1;true"

// Source(2) = output of the shell script based on dd
// 1;Status;StatusInformation
PhysicalDisk.Collect.Source(2).Type="OsCommand"
PhysicalDisk.Collect.Source(2).CommandLine="/bin/sh %EmbeddedFile(5)% %PhysicalDisk.Collect.DeviceID%"
PhysicalDisk.Collect.Source(2).KeepOnlyRegExp="^MSHW;"
PhysicalDisk.Collect.Source(2).Separators=";"
PhysicalDisk.Collect.Source(2).SelectColumns="2,3,4"

// Source(3) = Table joint of Source(1) and Source(2)
// 1;PredictedFailure;1;Status;StatusInformation
PhysicalDisk.Collect.Source(3).Type="TableJoint"
PhysicalDisk.Collect.Source(3).LeftTable=%PhysicalDisk.Collect.Source(1)%
PhysicalDisk.Collect.Source(3).RightTable=%PhysicalDisk.Collect.Source(2)%
PhysicalDisk.Collect.Source(3).LeftKeyColumn=1
PhysicalDisk.Collect.Source(3).RightKeyColumn=1

// ValueTable = Source(1)
PhysicalDisk.Collect.ValueTable=%PhysicalDisk.Collect.Source(3)%
PhysicalDisk.Collect.PredictedFailure=ValueTable.Column(2)
PhysicalDisk.Collect.Status=ValueTable.Column(4)
PhysicalDisk.Collect.StatusInformation=ValueTable.Column(5)


//
//   T E M P E R A T U R E S
//

//
// Discovery

// Source(1) = output of EmbeddedFile(2)
// DeviceID;WarningThreshold
Temperature.Discovery.Source(1).Type="OSCommand"
Temperature.Discovery.Source(1).CommandLine="sh %EmbeddedFile(2)% ""%{SUDO:/usr/sbin/smartctl}/usr/sbin/smartd"" ""%{SUDO:/usr/sbin/smartctl}/usr/sbin/smartctl"""
Temperature.Discovery.Source(1).KeepOnlyRegExp="^MSHW;"
Temperature.Discovery.Source(1).Separators=";"
Temperature.Discovery.Source(1).SelectColumns="2,3"

// InstanceTable = Source(1)
Temperature.Discovery.InstanceTable=%Temperature.Discovery.Source(1)%
Temperature.Discovery.Instance.DeviceID=InstanceTable.Column(1)
Temperature.Discovery.Instance.TemperatureType="Harddisk"
Temperature.Discovery.Instance.WarningThreshold=InstanceTable.Column(2)

//
// Collect

// Collect type is mono-instance (one instance per collect)
Temperature.Collect.Type="MonoInstance"

// Source(1) = output of smartctl
Temperature.Collect.Source(1).Type="OsCommand"
Temperature.Collect.Source(1).CommandLine="%{SUDO:/usr/sbin/smartctl}/usr/sbin/smartctl -a %PhysicalDisk.Collect.DeviceID%"

// Process smartctl's output through awk EmbeddedFile(3)
// Temperature
Temperature.Collect.Source(1).Compute(1).Type="Awk"
Temperature.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(3)
Temperature.Collect.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
Temperature.Collect.Source(1).Compute(1).Separators=";"
Temperature.Collect.Source(1).Compute(1).SelectColumns="2"

// ValueTable = Source(1)
Temperature.Collect.ValueTable=%Temperature.Collect.Source(1)%
Temperature.Collect.Temperature=ValueTable.Column(1)


/////////////////////////////////////////////////////////////
///
///    Embedded File 1
///
///    Shell script that takes smartd and smartctl
///	   and lists all of the S.M.A.R.T-enabled disks
///
/////////////////////////////////////////////////////////////
EmbeddedFile(1):
#!/bin/sh
SMARTD=$1
SMARTCTL=$2
TMPFILE=/tmp/MS_HW_smartmontoolsHDF_$$

$SMARTD -c>$TMPFILE
$SMARTD -q onecheck>>$TMPFILE

DISKIDLIST=`cat $TMPFILE|awk '/^Device: .* is SMART capable/ {
	deviceID = $2;
	if (substr(deviceID, length(deviceID), 1) == ",")
	{
		deviceID = substr(deviceID, 1, length(deviceID)-1);
	}
	print deviceID
}'`

/bin/rm -f $TMPFILE

for DISKID in $DISKIDLIST
do
	$SMARTCTL -a $DISKID|awk -v deviceID=$DISKID 'BEGIN {
		vendor = "";
		serialNumber = "";
	}
	{
		if ($1 == "Device:")
		{
			if ($5 == "Version:") { vendor = $2 " " $3 " " $4; }
			else if ($4 == "Version:") { vendor = $2 " " $3; }
			else { vendor = $2; }
		}

		if ($1 == "Device" && $2 == "Model:")
		{
			vendor = $3;
		}

		if ($0 ~ /^Serial [Nn]umber: /)
		{
			serialNumber = $3;
		}
	}
	END {
		print "MSHW;" deviceID ";" vendor ";" serialNumber
	}'
done
EmbeddedFile(1).End
///////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////
///
///    Embedded File 2
///
///	   Shell script that takes smartd and smartctl as arguments
///    to retrieve temperature sensors in the SMART-enabled disks
///
///////////////////////////////////////////////////////////////
EmbeddedFile(2):
#!/bin/sh
SMARTD=$1
SMARTCTL=$2
TMPFILE=/tmp/MS_HW_smartmontoolsHDF_$$

$SMARTD -c>$TMPFILE
$SMARTD -q onecheck>>$TMPFILE

DISKIDLIST=`cat $TMPFILE|awk '/^Device: .* is SMART capable/ {
	deviceID = $2;
	if (substr(deviceID, length(deviceID), 1) == ",")
	{
		deviceID = substr(deviceID, 1, length(deviceID)-1);
	}
	print deviceID
}'`

/bin/rm -f $TMPFILE

for DISKID in $DISKIDLIST
do
	$SMARTCTL -a $DISKID|awk -v deviceID=$DISKID 'BEGIN {
		foundTemperature = 0;
		warningThreshold = "";
	}
	{
		if ($0 ~ /^Current Drive Temperature: *[0-9]* C$/)
		{
			foundTemperature = 1;
		}

		if ($1 == "194" && $10 ~ /[0-9]+/)
		{
		  foundTemperature = 1;
		  warningThreshold = 53;
		}

		if ($0 ~ /^Drive Trip Temperature: /)
		{
			warningThreshold = $4;
		}
	}
	END {
		if (foundTemperature == 1)
		{
			print "MSHW;" deviceID ";" warningThreshold
		}
	}'
done
EmbeddedFile(2).End
//////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////
///
///    Embedded File 3
///
///	   awk script that takes smartctl -a's output as stdin and
///    retrieve the temperature of the disk
///
///////////////////////////////////////////////////////////////
EmbeddedFile(3):
{
	if ($0 ~ /Current Drive Temperature: *[0-9]* C$/)
	{
		print "MSHW;" $4
		exit;
	}

	if ($1 == "194" && $10 ~ /[0-9]+/)
	{
	  print "MSHW;" $10
	  exit;
	}
}
EmbeddedFile(3).End
//////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////
///
///    Embedded File 4
///
///	   awk script that takes smartctl -H's output as stdin and
///    retrieve the overall SMART status of the disk
///
///////////////////////////////////////////////////////////////

EmbeddedFile(4):
{
	if ($0 ~ /^SMART Sense: /)
	{
		print "MSHW;" $3
		exit;
	}

	if ($0 ~ /^SMART Health Status: /)
	{
		print "MSHW;" $4
		exit;
	}

	if ($0 ~ /^SMART overall-health self-assessment test result: /)
	{
		print "MSHW;" $6
		exit;
	}

}
EmbeddedFile(4).End
//////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////
///
///    Embedded File 5
///
///	   Shell script that test the specified disk device for read with the dd utility
///
///////////////////////////////////////////////////////////////
EmbeddedFile(5):
#!/bin/sh
ERRORMESSAGE=`%{SUDO:/bin/dd}/bin/dd if=$1 of=/dev/null count=20 2>&1`
if [ "$?" = "0" ]; then
	/bin/echo "MSHW;1;OK;Working";
else
	ERRORMESSAGE=`/bin/echo $ERRORMESSAGE|/bin/awk -F: '($4 !~ /denied/ && $4 !~ /[Nn]o such file/) {print $4}'`
	if [ -z "$ERRORMESSAGE" ]; then
		/bin/echo "MSHW;1;UNKNOWN;Unknown Status";
	else
		/bin/echo "MSHW;1;ALARM;$ERRORMESSAGE";
	fi
fi
EmbeddedFile(5).End
//////////////////////////////////////////////////////////////////
