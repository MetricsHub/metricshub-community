////////////////////////////////////////////////////////////////
//
//    H a r d w a r e   D e f i n i t i o n   F i l e
//
//                       f o r
//
//                 Hardware Sentry
//
//               by Sentry Software (c)
//
//
//      Supports: NetApp 7-Mode Filer
//                Connects to NetApp's REST API
//

//
// Header
//

hdf.DisplayName="NetApp 7-Mode Filer (REST)"
hdf.TypicalPlatform="NetApp"
hdf.ReliesOn="NetApp REST API"
hdf.Version="1.0"
hdf.Comments="This connector discovers the enclosure and the disks of NetApp disk arrays (filer) as well as the various environment sensors (temperatures, fans, power supplies, etc.). It relies on the REST API protocol."
hdf.RemoteSupport="true"
hdf.LocalSupport="false"
hdf.AppliesToOS="Storage"

//
// Detection
//

// Check that system-get-info for partnet-system-id tag to validate 7-Mode
Detection.Criteria(1).Type="HTTP"
Detection.Criteria(1).Method="POST"
Detection.Criteria(1).URL="/servlets/netapp.servlets.admin.XMLrequest_filer"
Detection.Criteria(1).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><system-get-info/></netapp>"
Detection.Criteria(1).ExpectedResult="partner-system-id"
Detection.Criteria(1).ErrorMessage="Credentials Incorrect / Not a NetApp 7-Mode Filer"

//
// Enclosure
//

// Discovery

// Source(1) = Nodes
// Get XML from REST API Call <system-get-info/>
Enclosure.Discovery.Source(1).Type="HTTP"
Enclosure.Discovery.Source(1).Method="POST"
Enclosure.Discovery.Source(1).URL="/servlets/netapp.servlets.admin.XMLrequest_filer"
Enclosure.Discovery.Source(1).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><system-get-info/></netapp>"

// Convert xml output to multiLine
Enclosure.Discovery.Source(1).Compute(1).Type="Awk"
Enclosure.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(11)

// Source(2) = Multi-line XML for Nodes
// Preserve Enclosure Discovery Source 1 for use elsewhere
Enclosure.Discovery.Source(2)=%Enclosure.Discovery.Source(1)%

// Convert xml output to CSV
// MSHW;system-id;system-name;system-model;vendor-id;system-serial-number;
Enclosure.Discovery.Source(2).Compute(1).Type="Awk"
Enclosure.Discovery.Source(2).Compute(1).AwkScript=EmbeddedFile(1)

// Add Node column to act as type
// MSHW;type;system-id;system-name;system-model;vendor-id;system-serial-number;
Enclosure.Discovery.Source(2).Compute(2).Type="RightConcat"
Enclosure.Discovery.Source(2).Compute(2).Column=1
Enclosure.Discovery.Source(2).Compute(2).String=";Node"

// Replace ID for Global to attach things more easily.
Enclosure.Discovery.Source(2).Compute(3).Type="Replace"
Enclosure.Discovery.Source(2).Compute(3).Column=3
Enclosure.Discovery.Source(2).Compute(3).Replace=Column(3)
Enclosure.Discovery.Source(2).Compute(3).ReplaceBy="Global"

//Add empty column for parameter activation (no status for controller)
Enclosure.Discovery.Source(2).Compute(4).Type="RightConcat"
Enclosure.Discovery.Source(2).Compute(4).Column=7
Enclosure.Discovery.Source(2).Compute(4).String=";"

// Source(3) = Storage Shelves
// Get XML from REST API Call <storage-shelf-environment-list-info/>
Enclosure.Discovery.Source(3).Type="HTTP"
Enclosure.Discovery.Source(3).Method="POST"
Enclosure.Discovery.Source(3).URL="/servlets/netapp.servlets.admin.XMLrequest_filer"
Enclosure.Discovery.Source(3).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><storage-shelf-environment-list-info/></netapp>"

// Convert xml output to multiLine
Enclosure.Discovery.Source(3).Compute(1).Type="Awk"
Enclosure.Discovery.Source(3).Compute(1).AwkScript=EmbeddedFile(11)

// Source(4) = Multi-line XML for Shelves
// Preserve Enclosure Discovery Source 3 for use elsewhere
Enclosure.Discovery.Source(4)=%Enclosure.Discovery.Source(3)%

// Convert xml output to CSV
// MSHW;shelf-id;ses-product-id;ses-product-id;vendor-id;;op-status
Enclosure.Discovery.Source(4).Compute(1).Type="Awk"
Enclosure.Discovery.Source(4).Compute(1).AwkScript=EmbeddedFile(2)

// Concat ";Shelf" to Column for type
// MSHW;type;shelf;shelf-model;serial-number;;;op-status
Enclosure.Discovery.Source(4).Compute(2).Type="RightConcat"
Enclosure.Discovery.Source(4).Compute(2).Column=1
Enclosure.Discovery.Source(4).Compute(2).String=";Shelf"

// add column 7 with value for ParameterActivation
Enclosure.Discovery.Source(4).Compute(3).Type="RightConcat"
Enclosure.Discovery.Source(4).Compute(3).Column=7
Enclosure.Discovery.Source(4).Compute(3).String=";ReportStatus"


// Source(5) = All enclosures (Nodes + Shelves)
// Union the Nodes and Shelves tables
// Table 1 // MSHW;type; system-id;system-name;  system-model;  vendor-id;system-serial-number;
// Table 2 // MSHW;type; shelf-id;ses-product-id;ses-product-id;vendor-id;                    ;op-status
// index   //   1;  2;     3;           4;            5;                    7;		        				8
Enclosure.Discovery.Source(5).Type="TableUnion"
Enclosure.Discovery.Source(5).Table1=%Enclosure.Discovery.Source(2)%
Enclosure.Discovery.Source(5).Table2=%Enclosure.Discovery.Source(4)%

// Enclosure Instance Table
// MSHW;type;node;model;serial;product-version;firmware;status
Enclosure.Discovery.InstanceTable=%Enclosure.Discovery.Source(5)%
Enclosure.Discovery.Instance.Type=InstanceTable.Column(2)
Enclosure.Discovery.Instance.DeviceID=InstanceTable.Column(3)
Enclosure.Discovery.Instance.DisplayID=InstanceTable.Column(4)
Enclosure.Discovery.Instance.Vendor=InstanceTable.Column(6)
Enclosure.Discovery.Instance.Model=InstanceTable.Column(5)
Enclosure.Discovery.Instance.SerialNumber=InstanceTable.Column(7)
Enclosure.Discovery.Instance.ParameterActivation.Status=InstanceTable.Column(8)


// Collection

// Collection Type (Multi-instance)
Enclosure.Collect.Type="MultiInstance"

// Source(1) = Nodes
// Get XML from REST API Call <system-get-info/>
Enclosure.Collect.Source(1).Type="HTTP"
Enclosure.Collect.Source(1).Method="POST"
Enclosure.Collect.Source(1).Url="/servlets/netapp.servlets.admin.XMLrequest_filer"
Enclosure.Collect.Source(1).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><system-get-info/></netapp>"

// Convert xml output to multiLine
Enclosure.Collect.Source(1).Compute(1).Type="Awk"
Enclosure.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(11)

// Source(2) = Multi-line XML for Nodes
// Preserve Enclosure Discovery Source 1 for use elsewhere
Enclosure.Collect.Source(2)=%Enclosure.Collect.Source(1)%

// Convert xml output to CSV
// MSHW;node;node-model;node-serial;product-version;cup-firmware-version;is-node-healthy
Enclosure.Collect.Source(2).Compute(1).Type="Awk"
Enclosure.Collect.Source(2).Compute(1).AwkScript=EmbeddedFile(1)

Enclosure.Collect.Source(2).Compute(2).Type="Replace"
Enclosure.Collect.Source(2).Compute(2).Column=2
Enclosure.Collect.Source(2).Compute(2).Replace=Column(2)
Enclosure.Collect.Source(2).Compute(2).ReplaceBy="Global"

// Source(3) = Shelves
// Get XML from REST API Call <storage-shelf-environment-list-info/>
Enclosure.Collect.Source(3).Type="HTTP"
Enclosure.Collect.Source(3).Method="POST"
Enclosure.Collect.Source(3).URL="/servlets/netapp.servlets.admin.XMLrequest_filer"
Enclosure.Collect.Source(3).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><storage-shelf-environment-list-info/></netapp>"

// Convert xml output to multiLine
Enclosure.Collect.Source(3).Compute(1).Type="Awk"
Enclosure.Collect.Source(3).Compute(1).AwkScript=EmbeddedFile(11)

// Source(4) = Multi-line XML for Nodes
// Preserve Enclosure Discovery Source 3 for use elsewhere
Enclosure.Collect.Source(4)=%Enclosure.Collect.Source(3)%

// Convert xml output to CSV
// MSHW;shelf;shelf-model;serial-number;;;op-status
Enclosure.Collect.Source(4).Compute(1).Type="Awk"
Enclosure.Collect.Source(4).Compute(1).AwkScript=EmbeddedFile(2)

// Union the Nodes and Shelves tables
// Source(5) = All enclosures (Nodes + Shelves)
// Table 1 // MSHW;system-id;system-name;  system-model;  vendor-id;system-serial-number;
// Table 2 // MSHW;shelf-id;ses-product-id;ses-product-id;vendor-id;     ;op-status
// index   //    1;   2;    3;          4;            5;              6;                   7;
Enclosure.Collect.Source(5).Type="TableUnion"
Enclosure.Collect.Source(5).Table1=%Enclosure.Collect.Source(2)%
Enclosure.Collect.Source(5).Table2=%Enclosure.Collect.Source(4)%

Enclosure.Collect.Source(5).Compute(1).Type="DuplicateColumn"
Enclosure.Collect.Source(5).Compute(1).Column=7

// Translate is-node-healthy to PatrolStatus
// MSHW;node;node-model;node-serial;product-version;cup-firmware-version;is-node-healthy
Enclosure.Collect.Source(5).Compute(2).Type="Translate"
Enclosure.Collect.Source(5).Compute(2).Column=7
Enclosure.Collect.Source(5).Compute(2).TranslationTable="EnclosureHealthTranslationTable"

EnclosureHealthTranslationTable("normal")="OK"
EnclosureHealthTranslationTable(Default)="ALARM"

// Enclosure Value Table
// MSHW;shelf-id;ses-product-id;ses-product-id;vendor-id;serialNumber;op-status
Enclosure.Collect.ValueTable=%Enclosure.Collect.Source(5)%
Enclosure.Collect.DeviceID=ValueTable.Column(2)
Enclosure.Collect.Status=ValueTable.Column(7)
Enclosure.Collect.StatusInformation=ValueTable.Column(8)

//
// PowerSupply
//

//
// Discovery

// Source(1) = Shelves
PowerSupply.Discovery.Source(1)=%Enclosure.Discovery.Source(3)%

// Xml2Cvs using AWK
// MSHW;ps-number;shelf-id;serial-no;error;not-installed
PowerSupply.Discovery.Source(1).Compute(1).Type="Awk"
PowerSupply.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(3)

// API reports ~"not installed = true" so we exclude those
PowerSupply.Discovery.Source(1).Compute(2).Type="ExcludeMatchingLines"
PowerSupply.Discovery.Source(1).Compute(2).Column=6
PowerSupply.Discovery.Source(1).Compute(2).RegExp="true"

// Duplicate column 2 for displayID
// MSHW;ps-number;ps-number;shelf-id;serial-no;error;not-installed
PowerSupply.Discovery.Source(1).Compute(3).Type="DuplicateColumn"
PowerSupply.Discovery.Source(1).Compute(3).Column=2

// MSHW;ps-number;DisplayID;shelf-id;serial-no;error;not-installed
PowerSupply.Discovery.Source(1).Compute(4).Type="LeftConcat"
PowerSupply.Discovery.Source(1).Compute(4).Column=3
PowerSupply.Discovery.Source(1).Compute(4).String="Power Supply #"

PowerSupply.Discovery.Source(1).Compute(5).Type="LeftConcat"
PowerSupply.Discovery.Source(1).Compute(5).Column=5
PowerSupply.Discovery.Source(1).Compute(5).String="Serial Number: "

// Powersupply Instance Table
// MSHW;ps-number;DisplayID;shelf-id;serial-no;error;not-installed
PowerSupply.Discovery.InstanceTable=%PowerSupply.Discovery.Source(1)%
PowerSupply.Discovery.Instance.DeviceID=InstanceTable.Column(2)
PowerSupply.Discovery.Instance.DisplayID=InstanceTable.Column(3)
PowerSupply.Discovery.Instance.AdditionalInformation1=InstanceTable.Column(5)
PowerSupply.Discovery.Instance.AttachedToDeviceID=InstanceTable.Column(4)

//
// Collection

// Collection Type (Multi-instance)
PowerSupply.Collect.Type="MultiInstance"

// Source(1) = Shelves
PowerSupply.Collect.Source(1)=%Enclosure.Collect.Source(3)%

// Convert XML to CSV
// MSHW;ps-number;shelf-id;serial-no;error;not-installed
PowerSupply.Collect.Source(1).Compute(1).Type="Awk"
PowerSupply.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(3)

// DuplicateColumn for StatusInformation
PowerSupply.Collect.Source(1).Compute(2).Type="DuplicateColumn"
PowerSupply.Collect.Source(1).Compute(2).Column=5

// Translate status to PatrolStatus
// MSHW;ps-number;shelf-id;serial-no;error;not-installed
PowerSupply.Collect.Source(1).Compute(3).Type="Translate"
PowerSupply.Collect.Source(1).Compute(3).Column=5
PowerSupply.Collect.Source(1).Compute(3).TranslationTable="PowerSupplyStatusTranslationTable"

PowerSupplyStatusTranslationTable("false")="OK"
PowerSupplyStatusTranslationTable(Default)="ALARM"

// Translate status to StatusInformation
// MSHW;ps-number;shelf-id;serial-no;PATROLStatus;error;not-installed;
PowerSupply.Collect.Source(1).Compute(4).Type="Translate"
PowerSupply.Collect.Source(1).Compute(4).Column=6
PowerSupply.Collect.Source(1).Compute(4).TranslationTable="PowerSupplyStatusInformationTranslationTable"

PowerSupplyStatusInformationTranslationTable("false")="No Errors"
PowerSupplyStatusInformationTranslationTable("true")="Error Detected"
PowerSupplyStatusInformationTranslationTable(Default)=""

// PowerSupply Value Table
// MSHW;ps-number;shelf-id;serial-no;error;not-installed
PowerSupply.Collect.ValueTable=%PowerSupply.Collect.Source(1)%
PowerSupply.Collect.DeviceID=ValueTable.Column(2)
PowerSupply.Collect.Status=ValueTable.Column(5)
PowerSupply.Collect.StatusInformation=ValueTable.Column(6)


//
// Fans
//

//
// Discovery

// Source(1) = Shelves
Fan.Discovery.Source(1)=%Enclosure.Discovery.Source(3)%

// Xml2Cvs using AWK
// MSHW;number;shelf-id;error;not-installed
Fan.Discovery.Source(1).Compute(1).Type="Awk"
Fan.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(4)

// API reports ~"not installed = true" so we exclude those
// MSHW;number;shelf-id;error;not-installed
Fan.Discovery.Source(1).Compute(2).Type="ExcludeMatchingLines"
Fan.Discovery.Source(1).Compute(2).Column=5
Fan.Discovery.Source(1).Compute(2).RegExp="true"

Fan.Discovery.Source(1).Compute(3).Type="DuplicateColumn"
Fan.Discovery.Source(1).Compute(3).Column=2

Fan.Discovery.Source(1).Compute(4).Type="LeftConcat"
Fan.Discovery.Source(1).Compute(4).Column=3
Fan.Discovery.Source(1).Compute(4).String="Fan #"

// Fan Instance Table
// MSHW;number;shelf-id;error;not-installed
Fan.Discovery.InstanceTable=%Fan.Discovery.Source(1)%
Fan.Discovery.Instance.DeviceID=InstanceTable.Column(2)
Fan.Discovery.Instance.DisplayID=InstanceTable.Column(3)

Fan.Discovery.Instance.AttachedToDeviceID=InstanceTable.Column(4)

//
// Collection

// Collection Type (Multi-instance)
Fan.Collect.Type="MultiInstance"

// Source(1) = Nodes
Fan.Collect.Source(1)=%Enclosure.Collect.Source(3)%

// Xml2Cvs using AWK
// MSHW;number;shelf-id;error;not-installed
Fan.Collect.Source(1).Compute(1).Type="Awk"
Fan.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(4)

// Duplicate Column 4 for StatusInformation
// MSHW;number;shelf-id;error;not-installed
Fan.Collect.Source(1).Compute(2).Type="DuplicateColumn"
Fan.Collect.Source(1).Compute(2).Column=4

// Translate Fan status into PatrolStatus
// MSHW;number;shelf-id;PatrolStatus;not-installed
Fan.Collect.Source(1).Compute(3).Type="Translate"
Fan.Collect.Source(1).Compute(3).Column=4
Fan.Collect.Source(1).Compute(3).TranslationTable="FanStatusTranslationTable"

FanStatusTranslationTable("false")="OK"
FanStatusTranslationTable(Default)="ALARM"

// Translate Fan status into StatusInformation
// MSHW;number;shelf-id;PatrolStatus;StatusInformation
Fan.Collect.Source(1).Compute(4).Type="Translate"
Fan.Collect.Source(1).Compute(4).Column=5
Fan.Collect.Source(1).Compute(4).TranslationTable="FanStatusInformationTranslationTable"

FanStatusInformationTranslationTable("false")="No Error Detected"
FanStatusInformationTranslationTable("true")="Error Detected"
FanStatusInformationTranslationTable(Default)=""

// Fan Value Table
// MSHW;unique-id;PatrolStatus;StatusInformation
Fan.Collect.ValueTable=%Fan.Collect.Source(1)%
Fan.Collect.DeviceID=ValueTable.Column(2)
Fan.Collect.Status=ValueTable.Column(4)
Fan.Collect.StatusInformation=ValueTable.Column(5)

//
// Temperature
//

//
// Discovery

// Source(1) = Shelves
Temperature.Discovery.Source(1)=%Enclosure.Discovery.Source(3)%

// Xml2Cvs using AWK
// MSHW;id;shelf-id;is-error;current-condition
Temperature.Discovery.Source(1).Compute(1).Type="Awk"
Temperature.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(5)

Temperature.Discovery.Source(1).Compute(2).Type="DuplicateColumn"
Temperature.Discovery.Source(1).Compute(2).Column=2

Temperature.Discovery.Source(1).Compute(3).Type="LeftConcat"
Temperature.Discovery.Source(1).Compute(3).Column=3
Temperature.Discovery.Source(1).Compute(3).String="Temperature #"

// Temperature Instance Table
// MSHW;node;uniqueID;name;env-over-temperature
Temperature.Discovery.InstanceTable=%Temperature.Discovery.Source(1)%
Temperature.Discovery.Instance.DeviceID=InstanceTable.Column(2)
Temperature.Discovery.Instance.DisplayID=InstanceTable.Column(3)

Temperature.Discovery.Instance.AttachedToDeviceID=InstanceTable.Column(4)

//
// Collection

// Collection Type (Multi-instance)
Temperature.Collect.Type="MultiInstance"

// Source(1) = Shelves
Temperature.Collect.Source(1)=%Enclosure.Collect.Source(3)%

// Xml2Cvs using AWK
// MSHW;node;env-over-temperature
Temperature.Collect.Source(1).Compute(1).Type="Awk"
Temperature.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(5)

// Translate status information into PatrolStatus
Temperature.Collect.Source(1).Compute(2).Type="Translate"
Temperature.Collect.Source(1).Compute(2).Column=4
Temperature.Collect.Source(1).Compute(2).TranslationTable="TemperatureStatusTranslationTable"

TemperatureStatusTranslationTable("false")="OK"
TemperatureStatusTranslationTable(Default)="ALARM"

Temperature.Collect.Source(1).Compute(3).Type="Replace"
Temperature.Collect.Source(1).Compute(3).Column=5
Temperature.Collect.Source(1).Compute(3).Replace="_"
Temperature.Collect.Source(1).Compute(3).ReplaceBy=" "

// Temperature Value Table
// MSHW;unique-id;PatrolStatus;StatusInformation
Temperature.Collect.ValueTable=%Temperature.Collect.Source(1)%
Temperature.Collect.DeviceID=ValueTable.Column(2)
Temperature.Collect.Status=ValueTable.Column(4)
Temperature.Collect.StatusInformation=ValueTable.Column(5)


//
// PhysicalDisk
//

//
// Discovery

// Source(1) = disk-list-info
// Get XML from REST API Call <disk-list-info/>
PhysicalDisk.Discovery.Source(1).Type="HTTP"
PhysicalDisk.Discovery.Source(1).Method="POST"
PhysicalDisk.Discovery.Source(1).Url="/servlets/netapp.servlets.admin.XMLrequest_filer"
PhysicalDisk.Discovery.Source(1).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><disk-list-info/></netapp>"

// Convert xml output to multiLine
PhysicalDisk.Discovery.Source(1).Compute(1).Type="Awk"
PhysicalDisk.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(11)

// Source(2) = Storage Shelf Info
PhysicalDisk.Discovery.Source(2)=%PhysicalDisk.Discovery.Source(1)%

// Xml2Cvs using AWK
// MSHW;shelf;bay;model;vendor;serialNumber;disk-type;rpm;fw;physical-space;is-prefailed;
PhysicalDisk.Discovery.Source(2).Compute(1).Type="Awk"
PhysicalDisk.Discovery.Source(2).Compute(1).AwkScript=EmbeddedFile(6)

// MSHW;shelf;shelf;bay;model;vendor;serialNumber;disk-type;rpm;fw;physical-space;is-prefailed;
PhysicalDisk.Discovery.Source(2).Compute(2).Type="DuplicateColumn"
PhysicalDisk.Discovery.Source(2).Compute(2).Column=2

// create uniqueID (Computes 2-3)
// MSHW;shelf.;shelf;bay;model;vendor;serialNumber;disk-type;rpm;fw;physical-space;is-prefailed;
PhysicalDisk.Discovery.Source(2).Compute(3).Type="RightConcat"
PhysicalDisk.Discovery.Source(2).Compute(3).Column=2
PhysicalDisk.Discovery.Source(2).Compute(3).String="."

// MSHW;shelf.bay;shelf;bay;model;vendor;serialNumber;disk-type;rpm;fw;physical-space;is-prefailed;
PhysicalDisk.Discovery.Source(2).Compute(4).Type="RightConcat"
PhysicalDisk.Discovery.Source(2).Compute(4).Column=2
PhysicalDisk.Discovery.Source(2).Compute(4).String=Column(4)

PhysicalDisk.Discovery.Source(2).Compute(5).Type="LeftConcat"
PhysicalDisk.Discovery.Source(2).Compute(5).Column=9
PhysicalDisk.Discovery.Source(2).Compute(5).String="RPM: "

PhysicalDisk.Discovery.Source(3)=%PhysicalDisk.Discovery.Source(2)%

// if Column 12 (is-prefailed) has a value, the disk is assigned.
PhysicalDisk.Discovery.Source(3).Compute(1).Type="KeepOnlyMatchingLines"
PhysicalDisk.Discovery.Source(3).Compute(1).Column=12
PhysicalDisk.Discovery.Source(3).Compute(1).RegExp="."

PhysicalDisk.Discovery.Source(4)=%PhysicalDisk.Discovery.Source(2)%

// if Column 12 (is-prefailed) has no value, the disk is un-assigned.
PhysicalDisk.Discovery.Source(4).Compute(1).Type="ExcludeMatchingLines"
PhysicalDisk.Discovery.Source(4).Compute(1).Column=12
PhysicalDisk.Discovery.Source(4).Compute(1).RegExp="."

// Add description for disks that are not assigned. No status can be provided.
PhysicalDisk.Discovery.Source(4).Compute(2).Type="RightConcat"
PhysicalDisk.Discovery.Source(4).Compute(2).Column=4
PhysicalDisk.Discovery.Source(4).Compute(2).String=" (Unassigned - Not Monitored)"

// Join the Assigned and un-assigned disk tables.
PhysicalDisk.Discovery.Source(5).Type="TableUnion"
PhysicalDisk.Discovery.Source(5).Table1=%PhysicalDisk.Discovery.Source(3)%
PhysicalDisk.Discovery.Source(5).Table2=%PhysicalDisk.Discovery.Source(4)%

PhysicalDisk.Discovery.Source(5).Compute(1).Type="LeftConcat"
PhysicalDisk.Discovery.Source(5).Compute(1).Column=8
PhysicalDisk.Discovery.Source(5).Compute(1).String="Type: "

// PhysicalDisk Instancce
// MSHW;shelf.bay;shelf;bay;model;vendor;serialNumber;disk-type;rpm;fw;physical-space;is-prefailed;
PhysicalDisk.Discovery.InstanceTable=%PhysicalDisk.Discovery.Source(5)%
PhysicalDisk.Discovery.Instance.DeviceID=InstanceTable.Column(2)
PhysicalDisk.Discovery.Instance.DisplayID=InstanceTable.Column(4)
PhysicalDisk.Discovery.Instance.Model=InstanceTable.Column(5)
PhysicalDisk.Discovery.Instance.Vendor=InstanceTable.Column(6)
PhysicalDisk.Discovery.Instance.SerialNumber=InstanceTable.Column(7)
PhysicalDisk.Discovery.Instance.AdditionalInformation2=InstanceTable.Column(8)
PhysicalDisk.Discovery.Instance.AdditionalInformation1=InstanceTable.Column(9)
PhysicalDisk.Discovery.Instance.FirmwareVersion=InstanceTable.Column(10)
PhysicalDisk.Discovery.Instance.Size=InstanceTable.Column(11)
PhysicalDisk.Discovery.Instance.ParameterActivation.Status=InstanceTable.Column(12)

PhysicalDisk.Discovery.Instance.AttachedToDeviceID=InstanceTable.Column(3)

// Collect
// Collect type: MultiInstance
PhysicalDisk.Collect.Type="MultiInstance"

// Source(1) = disk-list-info
// Get XML from REST API Call
PhysicalDisk.Collect.Source(1).Type="HTTP"
PhysicalDisk.Collect.Source(1).Method="POST"
PhysicalDisk.Collect.Source(1).Url="/servlets/netapp.servlets.admin.XMLrequest_filer"
PhysicalDisk.Collect.Source(1).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><disk-list-info/></netapp>"

PhysicalDisk.Collect.Source(1).Compute(1).Type="Awk"
PhysicalDisk.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(11)

// Source(2) = disk-list-info
PhysicalDisk.Collect.Source(2)=%PhysicalDisk.Collect.Source(1)%

// Xml2Cvs with Awk
// MSHW;shelf;bay;model;vendor;serialNumber;disk-type;rpm;fw;physical-space;is-prefailed;
PhysicalDisk.Collect.Source(2).Compute(1).Type="Awk"
PhysicalDisk.Collect.Source(2).Compute(1).AwkScript=EmbeddedFile(6)

// MSHW;shelf;shelf;bay;model;vendor;serialNumber;disk-type;rpm;fw;physical-space;is-prefailed;
PhysicalDisk.Collect.Source(2).Compute(2).Type="DuplicateColumn"
PhysicalDisk.Collect.Source(2).Compute(2).Column=2

// create uniqueID (Computes 2-3)
// MSHW;shelf.;shelf;bay;model;vendor;serialNumber;disk-type;rpm;fw;physical-space;is-prefailed;
PhysicalDisk.Collect.Source(2).Compute(3).Type="RightConcat"
PhysicalDisk.Collect.Source(2).Compute(3).Column=2
PhysicalDisk.Collect.Source(2).Compute(3).String="."

// MSHW;shelf.bay;shelf;bay;model;vendor;serialNumber;disk-type;rpm;fw;physical-space;is-prefailed;
PhysicalDisk.Collect.Source(2).Compute(4).Type="RightConcat"
PhysicalDisk.Collect.Source(2).Compute(4).Column=2
PhysicalDisk.Collect.Source(2).Compute(4).String=Column(4)

// MSHW;shelf;shelf;bay;model;vendor;serialNumber;disk-type;rpm;fw;physical-space;is-prefailed;
PhysicalDisk.Collect.Source(2).Compute(5).Type="DuplicateColumn"
PhysicalDisk.Collect.Source(2).Compute(5).Column=12

// Translate bay-op-status into PatrolStatus
// MSHW;shelf-id;bay-id;bay-has-disk;bay-type;PatrolStatus;
PhysicalDisk.Collect.Source(2).Compute(6).Type="Translate"
PhysicalDisk.Collect.Source(2).Compute(6).Column=12
PhysicalDisk.Collect.Source(2).Compute(6).TranslationTable="PhysicalDiskTranslationTable"

PhysicalDiskTranslationTable("false")="OK"
PhysicalDiskTranslationTable(Default)="ALARM"

PhysicalDisk.Collect.Source(2).Compute(7).Type="LeftConcat"
PhysicalDisk.Collect.Source(2).Compute(7).Column=13
PhysicalDisk.Collect.Source(2).Compute(7).String="Is prefailed : "

// PhysicalDisk Value Table
// MSHW;shelf;unique-id;bay-has-disk;bay-type;PatrolStatus;
PhysicalDisk.Collect.ValueTable=%PhysicalDisk.Collect.Source(2)%
PhysicalDisk.Collect.DeviceID=ValueTable.Column(2)
PhysicalDisk.Collect.Status=ValueTable.Column(12)
PhysicalDisk.Collect.StatusInformation=ValueTable.Column(13)

//
// NetworkCard
//

// Discovery

// Source(1) = net-config-get-active
// Get XML from REST API Call
NetworkCard.Discovery.Source(1).Type="HTTP"
NetworkCard.Discovery.Source(1).Method="POST"
NetworkCard.Discovery.Source(1).Url="/servlets/netapp.servlets.admin.XMLrequest_filer"
NetworkCard.Discovery.Source(1).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><net-config-get-active/></netapp>"

// multi-line the xml response
NetworkCard.Discovery.Source(1).Compute(1).Type="Awk"
NetworkCard.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(11)

// Source(2) = NetworkCards
NetworkCard.Discovery.Source(2)=%NetworkCard.Discovery.Source(1)%

// Xml2Cvs with Awk
// MSHW;interface-name;mac-address;mediatype;
NetworkCard.Discovery.Source(2).Compute(1).Type="Awk"
NetworkCard.Discovery.Source(2).Compute(1).AwkScript=EmbeddedFile(7)

// Add port identifying information for this source (always MAC and "Ethernet Port")
// MSHW;interface-name;mac-address;MAC;Type;mediatype;
NetworkCard.Discovery.Source(2).Compute(2).Type="RightConcat"
NetworkCard.Discovery.Source(2).Compute(2).Column=3
NetworkCard.Discovery.Source(2).Compute(2).String=";MAC;Ethernet Port;"

// Source(3) = fcp-adapter-list-info
// Get XML from REST API Call
NetworkCard.Discovery.Source(3).Type="HTTP"
NetworkCard.Discovery.Source(3).Method="POST"
NetworkCard.Discovery.Source(3).Url="/servlets/netapp.servlets.admin.XMLrequest_filer"
NetworkCard.Discovery.Source(3).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><fcp-adapter-list-info/></netapp>"

// multi-line the xml response
NetworkCard.Discovery.Source(3).Compute(1).Type="Awk"
NetworkCard.Discovery.Source(3).Compute(1).AwkScript=EmbeddedFile(11)

NetworkCard.Discovery.Source(4) = %NetworkCard.Discovery.Source(3)%

// Xml2Cvs with Awk
// MSHW;node;adapter;port-name;state;speed;
NetworkCard.Discovery.Source(4).Compute(1).Type="Awk"
NetworkCard.Discovery.Source(4).Compute(1).AwkScript=EmbeddedFile(10)

// Add port identifying information for this source (always WWN and "FC Port")
// MSHW;adapter;port-name;WWN;FC;state;speed;
NetworkCard.Discovery.Source(4).Compute(2).Type="RightConcat"
NetworkCard.Discovery.Source(4).Compute(2).Column=3
NetworkCard.Discovery.Source(4).Compute(2).String=";WWN;FC Port"

NetworkCard.Discovery.Source(5).Type="TableUnion"
NetworkCard.Discovery.Source(5).Table1=%NetworkCard.Discovery.Source(2)%
NetworkCard.Discovery.Source(5).Table2=%NetworkCard.Discovery.Source(4)%

//Replace auto with blank to deactivate LinkSpeed
NetworkCard.Discovery.Source(5).Compute(1).Type="Replace"
NetworkCard.Discovery.Source(5).Compute(1).Column=7
NetworkCard.Discovery.Source(5).Compute(1).Replace="auto"
NetworkCard.Discovery.Source(5).Compute(1).ReplaceBy=""

// NetworkCard Instance Table
// MSHW;node;uniqueId;port;link-status;health-status;mac-address;link-speed;physical-address-type;device-type
NetworkCard.Discovery.InstanceTable=%NetworkCard.Discovery.Source(5)%
NetworkCard.Discovery.Instance.DeviceID=InstanceTable.Column(2)
NetworkCard.Discovery.Instance.DisplayID=InstanceTable.Column(2)
NetworkCard.Discovery.Instance.PhysicalAddress=InstanceTable.Column(3)
NetworkCard.Discovery.Instance.PhysicalAddressType=InstanceTable.Column(4)
NetworkCard.Discovery.Instance.DeviceType=InstanceTable.Column(5)
NetworkCard.Discovery.Instance.ParameterActivation.LinkSpeed=InstanceTable.Column(7)

NetworkCard.Discovery.Instance.AttachedToDeviceID="Global"

//
// Collect

// Collection type (Multi-instance)
NetworkCard.Collect.Type="MultiInstance"

// Source(1) = NetworkCards
// Get XML from REST API Call
NetworkCard.Collect.Source(1).Type="HTTP"
NetworkCard.Collect.Source(1).Method="POST"
NetworkCard.Collect.Source(1).Url="/servlets/netapp.servlets.admin.XMLrequest_filer"
NetworkCard.Collect.Source(1).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><net-config-get-active/></netapp>"

// xml to multi-line
NetworkCard.Collect.Source(1).Compute(1).Type="Awk"
NetworkCard.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(11)

// Source(2) = NetworkCards
NetworkCard.Collect.Source(2)=%NetworkCard.Collect.Source(1)%

// Xml2Cvs using AWK
// MSHW;interface-name;mac-address;mediatype;
NetworkCard.Collect.Source(2).Compute(1).Type="Awk"
NetworkCard.Collect.Source(2).Compute(1).AwkScript=EmbeddedFile(7)

// Duplicate status column (status information)
NetworkCard.Collect.Source(2).Compute(2).Type="DuplicateColumn"
NetworkCard.Collect.Source(2).Compute(2).Column=4

// MSHW;interface-name;mac-address;auto;speed;duplex;link;mediaType;
NetworkCard.Collect.Source(2).Compute(3).Type="Replace"
NetworkCard.Collect.Source(2).Compute(3).Column=4
NetworkCard.Collect.Source(2).Compute(3).Replace="-"
NetworkCard.Collect.Source(2).Compute(3).ReplaceBy=";"

NetworkCard.Collect.Source(2).Compute(4).Type="DuplicateColumn"
NetworkCard.Collect.Source(2).Compute(4).Column=7

NetworkCard.Collect.Source(2).Compute(5).Type="Translate"
NetworkCard.Collect.Source(2).Compute(5).Column=7
NetworkCard.Collect.Source(2).Compute(5).TranslationTable="NetworkCardStatusTranslationTable"

// MSHW;interface-name;mac-address;mediatype;
NetworkCard.Collect.Source(2).Compute(6).Type="Translate"
NetworkCard.Collect.Source(2).Compute(6).Column=8
NetworkCard.Collect.Source(2).Compute(6).TranslationTable="LinkStatusTranslationTable"

// Remove t from speed column to be used for LinkSpeed
NetworkCard.Collect.Source(2).Compute(7).Type="Replace"
NetworkCard.Collect.Source(2).Compute(7).Column=5
NetworkCard.Collect.Source(2).Compute(7).Replace="t"
NetworkCard.Collect.Source(2).Compute(7).ReplaceBy=""

// Source(3) = fcp-adapter-list-info
// Get XML from REST API Call
NetworkCard.Collect.Source(3).Type="HTTP"
NetworkCard.Collect.Source(3).Method="POST"
NetworkCard.Collect.Source(3).Url="/servlets/netapp.servlets.admin.XMLrequest_filer"
NetworkCard.Collect.Source(3).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><fcp-adapter-list-info/></netapp>"

// xml to multi-line
NetworkCard.Collect.Source(3).Compute(1).Type="Awk"
NetworkCard.Collect.Source(3).Compute(1).AwkScript=EmbeddedFile(11)

// Source(2) = NetworkCards
NetworkCard.Collect.Source(4)=%NetworkCard.Collect.Source(3)%

// Xml2Cvs using AWK
// MSHW;adapter;adapter-wwnn;status-admin;speed;
NetworkCard.Collect.Source(4).Compute(1).Type="Awk"
NetworkCard.Collect.Source(4).Compute(1).AwkScript=EmbeddedFile(10)

// Duplicate status column (status information)
// MSHW;adapter;adapter-wwnn;status-admin;status-admin;speed;
NetworkCard.Collect.Source(4).Compute(2).Type="DuplicateColumn"
NetworkCard.Collect.Source(4).Compute(2).Column=4

// Duplicate status column (status information)
// MSHW;adapter;adapter-wwnn;status-admin;status-admin;status-admin;speed;
NetworkCard.Collect.Source(4).Compute(3).Type="DuplicateColumn"
NetworkCard.Collect.Source(4).Compute(3).Column=4

// Duplicate status column (status information)
// MSHW;adapter;adapter-wwnn;status-admin;status-admin;status-admin;status-admin;speed;
NetworkCard.Collect.Source(4).Compute(4).Type="DuplicateColumn"
NetworkCard.Collect.Source(4).Compute(4).Column=4

// Duplicate status column (status information)
// MSHW;adapter;adapter-wwnn;status-admin;status-admin;status-admin;status-admin;status-admin;speed;
NetworkCard.Collect.Source(4).Compute(5).Type="DuplicateColumn"
NetworkCard.Collect.Source(4).Compute(5).Column=4

// Translate NetworkCard Status
// MSHW;adapter;adapter-wwnn;status-admin;status-admin;status-admin;Status;status-admin;speed;
NetworkCard.Collect.Source(4).Compute(6).Type="Translate"
NetworkCard.Collect.Source(4).Compute(6).Column=7
NetworkCard.Collect.Source(4).Compute(6).TranslationTable="NetworkCardStatusTranslationTable"

// Translate NetworkCard LinkStatus
// MSHW;adapter;adapter-wwnn;status-admin;status-admin;status-admin;Status;LinkStatus;speed;
NetworkCard.Collect.Source(4).Compute(7).Type="Translate"
NetworkCard.Collect.Source(4).Compute(7).Column=8
NetworkCard.Collect.Source(4).Compute(7).TranslationTable="LinkStatusTranslationTable"

// Move speed to Column 5 to match Ethernet
// MSHW;adapter;adapter-wwnn;status-admin;speed;status-admin;Status;LinkStatus;speed;
NetworkCard.Collect.Source(4).Compute(8).Type="Replace"
NetworkCard.Collect.Source(4).Compute(8).Column=5
NetworkCard.Collect.Source(4).Compute(8).Replace=Column(5)
NetworkCard.Collect.Source(4).Compute(8).ReplaceBy=Column(9)

// Replace Gb with 000 for LinkSpeed
NetworkCard.Collect.Source(4).Compute(9).Type="Replace"
NetworkCard.Collect.Source(4).Compute(9).Column=5
NetworkCard.Collect.Source(4).Compute(9).Replace="Gb"
NetworkCard.Collect.Source(4).Compute(9).ReplaceBy="000"

NetworkCardStatusTranslationTable("inactive")="OK"
NetworkCardStatusTranslationTable("up")="OK"
NetworkCardStatusTranslationTable("no carrier")="OK"
NetworkCardStatusTranslationTable("online")="OK"
NetworkCardStatusTranslationTable("link not connected")="OK"
NetworkCardStatusTranslationTable("offlined by user/system")="OK"
NetworkCardStatusTranslationTable("")="OK"
NetworkCardStatusTranslationTable(Default)="ALARM"

// The NetworkCardStatusTranslationTable
LinkStatusTranslationTable("inactive")="WARN"
LinkStatusTranslationTable("up")="OK"
LinkStatusTranslationTable("no carrier")="WARN"
LinkStatusTranslationTable("online")="OK"
LinkStatusTranslationTable("link not connected")="WARN"
LinkStatusTranslationTable("")="WARN"
LinkStatusTranslationTable("offlined by user/system")="WARN"
LinkStatusTranslationTable(Default)="WARN"

NetworkCard.Collect.Source(5).Type="TableUnion"
NetworkCard.Collect.Source(5).Table1 = %NetworkCard.Collect.Source(2)%
NetworkCard.Collect.Source(5).Table2 = %NetworkCard.Collect.Source(4)%

// NetworkCard Value Table
// MSHW;adapter;adapter-wwnn;status-admin;speed;status-admin;Status;LinkStatus;speed;
// MSHW;interface-name;mac-address;statusArray;statusArray;statusArray
NetworkCard.Collect.ValueTable=%NetworkCard.Collect.Source(5)%
NetworkCard.Collect.DeviceID=ValueTable.Column(2)
NetworkCard.Collect.Status=ValueTable.Column(7)
NetworkCard.Collect.LinkStatus=ValueTable.Column(8)
NetworkCard.Collect.StatusInformation=ValueTable.Column(9)
NetworkCard.Collect.LinkSpeed=ValueTable.Column(5)

//
// LogicalDisk
//

// Discovery

// Source(1) = Aggregate (raid) information
// Get XML from REST API Call
LogicalDisk.Discovery.Source(1).Type="HTTP"
LogicalDisk.Discovery.Source(1).Method="POST"
LogicalDisk.Discovery.Source(1).Url="/servlets/netapp.servlets.admin.XMLrequest_filer"
LogicalDisk.Discovery.Source(1).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><aggr-list-info/></netapp>"

// XML to multi-line xml
LogicalDisk.Discovery.Source(1).Compute(1).Type="Awk"
LogicalDisk.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(11)

// Source(2) = Aggregate (raid) inforamtion
LogicalDisk.Discovery.Source(2)=%LogicalDisk.Discovery.Source(1)%

// Xml2Cvs using Awk
// MSHW;uuid;name;size;is-inconsistent
LogicalDisk.Discovery.Source(2).Compute(1).Type="Awk"
LogicalDisk.Discovery.Source(2).Compute(1).AwkScript=EmbeddedFile(8)

// LogicalDisk Instance Table
// MSHW;uuid;name;size;is-inconsistent
LogicalDisk.Discovery.InstanceTable=%LogicalDisk.Discovery.Source(2)%
LogicalDisk.Discovery.Instance.DeviceID=InstanceTable.Column(2)
LogicalDisk.Discovery.Instance.DisplayID=InstanceTable.Column(3)
LogicalDisk.Discovery.Instance.Size=InstanceTable.Column(4)

LogicalDisk.Discovery.Instance.AttachedToDeviceID="Global"

//
// Collection

// CollectionType (Multi-instance)
LogicalDisk.Collect.Type="MultiInstance"

// Source(1) = Aggregate (raid) information
// Get XML from REST API Call
LogicalDisk.Collect.Source(1).Type="HTTP"
LogicalDisk.Collect.Source(1).Method="POST"
LogicalDisk.Collect.Source(1).Url="/servlets/netapp.servlets.admin.XMLrequest_filer"
LogicalDisk.Collect.Source(1).Body="<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE netapp SYSTEM 'file:/etc/netapp_filer.dtd'><netapp version='1.0' xmlns='http://www.netapp.com/filer/admin'><aggr-list-info/></netapp>"

// XML to multi-line XML
LogicalDisk.Collect.Source(1).Compute(1).Type="Awk"
LogicalDisk.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(11)

// Source(2) = Aggregate (raid) information
LogicalDisk.Collect.Source(2)=%LogicalDisk.Collect.Source(1)%

// Xml2Cvs using Awk
// MSHW;uuid;name;size;is-inconsistent
LogicalDisk.Collect.Source(2).Compute(1).Type="Awk"
LogicalDisk.Collect.Source(2).Compute(1).AwkScript=EmbeddedFile(8)

// MSHW;uuid;name;size;is-inconsistent
LogicalDisk.Collect.Source(2).Compute(2).Type="Translate"
LogicalDisk.Collect.Source(2).Compute(2).Column=5
LogicalDisk.Collect.Source(2).Compute(2).TranslationTable="RaidStatusTranslationTable"

RaidStatusTranslationTable("false")="OK"
RaidStatusTranslationTable(Default)="ALARM"

// LogicalDisk Value Table
// MSHW;aggregate-uuid;PatrolStatus;StatusInformation;
LogicalDisk.Collect.ValueTable=%LogicalDisk.Collect.Source(2)%
LogicalDisk.Collect.DeviceID=ValueTable.Column(2)
LogicalDisk.Collect.Status=ValueTable.Column(5)
LogicalDisk.Collect.StatusInformation=ValueTable.Column(6)

//
// OtherDevices
//

//
// Discovery

OtherDevice.Discovery.Source(1)=%Enclosure.Discovery.Source(3)%

// Xml2Cvs using AWK
// MSHW;shelf-id;es-electronics-element-no;es-electronics-is-error;es-electronics-is-reporting-element
OtherDevice.Discovery.Source(1).Compute(1).Type="Awk"
OtherDevice.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(9)

// MSHW;shelf-id;es-electronics-element-no;es-electronics-element-no;es-electronics-is-error;es-electronics-is-reporting-element
OtherDevice.Discovery.Source(1).Compute(2).Type="DuplicateColumn"
OtherDevice.Discovery.Source(1).Compute(2).Column=3

OtherDevice.Discovery.Source(1).Compute(3).Type="LeftConcat"
OtherDevice.Discovery.Source(1).Compute(3).Column=4
OtherDevice.Discovery.Source(1).Compute(3).String="Service Electronics #"

OtherDevice.Discovery.Source(1).Compute(4).Type="ExcludeMatchingLines"
OtherDevice.Discovery.Source(1).Compute(4).Column=6
OtherDevice.Discovery.Source(1).Compute(4).RegExp="false"

// LogicalDisk Instance Table
// MSHW;shelf-id;es-electronics-element-no;es-electronics-element-no;es-electronics-is-error;es-electronics-is-reporting-element
OtherDevice.Discovery.InstanceTable=%OtherDevice.Discovery.Source(1)%
OtherDevice.Discovery.Instance.DeviceID=InstanceTable.Column(3)
OtherDevice.Discovery.Instance.DisplayID=InstanceTable.Column(4)

OtherDevice.Discovery.Instance.AttachedToDeviceID=InstanceTable.Column(2)


//
// Collection

// Collect type
OtherDevice.Collect.Type="MultiInstance"

OtherDevice.Collect.Source(1)=%Enclosure.Collect.Source(3)%

// XML to multi-line XML
OtherDevice.Collect.Source(1).Compute(1).Type="Awk"
OtherDevice.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(11)

OtherDevice.Collect.Source(2)=%OtherDevice.Collect.Source(1)%

// Xml2Cvs using Awk
// MSHW;shelf-id;es-electronics-element-no;es-electronics-is-error;es-electronics-is-reporting-element
OtherDevice.Collect.Source(2).Compute(1).Type="Awk"
OtherDevice.Collect.Source(2).Compute(1).AwkScript=EmbeddedFile(9)

// Translate into PatrolStatus
// MSHW;shelf-id;es-electronics-element-no;PatrolStatus;StatusDescription
OtherDevice.Collect.Source(2).Compute(2).Type="Translate"
OtherDevice.Collect.Source(2).Compute(2).Column=4
OtherDevice.Collect.Source(2).Compute(2).TranslationTable="ServiceElectornicsTranslationTable"

ServiceElectornicsTranslationTable("false")="OK"
ServiceElectornicsTranslationTable(Default)="ALARM"

// OtherDevice Value Table
// MSHW;shelf-id;es-electronics-element-no;PatrolStatus;StatusDescription
OtherDevice.Collect.ValueTable=%OtherDevice.Collect.Source(2)%
OtherDevice.Collect.DeviceID=ValueTable.Column(3)
OtherDevice.Collect.Status=ValueTable.Column(4)
OtherDevice.Collect.StatusInformation=ValueTable.Column(5)


/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(1) = system-get-info API call (XML2CSV awk script)
///
///    NB:
///    Returns:   MSHW;system-id;system-name;system-model;vendor-id;system-serial-number
///
/////////////////////////////////////////////////////////
EmbeddedFile(1):
BEGIN{
  # Set the name for each object level
	InstanceLevel = "system-info"
	ParentLevel = ""
	GrandParentLevel = ""

  # Set the Properties to Extract
  # The number indicates which column that property will be put in
  # If you specify property[1] and property[3], you will end up with:
  # MSHW;propertyvalue1;;propertyvalue3;
	property[1] = "system-id"
	property[2] = "system-name"
	property[3] = "system-model"
	property[4] = "vendor-id"
	property[5] = "system-serial-number"

  # The rest of this script is standardized
  # and does not need to be edited
  #
  #
  # System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(1).End

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(2) = storage-shelf-environment-list-info API call (XML2CSV awk script)
///
///    NB:        Extra columns to match return from EmbeddedFile(1)
///    Returns:   MSHW;shelf-id;ses-product-id;ses-product-id;vendor-id;;op-status
///
/////////////////////////////////////////////////////////
EmbeddedFile(2):
BEGIN{
# Set the name for each object level

  	InstanceLevel = "ses-generic-info"
		ParentLevel = "shelf-environ-shelf-info"
		GrandParentLevel = ""

# Set the Properties to Extract
# The number indicates which column that property will be put in
# If you specify property[1] and property[3], you will end up with:
# MSHW;propertyvalue1;;propertyvalue3;

	#storage-shelf-info
	property[1] = "../shelf-id"
	property[2] = "ses-product-id"
	property[3] = "ses-product-id"
	property[4] = "ses-vendor-id"
  property[6] = "../shelf-status"

# The rest of this script is standardized
# and does not need to be edited
#
#
# System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(2).End

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(3) = system-node-get-iter API call (XML2CSV awk script)
///
///    NB:        Node PSUs
///    Returns:   MSHW;ps-number;shelf-id;serial-no;error;not-installed
///
/////////////////////////////////////////////////////////
EmbeddedFile(3):
BEGIN{
  # Set the name for each object level
	InstanceLevel = "power-supply-info"
	ParentLevel = "power-supply-list"
	GrandParentLevel = "shelf-environ-shelf-info"

  # Set the Properties to Extract
  # The number indicates which column that property will be put in
  # If you specify property[1] and property[3], you will end up with:
  # MSHW;propertyvalue1;;propertyvalue3;

  property[1] = "power-supply-element-number"
  property[2] = "../../shelf-id"
  property[3] = "power-supply-serial-no"
  property[4] = "power-supply-is-error"
  property[5] = "power-supply-is-not-installed"


  # The rest of this script is standardized
  # and does not need to be edited
  #
  #
  # System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(3).End

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(4) = system-node-get-iter API call (XML2CSV awk script)
///
///    NB:        Node Fans
///    Returns:   MSHW;number;shelf-id;error;not-installed
///
/////////////////////////////////////////////////////////
EmbeddedFile(4):
BEGIN{
  # Set the name for each object level
  InstanceLevel = "cooling-element-info"
	ParentLevel = "cooling-element-list"
	GrandParentLevel = "shelf-environ-shelf-info"

  # Set the Properties to Extract
  # The number indicates which column that property will be put in
  # If you specify property[1] and property[3], you will end up with:
  # MSHW;propertyvalue1;;propertyvalue3;
	property[1] = "cooling-element-number"
  property[2] = "../../shelf-id"
	property[3] = "cooling-element-is-error"
	property[4] = "cooling-element-is-not-installed"

  # The rest of this script is standardized
  # and does not need to be edited
  #
  #
  # System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(4).End

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(5) = system-node-get-iter API call (XML2CSV awk script)
///
///    NB:        Node Temperature
///    Returns:   MSHW;node;env-over-temperature
///
/////////////////////////////////////////////////////////
EmbeddedFile(5):
BEGIN{
  # Set the name for each object level
	InstanceLevel = "temp-sensor-info"
	ParentLevel = "temp-sensor-list"
	GrandParentLevel = "shelf-environ-shelf-info"

  # Set the Properties to Extract
  # The number indicates which column that property will be put in
  # If you specify property[1] and property[3], you will end up with:
  # MSHW;propertyvalue1;;propertyvalue3;
	property[1] = "temp-sensor-element-no"
	property[2] = "../../shelf-id"
  property[3] = "temp-sensor-is-error"
  property[4] = "temp-sensor-current-condition"

  # The rest of this script is standardized
  # and does not need to be edited
  #
  #
  # System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(5).End

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(6) = storage-shelf-info-get-iter API call (XML2CSV awk script)
///
///    NB:        Storage Shelf Drive Bays
///    Returns:   MSHW;shelf;bay;model;vendor;serialNumber;disk-type;rpm;fw;physical-space;defects;
///
/////////////////////////////////////////////////////////
EmbeddedFile(6):
BEGIN{
	# Set the name for each object level
  InstanceLevel = "disk-detail-info"
	ParentLevel = ""
	GrandParentLevel = ""

  # Set the Properties to Extract
  # The number indicates which column that property will be put in
  # If you specify property[1] and property[3], you will end up with:
  # MSHW;propertyvalue1;;propertyvalue3;
	property[1] = "shelf"
	property[2] = "name"
	property[3] = "disk-model"
  property[4] = "vendor-id"
	property[5] = "serial-number"
	property[6] = "disk-type"
  property[7] = "rpm"
  property[8] = "firmware-revision"
  property[9] = "physical-space"
  property[10] = "is-prefailed"

  # The rest of this script is standardized
  # and does not need to be edited
  #
  #
  # System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(6).End

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(7) = <net-port-get-iter/> API call (XML2CSV awk script)
///
///    NB:        NetworkCard
///    Returns:   MSHW;interface-name;mac-address;mediatype;
///
/////////////////////////////////////////////////////////
EmbeddedFile(7):
BEGIN{
	# Set the name for each object level
  InstanceLevel = "interface-config-info"
	ParentLevel = ""
	GrandParentLevel = ""

  # Set the Properties to Extract
  # The number indicates which column that property will be put in
  # If you specify property[1] and property[3], you will end up with:
  # MSHW;propertyvalue1;;propertyvalue3;
	property[1] = "interface-name"
	property[2] = "mac-address"
	property[3] = "mediatype"

  # The rest of this script is standardized
  # and does not need to be edited
  #
  #
  # System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(7).End

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(8) = <aggr-list-info/> API call (XML2CSV awk script)
///
///    NB:        Logical Disk
///    Returns:   MSHW;uuid;name;size;is-inconsistent
///
/////////////////////////////////////////////////////////
EmbeddedFile(8):
BEGIN{
	# Set the name for each object level
  InstanceLevel = "aggr-info"
	ParentLevel = ""
	GrandParentLevel = ""

  # Set the Properties to Extract
  # The number indicates which column that property will be put in
  # If you specify property[1] and property[3], you will end up with:
  # MSHW;propertyvalue1;;propertyvalue3;

  property[1] = "uuid"
	property[2] = "name"
	property[3] = "size-total"
	property[4] = "is-inconsistent"

  # The rest of this script is standardized
  # and does not need to be edited
  #
  #
  # System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(8).End


/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(9) = storage-shelf-environment-list-info API call (XML2CSV awk script)
///
///    NB:        Extra columns to match return from EmbeddedFile(1)
///    Returns:   MSHW;shelf-id;es-electronics-element-no;es-electronics-is-error;es-electronics-is-reporting-element
///
/////////////////////////////////////////////////////////
EmbeddedFile(9):
BEGIN{
# Set the name for each object level

  	InstanceLevel = "es-electronics-info"
		ParentLevel = "shelf-environ-shelf-info"
		GrandParentLevel = ""

# Set the Properties to Extract
# The number indicates which column that property will be put in
# If you specify property[1] and property[3], you will end up with:
# MSHW;propertyvalue1;;propertyvalue3;

	#storage-shelf-info
	property[1] = "../shelf-id"
	property[2] = "es-electronics-element-no"
	property[3] = "es-electronics-is-error"
	property[4] = "es-electronics-is-reporting-element"

# The rest of this script is standardized
# and does not need to be edited
#
#
# System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(9).End

/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(9) = storage-shelf-environment-list-info API call (XML2CSV awk script)
///
///    NB:        Extra columns to match return from EmbeddedFile(1)
///    Returns:   MSHW;adapter;adapter-wwnn;status-admin;speed;
///
/////////////////////////////////////////////////////////
EmbeddedFile(10):
BEGIN{
# Set the name for each object level

  	InstanceLevel = "fcp-config-adapter-info"
		ParentLevel = ""
		GrandParentLevel = ""

# Set the Properties to Extract
# The number indicates which column that property will be put in
# If you specify property[1] and property[3], you will end up with:
# MSHW;propertyvalue1;;propertyvalue3;

	#storage-shelf-info
	property[1] = "adapter"
	property[2] = "port-name"
	property[3] = "state"
	property[4] = "speed"

# The rest of this script is standardized
# and does not need to be edited
#
#
# System Constants
  Level = "Unknown"
  FS="[<>]"
  skip = "0"
  InstanceEnum = "0"
  ParentEnum = "0"
  GrandParentEnum = "0"
  InstanceLevelEnd = "/" InstanceLevel
  ParentLevelEnd = "/" ParentLevel
  GrandParentLevelEnd = "/" GrandParentLevel
  }
(NF == 3 ) && ($2 == GrandParentLevel) {
  GrandParentEnum = GrandParentEnum + 1
  Level = "GrandParent"
  }
(NF == 3 ) && ($2 == GrandParentLevelEnd) {
  Level = "Unknown"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevel) {
  ParentEnum = ParentEnum + 1
  Level = "Parent"
  skip = "0"
  }
(NF == 3) && ($2 == ParentLevelEnd) {
  Level = "GrandParent"
  }
(NF == 3) && ($2 == InstanceLevel) {
  InstanceEnum = InstanceEnum + 1
  InstanceParentID[InstanceEnum] = ParentEnum
  InstanceGrandParentID[InstanceEnum] = GrandParentEnum
  Level = "Instance"
  skip = "0"
  }
(NF == 3) && ($2 == InstanceLevelEnd) {
  Level = "Parent"
  }

# Skip unknown subsections
NF == 3 && $2 != GrandParentLevel && $2 != ParentLevel && $2 != InstanceLevel && Level != "Unknown" && $2 !~ /\// {
  skip = "1"
  skipTo = "/" $2
  }
skip == "1" {
  if ( $2 == skipTo ) { skip = "0"}
    else { next }
  }

# Values
# When we get a property, we search through the "property" array to see if it matches something we are looking for
# We then stick the value in the "outputArray" for the right ID (instance / parent / grandparent"
NF == 5 {
  currentProperty = $2
  value = $3
  propertyID = InstanceEnum
  if ( Level == "Parent" ) { currentProperty = "\.\.\/" currentProperty ; propertyID = ParentEnum }
  if ( Level == "GrandParent" ) { currentProperty = "\.\.\/\.\.\/" currentProperty ; propertyID = GrandParentEnum }
  for ( pID in property) {
    if ( property[pID] == currentProperty ) { outputArray[Level,propertyID,pID] = value }
    }
  }

END {
  # figure out highest property value
  highestProperty = "0"
  for (pID in property) { if ( pID > highestProperty) { highestProperty = pID} }
  for ( instanceID = 1 ; instanceID <= InstanceEnum ; instanceID++ ) {
    printf("%s","MSHW;")
    for ( pID = 1 ; pID <= highestProperty ; pID++) {
      if ( property[pID] ~ "\.\.\/\.\.\/" ) { printID = InstanceGrandParentID[instanceID] ; Level = "GrandParent" }
      else if ( property[pID] ~ "\.\.\/" ) { printID = InstanceParentID[instanceID] ; Level = "Parent" }
      else { printID = instanceID ; Level = "Instance" }
      printf("%s",outputArray[Level,printID,pID] ";" )
      }
    print " "
    }
  }
EmbeddedFile(10).End


/////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(11) = Converts XML into multi-line for other AWK Script to understand.
///
///    NB:
///    Returns:   Multiple Lines
///
/////////////////////////////////////////////////////////
EmbeddedFile(11):
{
	# the line contains multiple objects
	if ($0 ~ />.*>.*>.*>/) {
    line = $0
    xmlArraySize = split(line,xmlArray,">")
    for ( objectNumber = 1; objectNumber <= xmlArraySize ; objectNumber++ ) {
      name = xmlArray[objectNumber]
      gsub(/.*</,"",name)
      nextobjectNumber = objectNumber + 1
      nextname = xmlArray[nextobjectNumber]
      gsub(/.*</,"",nextname)
      # if the object is blank, or its the second part of an array ( data</objectname ), then skip
      if ( name != "" || xmlArray[objectNumber] ~ /^</ ) {
        # if the next object contains the same object name (basically it's the </object>) , then print both objects
        if ( nextname ~ name && xmlArray[objectNumber] ) {
          print xmlArray[objectNumber] ">" xmlArray[nextobjectNumber] ">" }
        # else just print the current object
        else { print xmlArray[objectNumber] ">" }
        }
      }
    }
  # else if it's in the header, just print the line
  else { print $0 }
}
EmbeddedFile(11).End
