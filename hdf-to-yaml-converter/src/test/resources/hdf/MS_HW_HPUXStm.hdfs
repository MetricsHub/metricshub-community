//
//
//                 C O N N E C T O R
//
//                       f o r
//
//                 Hardware Sentry
//
//                 by Sentry Software (c)
//
//                   MS_HW_HPUXStm.hdf
//
//      Supports: HP/9000, HP SuperDome, HP Integrity running HP-UX
//		Monitors: Internal disks and memory
//      Connects to: STM (Support Tools Manager)
//
//

//
// HEADER
//

hdf.DisplayName="HP-UX (STM)"
hdf.TypicalPlatform="HP 9000,HP Integrity,HP SuperDome"
hdf.ReliesOn="HP-UX Support Tools Manager (STM)"
hdf.Comments="Provides physical disks and memory monitoring on HP-UX systems through the Support Tools Manager utilities (stm)."
hdf.Version="1.1"
hdf.RemoteSupport="true"
hdf.AppliesToOS="HP"

//
// DETECTION
//

// OS should be HP (for HP-UX, whatever version)
Detection.Criteria(1).Type="OS"
Detection.Criteria(1).KeepOnly="HP"

// The stm executable needs to be present
Detection.Criteria(2).Type="OSCommand"
Detection.Criteria(2).CommandLine="/bin/ls /usr/bin/stm"
Detection.Criteria(2).ExpectedResult="^/usr/bin/stm$"

// stm must return something
Detection.Criteria(3).Type="OSCommand"
Detection.Criteria(3).CommandLine="/bin/echo ""map""|/usr/bin/stm -c"
Detection.Criteria(3).ExpectedResult="Active Tool"

//
// NO COMPUTER
//

//
// DISK CONTROLLERS
//

//
// Discovery

// Source(1) = output of echo ""selclass type interface;cds""|stm -c
DiskController.Discovery.Source(1).Type="OsCommand"
DiskController.Discovery.Source(1).CommandLine="/bin/echo ""selclass type interface;cds""|/usr/bin/stm -c"
DiskController.Discovery.Source(1).Timeout="60"
DiskController.Discovery.Source(1).ForceSerialization=1

// Process output of cstom through awk EmbeddedFile(1)
// This contains the list of all interfaces in the system, which happen
// to include disk controllers
// DeviceID;Model
DiskController.Discovery.Source(1).Compute(1).Type="Awk"
DiskController.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(1)
DiskController.Discovery.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
DiskController.Discovery.Source(1).Compute(1).Separators=";"
DiskController.Discovery.Source(1).Compute(1).SelectColumns="2,3"

// Source(2) = output of echo ""selclass type Disk;wait;information;wait;infolog""|stm -c
DiskController.Discovery.Source(2).Type="OsCommand"
DiskController.Discovery.Source(2).CommandLine="/bin/echo ""selclass type Disk;wait;information;wait;infolog""|/usr/bin/stm -c"
DiskController.Discovery.Source(2).Timeout="60"
DiskController.Discovery.Source(2).ForceSerialization=1

// Process the output of cstm throughawk EmbeddedFile(2)
// DeviceID;ControllerID;Vendor Model;sizeMB;SerialNumber
DiskController.Discovery.Source(2).Compute(1).Type="Awk"
DiskController.Discovery.Source(2).Compute(1).AwkScript=EmbeddedFile(2)
DiskController.Discovery.Source(2).Compute(1).KeepOnlyRegExp="^MSHW;"
DiskController.Discovery.Source(2).Compute(1).Separators=";"
DiskController.Discovery.Source(2).Compute(1).SelectColumns="2,3,4,5,6"

// Source(3) = table joint of Source(1) and Source(2)
// This is to keep only interfaces that are disk controllers in fact,
// and among those disk controllers, the ones that actually have disks
// ControllerDeviceID;Model;DiskDeviceID;ControllerID;Vendor Model;sizeMB;SerialNumber
DiskController.Discovery.Source(3).Type="TableJoint"
DiskController.Discovery.Source(3).LeftTable=%DiskController.Discovery.Source(1)%
DiskController.Discovery.Source(3).RightTable=%DiskController.Discovery.Source(2)%
DiskController.Discovery.Source(3).LeftKeyColumn="1"
DiskController.Discovery.Source(3).RightKeyColumn="2"

// InstanceTable = Source(3)
DiskController.Discovery.InstanceTable=%DiskController.Discovery.Source(3)%
DiskController.Discovery.Instance.DeviceID=InstanceTable.Column(1)
DiskController.Discovery.Instance.ControllerNumber=InstanceTable.Column(1)
DiskController.Discovery.Instance.Model=InstanceTable.Column(2)


//
// PHYSICAL DISKS
//

//
// Discovery

// Source(1) = table joint of DiskController.Discovery.Source(2) and DiskController.Discovery.Source(3)
// in order to keep only disks that are attached to an existing disk controller
// DeviceID;ControllerID;Vendor Model;sizeMB;SerialNumber;ControllerDeviceID;Model;DiskDeviceID;ControllerID;Vendor Model;sizeMB;SerialNumber
PhysicalDisk.Discovery.Source(1).Type="TableJoint"
PhysicalDisk.Discovery.Source(1).LeftTable=%DiskController.Discovery.Source(2)%
PhysicalDisk.Discovery.Source(1).RightTable=%DiskController.Discovery.Source(3)%
PhysicalDisk.Discovery.Source(1).LeftKeyColumn=2
PhysicalDisk.Discovery.Source(1).RightKeyColumn=1

// Convert SizeMB into bytes
// DeviceID;ControllerID;Vendor Model;size;SerialNumber
PhysicalDisk.Discovery.Source(1).Compute(1).Type="Multiply"
PhysicalDisk.Discovery.Source(1).Compute(1).Column=4
PhysicalDisk.Discovery.Source(1).Compute(1).MultiplyBy=1048576

// InstanceTable = Source(1)
PhysicalDisk.Discovery.InstanceTable=%PhysicalDisk.Discovery.Source(1)%
PhysicalDisk.Discovery.Instance.DeviceID=InstanceTable.Column(1)
PhysicalDisk.Discovery.Instance.ControllerNumber=InstanceTable.Column(2)
PhysicalDisk.Discovery.Instance.Size=InstanceTable.Column(4)
PhysicalDisk.Discovery.Instance.Vendor=InstanceTable.Column(3)
PhysicalDisk.Discovery.Instance.SerialNumber=InstanceTable.Column(5)

//
// Collect

// Collect type is "multi-instance"
PhysicalDisk.Collect.Type="MonoInstance"

// Source(1) = output of cstm echo ""selclass type Disk;wait;information;wait;infolog""|stm -c
PhysicalDisk.Collect.Source(1).Type="OsCommand"
PhysicalDisk.Collect.Source(1).CommandLine="/bin/echo ""select path %PhysicalDisk.Collect.DeviceID%;wait;information;wait;infolog""|/usr/bin/stm -c\n/bin/echo ""select path %PhysicalDisk.Collect.DeviceID%;wait;veroptions execctrl iterations 1 behavior errorcount 10 testcoverage mincoverage gentactlog no reporterrors reportwarnings queries querynondes;verify;wait;currdevstatus""|/usr/bin/stm -c"
PhysicalDisk.Collect.Source(1).Timeout="60"
PhysicalDisk.Collect.Source(1).ForceSerialization=1

// Process output of cstm through awk EmbeddedFile(2)
// ErrorCount;Status;
PhysicalDisk.Collect.Source(1).Compute(1).Type="Awk"
PhysicalDisk.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(3)
PhysicalDisk.Collect.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
PhysicalDisk.Collect.Source(1).Compute(1).Separators=";"
PhysicalDisk.Collect.Source(1).Compute(1).SelectColumns="2,3"

// Duplicate the status column
// ErrorCount;Status;Status
PhysicalDisk.Collect.Source(1).Compute(2).Type="DuplicateColumn"
PhysicalDisk.Collect.Source(1).Compute(2).Column=2

// Translate the first status into a PATROL status
// ErrorCount;PATROLStatus;Status
PhysicalDisk.Collect.Source(1).Compute(3).Type="Translate"
PhysicalDisk.Collect.Source(1).Compute(3).Column=2
PhysicalDisk.Collect.Source(1).Compute(3).TranslationTable="PhysicalDiskStatusTranslationTable"

// Translate the second Status into a more readable string
// ErrorCount;PATROLStatus;StatusInformation
PhysicalDisk.Collect.Source(1).Compute(4).Type="Translate"
PhysicalDisk.Collect.Source(1).Compute(4).Column=3
PhysicalDisk.Collect.Source(1).Compute(4).TranslationTable="PhysicalDiskStatusInformationTranslationTable"

// The PhysicalDiskStatusTranslationTable
//PhysicalDiskStatusTranslationTable("Testing")=""
//PhysicalDiskStatusTranslationTable("QUERY PENDING")=""
//PhysicalDiskStatusTranslationTable("SUSPENDED")=""
PhysicalDiskStatusTranslationTable("HUNG")="WARN"
//PhysicalDiskStatusTranslationTable("ABORTED")=""
PhysicalDiskStatusTranslationTable("WARNING")="WARN"
PhysicalDiskStatusTranslationTable("FAILURE")="ALARM"
PhysicalDiskStatusTranslationTable("INCOMPLETE")="ALARM"
PhysicalDiskStatusTranslationTable("Success")="OK"
PhysicalDiskStatusTranslationTable(Default)="UNKNOWN"

// The PhysicalDiskStatusInformationTranslationTable
PhysicalDiskStatusInformationTranslationTable("Testing")="Testing in Progress"
PhysicalDiskStatusInformationTranslationTable("QUERY PENDING")="User Input Expected"
PhysicalDiskStatusInformationTranslationTable("SUSPENDED")="Testing Suspended"
PhysicalDiskStatusInformationTranslationTable("HUNG")="Testing Hung"
PhysicalDiskStatusInformationTranslationTable("ABORTED")="Testing Aborted"
PhysicalDiskStatusInformationTranslationTable("WARNING")="Testing Warning"
PhysicalDiskStatusInformationTranslationTable("FAILURE")="Testing Failed"
PhysicalDiskStatusInformationTranslationTable("INCOMPLETE")="Testing Incomplete"
PhysicalDiskStatusInformationTranslationTable("Success")=""
PhysicalDiskStatusInformationTranslationTable(Default)="Unknown Status"

// ValueTable = Source(1)
PhysicalDisk.Collect.ValueTable=%PhysicalDisk.Collect.Source(1)%
//PhysicalDisk.Collect.DeviceID=ValueTable.Column(1)
PhysicalDisk.Collect.Status=ValueTable.Column(2)
PhysicalDisk.Collect.StatusInformation=ValueTable.Column(3)
PhysicalDisk.Collect.ErrorCount=ValueTable.Column(1)


//
//   M E M O R Y   M O D U L E S
//

//
// Discovery

// Source(1) = output of echo ""selclass type memory;wait;information;wait;infolog""|stm -c
Memory.Discovery.Source(1).Type="OsCommand"
Memory.Discovery.Source(1).CommandLine="/bin/echo ""selclass type memory;wait;information;wait;infolog""|/usr/bin/stm -c"
Memory.Discovery.Source(1).Timeout="60"
Memory.Discovery.Source(1).ForceSerialization=1

// Process cstm output through awk EmbeddedFile(4)
// Memory modules' IDs and sizes and the "Page Deallocation Table (PDT)"
// DeviceID;Size;Type
Memory.Discovery.Source(1).Compute(1).Type="Awk"
Memory.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(4)
Memory.Discovery.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
Memory.Discovery.Source(1).Compute(1).Separators=";"
Memory.Discovery.Source(1).Compute(1).SelectColumns="2,3,4"

// InstanceTable = Source(&)
Memory.Discovery.InstanceTable=%Memory.Discovery.Source(1)%
Memory.Discovery.Instance.DeviceID=InstanceTable.Column(1)
Memory.Discovery.Instance.Size=InstanceTable.Column(2)
Memory.Discovery.Instance.Type=InstanceTable.Column(3)

//
// Collect

// Collect type is multi-instance
Memory.Collect.Type="MultiInstance"

// Source(1) = output of echo ""selclass type memory;wait;information;wait;infolog""|stm -c
Memory.Collect.Source(1).Type="OsCommand"
Memory.Collect.Source(1).CommandLine="/bin/echo ""selclass type memory;wait;information;wait;infolog""|/usr/bin/stm -c"
Memory.Collect.Source(1).Timeout="60"
Memory.Collect.Source(1).ForceSerialization=1

// Process output of cstm through awk EmbeddedFile(5)
// Memory modules error count and status (as well as for the "Page Deallocation Table (PDT)")
// DeviceID;Status;StatusInformation;ErrorCount
Memory.Collect.Source(1).Compute(1).Type="Awk"
Memory.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(5)
Memory.Collect.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;"
Memory.Collect.Source(1).Compute(1).Separators=";"
Memory.Collect.Source(1).Compute(1).SelectColumns="2,3,4,5"

// Source(2) = copy of discovery.source(1)
// Yeah, that's because our source(1) does contain lines only about memory modules
// that encountered some errors. So we need to add the entire list of modules with
// an error count of zero. The collection process will keep only the first line
// DeviceID;Size;Type
Memory.Collect.Source(2)=%Memory.Discovery.Source(1)%

// Remove size and type (keep only device ID)
// DeviceID
Memory.Collect.Source(2).Compute(1).Type="KeepColumns"
Memory.Collect.Source(2).Compute(1).ColumnNumbers="1"

// Add fake OK and ErrorCount=0 columns
// DeviceID;OK;;0
Memory.Collect.Source(2).Compute(2).Type="RightConcat"
Memory.Collect.Source(2).Compute(2).Column="1"
Memory.Collect.Source(2).Compute(2).String=";OK;;0"

// Source(3) = union of Source(1) and Source(2)
// DeviceID;Status;StatusInformation;ErrorCount
Memory.Collect.Source(3).Type="TableUnion"
Memory.Collect.Source(3).Table1=%Memory.Collect.Source(1)%
Memory.Collect.Source(3).Table2=%Memory.Collect.Source(2)%

// Okay, we have everything now (hope so)
// ValueTable = Source(3)
Memory.Collect.ValueTable=%Memory.Collect.Source(3)%
Memory.Collect.DeviceID=ValueTable.Column(1)
Memory.Collect.Status=ValueTable.Column(2)
Memory.Collect.StatusInformation=ValueTable.Column(3)
Memory.Collect.ErrorCount=ValueTable.Column(4)


//
//   F A N   M O D U L E S
//

//
// Discovery

// Source(1) = output of /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
Fan.Discovery.Source(1).Type="OsCommand"
Fan.Discovery.Source(1).CommandLine="/bin/echo ""select device 1;info;wait;infolog;cds""|/usr/bin/stm -c"
Fan.Discovery.Source(1).Timeout="60"
Fan.Discovery.Source(1).ForceSerialization=1

// Process cstm output through awk EmbeddedFile(6)
// Type;DeviceID
Fan.Discovery.Source(1).Compute(1).Type="Awk"
Fan.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(6)
Fan.Discovery.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;FAN"
Fan.Discovery.Source(1).Compute(1).Separators=";"
Fan.Discovery.Source(1).Compute(1).SelectColumns="2,3"

// InstanceTable = Source(1)
Fan.Discovery.InstanceTable=%Fan.Discovery.Source(1)%
Fan.Discovery.Instance.DeviceID=InstanceTable.Column(2)
Fan.Discovery.Instance.FanType=InstanceTable.Column(1)

//
// Collect


// Collect type is multi-instance
Fan.Collect.Type="MultiInstance"

// Source(1) = output of /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
Fan.Collect.Source(1).Type="OsCommand"
Fan.Collect.Source(1).CommandLine="/bin/echo ""select device 1;info;wait;infolog;cds""|/usr/bin/stm -c"
Fan.Collect.Source(1).Timeout="60"
Fan.Collect.Source(1).ForceSerialization=1

// Process cstm output through awk EmbeddedFile(6)
// DeviceID;Status;StatusInformation
Fan.Collect.Source(1).Compute(1).Type="Awk"
Fan.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(6)
Fan.Collect.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;FAN"
Fan.Collect.Source(1).Compute(1).Separators=";"
Fan.Collect.Source(1).Compute(1).SelectColumns="3,4,5"

//
// ValueTable = Source(1)
Fan.Collect.ValueTable=%Fan.Collect.Source(1)%
Fan.Collect.DeviceID=ValueTable.Column(1)
Fan.Collect.Status=ValueTable.Column(2)
Fan.Collect.StatusInformation=ValueTable.Column(3)

//
//   PowerSupply   M O D U L E S
//

//
// Discovery

// Source(1) = output of /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
PowerSupply.Discovery.Source(1).Type="OsCommand"
PowerSupply.Discovery.Source(1).CommandLine="/bin/echo ""select device 1;info;wait;infolog;cds""|/usr/bin/stm -c"
PowerSupply.Discovery.Source(1).Timeout="60"
PowerSupply.Discovery.Source(1).ForceSerialization=1

// Process cstm output through awk EmbeddedFile(6)
// Type;DeviceID
PowerSupply.Discovery.Source(1).Compute(1).Type="Awk"
PowerSupply.Discovery.Source(1).Compute(1).AwkScript=EmbeddedFile(6)
PowerSupply.Discovery.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;PSU"
PowerSupply.Discovery.Source(1).Compute(1).Separators=";"
PowerSupply.Discovery.Source(1).Compute(1).SelectColumns="2,3"

// InstanceTable = Source(1)
PowerSupply.Discovery.InstanceTable=%PowerSupply.Discovery.Source(1)%
PowerSupply.Discovery.Instance.DeviceID=InstanceTable.Column(2)
PowerSupply.Discovery.Instance.PowersupplyType=InstanceTable.Column(1)

//
// Collect


// Collect type is multi-instance
PowerSupply.Collect.Type="MultiInstance"

// Source(1) = output of /bin/echo "select device 1;info;wait;infolog;cds"|/usr/bin/stm -c
PowerSupply.Collect.Source(1).Type="OsCommand"
PowerSupply.Collect.Source(1).CommandLine="/bin/echo ""select device 1;info;wait;infolog;cds""|/usr/bin/stm -c"
PowerSupply.Collect.Source(1).Timeout="60"
PowerSupply.Collect.Source(1).ForceSerialization=1

// Process cstm output through awk EmbeddedFile(6)
// DeviceID;Status;StatusInformation
PowerSupply.Collect.Source(1).Compute(1).Type="Awk"
PowerSupply.Collect.Source(1).Compute(1).AwkScript=EmbeddedFile(6)
PowerSupply.Collect.Source(1).Compute(1).KeepOnlyRegExp="^MSHW;PSU"
PowerSupply.Collect.Source(1).Compute(1).Separators=";"
PowerSupply.Collect.Source(1).Compute(1).SelectColumns="3,4,5"

//
// ValueTable = Source(1)
PowerSupply.Collect.ValueTable=%PowerSupply.Collect.Source(1)%
PowerSupply.Collect.DeviceID=ValueTable.Column(1)
PowerSupply.Collect.Status=ValueTable.Column(2)
PowerSupply.Collect.StatusInformation=ValueTable.Column(3)

////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(1) = awk script that extract the adapter
///    information and build a proper list with it
///
/////////////////////////////////////////////////////////
EmbeddedFile(1):
BEGIN {
	hardwarePath = "";
	productName = "";
}
/^Product +:/ {
	colonIndex = index($0, ":");
	if (colonIndex > 10)
	{
		productName = substr($0, colonIndex + 2)
	}
}
/^Hardware [pP]ath +:/ {
	hardwarePath = $4
	if (productName != "")
	{
		print "MSHW;" hardwarePath ";" productName;
		productName = "";
	}
}
EmbeddedFile(1).End
/////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(2) = awk script that extract the disk
///    information from cstm result and build a proper list with it
///
/////////////////////////////////////////////////////////
EmbeddedFile(2):
BEGIN {
	hardwarePath = "";
	productID = "";
	vendor = "";
	serialNumber = "";
	size = "";
	controllerPath = "";
}
/^Hardware [Pp]ath:/ {
	hardwarePath = $3;
}
/^Product Id:/ {
	productID = $3;
	vendor = $5;
}
/^Serial [Nn]umber:/ {
	serialNumber = $3;
}
/^Capacity \(M Byte\): +[0-9\.]+/ {
	size = $4;
}
/^ *Verify Errors: +[0-9]+/ {

	if (hardwarePath != "" && productID != "" && size > 0)
	{
		n = split(hardwarePath, controllerPathArray, "[\.]");
		controllerPath = controllerPathArray[1];
		for (i=2 ; i<=n ; i++)
		{
			print "MSHW;" hardwarePath ";" controllerPath ";" vendor " " productID ";" size ";" serialNumber ";";
			controllerPath = controllerPath "." controllerPathArray[i];
		}
		hardwarePath = "";
		productID = "";
		vendor = "";
		serialNumber = "";
		size = "";
		controllerPath = "";
	}
}
EmbeddedFile(2).End
/////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(3) = awk script that extract the disk status
///    from cstm result and build a proper list
///
/////////////////////////////////////////////////////////
EmbeddedFile(3):
BEGIN {
	readErrors = 0;
	writeErrors = 0;
	readReverseErrors = 0;
	verifyErrors = 0;
	status = "";
}
/^ *Read Errors: +[0-9]+/ {
	readErrors = $3;
}
/^ *Read Reverse Errors: +[0-9]+/ {
	readReverseErrors = $4;
}
/^ *Write Errors: +[0-9]+/ {
	writeErrors = $3;
}
/^ *Verify Errors: +[0-9]+/ {
	verifyErrors = $3;
}
/^Current [Ss]tatus +:/ {
	status = $4;

	totalErrors = readErrors + readReverseErrors + writeErrors + verifyErrors;
	print "MSHW;" totalErrors ";" status ";";
}
EmbeddedFile(3).End
/////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(4) = awk script that extract the memory
///    information from the cstm script above
///
/////////////////////////////////////////////////////////
EmbeddedFile(4):
BEGIN {
	prefixLetter = "";
	cabCell = "";
	matrixFormat = 0;
}
/^ *Memory [Bb]oard [Ii]nventory *$/,/^ *Memory [Ee]rror [Ll]og [Ss]ummary *$/ {
	if ($0 ~ /Total/)
	{
		next;
	}

	if ($0 ~ "^ *CAB/CELL:")
	{
		cabCell = $2;
		matrixFormat = 1;
		split("A B C D E F G H", slotLabel);
	}

	if ($0 ~ /Note: The first letter in all DIMM slots start with a/)
	{
		split($0, prefixArray, "\"");
		prefixLetter = prefixArray[2];
	}

	if ($0 ~ /Configured and Slot label for each DIMM/)
	{
		getline
		getline
		split($0, slotLabel);
		matrixFormat = 1;
	}

	if (matrixFormat)
	{
		if ($0 ~ /^ *[0-9A-Za-z]+ +[0-9]+ +[0-9]+/)
		{
			if (tolower($1) == "ext")
			{
				bank = $1 " " $2 " DIMM ";
				startAt = 3;
			}
			else
			{
				bank = $1;
				startAt = 2;
			}

			if (cabCell != "")
			{
				bank = cabCell " " bank;
			}

			if (prefixLetter != "")
			{
				bank = bank "/" prefixLetter;
			}

			for (i=startAt ; i<=NF ; i++)
			{
				if ($i == 64 || $i == 128 || $i == 256 || $i == 512 || $i == 1024 || $i == 2048 || $i == 4096)
				{
					print "MSHW;" bank slotLabel[(i - startAt + 1)] ";" $i ";"
				}
			}
		}
	}
	else
	{
		lastMBColumn = 0;
		for (i=2 ; i<=NF ; i++)
		{
			if ($i == 64 || $i == 128 || $i == 256 || $i == 512 || $i == 1024 || $i == 2048 || $i == 4096)
			{
				result = "MSHW;"
				for (j=lastMBColumn + 1 ; j<i-1 ; j++)
				{
					result = result $j " "
				}
				result = result $(i-1) ";" $i ";"
				print result
				lastMBColumn = i;
			}
		}
	}

}
END {
	print "MSHW;PDT;;Page Deallocation Table"
}
EmbeddedFile(4).End
/////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(5) = awk script that extract the memory
///    information from the cstm script above
///
/////////////////////////////////////////////////////////
EmbeddedFile(5):
BEGIN {
	pdtUsed = "";
	pdtTotal = "";
}
/^ *Memory Error Log Summary *$/,/^ *Page Deallocation Table \(PDT\) *$/ {
	if ($NF ~ /^[0-9]+$/)
	{
		if ($2 ~ /^0x[0-9a-fA-F]+$/)
		{
			print "MSHW;" $1 ";OK;" $3 " Errors Occured;" $NF
		}
		else if ($3 ~ /^0x[0-9a-fA-F]+$/)
		{
			print "MSHW;" $1 " " $2 ";OK;" $4 " Errors Occured;" $NF
		}
	}
}
/^ *PDT Entries Used: +[0-9]+ *$/ {
	pdtUsed = $NF;
}
/^ *PDT Total Size: +[0-9]+ *$/ {
	pdtTotal = $NF;
}
END {
	if (pdtUsed != "" && pdtTotal != "")
	{
		pdtPercentUsed = pdtUsed / pdtTotal * 100;
		if (pdtPercentUsed > 70)
		{
			pdtStatus = "ALARM";
		}
		else if (pdtPercentUsed > 50)
		{
			pdtStatus = "WARN";
		}
		else
		{
			pdtStatus = "OK";
		}
		printf("MSHW;PDT;%s;%d%% Used;%d\n", pdtStatus, pdtPercentUsed, pdtUsed);
	}
}
EmbeddedFile(5).End
/////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////
///
///    E M B E D D E D   F I L E ! ! !
///
///    EmbeddedFile(6) = awk script that extract the Fans and Power Supplies Information
///    information from the
///
/////////////////////////////////////////////////////////
EmbeddedFile(6):
BEGIN {Cabinet="";IDIndex="";Present=0;Failure=0;State=0;fans="";powerSupplies=""}
/Cabinet [0-9]+ Hardware Inventory/,/=-+-=-+-=-+-=-+-=-+/ {

# Processes the "Overall Table"
if ($1 ~ /Cabinet/ && $2 ~ /[0-9]+/ && $3 ~ /Hardware/) {Cabinet = $2}
if ($1 ~ /Component/ && $(NF-2) ~ /Present/ && $(NF-1) ~ /Failure/ && $NF ~ /State/) {IDIndex = match($0,$2)
	                                                                                   }
if (IDIndex != "" && NF > 2 && $(NF-1) ~ /^[0-9]+$/) {
	                  DeviceID = substr($0,1,IDIndex) ; gsub (/^ +/,"",DeviceID);gsub (/ +$/,"",DeviceID);
                    if (DeviceID ~ /[Ff]an/) {type = "FAN-Global" ; if ($NF !~ /[Uu]nknown/) {fans = "Monitored" }}
                     	else if (DeviceID ~ /[Pp]ower/) {type = "PSU-Global"; if ($NF !~ /[Uu]nknown/) {powerSupplies = "Monitored"}}
                     		else {type = "OTHER"}
                    if ($Failure > 0) {status = "ALARM"; statusInformation = $Failure " Failed"}
                    	else {status = "OK" ; statusInformation = ""}
                    print ("MSHW;" type ";CAB-" Cabinet " " DeviceID ";" status ";" statusInformation ";")
                   }

if (NF < 2) {IDIndex="";Present=0;Failure=0;State=0;}

# Processes the "Individual Components" - only if the Fans / Power Supplies are being monitored in the table above (not "unknown")  Flag fans & powerSupplies are used.

if ($0 ~ /\|[0-9]\|[0-9]/) {
                          ArrayLength=split($0,OutputArray,/\|/);
                          getline;
                          split($0,LineArray,/\|/);
                          for (i=2;i<=ArrayLength-1;i++) {OutputArray[i]=OutputArray[i] LineArray[i];}
                          getline;
                          getline;
                          while ($0 !~ /------------/) {
                                                        split($0,LineArray,/\|/);
                                                        gsub(/ /,"",LineArray[1]);
                                                        for (i=2;i<=ArrayLength-1;i++) {
                                                        	                              gsub(/ /,"",LineArray[i]);
                                                        	                              if (LineArray[1] ~ /^cf/ && fans != "") {type = "FAN"}
                                                        	                              	else if (LineArray[1] ~ /^cp/ && powerSupplies != "") {type = "PSU"}
                                                        	                              		else {type = ""}
                                                        	                              if ( LineArray[i] == "p" ) {status="OK";statusInformation=""}
                                                        	                              	else if ( LineArray[i] == "F" ) {status="ALARM";statusInformation="Failed"}
                                                        	                              		else {status="";statusInformation=""}
                                                        	                              if (type != "" && status != "") {print ("MSHW;"type";CAB-" Cabinet " " LineArray[1]"-" OutputArray[i] ";" status ";" statusInformation";");}
                                                        	                              }
                                                        getline;
                                                       }
                          }
                       }
EmbeddedFile(6).End
/////////////////////////////////////////////////////////////////////