package com.sentrysoftware.hardware.agent.service;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doCallRealMethod;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

import java.io.IOException;
import java.io.InputStream;
import java.util.concurrent.TimeUnit;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.DefaultApplicationArguments;

@ExtendWith(MockitoExtension.class)
class SelfClosingGuardServiceTest {

	@Test
	void testRunStdinClosed() throws Exception {

		// End of the stream is detected
		final InputStream is = new InputStream() {

			@Override
			public int read() throws IOException {
				return -1;
			}
		};

		final InputStream origin = System.in;
		try {
			// Change the stdin temporarily for the test
			System.setIn(is);

			// Mock the service as we want to disable the System.exit
			final SelfClosingGuardService service = Mockito.spy(SelfClosingGuardService.class);

			doCallRealMethod().when(service).run(any(ApplicationArguments.class));

			// Disable System.exit
			doNothing().when(service).exit();

			// Call the entry point
			service.run(new DefaultApplicationArguments("--enable-self-closing-guard"));

			// Make sure the thread generated by the SelfClosingGuardService terminates
			// correctly
			TimeUnit.MILLISECONDS.sleep(500);

			// Check that the exit method has been called
			verify(service, times(1)).exit();

		} finally {
			// Back to origin
			System.setIn(origin);
		}
	}

	@Test
	void testRunStdinNotClosed() throws Exception {

		// No data
		final InputStream is = new InputStream() {

			@Override
			public int read() throws IOException {
				return 0;
			}
		};

		final InputStream origin = System.in;
		try {
			// Change the stdin temporarily for the test
			System.setIn(is);

			// Mock the service to be able to check the exit is never called
			final SelfClosingGuardService service = Mockito.spy(SelfClosingGuardService.class);

			doCallRealMethod().when(service).run(any(ApplicationArguments.class));

			// Call real method
			service.run(new DefaultApplicationArguments("--enable-self-closing-guard"));

			// Wait a bit
			TimeUnit.MILLISECONDS.sleep(500);

			// Check that the exit method is never called means the program is alive ;)
			verify(service, never()).exit();

		} finally {
			// Back to origin
			System.setIn(origin);
		}
	}

	@Test
	void testRunSelfClosingGuardNotEnabled() throws Exception {

		final SelfClosingGuardService service = Mockito.spy(SelfClosingGuardService.class);

		doCallRealMethod().when(service).run(any(ApplicationArguments.class));

		// Without arguments means the guard is not enabled
		service.run(new DefaultApplicationArguments());

		verify(service, never()).exitApplicationOnClosedStdin();

	}

}
